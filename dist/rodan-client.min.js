!function(e){function r(e,r,o){return 4===arguments.length?t.apply(this,arguments):void n(e,{declarative:!0,deps:r,declare:o})}function t(e,r,t,o){n(e,{declarative:!1,deps:r,executingRequire:t,execute:o})}function n(e,r){r.name=e,e in g||(g[e]=r),r.normalizedDeps=r.deps}function o(e,r){if(r[e.groupIndex]=r[e.groupIndex]||[],-1==m.call(r[e.groupIndex],e)){r[e.groupIndex].push(e);for(var t=0,n=e.normalizedDeps.length;n>t;t++){var a=e.normalizedDeps[t],u=g[a];if(u&&!u.evaluated){var d=e.groupIndex+(u.declarative!=e.declarative);if(void 0===u.groupIndex||u.groupIndex<d){if(void 0!==u.groupIndex&&(r[u.groupIndex].splice(m.call(r[u.groupIndex],u),1),0==r[u.groupIndex].length))throw new TypeError("Mixed dependency cycle detected");u.groupIndex=d}o(u,r)}}}}function a(e){var r=g[e];r.groupIndex=0;var t=[];o(r,t);for(var n=!!r.declarative==t.length%2,a=t.length-1;a>=0;a--){for(var u=t[a],i=0;i<u.length;i++){var s=u[i];n?d(s):l(s)}n=!n}}function u(e){return D[e]||(D[e]={name:e,dependencies:[],exports:{},importers:[]})}function d(r){if(!r.module){var t=r.module=u(r.name),n=r.module.exports,o=r.declare.call(e,function(e,r){if(t.locked=!0,"object"==typeof e)for(var o in e)n[o]=e[o];else n[e]=r;for(var a=0,u=t.importers.length;u>a;a++){var d=t.importers[a];if(!d.locked)for(var i=0;i<d.dependencies.length;++i)d.dependencies[i]===t&&d.setters[i](n)}return t.locked=!1,r},r.name);t.setters=o.setters,t.execute=o.execute;for(var a=0,i=r.normalizedDeps.length;i>a;a++){var l,s=r.normalizedDeps[a],c=g[s],f=D[s];f?l=f.exports:c&&!c.declarative?l=c.esModule:c?(d(c),f=c.module,l=f.exports):l=v(s),f&&f.importers?(f.importers.push(t),t.dependencies.push(f)):t.dependencies.push(null),t.setters[a]&&t.setters[a](l)}}}function i(e){var r,t=g[e];if(t)t.declarative?p(e,[]):t.evaluated||l(t),r=t.module.exports;else if(r=v(e),!r)throw new Error("Unable to load dependency "+e+".");return(!t||t.declarative)&&r&&r.__useDefault?r["default"]:r}function l(r){if(!r.module){var t={},n=r.module={exports:t,id:r.name};if(!r.executingRequire)for(var o=0,a=r.normalizedDeps.length;a>o;o++){var u=r.normalizedDeps[o],d=g[u];d&&l(d)}r.evaluated=!0;var c=r.execute.call(e,function(e){for(var t=0,n=r.deps.length;n>t;t++)if(r.deps[t]==e)return i(r.normalizedDeps[t]);throw new TypeError("Module "+e+" not declared as a dependency.")},t,n);c&&(n.exports=c),t=n.exports,t&&t.__esModule?r.esModule=t:r.esModule=s(t)}}function s(e){var r={};if("object"==typeof e||"function"==typeof e){var t=e&&e.hasOwnProperty;if(h)for(var n in e)f(r,e,n)||c(r,e,n,t);else for(var n in e)c(r,e,n,t)}return r["default"]=e,y(r,"__useDefault",{value:!0}),r}function c(e,r,t,n){(!n||r.hasOwnProperty(t))&&(e[t]=r[t])}function f(e,r,t){try{var n;return(n=Object.getOwnPropertyDescriptor(r,t))&&y(e,t,n),!0}catch(o){return!1}}function p(r,t){var n=g[r];if(n&&!n.evaluated&&n.declarative){t.push(r);for(var o=0,a=n.normalizedDeps.length;a>o;o++){var u=n.normalizedDeps[o];-1==m.call(t,u)&&(g[u]?p(u,t):v(u))}n.evaluated||(n.evaluated=!0,n.module.execute.call(e))}}function v(e){if(I[e])return I[e];if("@node/"==e.substr(0,6))return _(e.substr(6));var r=g[e];if(!r)throw"Module "+e+" not present.";return a(e),p(e,[]),g[e]=void 0,r.declarative&&y(r.module.exports,"__esModule",{value:!0}),I[e]=r.declarative?r.module.exports:r.esModule}var g={},m=Array.prototype.indexOf||function(e){for(var r=0,t=this.length;t>r;r++)if(this[r]===e)return r;return-1},h=!0;try{Object.getOwnPropertyDescriptor({a:0},"a")}catch(x){h=!1}var y;!function(){try{Object.defineProperty({},"a",{})&&(y=Object.defineProperty)}catch(e){y=function(e,r,t){try{e[r]=t.value||t.get.call(e)}catch(n){}}}}();var D={},_="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&require.resolve&&"undefined"!=typeof process&&require,I={"@empty":{}};return function(e,n,o){return function(a){a(function(a){for(var u={_nodeRequire:_,register:r,registerDynamic:t,get:v,set:function(e,r){I[e]=r},newModule:function(e){return e}},d=0;d<n.length;d++)(function(e,r){r&&r.__esModule?I[e]=r:I[e]=s(r)})(n[d],arguments[d]);o(u);var i=v(e[0]);if(e.length>1)for(var d=1;d<e.length;d++)v(e[d]);return i.__useDefault?i["default"]:i})}}}("undefined"!=typeof self?self:global)

(["1"], [], function($__System) {
var require = this.require, exports = this.exports, module = this.module;
!function(e){function r(e,r){for(var n=e.split(".");n.length;)r=r[n.shift()];return r}function n(n){if("string"==typeof n)return r(n,e);if(!(n instanceof Array))throw new Error("Global exports must be a string or array.");for(var t={},o=!0,f=0;f<n.length;f++){var i=r(n[f],e);o&&(t["default"]=i,o=!1),t[n[f].split(".").pop()]=i}return t}function t(r){if(Object.keys)Object.keys(e).forEach(r);else for(var n in e)a.call(e,n)&&r(n)}function o(r){t(function(n){if(-1==l.call(s,n)){try{var t=e[n]}catch(o){s.push(n)}r(n,t)}})}var f,i=$__System,a=Object.prototype.hasOwnProperty,l=Array.prototype.indexOf||function(e){for(var r=0,n=this.length;n>r;r++)if(this[r]===e)return r;return-1},s=["_g","sessionStorage","localStorage","clipboardData","frames","frameElement","external","mozAnimationStartTime","webkitStorageInfo","webkitIndexedDB","mozInnerScreenY","mozInnerScreenX"];i.set("@@global-helpers",i.newModule({prepareGlobal:function(r,t,i){var a=e.define;e.define=void 0;var l;if(i){l={};for(var s in i)l[s]=e[s],e[s]=i[s]}return t||(f={},o(function(e,r){f[e]=r})),function(){var r;if(t)r=n(t);else{r={};var i,s;o(function(e,n){f[e]!==n&&"undefined"!=typeof n&&(r[e]=n,"undefined"!=typeof i?s||i===n||(s=!0):i=n)}),r=s?r:i}if(l)for(var u in l)e[u]=l[u];return e.define=a,r}}}))}("undefined"!=typeof self?self:global);
!function(e){function n(e,n){e=e.replace(l,"");var r=e.match(u),t=(r[1].split(",")[n]||"require").replace(s,""),i=p[t]||(p[t]=new RegExp(a+t+f,"g"));i.lastIndex=0;for(var o,c=[];o=i.exec(e);)c.push(o[2]||o[3]);return c}function r(e,n,t,o){if("object"==typeof e&&!(e instanceof Array))return r.apply(null,Array.prototype.splice.call(arguments,1,arguments.length-1));if("string"==typeof e&&"function"==typeof n&&(e=[e]),!(e instanceof Array)){if("string"==typeof e){var l=i.get(e);return l.__useDefault?l["default"]:l}throw new TypeError("Invalid require")}for(var a=[],f=0;f<e.length;f++)a.push(i["import"](e[f],o));Promise.all(a).then(function(e){n&&n.apply(null,e)},t)}function t(t,l,a){"string"!=typeof t&&(a=l,l=t,t=null),l instanceof Array||(a=l,l=["require","exports","module"].splice(0,a.length)),"function"!=typeof a&&(a=function(e){return function(){return e}}(a)),void 0===l[l.length-1]&&l.pop();var f,u,s;-1!=(f=o.call(l,"require"))&&(l.splice(f,1),t||(l=l.concat(n(a.toString(),f)))),-1!=(u=o.call(l,"exports"))&&l.splice(u,1),-1!=(s=o.call(l,"module"))&&l.splice(s,1);var p={name:t,deps:l,execute:function(n,t,o){for(var p=[],c=0;c<l.length;c++)p.push(n(l[c]));o.uri=o.id,o.config=function(){},-1!=s&&p.splice(s,0,o),-1!=u&&p.splice(u,0,t),-1!=f&&p.splice(f,0,function(e,t,l){return"string"==typeof e&&"function"!=typeof t?n(e):r.call(i,e,t,l,o.id)});var d=a.apply(-1==u?e:t,p);return"undefined"==typeof d&&o&&(d=o.exports),"undefined"!=typeof d?d:void 0}};if(t)c.anonDefine||c.isBundle?c.anonDefine&&c.anonDefine.name&&(c.anonDefine=null):c.anonDefine=p,c.isBundle=!0,i.registerDynamic(p.name,p.deps,!1,p.execute);else{if(c.anonDefine&&!c.anonDefine.name)throw new Error("Multiple anonymous defines in module "+t);c.anonDefine=p}}var i=$__System,o=Array.prototype.indexOf||function(e){for(var n=0,r=this.length;r>n;n++)if(this[n]===e)return n;return-1},l=/(\/\*([\s\S]*?)\*\/|([^:]|^)\/\/(.*)$)/gm,a="(?:^|[^$_a-zA-Z\\xA0-\\uFFFF.])",f="\\s*\\(\\s*(\"([^\"]+)\"|'([^']+)')\\s*\\)",u=/\(([^\)]*)\)/,s=/^\s+|\s+$/g,p={};t.amd={};var c={isBundle:!1,anonDefine:null};i.amdDefine=t,i.amdRequire=r}("undefined"!=typeof self?self:global);
$__System.registerDynamic("2", ["3"], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, "$", null);
  (function() {
    "format global";
    "deps jquery";
    "exports $";
    if (typeof jQuery === 'undefined') {
      throw new Error('Bootstrap\'s JavaScript requires jQuery');
    }
    +function($) {
      'use strict';
      var version = $.fn.jquery.split(' ')[0].split('.');
      if ((version[0] < 2 && version[1] < 9) || (version[0] == 1 && version[1] == 9 && version[2] < 1) || (version[0] > 2)) {
        throw new Error('Bootstrap\'s JavaScript requires jQuery version 1.9.1 or higher, but lower than version 3');
      }
    }(jQuery);
    +function($) {
      'use strict';
      function transitionEnd() {
        var el = document.createElement('bootstrap');
        var transEndEventNames = {
          WebkitTransition: 'webkitTransitionEnd',
          MozTransition: 'transitionend',
          OTransition: 'oTransitionEnd otransitionend',
          transition: 'transitionend'
        };
        for (var name in transEndEventNames) {
          if (el.style[name] !== undefined) {
            return {end: transEndEventNames[name]};
          }
        }
        return false;
      }
      $.fn.emulateTransitionEnd = function(duration) {
        var called = false;
        var $el = this;
        $(this).one('bsTransitionEnd', function() {
          called = true;
        });
        var callback = function() {
          if (!called)
            $($el).trigger($.support.transition.end);
        };
        setTimeout(callback, duration);
        return this;
      };
      $(function() {
        $.support.transition = transitionEnd();
        if (!$.support.transition)
          return;
        $.event.special.bsTransitionEnd = {
          bindType: $.support.transition.end,
          delegateType: $.support.transition.end,
          handle: function(e) {
            if ($(e.target).is(this))
              return e.handleObj.handler.apply(this, arguments);
          }
        };
      });
    }(jQuery);
    +function($) {
      'use strict';
      var dismiss = '[data-dismiss="alert"]';
      var Alert = function(el) {
        $(el).on('click', dismiss, this.close);
      };
      Alert.VERSION = '3.3.6';
      Alert.TRANSITION_DURATION = 150;
      Alert.prototype.close = function(e) {
        var $this = $(this);
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = $(selector);
        if (e)
          e.preventDefault();
        if (!$parent.length) {
          $parent = $this.closest('.alert');
        }
        $parent.trigger(e = $.Event('close.bs.alert'));
        if (e.isDefaultPrevented())
          return;
        $parent.removeClass('in');
        function removeElement() {
          $parent.detach().trigger('closed.bs.alert').remove();
        }
        $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.alert');
          if (!data)
            $this.data('bs.alert', (data = new Alert(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.alert;
      $.fn.alert = Plugin;
      $.fn.alert.Constructor = Alert;
      $.fn.alert.noConflict = function() {
        $.fn.alert = old;
        return this;
      };
      $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
    }(jQuery);
    +function($) {
      'use strict';
      var Button = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Button.DEFAULTS, options);
        this.isLoading = false;
      };
      Button.VERSION = '3.3.6';
      Button.DEFAULTS = {loadingText: 'loading...'};
      Button.prototype.setState = function(state) {
        var d = 'disabled';
        var $el = this.$element;
        var val = $el.is('input') ? 'val' : 'html';
        var data = $el.data();
        state += 'Text';
        if (data.resetText == null)
          $el.data('resetText', $el[val]());
        setTimeout($.proxy(function() {
          $el[val](data[state] == null ? this.options[state] : data[state]);
          if (state == 'loadingText') {
            this.isLoading = true;
            $el.addClass(d).attr(d, d);
          } else if (this.isLoading) {
            this.isLoading = false;
            $el.removeClass(d).removeAttr(d);
          }
        }, this), 0);
      };
      Button.prototype.toggle = function() {
        var changed = true;
        var $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
          var $input = this.$element.find('input');
          if ($input.prop('type') == 'radio') {
            if ($input.prop('checked'))
              changed = false;
            $parent.find('.active').removeClass('active');
            this.$element.addClass('active');
          } else if ($input.prop('type') == 'checkbox') {
            if (($input.prop('checked')) !== this.$element.hasClass('active'))
              changed = false;
            this.$element.toggleClass('active');
          }
          $input.prop('checked', this.$element.hasClass('active'));
          if (changed)
            $input.trigger('change');
        } else {
          this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
          this.$element.toggleClass('active');
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.button');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.button', (data = new Button(this, options)));
          if (option == 'toggle')
            data.toggle();
          else if (option)
            data.setState(option);
        });
      }
      var old = $.fn.button;
      $.fn.button = Plugin;
      $.fn.button.Constructor = Button;
      $.fn.button.noConflict = function() {
        $.fn.button = old;
        return this;
      };
      $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        var $btn = $(e.target);
        if (!$btn.hasClass('btn'))
          $btn = $btn.closest('.btn');
        Plugin.call($btn, 'toggle');
        if (!($(e.target).is('input[type="radio"]') || $(e.target).is('input[type="checkbox"]')))
          e.preventDefault();
      }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function(e) {
        $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Carousel = function(element, options) {
        this.$element = $(element);
        this.$indicators = this.$element.find('.carousel-indicators');
        this.options = options;
        this.paused = null;
        this.sliding = null;
        this.interval = null;
        this.$active = null;
        this.$items = null;
        this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
        this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
      };
      Carousel.VERSION = '3.3.6';
      Carousel.TRANSITION_DURATION = 600;
      Carousel.DEFAULTS = {
        interval: 5000,
        pause: 'hover',
        wrap: true,
        keyboard: true
      };
      Carousel.prototype.keydown = function(e) {
        if (/input|textarea/i.test(e.target.tagName))
          return;
        switch (e.which) {
          case 37:
            this.prev();
            break;
          case 39:
            this.next();
            break;
          default:
            return;
        }
        e.preventDefault();
      };
      Carousel.prototype.cycle = function(e) {
        e || (this.paused = false);
        this.interval && clearInterval(this.interval);
        this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
        return this;
      };
      Carousel.prototype.getItemIndex = function(item) {
        this.$items = item.parent().children('.item');
        return this.$items.index(item || this.$active);
      };
      Carousel.prototype.getItemForDirection = function(direction, active) {
        var activeIndex = this.getItemIndex(active);
        var willWrap = (direction == 'prev' && activeIndex === 0) || (direction == 'next' && activeIndex == (this.$items.length - 1));
        if (willWrap && !this.options.wrap)
          return active;
        var delta = direction == 'prev' ? -1 : 1;
        var itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex);
      };
      Carousel.prototype.to = function(pos) {
        var that = this;
        var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
        if (pos > (this.$items.length - 1) || pos < 0)
          return;
        if (this.sliding)
          return this.$element.one('slid.bs.carousel', function() {
            that.to(pos);
          });
        if (activeIndex == pos)
          return this.pause().cycle();
        return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
      };
      Carousel.prototype.pause = function(e) {
        e || (this.paused = true);
        if (this.$element.find('.next, .prev').length && $.support.transition) {
          this.$element.trigger($.support.transition.end);
          this.cycle(true);
        }
        this.interval = clearInterval(this.interval);
        return this;
      };
      Carousel.prototype.next = function() {
        if (this.sliding)
          return;
        return this.slide('next');
      };
      Carousel.prototype.prev = function() {
        if (this.sliding)
          return;
        return this.slide('prev');
      };
      Carousel.prototype.slide = function(type, next) {
        var $active = this.$element.find('.item.active');
        var $next = next || this.getItemForDirection(type, $active);
        var isCycling = this.interval;
        var direction = type == 'next' ? 'left' : 'right';
        var that = this;
        if ($next.hasClass('active'))
          return (this.sliding = false);
        var relatedTarget = $next[0];
        var slideEvent = $.Event('slide.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        this.$element.trigger(slideEvent);
        if (slideEvent.isDefaultPrevented())
          return;
        this.sliding = true;
        isCycling && this.pause();
        if (this.$indicators.length) {
          this.$indicators.find('.active').removeClass('active');
          var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
          $nextIndicator && $nextIndicator.addClass('active');
        }
        var slidEvent = $.Event('slid.bs.carousel', {
          relatedTarget: relatedTarget,
          direction: direction
        });
        if ($.support.transition && this.$element.hasClass('slide')) {
          $next.addClass(type);
          $next[0].offsetWidth;
          $active.addClass(direction);
          $next.addClass(direction);
          $active.one('bsTransitionEnd', function() {
            $next.removeClass([type, direction].join(' ')).addClass('active');
            $active.removeClass(['active', direction].join(' '));
            that.sliding = false;
            setTimeout(function() {
              that.$element.trigger(slidEvent);
            }, 0);
          }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
        } else {
          $active.removeClass('active');
          $next.addClass('active');
          this.sliding = false;
          this.$element.trigger(slidEvent);
        }
        isCycling && this.cycle();
        return this;
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.carousel');
          var options = $.extend({}, Carousel.DEFAULTS, $this.data(), typeof option == 'object' && option);
          var action = typeof option == 'string' ? option : options.slide;
          if (!data)
            $this.data('bs.carousel', (data = new Carousel(this, options)));
          if (typeof option == 'number')
            data.to(option);
          else if (action)
            data[action]();
          else if (options.interval)
            data.pause().cycle();
        });
      }
      var old = $.fn.carousel;
      $.fn.carousel = Plugin;
      $.fn.carousel.Constructor = Carousel;
      $.fn.carousel.noConflict = function() {
        $.fn.carousel = old;
        return this;
      };
      var clickHandler = function(e) {
        var href;
        var $this = $(this);
        var $target = $($this.attr('data-target') || (href = $this.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''));
        if (!$target.hasClass('carousel'))
          return;
        var options = $.extend({}, $target.data(), $this.data());
        var slideIndex = $this.attr('data-slide-to');
        if (slideIndex)
          options.interval = false;
        Plugin.call($target, options);
        if (slideIndex) {
          $target.data('bs.carousel').to(slideIndex);
        }
        e.preventDefault();
      };
      $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
      $(window).on('load', function() {
        $('[data-ride="carousel"]').each(function() {
          var $carousel = $(this);
          Plugin.call($carousel, $carousel.data());
        });
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Collapse = function(element, options) {
        this.$element = $(element);
        this.options = $.extend({}, Collapse.DEFAULTS, options);
        this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
        this.transitioning = null;
        if (this.options.parent) {
          this.$parent = this.getParent();
        } else {
          this.addAriaAndCollapsedClass(this.$element, this.$trigger);
        }
        if (this.options.toggle)
          this.toggle();
      };
      Collapse.VERSION = '3.3.6';
      Collapse.TRANSITION_DURATION = 350;
      Collapse.DEFAULTS = {toggle: true};
      Collapse.prototype.dimension = function() {
        var hasWidth = this.$element.hasClass('width');
        return hasWidth ? 'width' : 'height';
      };
      Collapse.prototype.show = function() {
        if (this.transitioning || this.$element.hasClass('in'))
          return;
        var activesData;
        var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');
        if (actives && actives.length) {
          activesData = actives.data('bs.collapse');
          if (activesData && activesData.transitioning)
            return;
        }
        var startEvent = $.Event('show.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        if (actives && actives.length) {
          Plugin.call(actives, 'hide');
          activesData || actives.data('bs.collapse', null);
        }
        var dimension = this.dimension();
        this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
        this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
        this.transitioning = 1;
        var complete = function() {
          this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
          this.transitioning = 0;
          this.$element.trigger('shown.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        var scrollSize = $.camelCase(['scroll', dimension].join('-'));
        this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
      };
      Collapse.prototype.hide = function() {
        if (this.transitioning || !this.$element.hasClass('in'))
          return;
        var startEvent = $.Event('hide.bs.collapse');
        this.$element.trigger(startEvent);
        if (startEvent.isDefaultPrevented())
          return;
        var dimension = this.dimension();
        this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
        this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
        this.$trigger.addClass('collapsed').attr('aria-expanded', false);
        this.transitioning = 1;
        var complete = function() {
          this.transitioning = 0;
          this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
        };
        if (!$.support.transition)
          return complete.call(this);
        this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
      };
      Collapse.prototype.toggle = function() {
        this[this.$element.hasClass('in') ? 'hide' : 'show']();
      };
      Collapse.prototype.getParent = function() {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function(i, element) {
          var $element = $(element);
          this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
        }, this)).end();
      };
      Collapse.prototype.addAriaAndCollapsedClass = function($element, $trigger) {
        var isOpen = $element.hasClass('in');
        $element.attr('aria-expanded', isOpen);
        $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
      };
      function getTargetFromTrigger($trigger) {
        var href;
        var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, '');
        return $(target);
      }
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.collapse');
          var options = $.extend({}, Collapse.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data && options.toggle && /show|hide/.test(option))
            options.toggle = false;
          if (!data)
            $this.data('bs.collapse', (data = new Collapse(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.collapse;
      $.fn.collapse = Plugin;
      $.fn.collapse.Constructor = Collapse;
      $.fn.collapse.noConflict = function() {
        $.fn.collapse = old;
        return this;
      };
      $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function(e) {
        var $this = $(this);
        if (!$this.attr('data-target'))
          e.preventDefault();
        var $target = getTargetFromTrigger($this);
        var data = $target.data('bs.collapse');
        var option = data ? 'toggle' : $this.data();
        Plugin.call($target, option);
      });
    }(jQuery);
    +function($) {
      'use strict';
      var backdrop = '.dropdown-backdrop';
      var toggle = '[data-toggle="dropdown"]';
      var Dropdown = function(element) {
        $(element).on('click.bs.dropdown', this.toggle);
      };
      Dropdown.VERSION = '3.3.6';
      function getParent($this) {
        var selector = $this.attr('data-target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent();
      }
      function clearMenus(e) {
        if (e && e.which === 3)
          return;
        $(backdrop).remove();
        $(toggle).each(function() {
          var $this = $(this);
          var $parent = getParent($this);
          var relatedTarget = {relatedTarget: this};
          if (!$parent.hasClass('open'))
            return;
          if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target))
            return;
          $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.attr('aria-expanded', 'false');
          $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
        });
      }
      Dropdown.prototype.toggle = function(e) {
        var $this = $(this);
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        clearMenus();
        if (!isActive) {
          if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
            $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
          }
          var relatedTarget = {relatedTarget: this};
          $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
          if (e.isDefaultPrevented())
            return;
          $this.trigger('focus').attr('aria-expanded', 'true');
          $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
        }
        return false;
      };
      Dropdown.prototype.keydown = function(e) {
        if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName))
          return;
        var $this = $(this);
        e.preventDefault();
        e.stopPropagation();
        if ($this.is('.disabled, :disabled'))
          return;
        var $parent = getParent($this);
        var isActive = $parent.hasClass('open');
        if (!isActive && e.which != 27 || isActive && e.which == 27) {
          if (e.which == 27)
            $parent.find(toggle).trigger('focus');
          return $this.trigger('click');
        }
        var desc = ' li:not(.disabled):visible a';
        var $items = $parent.find('.dropdown-menu' + desc);
        if (!$items.length)
          return;
        var index = $items.index(e.target);
        if (e.which == 38 && index > 0)
          index--;
        if (e.which == 40 && index < $items.length - 1)
          index++;
        if (!~index)
          index = 0;
        $items.eq(index).trigger('focus');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.dropdown');
          if (!data)
            $this.data('bs.dropdown', (data = new Dropdown(this)));
          if (typeof option == 'string')
            data[option].call($this);
        });
      }
      var old = $.fn.dropdown;
      $.fn.dropdown = Plugin;
      $.fn.dropdown.Constructor = Dropdown;
      $.fn.dropdown.noConflict = function() {
        $.fn.dropdown = old;
        return this;
      };
      $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function(e) {
        e.stopPropagation();
      }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
    }(jQuery);
    +function($) {
      'use strict';
      var Modal = function(element, options) {
        this.options = options;
        this.$body = $(document.body);
        this.$element = $(element);
        this.$dialog = this.$element.find('.modal-dialog');
        this.$backdrop = null;
        this.isShown = null;
        this.originalBodyPad = null;
        this.scrollbarWidth = 0;
        this.ignoreBackdropClick = false;
        if (this.options.remote) {
          this.$element.find('.modal-content').load(this.options.remote, $.proxy(function() {
            this.$element.trigger('loaded.bs.modal');
          }, this));
        }
      };
      Modal.VERSION = '3.3.6';
      Modal.TRANSITION_DURATION = 300;
      Modal.BACKDROP_TRANSITION_DURATION = 150;
      Modal.DEFAULTS = {
        backdrop: true,
        keyboard: true,
        show: true
      };
      Modal.prototype.toggle = function(_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget);
      };
      Modal.prototype.show = function(_relatedTarget) {
        var that = this;
        var e = $.Event('show.bs.modal', {relatedTarget: _relatedTarget});
        this.$element.trigger(e);
        if (this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = true;
        this.checkScrollbar();
        this.setScrollbar();
        this.$body.addClass('modal-open');
        this.escape();
        this.resize();
        this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
        this.$dialog.on('mousedown.dismiss.bs.modal', function() {
          that.$element.one('mouseup.dismiss.bs.modal', function(e) {
            if ($(e.target).is(that.$element))
              that.ignoreBackdropClick = true;
          });
        });
        this.backdrop(function() {
          var transition = $.support.transition && that.$element.hasClass('fade');
          if (!that.$element.parent().length) {
            that.$element.appendTo(that.$body);
          }
          that.$element.show().scrollTop(0);
          that.adjustDialog();
          if (transition) {
            that.$element[0].offsetWidth;
          }
          that.$element.addClass('in');
          that.enforceFocus();
          var e = $.Event('shown.bs.modal', {relatedTarget: _relatedTarget});
          transition ? that.$dialog.one('bsTransitionEnd', function() {
            that.$element.trigger('focus').trigger(e);
          }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
        });
      };
      Modal.prototype.hide = function(e) {
        if (e)
          e.preventDefault();
        e = $.Event('hide.bs.modal');
        this.$element.trigger(e);
        if (!this.isShown || e.isDefaultPrevented())
          return;
        this.isShown = false;
        this.escape();
        this.resize();
        $(document).off('focusin.bs.modal');
        this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
        this.$dialog.off('mousedown.dismiss.bs.modal');
        $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
      };
      Modal.prototype.enforceFocus = function() {
        $(document).off('focusin.bs.modal').on('focusin.bs.modal', $.proxy(function(e) {
          if (this.$element[0] !== e.target && !this.$element.has(e.target).length) {
            this.$element.trigger('focus');
          }
        }, this));
      };
      Modal.prototype.escape = function() {
        if (this.isShown && this.options.keyboard) {
          this.$element.on('keydown.dismiss.bs.modal', $.proxy(function(e) {
            e.which == 27 && this.hide();
          }, this));
        } else if (!this.isShown) {
          this.$element.off('keydown.dismiss.bs.modal');
        }
      };
      Modal.prototype.resize = function() {
        if (this.isShown) {
          $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
        } else {
          $(window).off('resize.bs.modal');
        }
      };
      Modal.prototype.hideModal = function() {
        var that = this;
        this.$element.hide();
        this.backdrop(function() {
          that.$body.removeClass('modal-open');
          that.resetAdjustments();
          that.resetScrollbar();
          that.$element.trigger('hidden.bs.modal');
        });
      };
      Modal.prototype.removeBackdrop = function() {
        this.$backdrop && this.$backdrop.remove();
        this.$backdrop = null;
      };
      Modal.prototype.backdrop = function(callback) {
        var that = this;
        var animate = this.$element.hasClass('fade') ? 'fade' : '';
        if (this.isShown && this.options.backdrop) {
          var doAnimate = $.support.transition && animate;
          this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
          this.$element.on('click.dismiss.bs.modal', $.proxy(function(e) {
            if (this.ignoreBackdropClick) {
              this.ignoreBackdropClick = false;
              return;
            }
            if (e.target !== e.currentTarget)
              return;
            this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
          }, this));
          if (doAnimate)
            this.$backdrop[0].offsetWidth;
          this.$backdrop.addClass('in');
          if (!callback)
            return;
          doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
        } else if (!this.isShown && this.$backdrop) {
          this.$backdrop.removeClass('in');
          var callbackRemove = function() {
            that.removeBackdrop();
            callback && callback();
          };
          $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
        } else if (callback) {
          callback();
        }
      };
      Modal.prototype.handleUpdate = function() {
        this.adjustDialog();
      };
      Modal.prototype.adjustDialog = function() {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
          paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
          paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
        });
      };
      Modal.prototype.resetAdjustments = function() {
        this.$element.css({
          paddingLeft: '',
          paddingRight: ''
        });
      };
      Modal.prototype.checkScrollbar = function() {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
          var documentElementRect = document.documentElement.getBoundingClientRect();
          fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
        this.scrollbarWidth = this.measureScrollbar();
      };
      Modal.prototype.setScrollbar = function() {
        var bodyPad = parseInt((this.$body.css('padding-right') || 0), 10);
        this.originalBodyPad = document.body.style.paddingRight || '';
        if (this.bodyIsOverflowing)
          this.$body.css('padding-right', bodyPad + this.scrollbarWidth);
      };
      Modal.prototype.resetScrollbar = function() {
        this.$body.css('padding-right', this.originalBodyPad);
      };
      Modal.prototype.measureScrollbar = function() {
        var scrollDiv = document.createElement('div');
        scrollDiv.className = 'modal-scrollbar-measure';
        this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        this.$body[0].removeChild(scrollDiv);
        return scrollbarWidth;
      };
      function Plugin(option, _relatedTarget) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.modal');
          var options = $.extend({}, Modal.DEFAULTS, $this.data(), typeof option == 'object' && option);
          if (!data)
            $this.data('bs.modal', (data = new Modal(this, options)));
          if (typeof option == 'string')
            data[option](_relatedTarget);
          else if (options.show)
            data.show(_relatedTarget);
        });
      }
      var old = $.fn.modal;
      $.fn.modal = Plugin;
      $.fn.modal.Constructor = Modal;
      $.fn.modal.noConflict = function() {
        $.fn.modal = old;
        return this;
      };
      $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function(e) {
        var $this = $(this);
        var href = $this.attr('href');
        var $target = $($this.attr('data-target') || (href && href.replace(/.*(?=#[^\s]+$)/, '')));
        var option = $target.data('bs.modal') ? 'toggle' : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data());
        if ($this.is('a'))
          e.preventDefault();
        $target.one('show.bs.modal', function(showEvent) {
          if (showEvent.isDefaultPrevented())
            return;
          $target.one('hidden.bs.modal', function() {
            $this.is(':visible') && $this.trigger('focus');
          });
        });
        Plugin.call($target, option, this);
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Tooltip = function(element, options) {
        this.type = null;
        this.options = null;
        this.enabled = null;
        this.timeout = null;
        this.hoverState = null;
        this.$element = null;
        this.inState = null;
        this.init('tooltip', element, options);
      };
      Tooltip.VERSION = '3.3.6';
      Tooltip.TRANSITION_DURATION = 150;
      Tooltip.DEFAULTS = {
        animation: true,
        placement: 'top',
        selector: false,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: 'hover focus',
        title: '',
        delay: 0,
        html: false,
        container: false,
        viewport: {
          selector: 'body',
          padding: 0
        }
      };
      Tooltip.prototype.init = function(type, element, options) {
        this.enabled = true;
        this.type = type;
        this.$element = $(element);
        this.options = this.getOptions(options);
        this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : (this.options.viewport.selector || this.options.viewport));
        this.inState = {
          click: false,
          hover: false,
          focus: false
        };
        if (this.$element[0] instanceof document.constructor && !this.options.selector) {
          throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
        }
        var triggers = this.options.trigger.split(' ');
        for (var i = triggers.length; i--; ) {
          var trigger = triggers[i];
          if (trigger == 'click') {
            this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
          } else if (trigger != 'manual') {
            var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
            var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
            this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
            this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
          }
        }
        this.options.selector ? (this._options = $.extend({}, this.options, {
          trigger: 'manual',
          selector: ''
        })) : this.fixTitle();
      };
      Tooltip.prototype.getDefaults = function() {
        return Tooltip.DEFAULTS;
      };
      Tooltip.prototype.getOptions = function(options) {
        options = $.extend({}, this.getDefaults(), this.$element.data(), options);
        if (options.delay && typeof options.delay == 'number') {
          options.delay = {
            show: options.delay,
            hide: options.delay
          };
        }
        return options;
      };
      Tooltip.prototype.getDelegateOptions = function() {
        var options = {};
        var defaults = this.getDefaults();
        this._options && $.each(this._options, function(key, value) {
          if (defaults[key] != value)
            options[key] = value;
        });
        return options;
      };
      Tooltip.prototype.enter = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
        }
        if (self.tip().hasClass('in') || self.hoverState == 'in') {
          self.hoverState = 'in';
          return;
        }
        clearTimeout(self.timeout);
        self.hoverState = 'in';
        if (!self.options.delay || !self.options.delay.show)
          return self.show();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'in')
            self.show();
        }, self.options.delay.show);
      };
      Tooltip.prototype.isInStateTrue = function() {
        for (var key in this.inState) {
          if (this.inState[key])
            return true;
        }
        return false;
      };
      Tooltip.prototype.leave = function(obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);
        if (!self) {
          self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
          $(obj.currentTarget).data('bs.' + this.type, self);
        }
        if (obj instanceof $.Event) {
          self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
        }
        if (self.isInStateTrue())
          return;
        clearTimeout(self.timeout);
        self.hoverState = 'out';
        if (!self.options.delay || !self.options.delay.hide)
          return self.hide();
        self.timeout = setTimeout(function() {
          if (self.hoverState == 'out')
            self.hide();
        }, self.options.delay.hide);
      };
      Tooltip.prototype.show = function() {
        var e = $.Event('show.bs.' + this.type);
        if (this.hasContent() && this.enabled) {
          this.$element.trigger(e);
          var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
          if (e.isDefaultPrevented() || !inDom)
            return;
          var that = this;
          var $tip = this.tip();
          var tipId = this.getUID(this.type);
          this.setContent();
          $tip.attr('id', tipId);
          this.$element.attr('aria-describedby', tipId);
          if (this.options.animation)
            $tip.addClass('fade');
          var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
          var autoToken = /\s?auto?\s?/i;
          var autoPlace = autoToken.test(placement);
          if (autoPlace)
            placement = placement.replace(autoToken, '') || 'top';
          $tip.detach().css({
            top: 0,
            left: 0,
            display: 'block'
          }).addClass(placement).data('bs.' + this.type, this);
          this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element);
          this.$element.trigger('inserted.bs.' + this.type);
          var pos = this.getPosition();
          var actualWidth = $tip[0].offsetWidth;
          var actualHeight = $tip[0].offsetHeight;
          if (autoPlace) {
            var orgPlacement = placement;
            var viewportDim = this.getPosition(this.$viewport);
            placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;
            $tip.removeClass(orgPlacement).addClass(placement);
          }
          var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
          this.applyPlacement(calculatedOffset, placement);
          var complete = function() {
            var prevHoverState = that.hoverState;
            that.$element.trigger('shown.bs.' + that.type);
            that.hoverState = null;
            if (prevHoverState == 'out')
              that.leave(that);
          };
          $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        }
      };
      Tooltip.prototype.applyPlacement = function(offset, placement) {
        var $tip = this.tip();
        var width = $tip[0].offsetWidth;
        var height = $tip[0].offsetHeight;
        var marginTop = parseInt($tip.css('margin-top'), 10);
        var marginLeft = parseInt($tip.css('margin-left'), 10);
        if (isNaN(marginTop))
          marginTop = 0;
        if (isNaN(marginLeft))
          marginLeft = 0;
        offset.top += marginTop;
        offset.left += marginLeft;
        $.offset.setOffset($tip[0], $.extend({using: function(props) {
            $tip.css({
              top: Math.round(props.top),
              left: Math.round(props.left)
            });
          }}, offset), 0);
        $tip.addClass('in');
        var actualWidth = $tip[0].offsetWidth;
        var actualHeight = $tip[0].offsetHeight;
        if (placement == 'top' && actualHeight != height) {
          offset.top = offset.top + height - actualHeight;
        }
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        if (delta.left)
          offset.left += delta.left;
        else
          offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement);
        var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
        var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
        $tip.offset(offset);
        this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
      };
      Tooltip.prototype.replaceArrow = function(delta, dimension, isVertical) {
        this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
      };
      Tooltip.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        $tip.find('.tooltip-inner')[this.options.html ? 'html' : 'text'](title);
        $tip.removeClass('fade in top bottom left right');
      };
      Tooltip.prototype.hide = function(callback) {
        var that = this;
        var $tip = $(this.$tip);
        var e = $.Event('hide.bs.' + this.type);
        function complete() {
          if (that.hoverState != 'in')
            $tip.detach();
          that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
          callback && callback();
        }
        this.$element.trigger(e);
        if (e.isDefaultPrevented())
          return;
        $tip.removeClass('in');
        $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
        this.hoverState = null;
        return this;
      };
      Tooltip.prototype.fixTitle = function() {
        var $e = this.$element;
        if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
          $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
        }
      };
      Tooltip.prototype.hasContent = function() {
        return this.getTitle();
      };
      Tooltip.prototype.getPosition = function($element) {
        $element = $element || this.$element;
        var el = $element[0];
        var isBody = el.tagName == 'BODY';
        var elRect = el.getBoundingClientRect();
        if (elRect.width == null) {
          elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
          });
        }
        var elOffset = isBody ? {
          top: 0,
          left: 0
        } : $element.offset();
        var scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()};
        var outerDims = isBody ? {
          width: $(window).width(),
          height: $(window).height()
        } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset);
      };
      Tooltip.prototype.getCalculatedOffset = function(placement, pos, actualWidth, actualHeight) {
        return placement == 'bottom' ? {
          top: pos.top + pos.height,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'top' ? {
          top: pos.top - actualHeight,
          left: pos.left + pos.width / 2 - actualWidth / 2
        } : placement == 'left' ? {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left - actualWidth
        } : {
          top: pos.top + pos.height / 2 - actualHeight / 2,
          left: pos.left + pos.width
        };
      };
      Tooltip.prototype.getViewportAdjustedDelta = function(placement, pos, actualWidth, actualHeight) {
        var delta = {
          top: 0,
          left: 0
        };
        if (!this.$viewport)
          return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
        var viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
          var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
          var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
          if (topEdgeOffset < viewportDimensions.top) {
            delta.top = viewportDimensions.top - topEdgeOffset;
          } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
            delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
          }
        } else {
          var leftEdgeOffset = pos.left - viewportPadding;
          var rightEdgeOffset = pos.left + viewportPadding + actualWidth;
          if (leftEdgeOffset < viewportDimensions.left) {
            delta.left = viewportDimensions.left - leftEdgeOffset;
          } else if (rightEdgeOffset > viewportDimensions.right) {
            delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
          }
        }
        return delta;
      };
      Tooltip.prototype.getTitle = function() {
        var title;
        var $e = this.$element;
        var o = this.options;
        title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
        return title;
      };
      Tooltip.prototype.getUID = function(prefix) {
        do
          prefix += ~~(Math.random() * 1000000);
 while (document.getElementById(prefix));
        return prefix;
      };
      Tooltip.prototype.tip = function() {
        if (!this.$tip) {
          this.$tip = $(this.options.template);
          if (this.$tip.length != 1) {
            throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
          }
        }
        return this.$tip;
      };
      Tooltip.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow'));
      };
      Tooltip.prototype.enable = function() {
        this.enabled = true;
      };
      Tooltip.prototype.disable = function() {
        this.enabled = false;
      };
      Tooltip.prototype.toggleEnabled = function() {
        this.enabled = !this.enabled;
      };
      Tooltip.prototype.toggle = function(e) {
        var self = this;
        if (e) {
          self = $(e.currentTarget).data('bs.' + this.type);
          if (!self) {
            self = new this.constructor(e.currentTarget, this.getDelegateOptions());
            $(e.currentTarget).data('bs.' + this.type, self);
          }
        }
        if (e) {
          self.inState.click = !self.inState.click;
          if (self.isInStateTrue())
            self.enter(self);
          else
            self.leave(self);
        } else {
          self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
        }
      };
      Tooltip.prototype.destroy = function() {
        var that = this;
        clearTimeout(this.timeout);
        this.hide(function() {
          that.$element.off('.' + that.type).removeData('bs.' + that.type);
          if (that.$tip) {
            that.$tip.detach();
          }
          that.$tip = null;
          that.$arrow = null;
          that.$viewport = null;
        });
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tooltip');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.tooltip', (data = new Tooltip(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tooltip;
      $.fn.tooltip = Plugin;
      $.fn.tooltip.Constructor = Tooltip;
      $.fn.tooltip.noConflict = function() {
        $.fn.tooltip = old;
        return this;
      };
    }(jQuery);
    +function($) {
      'use strict';
      var Popover = function(element, options) {
        this.init('popover', element, options);
      };
      if (!$.fn.tooltip)
        throw new Error('Popover requires tooltip.js');
      Popover.VERSION = '3.3.6';
      Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: 'right',
        trigger: 'click',
        content: '',
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
      });
      Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
      Popover.prototype.constructor = Popover;
      Popover.prototype.getDefaults = function() {
        return Popover.DEFAULTS;
      };
      Popover.prototype.setContent = function() {
        var $tip = this.tip();
        var title = this.getTitle();
        var content = this.getContent();
        $tip.find('.popover-title')[this.options.html ? 'html' : 'text'](title);
        $tip.find('.popover-content').children().detach().end()[this.options.html ? (typeof content == 'string' ? 'html' : 'append') : 'text'](content);
        $tip.removeClass('fade top bottom left right in');
        if (!$tip.find('.popover-title').html())
          $tip.find('.popover-title').hide();
      };
      Popover.prototype.hasContent = function() {
        return this.getTitle() || this.getContent();
      };
      Popover.prototype.getContent = function() {
        var $e = this.$element;
        var o = this.options;
        return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
      };
      Popover.prototype.arrow = function() {
        return (this.$arrow = this.$arrow || this.tip().find('.arrow'));
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.popover');
          var options = typeof option == 'object' && option;
          if (!data && /destroy|hide/.test(option))
            return;
          if (!data)
            $this.data('bs.popover', (data = new Popover(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.popover;
      $.fn.popover = Plugin;
      $.fn.popover.Constructor = Popover;
      $.fn.popover.noConflict = function() {
        $.fn.popover = old;
        return this;
      };
    }(jQuery);
    +function($) {
      'use strict';
      function ScrollSpy(element, options) {
        this.$body = $(document.body);
        this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
        this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
        this.selector = (this.options.target || '') + ' .nav li > a';
        this.offsets = [];
        this.targets = [];
        this.activeTarget = null;
        this.scrollHeight = 0;
        this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
        this.refresh();
        this.process();
      }
      ScrollSpy.VERSION = '3.3.6';
      ScrollSpy.DEFAULTS = {offset: 10};
      ScrollSpy.prototype.getScrollHeight = function() {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
      };
      ScrollSpy.prototype.refresh = function() {
        var that = this;
        var offsetMethod = 'offset';
        var offsetBase = 0;
        this.offsets = [];
        this.targets = [];
        this.scrollHeight = this.getScrollHeight();
        if (!$.isWindow(this.$scrollElement[0])) {
          offsetMethod = 'position';
          offsetBase = this.$scrollElement.scrollTop();
        }
        this.$body.find(this.selector).map(function() {
          var $el = $(this);
          var href = $el.data('target') || $el.attr('href');
          var $href = /^#./.test(href) && $(href);
          return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null;
        }).sort(function(a, b) {
          return a[0] - b[0];
        }).each(function() {
          that.offsets.push(this[0]);
          that.targets.push(this[1]);
        });
      };
      ScrollSpy.prototype.process = function() {
        var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
        var scrollHeight = this.getScrollHeight();
        var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
        var offsets = this.offsets;
        var targets = this.targets;
        var activeTarget = this.activeTarget;
        var i;
        if (this.scrollHeight != scrollHeight) {
          this.refresh();
        }
        if (scrollTop >= maxScroll) {
          return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        }
        if (activeTarget && scrollTop < offsets[0]) {
          this.activeTarget = null;
          return this.clear();
        }
        for (i = offsets.length; i--; ) {
          activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
        }
      };
      ScrollSpy.prototype.activate = function(target) {
        this.activeTarget = target;
        this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
        var active = $(selector).parents('li').addClass('active');
        if (active.parent('.dropdown-menu').length) {
          active = active.closest('li.dropdown').addClass('active');
        }
        active.trigger('activate.bs.scrollspy');
      };
      ScrollSpy.prototype.clear = function() {
        $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.scrollspy');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.scrollspy', (data = new ScrollSpy(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.scrollspy;
      $.fn.scrollspy = Plugin;
      $.fn.scrollspy.Constructor = ScrollSpy;
      $.fn.scrollspy.noConflict = function() {
        $.fn.scrollspy = old;
        return this;
      };
      $(window).on('load.bs.scrollspy.data-api', function() {
        $('[data-spy="scroll"]').each(function() {
          var $spy = $(this);
          Plugin.call($spy, $spy.data());
        });
      });
    }(jQuery);
    +function($) {
      'use strict';
      var Tab = function(element) {
        this.element = $(element);
      };
      Tab.VERSION = '3.3.6';
      Tab.TRANSITION_DURATION = 150;
      Tab.prototype.show = function() {
        var $this = this.element;
        var $ul = $this.closest('ul:not(.dropdown-menu)');
        var selector = $this.data('target');
        if (!selector) {
          selector = $this.attr('href');
          selector = selector && selector.replace(/.*(?=#[^\s]*$)/, '');
        }
        if ($this.parent('li').hasClass('active'))
          return;
        var $previous = $ul.find('.active:last a');
        var hideEvent = $.Event('hide.bs.tab', {relatedTarget: $this[0]});
        var showEvent = $.Event('show.bs.tab', {relatedTarget: $previous[0]});
        $previous.trigger(hideEvent);
        $this.trigger(showEvent);
        if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented())
          return;
        var $target = $(selector);
        this.activate($this.closest('li'), $ul);
        this.activate($target, $target.parent(), function() {
          $previous.trigger({
            type: 'hidden.bs.tab',
            relatedTarget: $this[0]
          });
          $this.trigger({
            type: 'shown.bs.tab',
            relatedTarget: $previous[0]
          });
        });
      };
      Tab.prototype.activate = function(element, container, callback) {
        var $active = container.find('> .active');
        var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);
        function next() {
          $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
          element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);
          if (transition) {
            element[0].offsetWidth;
            element.addClass('in');
          } else {
            element.removeClass('fade');
          }
          if (element.parent('.dropdown-menu').length) {
            element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
          }
          callback && callback();
        }
        $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
        $active.removeClass('in');
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.tab');
          if (!data)
            $this.data('bs.tab', (data = new Tab(this)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.tab;
      $.fn.tab = Plugin;
      $.fn.tab.Constructor = Tab;
      $.fn.tab.noConflict = function() {
        $.fn.tab = old;
        return this;
      };
      var clickHandler = function(e) {
        e.preventDefault();
        Plugin.call($(this), 'show');
      };
      $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
    }(jQuery);
    +function($) {
      'use strict';
      var Affix = function(element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options);
        this.$target = $(this.options.target).on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
        this.$element = $(element);
        this.affixed = null;
        this.unpin = null;
        this.pinnedOffset = null;
        this.checkPosition();
      };
      Affix.VERSION = '3.3.6';
      Affix.RESET = 'affix affix-top affix-bottom';
      Affix.DEFAULTS = {
        offset: 0,
        target: window
      };
      Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        var targetHeight = this.$target.height();
        if (offsetTop != null && this.affixed == 'top')
          return scrollTop < offsetTop ? 'top' : false;
        if (this.affixed == 'bottom') {
          if (offsetTop != null)
            return (scrollTop + this.unpin <= position.top) ? false : 'bottom';
          return (scrollTop + targetHeight <= scrollHeight - offsetBottom) ? false : 'bottom';
        }
        var initializing = this.affixed == null;
        var colliderTop = initializing ? scrollTop : position.top;
        var colliderHeight = initializing ? targetHeight : height;
        if (offsetTop != null && scrollTop <= offsetTop)
          return 'top';
        if (offsetBottom != null && (colliderTop + colliderHeight >= scrollHeight - offsetBottom))
          return 'bottom';
        return false;
      };
      Affix.prototype.getPinnedOffset = function() {
        if (this.pinnedOffset)
          return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass('affix');
        var scrollTop = this.$target.scrollTop();
        var position = this.$element.offset();
        return (this.pinnedOffset = position.top - scrollTop);
      };
      Affix.prototype.checkPositionWithEventLoop = function() {
        setTimeout($.proxy(this.checkPosition, this), 1);
      };
      Affix.prototype.checkPosition = function() {
        if (!this.$element.is(':visible'))
          return;
        var height = this.$element.height();
        var offset = this.options.offset;
        var offsetTop = offset.top;
        var offsetBottom = offset.bottom;
        var scrollHeight = Math.max($(document).height(), $(document.body).height());
        if (typeof offset != 'object')
          offsetBottom = offsetTop = offset;
        if (typeof offsetTop == 'function')
          offsetTop = offset.top(this.$element);
        if (typeof offsetBottom == 'function')
          offsetBottom = offset.bottom(this.$element);
        var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
        if (this.affixed != affix) {
          if (this.unpin != null)
            this.$element.css('top', '');
          var affixType = 'affix' + (affix ? '-' + affix : '');
          var e = $.Event(affixType + '.bs.affix');
          this.$element.trigger(e);
          if (e.isDefaultPrevented())
            return;
          this.affixed = affix;
          this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
          this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
        }
        if (affix == 'bottom') {
          this.$element.offset({top: scrollHeight - height - offsetBottom});
        }
      };
      function Plugin(option) {
        return this.each(function() {
          var $this = $(this);
          var data = $this.data('bs.affix');
          var options = typeof option == 'object' && option;
          if (!data)
            $this.data('bs.affix', (data = new Affix(this, options)));
          if (typeof option == 'string')
            data[option]();
        });
      }
      var old = $.fn.affix;
      $.fn.affix = Plugin;
      $.fn.affix.Constructor = Affix;
      $.fn.affix.noConflict = function() {
        $.fn.affix = old;
        return this;
      };
      $(window).on('load', function() {
        $('[data-spy="affix"]').each(function() {
          var $spy = $(this);
          var data = $spy.data();
          data.offset = data.offset || {};
          if (data.offsetBottom != null)
            data.offset.bottom = data.offsetBottom;
          if (data.offsetTop != null)
            data.offset.top = data.offsetTop;
          Plugin.call($spy, data);
        });
      });
    }(jQuery);
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("4", ["2"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('2');
  return module.exports;
});

$__System.register("5", [], function() { return { setters: [], execute: function() {} } });

$__System.register('6', [], function (_export) {
    /**
     * Draws a grid on the current viewport
     * - If grid already exists, it removes and redraws it
     *
     * @param  {Number} cellSize - Size of each cell in pixels
     *
     * Author:
     * - Nicholas Kyriakides(@nicholaswmin, nik.kyriakides@gmail.com)
     *
     * License:
     * - MIT
     */
    'use strict';

    _export('drawGrid', drawGrid);

    function drawGrid(options, paperScope) {
        'use strict';
        this.cellSize = options.DIMENSION;
        this.gridColor = options.LINE_COLOR;
        this.lineWidth = options.LINE_WIDTH;

        var self = this;
        this.gridGroup;

        var boundingRect = paperScope.view.bounds;
        var rectanglesX = paperScope.view.bounds.width / this.cellSize;
        var rectanglesY = paperScope.view.bounds.height / this.cellSize;

        this.createGrid = function () {

            self.gridGroup = new paperScope.Group();

            //Vertical Lines
            for (var i = 0; i <= rectanglesX; i++) {
                var correctedLeftBounds = Math.ceil(boundingRect.left / self.cellSize) * self.cellSize;
                var xPos = correctedLeftBounds + i * self.cellSize;
                var topPoint = new paperScope.Point(xPos, boundingRect.top);
                var bottomPoint = new paperScope.Point(xPos, boundingRect.bottom);
                var gridLine = new paperScope.Path.Line(topPoint, bottomPoint);
                gridLine.strokeColor = self.gridColor;
                gridLine.strokeWidth = self.lineWidth / paperScope.view.zoom;

                self.gridGroup.addChild(gridLine);
            }

            //Horizontal Lines
            for (var i = 0; i <= rectanglesY; i++) {
                var correctedTopBounds = Math.ceil(boundingRect.top / self.cellSize) * self.cellSize;
                var yPos = correctedTopBounds + i * self.cellSize;
                var leftPoint = new paperScope.Point(boundingRect.left, yPos);
                var rightPoint = new paperScope.Point(boundingRect.right, yPos);
                var gridLine = new paperScope.Path.Line(leftPoint, rightPoint);

                gridLine.strokeColor = self.gridColor;
                gridLine.strokeWidth = self.lineWidth / paperScope.view.zoom;

                self.gridGroup.addChild(gridLine);
            }

            self.gridGroup.sendToBack();
            paperScope.view.update();
        };

        //Removes the children of the gridGroup and discards the gridGroup itself
        this.removeGrid = function () {
            for (var i = 0; i <= gridGroup.children.length - 1; i++) {
                self.gridGroup.children[i].remove();
            }
            self.gridGroup.remove();
        };

        //Initialization
        if (typeof gridGroup === 'undefined') {
            this.createGrid();
        } else {
            this.removeGrid();
            this.createGrid();
        }
    }

    return {
        setters: [],
        execute: function () {}
    };
});

$__System.registerDynamic("7", ["8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var defined = $__require('8');
  module.exports = function(it) {
    return Object(defined(it));
  };
  return module.exports;
});

$__System.registerDynamic("9", ["7", "a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toObject = $__require('7');
  $__require('a')('keys', function($keys) {
    return function keys(it) {
      return $keys(toObject(it));
    };
  });
  return module.exports;
});

$__System.registerDynamic("b", ["9", "c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('9');
  module.exports = $__require('c').Object.keys;
  return module.exports;
});

$__System.registerDynamic("d", ["b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('b'),
    __esModule: true
  };
  return module.exports;
});

$__System.register('e', ['10', '11', '12', '13', '14', '15', '16', '17', 'f'], function (_export) {
    var Configuration, RODAN_EVENTS, GUI_EVENTS, paper, _get, _inherits, _createClass, _classCallCheck, BaseItem, ConnectionItem;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_8) {
            GUI_EVENTS = _8['default'];
        }, function (_5) {
            paper = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }],
        execute: function () {

            /**
             * Connection item.
             */
            'use strict';

            ConnectionItem = (function (_BaseItem) {
                _inherits(ConnectionItem, _BaseItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function ConnectionItem(options) {
                    var _this = this;

                    _classCallCheck(this, ConnectionItem);

                    _get(Object.getPrototypeOf(ConnectionItem.prototype), 'constructor', this).call(this, options);

                    var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                    this.menuItems = [{ label: 'Delete', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_CONNECTION, options: { connection: options.model, workflow: workflow } }];

                    this.strokeWidth = Configuration.WORKFLOWBUILDERGUI.STROKE_WIDTH;
                    this._inputPortItem = null;
                    this._outputPortItem = null;
                    this._inputPortUrl = options.inputporturl;
                    this._outputPortUrl = options.outputporturl;

                    // We'll put a small circle in the middle of our connection so it's easier to select.
                    var circleCenter = new paper.Point(0, 0);
                    this._circle = new paper.Shape.Circle(circleCenter, Configuration.WORKFLOWBUILDERGUI.CONNECTION_CIRCLE_RADIUS);
                    this._circle.fillColor = Configuration.WORKFLOWBUILDERGUI.STROKE_COLOR;
                    this._circle.onMouseDown = function (event) {
                        return _this._handleMouseEvent(event);
                    };
                    this._circle.onMouseUp = function (event) {
                        return _this._handleMouseEvent(event);
                    };
                    this._circle.onClick = function (event) {
                        return _this._handleMouseEvent(event);
                    };
                    this._circle.onMouseEnter = function (event) {
                        return _this._handleMouseEvent(event);
                    };
                    this._circle.onMouseLeave = function (event) {
                        return _this._handleMouseEvent(event);
                    };
                    this.addChild(this._circle);
                }

                /**
                 * Return true iff this item can be moved by itself.
                 */

                _createClass(ConnectionItem, [{
                    key: 'isMoveable',
                    value: function isMoveable() {
                        return false;
                    }

                    /**
                     * Update.
                     */
                }, {
                    key: 'update',
                    value: function update() {
                        // We do this in case the InputPortItem was created AFTER this ConnectionItem.
                        if (!this._inputPortItem) {
                            this._inputPortItem = BaseItem.getAssociatedItem(this._inputPortUrl);
                            if (this._inputPortItem) {
                                this._inputPortItem.setConnectionItem(this);
                            }
                        }

                        // We do this in case the OutputPortItem was created AFTER this port.
                        if (!this._outputPortItem) {
                            this._outputPortItem = BaseItem.getAssociatedItem(this._outputPortUrl);
                            if (this._outputPortItem) {
                                this._outputPortItem.addConnectionItem(this);
                            }
                        }

                        if (this._inputPortItem && this._outputPortItem) {
                            this._circle.visible = this.visible;
                            this.firstSegment.point.x = this._outputPortItem.position.x;
                            this.firstSegment.point.y = this._outputPortItem.bounds.bottom;
                            this.lastSegment.point.x = this._inputPortItem.position.x;
                            this.lastSegment.point.y = this._inputPortItem.bounds.top;
                            this._circle.position.x = this.firstSegment.point.x + (this.lastSegment.point.x - this.firstSegment.point.x) / 2;
                            this._circle.position.y = this.firstSegment.point.y + (this.lastSegment.point.y - this.firstSegment.point.y) / 2;
                        }
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this._circle.remove();
                        if (this._inputPortItem) {
                            this._inputPortItem.setConnectionItem(null);
                        }
                        this._inputPortItem = null;
                        if (this._outputPortItem) {
                            this._outputPortItem.removeConnectionItem(this);
                        }
                        this._outputPortItem = null;
                        _get(Object.getPrototypeOf(ConnectionItem.prototype), 'destroy', this).call(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                }]);

                return ConnectionItem;
            })(BaseItem);

            _export('default', ConnectionItem);
        }
    };
});

$__System.register('18', ['10', '11', '12', '14', '15', '16', '17', '19'], function (_export) {
    var Configuration, RODAN_EVENTS, GUI_EVENTS, _get, _inherits, _createClass, _classCallCheck, BasePortItem, InputPortItem;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_8) {
            GUI_EVENTS = _8['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            BasePortItem = _5['default'];
        }],
        execute: function () {

            /**
             * InputPort item.
             */
            'use strict';

            InputPortItem = (function (_BasePortItem) {
                _inherits(InputPortItem, _BasePortItem);

                _createClass(InputPortItem, null, [{
                    key: 'getContextMenuDataMultiple',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC STATIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns context menu data for multiple items of this class.
                     * Takes in URLs of multiple selections.
                     *
                     * The menu data is simply an array of objects. Objects should be:
                     *
                     * {
                     *      label: [string] // The text that should appear
                     *      radiorequest: RODAN_EVENTS.?  // The Request to make. NOT A RADIO EVENT, rather a REQUEST.
                     *      options: Object holding any options for Event
                     * }
                     */
                    value: function getContextMenuDataMultiple() {
                        return [{ channel: 'rodan-client_gui', label: 'Create Resource Distributor', radiorequest: GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ADD_RESOURCEDISTRIBUTOR }];
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Constructor.
                     */
                }]);

                function InputPortItem(options) {
                    _classCallCheck(this, InputPortItem);

                    _get(Object.getPrototypeOf(InputPortItem.prototype), 'constructor', this).call(this, options);
                    this._connectionItem = null;
                }

                /**
                 * Sets associated connection item.
                 */

                _createClass(InputPortItem, [{
                    key: 'setConnectionItem',
                    value: function setConnectionItem(item) {
                        this._connectionItem = item;
                    }

                    /**
                     * Return true iff has connection item.
                     */
                }, {
                    key: 'hasConnectionItem',
                    value: function hasConnectionItem() {
                        return this._connectionItem !== null;
                    }

                    /**
                     * Return true iff satisfied.
                     */
                }, {
                    key: 'isSatisfied',
                    value: function isSatisfied() {
                        var resourceAssignments = this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_GET_RESOURCEASSIGNMENTS, { inputport: this.getModel() });
                        return this.hasConnectionItem() || resourceAssignments.length > 0;
                    }

                    /**
                     * Update.
                     */
                }, {
                    key: 'update',
                    value: function update() {
                        _get(Object.getPrototypeOf(InputPortItem.prototype), 'update', this).call(this);
                        if (this._temporaryColor) {
                            this.fillColor = this._temporaryColor;
                        } else {
                            this.fillColor = this.isSatisfied() ? Configuration.WORKFLOWBUILDERGUI.INPUTPORT_COLOR_SATISFIED : Configuration.WORKFLOWBUILDERGUI.INPUTPORT_COLOR_UNSATISFIED;
                        }
                        if (this._connectionItem !== null) {
                            this._connectionItem.setVisible(this.visible);
                        }
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        if (this.hasConnectionItem()) {
                            this._connectionItem.destroy();
                            this._connectionItem = null;
                        }
                        _get(Object.getPrototypeOf(InputPortItem.prototype), 'destroy', this).call(this);
                    }

                    /**
                     * Returns context menu data for single item of this class.
                     * We override as some things should not be visible.
                     */
                }, {
                    key: 'getContextMenuDataSingle',
                    value: function getContextMenuDataSingle() {
                        var menuItems = [];
                        if (!this.hasConnectionItem()) {
                            var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                            menuItems.push({ label: 'Assign Resources', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_RESOURCEASSIGNMENT_VIEW, options: { inputport: this.getModel(), workflow: workflow } });
                        }
                        return menuItems;
                    }

                    /**
                     * Override.
                     */
                }, {
                    key: 'addToOwner',
                    value: function addToOwner(ownerItem) {
                        ownerItem.addInputPortItem(this);
                    }

                    /**
                     * Override.
                     */
                }, {
                    key: 'removeFromOwner',
                    value: function removeFromOwner(ownerItem) {
                        ownerItem.deleteInputPortItem(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick(mouseEvent) {
                        if (!this.hasConnectionItem()) {
                            var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                            this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_RESOURCEASSIGNMENT_VIEW, { inputport: this.getModel(), workflow: workflow });
                        }
                    }
                }]);

                return InputPortItem;
            })(BasePortItem);

            _export('default', InputPortItem);
        }
    };
});

$__System.register('1a', ['14', '15', '16', '17', 'f'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseItem, LineItem;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }],
        execute: function () {

            /**
             * Line item.
             */
            'use strict';

            LineItem = (function (_BaseItem) {
                _inherits(LineItem, _BaseItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function LineItem(options) {
                    _classCallCheck(this, LineItem);

                    _get(Object.getPrototypeOf(LineItem.prototype), 'constructor', this).call(this, options);
                    this.firstSegment.point = options.startPoint;
                }

                /**
                 * Sets endpoint.
                 */

                _createClass(LineItem, [{
                    key: 'setEndPoint',
                    value: function setEndPoint(point) {
                        this.lastSegment.point = point;
                    }

                    /**
                     * Update (dummy).
                     */
                }, {
                    key: 'update',
                    value: function update() {}
                }]);

                return LineItem;
            })(BaseItem);

            _export('default', LineItem);
        }
    };
});

$__System.register('19', ['14', '15', '16', '17', 'f'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseItem, BasePortItem;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }],
        execute: function () {

            /**
             * BasePortItem item.
             */
            'use strict';

            BasePortItem = (function (_BaseItem) {
                _inherits(BasePortItem, _BaseItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function BasePortItem(options) {
                    var _this = this;

                    _classCallCheck(this, BasePortItem);

                    _get(Object.getPrototypeOf(BasePortItem.prototype), 'constructor', this).call(this, options);
                    this._workflowJobUrl = options.workflowjoburl;
                    this._ownerUrl = this._workflowJobUrl;
                    this._ownerItem = null;
                    this.onDoubleClick = function (event) {
                        return _this._handleDoubleClick(event);
                    };
                }

                /**
                 * Return true iff this item can be moved by itself.
                 */

                _createClass(BasePortItem, [{
                    key: 'isMoveable',
                    value: function isMoveable() {
                        return false;
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        if (this._ownerItem) {
                            this.removeFromOwner(this._ownerItem);
                        }
                        _get(Object.getPrototypeOf(BasePortItem.prototype), 'destroy', this).call(this);
                    }

                    /**
                     * Return menu items.
                     */
                }, {
                    key: 'getContextMenuDataSingle',
                    value: function getContextMenuDataSingle() {
                        return this._menuItems;
                    }

                    /**
                     * Returns associated WorkflowJobItem.
                     */
                }, {
                    key: 'getWorkflowJobItem',
                    value: function getWorkflowJobItem() {
                        return BaseItem.getAssociatedItem(this._workflowJobUrl);
                    }

                    /**
                     * Update.
                     */
                }, {
                    key: 'update',
                    value: function update() {
                        this.updateOwnership();
                    }

                    /**
                     * Resets the owner to the WorkflowJobItem.
                     */
                }, {
                    key: 'resetOwner',
                    value: function resetOwner() {
                        this._ownerUrl = this._workflowJobUrl;
                    }

                    /**
                     * Sets the owner URL.
                     */
                }, {
                    key: 'setOwner',
                    value: function setOwner(url) {
                        this._ownerUrl = url;
                    }

                    /**
                     * Updates ownership. It makes sure that the associated ownerItem (the one positioning it and setting the visibility) is set.
                     * If it is NOT set, it looks for it. When found, it adds itself as a child.
                     */
                }, {
                    key: 'updateOwnership',
                    value: function updateOwnership() {
                        this._ownerItem = BaseItem.getAssociatedItem(this._ownerUrl);
                        if (this._ownerItem) {
                            this.addToOwner(this._ownerItem);
                        }
                    }

                    /**
                     * Add this item to the owner.
                     * Must be implemented by inheriting class.
                     */
                }, {
                    key: 'addToOwner',
                    value: function addToOwner(ownerItem) {
                        // TODO - better way to do abstract methods
                        console.error('This must be defined in sub-class.');
                    }

                    /**
                     * Remove this item from the owner.
                     * Must be implemented by inheriting class.
                     */
                }, {
                    key: 'removeFromOwner',
                    value: function removeFromOwner(ownerItem) {
                        // TODO - better way to do abstract methods
                        console.error('This must be defined in sub-class.');
                    }
                }]);

                return BasePortItem;
            })(BaseItem);

            _export('default', BasePortItem);
        }
    };
});

$__System.register('1b', ['10', '14', '15', '16', '17', '19'], function (_export) {
    var Configuration, _get, _inherits, _createClass, _classCallCheck, BasePortItem, OutputPortItem;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            BasePortItem = _5['default'];
        }],
        execute: function () {

            /**
             * OutputPort item.
             */
            'use strict';

            OutputPortItem = (function (_BasePortItem) {
                _inherits(OutputPortItem, _BasePortItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function OutputPortItem(options) {
                    _classCallCheck(this, OutputPortItem);

                    _get(Object.getPrototypeOf(OutputPortItem.prototype), 'constructor', this).call(this, options);
                    this.fillColor = Configuration.WORKFLOWBUILDERGUI.OUTPUTPORT_COLOR;
                    this._connectionItems = [];
                }

                /**
                 * Adds associated connection item.
                 */

                _createClass(OutputPortItem, [{
                    key: 'addConnectionItem',
                    value: function addConnectionItem(item) {
                        this._connectionItems.push(item);
                    }

                    /**
                     * Removes connection item.
                     */
                }, {
                    key: 'removeConnectionItem',
                    value: function removeConnectionItem(item) {
                        for (var i = 0; i < this._connectionItems.length; i++) {
                            if (this._connectionItems[i] === item) {
                                this._connectionItems.splice(i, 1);
                            }
                        }
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this._destroyConnections();
                        _get(Object.getPrototypeOf(OutputPortItem.prototype), 'destroy', this).call(this);
                    }

                    /**
                     * Override.
                     */
                }, {
                    key: 'addToOwner',
                    value: function addToOwner(ownerItem) {
                        ownerItem.addOutputPortItem(this);
                    }

                    /**
                     * Override.
                     */
                }, {
                    key: 'removeFromOwner',
                    value: function removeFromOwner(ownerItem) {
                        ownerItem.deleteOutputPortItem(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Destroys connections.
                     */
                }, {
                    key: '_destroyConnections',
                    value: function _destroyConnections() {
                        while (this._connectionItems.length > 0) {
                            this._connectionItems[0].destroy();
                        }
                        this._connectionItems = [];
                    }

                    /**
                     * Handle click.
                     */
                }, {
                    key: '_handleClick',
                    value: function _handleClick(event) {
                        _get(Object.getPrototypeOf(OutputPortItem.prototype), '_handleClick', this).call(this, event);
                        console.log('adsadf');
                    }
                }]);

                return OutputPortItem;
            })(BasePortItem);

            _export('default', OutputPortItem);
        }
    };
});

$__System.register('1c', ['14', '15', '16', '17', '1d'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseModel, WorkflowJobGroupCoordinateSet;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * WorkflowJobGroupCoordinateSet.
             */
            'use strict';

            WorkflowJobGroupCoordinateSet = (function (_BaseModel) {
                _inherits(WorkflowJobGroupCoordinateSet, _BaseModel);

                function WorkflowJobGroupCoordinateSet() {
                    _classCallCheck(this, WorkflowJobGroupCoordinateSet);

                    _get(Object.getPrototypeOf(WorkflowJobGroupCoordinateSet.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(WorkflowJobGroupCoordinateSet, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this.routeName = 'workflowjobgroupcoordinatesets';
                    }

                    /**
                     * Parse response from server.
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        if (!response.results) {
                            return response;
                        } else if (response.results.length > 1) {
                            throw new Error('received multiple results for individual model');
                        }
                        return response.results[0];
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                }]);

                return WorkflowJobGroupCoordinateSet;
            })(BaseModel);

            _export('default', WorkflowJobGroupCoordinateSet);
        }
    };
});

$__System.register('1e', ['10', '11', '12', '14', '15', '16', '17', '20', 'f', '1f', '1c'], function (_export) {
    var Configuration, RODAN_EVENTS, GUI_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseItem, BaseWorkflowJobItem, WorkflowJobGroupCoordinateSet, WorkflowJobGroupItem;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_8) {
            GUI_EVENTS = _8['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            Radio = _5['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }, function (_f2) {
            BaseWorkflowJobItem = _f2['default'];
        }, function (_c) {
            WorkflowJobGroupCoordinateSet = _c['default'];
        }],
        execute: function () {

            /**
             * WorkflowJobGroup item.
             */
            'use strict';

            WorkflowJobGroupItem = (function (_BaseWorkflowJobItem) {
                _inherits(WorkflowJobGroupItem, _BaseWorkflowJobItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function WorkflowJobGroupItem(options) {
                    _classCallCheck(this, WorkflowJobGroupItem);

                    _get(Object.getPrototypeOf(WorkflowJobGroupItem.prototype), 'constructor', this).call(this, options);
                    this._workflowJobUrls = options.model.get('workflow_jobs');
                    var workflow = Radio.channel('rodan-client_gui').request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                    this.menuItems = [{ label: 'Edit', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOBGROUP_VIEW, options: { workflow: workflow, workflowjobgroup: this.getModel() } }, { label: 'Ungroup', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_UNGROUP_WORKFLOWJOBGROUP, options: { workflowjobgroup: this.getModel(), workflow: workflow } }, { label: 'Delete', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOBGROUP, options: { workflow: workflow, workflowjobgroup: this.getModel() } }];

                    this.coordinateSetInfo = [];
                    this.coordinateSetInfo['class'] = WorkflowJobGroupCoordinateSet;
                    this.coordinateSetInfo['url'] = 'workflow_job_group';
                    this.loadCoordinates();
                    this.fillColor = Configuration.WORKFLOWBUILDERGUI.WORKFLOWJOBGROUP_FILL_COLOR;
                    this._gotPorts = false;
                }

                /**
                 * Update.
                 */

                _createClass(WorkflowJobGroupItem, [{
                    key: 'update',
                    value: function update() {
                        // Make sure WorkflowJobItems are hidden.
                        this._setWorkflowJobVisibility(false);

                        // We need to get the associated ports.
                        if (!this._gotPorts) {
                            this._getAssociatedPorts();
                        }

                        _get(Object.getPrototypeOf(WorkflowJobGroupItem.prototype), 'update', this).call(this);
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        this._setWorkflowJobVisibility(true);
                        var inputPortItems = this._paperGroupInputPorts.removeChildren();
                        var outputPortItems = this._paperGroupOutputPorts.removeChildren();
                        for (var index in inputPortItems) {
                            inputPortItems[index].resetOwner();
                        }
                        for (var index in outputPortItems) {
                            outputPortItems[index].resetOwner();
                        }
                        _get(Object.getPrototypeOf(WorkflowJobGroupItem.prototype), 'destroy', this).call(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick(mouseEvent) {
                        var workflow = Radio.channel('rodan-client_gui').request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOBGROUP_VIEW, { workflowjobgroup: this.getModel(), workflow: workflow });
                    }

                    /**
                     * Set visibility of associated WorkflowJobItems.
                     */
                }, {
                    key: '_setWorkflowJobVisibility',
                    value: function _setWorkflowJobVisibility(visible) {
                        for (var index in this._workflowJobUrls) {
                            var item = BaseItem.getAssociatedItem(this._workflowJobUrls[index]);
                            if (item) {
                                item.setVisible(visible);
                            }
                        }
                    }

                    /**
                     * Get associated ports.
                     */
                }, {
                    key: '_getAssociatedPorts',
                    value: function _getAssociatedPorts() {
                        var workflow = Radio.channel('rodan-client_gui').request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                        var ports = this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_GET_PORTS, { url: this._modelURL, workflow: workflow });
                        if (ports) {
                            for (var index in ports.inputports) {
                                var inputPortItem = BaseItem.getAssociatedItem(ports.inputports[index].get('url'));
                                inputPortItem.setOwner(this._modelURL);
                            }

                            for (index in ports.outputports) {
                                var outputPortItem = BaseItem.getAssociatedItem(ports.outputports[index].get('url'));
                                outputPortItem.setOwner(this._modelURL);
                            }
                            this._gotPorts = true;
                        }
                    }
                }]);

                return WorkflowJobGroupItem;
            })(BaseWorkflowJobItem);

            _export('default', WorkflowJobGroupItem);
        }
    };
});

$__System.registerDynamic("21", ["22"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    var paper = new function(undefined) {
      var Base = new function() {
        var hidden = /^(statics|enumerable|beans|preserve)$/,
            forEach = [].forEach || function(iter, bind) {
              for (var i = 0,
                  l = this.length; i < l; i++)
                iter.call(bind, this[i], i, this);
            },
            forIn = function(iter, bind) {
              for (var i in this)
                if (this.hasOwnProperty(i))
                  iter.call(bind, this[i], i, this);
            },
            create = Object.create || function(proto) {
              return {__proto__: proto};
            },
            describe = Object.getOwnPropertyDescriptor || function(obj, name) {
              var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
              return get ? {
                get: get,
                set: obj.__lookupSetter__(name),
                enumerable: true,
                configurable: true
              } : obj.hasOwnProperty(name) ? {
                value: obj[name],
                enumerable: true,
                configurable: true,
                writable: true
              } : null;
            },
            _define = Object.defineProperty || function(obj, name, desc) {
              if ((desc.get || desc.set) && obj.__defineGetter__) {
                if (desc.get)
                  obj.__defineGetter__(name, desc.get);
                if (desc.set)
                  obj.__defineSetter__(name, desc.set);
              } else {
                obj[name] = desc.value;
              }
              return obj;
            },
            define = function(obj, name, desc) {
              delete obj[name];
              return _define(obj, name, desc);
            };
        function inject(dest, src, enumerable, beans, preserve) {
          var beansNames = {};
          function field(name, val) {
            val = val || (val = describe(src, name)) && (val.get ? val : val.value);
            if (typeof val === 'string' && val[0] === '#')
              val = dest[val.substring(1)] || val;
            var isFunc = typeof val === 'function',
                res = val,
                prev = preserve || isFunc && !val.base ? (val && val.get ? name in dest : dest[name]) : null,
                bean;
            if (!preserve || !prev) {
              if (isFunc && prev)
                val.base = prev;
              if (isFunc && beans !== false && (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
                beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
              if (!res || isFunc || !res.get || typeof res.get !== 'function' || !Base.isPlainObject(res))
                res = {
                  value: res,
                  writable: true
                };
              if ((describe(dest, name) || {configurable: true}).configurable) {
                res.configurable = true;
                res.enumerable = enumerable;
              }
              define(dest, name, res);
            }
          }
          if (src) {
            for (var name in src) {
              if (src.hasOwnProperty(name) && !hidden.test(name))
                field(name);
            }
            for (var name in beansNames) {
              var part = beansNames[name],
                  set = dest['set' + part],
                  get = dest['get' + part] || set && dest['is' + part];
              if (get && (beans === true || get.length === 0))
                field(name, {
                  get: get,
                  set: set
                });
            }
          }
          return dest;
        }
        function each(obj, iter, bind) {
          if (obj)
            ('length' in obj && !obj.getLength && typeof obj.length === 'number' ? forEach : forIn).call(obj, iter, bind = bind || obj);
          return bind;
        }
        function set(obj, props, exclude) {
          for (var key in props)
            if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
              obj[key] = props[key];
          return obj;
        }
        return inject(function Base() {
          for (var i = 0,
              l = arguments.length; i < l; i++)
            set(this, arguments[i]);
        }, {
          inject: function(src) {
            if (src) {
              var statics = src.statics === true ? src : src.statics,
                  beans = src.beans,
                  preserve = src.preserve;
              if (statics !== src)
                inject(this.prototype, src, src.enumerable, beans, preserve);
              inject(this, statics, true, beans, preserve);
            }
            for (var i = 1,
                l = arguments.length; i < l; i++)
              this.inject(arguments[i]);
            return this;
          },
          extend: function() {
            var base = this,
                ctor,
                proto;
            for (var i = 0,
                l = arguments.length; i < l; i++)
              if (ctor = arguments[i].initialize)
                break;
            ctor = ctor || function() {
              base.apply(this, arguments);
            };
            proto = ctor.prototype = create(this.prototype);
            define(proto, 'constructor', {
              value: ctor,
              writable: true,
              configurable: true
            });
            inject(ctor, this, true);
            if (arguments.length)
              this.inject.apply(ctor, arguments);
            ctor.base = base;
            return ctor;
          }
        }, true).inject({
          inject: function() {
            for (var i = 0,
                l = arguments.length; i < l; i++) {
              var src = arguments[i];
              if (src)
                inject(this, src, src.enumerable, src.beans, src.preserve);
            }
            return this;
          },
          extend: function() {
            var res = create(this);
            return res.inject.apply(res, arguments);
          },
          each: function(iter, bind) {
            return each(this, iter, bind);
          },
          set: function(props) {
            return set(this, props);
          },
          clone: function() {
            return new this.constructor(this);
          },
          statics: {
            each: each,
            create: create,
            define: define,
            describe: describe,
            set: set,
            clone: function(obj) {
              return set(new obj.constructor(), obj);
            },
            isPlainObject: function(obj) {
              var ctor = obj != null && obj.constructor;
              return ctor && (ctor === Object || ctor === Base || ctor.name === 'Object');
            },
            pick: function(a, b) {
              return a !== undefined ? a : b;
            }
          }
        });
      };
      if (typeof module !== 'undefined')
        module.exports = Base;
      Base.inject({
        toString: function() {
          return this._id != null ? (this._class || 'Object') + (this._name ? " '" + this._name + "'" : ' @' + this._id) : '{ ' + Base.each(this, function(value, key) {
            if (!/^_/.test(key)) {
              var type = typeof value;
              this.push(key + ': ' + (type === 'number' ? Formatter.instance.number(value) : type === 'string' ? "'" + value + "'" : value));
            }
          }, []).join(', ') + ' }';
        },
        getClassName: function() {
          return this._class || '';
        },
        exportJSON: function(options) {
          return Base.exportJSON(this, options);
        },
        toJSON: function() {
          return Base.serialize(this);
        },
        _set: function(props, exclude, dontCheck) {
          if (props && (dontCheck || Base.isPlainObject(props))) {
            var keys = Object.keys(props._filtering || props);
            for (var i = 0,
                l = keys.length; i < l; i++) {
              var key = keys[i];
              if (!(exclude && exclude[key])) {
                var value = props[key];
                if (value !== undefined)
                  this[key] = value;
              }
            }
            return true;
          }
        },
        statics: {
          exports: {enumerable: true},
          extend: function extend() {
            var res = extend.base.apply(this, arguments),
                name = res.prototype._class;
            if (name && !Base.exports[name])
              Base.exports[name] = res;
            return res;
          },
          equals: function(obj1, obj2) {
            if (obj1 === obj2)
              return true;
            if (obj1 && obj1.equals)
              return obj1.equals(obj2);
            if (obj2 && obj2.equals)
              return obj2.equals(obj1);
            if (obj1 && obj2 && typeof obj1 === 'object' && typeof obj2 === 'object') {
              if (Array.isArray(obj1) && Array.isArray(obj2)) {
                var length = obj1.length;
                if (length !== obj2.length)
                  return false;
                while (length--) {
                  if (!Base.equals(obj1[length], obj2[length]))
                    return false;
                }
              } else {
                var keys = Object.keys(obj1),
                    length = keys.length;
                if (length !== Object.keys(obj2).length)
                  return false;
                while (length--) {
                  var key = keys[length];
                  if (!(obj2.hasOwnProperty(key) && Base.equals(obj1[key], obj2[key])))
                    return false;
                }
              }
              return true;
            }
            return false;
          },
          read: function(list, start, options, length) {
            if (this === Base) {
              var value = this.peek(list, start);
              list.__index++;
              return value;
            }
            var proto = this.prototype,
                readIndex = proto._readIndex,
                index = start || readIndex && list.__index || 0;
            if (!length)
              length = list.length - index;
            var obj = list[index];
            if (obj instanceof this || options && options.readNull && obj == null && length <= 1) {
              if (readIndex)
                list.__index = index + 1;
              return obj && options && options.clone ? obj.clone() : obj;
            }
            obj = Base.create(this.prototype);
            if (readIndex)
              obj.__read = true;
            obj = obj.initialize.apply(obj, index > 0 || length < list.length ? Array.prototype.slice.call(list, index, index + length) : list) || obj;
            if (readIndex) {
              list.__index = index + obj.__read;
              obj.__read = undefined;
            }
            return obj;
          },
          peek: function(list, start) {
            return list[list.__index = start || list.__index || 0];
          },
          remain: function(list) {
            return list.length - (list.__index || 0);
          },
          readAll: function(list, start, options) {
            var res = [],
                entry;
            for (var i = start || 0,
                l = list.length; i < l; i++) {
              res.push(Array.isArray(entry = list[i]) ? this.read(entry, 0, options) : this.read(list, i, options, 1));
            }
            return res;
          },
          readNamed: function(list, name, start, options, length) {
            var value = this.getNamed(list, name),
                hasObject = value !== undefined;
            if (hasObject) {
              var filtered = list._filtered;
              if (!filtered) {
                filtered = list._filtered = Base.create(list[0]);
                filtered._filtering = list[0];
              }
              filtered[name] = undefined;
            }
            return this.read(hasObject ? [value] : list, start, options, length);
          },
          getNamed: function(list, name) {
            var arg = list[0];
            if (list._hasObject === undefined)
              list._hasObject = list.length === 1 && Base.isPlainObject(arg);
            if (list._hasObject)
              return name ? arg[name] : list._filtered || arg;
          },
          hasNamed: function(list, name) {
            return !!this.getNamed(list, name);
          },
          isPlainValue: function(obj, asString) {
            return this.isPlainObject(obj) || Array.isArray(obj) || asString && typeof obj === 'string';
          },
          serialize: function(obj, options, compact, dictionary) {
            options = options || {};
            var root = !dictionary,
                res;
            if (root) {
              options.formatter = new Formatter(options.precision);
              dictionary = {
                length: 0,
                definitions: {},
                references: {},
                add: function(item, create) {
                  var id = '#' + item._id,
                      ref = this.references[id];
                  if (!ref) {
                    this.length++;
                    var res = create.call(item),
                        name = item._class;
                    if (name && res[0] !== name)
                      res.unshift(name);
                    this.definitions[id] = res;
                    ref = this.references[id] = [id];
                  }
                  return ref;
                }
              };
            }
            if (obj && obj._serialize) {
              res = obj._serialize(options, dictionary);
              var name = obj._class;
              if (name && !compact && !res._compact && res[0] !== name)
                res.unshift(name);
            } else if (Array.isArray(obj)) {
              res = [];
              for (var i = 0,
                  l = obj.length; i < l; i++)
                res[i] = Base.serialize(obj[i], options, compact, dictionary);
              if (compact)
                res._compact = true;
            } else if (Base.isPlainObject(obj)) {
              res = {};
              var keys = Object.keys(obj);
              for (var i = 0,
                  l = keys.length; i < l; i++) {
                var key = keys[i];
                res[key] = Base.serialize(obj[key], options, compact, dictionary);
              }
            } else if (typeof obj === 'number') {
              res = options.formatter.number(obj, options.precision);
            } else {
              res = obj;
            }
            return root && dictionary.length > 0 ? [['dictionary', dictionary.definitions], res] : res;
          },
          deserialize: function(json, create, _data, _isDictionary) {
            var res = json,
                isRoot = !_data;
            _data = _data || {};
            if (Array.isArray(json)) {
              var type = json[0],
                  isDictionary = type === 'dictionary';
              if (json.length == 1 && /^#/.test(type))
                return _data.dictionary[type];
              type = Base.exports[type];
              res = [];
              if (_isDictionary)
                _data.dictionary = res;
              for (var i = type ? 1 : 0,
                  l = json.length; i < l; i++)
                res.push(Base.deserialize(json[i], create, _data, isDictionary));
              if (type) {
                var args = res;
                if (create) {
                  res = create(type, args);
                } else {
                  res = Base.create(type.prototype);
                  type.apply(res, args);
                }
              }
            } else if (Base.isPlainObject(json)) {
              res = {};
              if (_isDictionary)
                _data.dictionary = res;
              for (var key in json)
                res[key] = Base.deserialize(json[key], create, _data);
            }
            return isRoot && json && json.length && json[0][0] === 'dictionary' ? res[1] : res;
          },
          exportJSON: function(obj, options) {
            var json = Base.serialize(obj, options);
            return options && options.asString === false ? json : JSON.stringify(json);
          },
          importJSON: function(json, target) {
            return Base.deserialize(typeof json === 'string' ? JSON.parse(json) : json, function(type, args) {
              var obj = target && target.constructor === type ? target : Base.create(type.prototype),
                  isTarget = obj === target;
              if (args.length === 1 && obj instanceof Item && (isTarget || !(obj instanceof Layer))) {
                var arg = args[0];
                if (Base.isPlainObject(arg))
                  arg.insert = false;
              }
              type.apply(obj, args);
              if (isTarget)
                target = null;
              return obj;
            });
          },
          splice: function(list, items, index, remove) {
            var amount = items && items.length,
                append = index === undefined;
            index = append ? list.length : index;
            if (index > list.length)
              index = list.length;
            for (var i = 0; i < amount; i++)
              items[i]._index = index + i;
            if (append) {
              list.push.apply(list, items);
              return [];
            } else {
              var args = [index, remove];
              if (items)
                args.push.apply(args, items);
              var removed = list.splice.apply(list, args);
              for (var i = 0,
                  l = removed.length; i < l; i++)
                removed[i]._index = undefined;
              for (var i = index + amount,
                  l = list.length; i < l; i++)
                list[i]._index = i;
              return removed;
            }
          },
          capitalize: function(str) {
            return str.replace(/\b[a-z]/g, function(match) {
              return match.toUpperCase();
            });
          },
          camelize: function(str) {
            return str.replace(/-(.)/g, function(all, chr) {
              return chr.toUpperCase();
            });
          },
          hyphenate: function(str) {
            return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
          }
        }
      });
      var Emitter = {
        on: function(type, func) {
          if (typeof type !== 'string') {
            Base.each(type, function(value, key) {
              this.on(key, value);
            }, this);
          } else {
            var types = this._eventTypes,
                entry = types && types[type],
                handlers = this._callbacks = this._callbacks || {};
            handlers = handlers[type] = handlers[type] || [];
            if (handlers.indexOf(func) === -1) {
              handlers.push(func);
              if (entry && entry.install && handlers.length === 1)
                entry.install.call(this, type);
            }
          }
          return this;
        },
        off: function(type, func) {
          if (typeof type !== 'string') {
            Base.each(type, function(value, key) {
              this.off(key, value);
            }, this);
            return;
          }
          var types = this._eventTypes,
              entry = types && types[type],
              handlers = this._callbacks && this._callbacks[type],
              index;
          if (handlers) {
            if (!func || (index = handlers.indexOf(func)) !== -1 && handlers.length === 1) {
              if (entry && entry.uninstall)
                entry.uninstall.call(this, type);
              delete this._callbacks[type];
            } else if (index !== -1) {
              handlers.splice(index, 1);
            }
          }
          return this;
        },
        once: function(type, func) {
          return this.on(type, function() {
            func.apply(this, arguments);
            this.off(type, func);
          });
        },
        emit: function(type, event) {
          var handlers = this._callbacks && this._callbacks[type];
          if (!handlers)
            return false;
          var args = [].slice.call(arguments, 1);
          handlers = handlers.slice();
          for (var i = 0,
              l = handlers.length; i < l; i++) {
            if (handlers[i].apply(this, args) === false) {
              if (event && event.stop)
                event.stop();
              break;
            }
          }
          return true;
        },
        responds: function(type) {
          return !!(this._callbacks && this._callbacks[type]);
        },
        attach: '#on',
        detach: '#off',
        fire: '#emit',
        _installEvents: function(install) {
          var handlers = this._callbacks,
              key = install ? 'install' : 'uninstall';
          for (var type in handlers) {
            if (handlers[type].length > 0) {
              var types = this._eventTypes,
                  entry = types && types[type],
                  func = entry && entry[key];
              if (func)
                func.call(this, type);
            }
          }
        },
        statics: {inject: function inject(src) {
            var events = src._events;
            if (events) {
              var types = {};
              Base.each(events, function(entry, key) {
                var isString = typeof entry === 'string',
                    name = isString ? entry : key,
                    part = Base.capitalize(name),
                    type = name.substring(2).toLowerCase();
                types[type] = isString ? {} : entry;
                name = '_' + name;
                src['get' + part] = function() {
                  return this[name];
                };
                src['set' + part] = function(func) {
                  var prev = this[name];
                  if (prev)
                    this.off(type, prev);
                  if (func)
                    this.on(type, func);
                  this[name] = func;
                };
              });
              src._eventTypes = types;
            }
            return inject.base.apply(this, arguments);
          }}
      };
      var PaperScope = Base.extend({
        _class: 'PaperScope',
        initialize: function PaperScope() {
          paper = this;
          this.settings = new Base({
            applyMatrix: true,
            handleSize: 4,
            hitTolerance: 0
          });
          this.project = null;
          this.projects = [];
          this.tools = [];
          this.palettes = [];
          this._id = PaperScope._id++;
          PaperScope._scopes[this._id] = this;
          var proto = PaperScope.prototype;
          if (!this.support) {
            var ctx = CanvasProvider.getContext(1, 1);
            proto.support = {
              nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
              nativeBlendModes: BlendMode.nativeModes
            };
            CanvasProvider.release(ctx);
          }
          if (!this.browser) {
            var agent = navigator.userAgent.toLowerCase(),
                platform = (/(win)/.exec(agent) || /(mac)/.exec(agent) || /(linux)/.exec(agent) || [])[0],
                browser = proto.browser = {platform: platform};
            if (platform)
              browser[platform] = true;
            agent.replace(/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g, function(all, n, v1, v2, rv) {
              if (!browser.chrome) {
                var v = n === 'opera' ? v2 : v1;
                if (n === 'trident') {
                  v = rv;
                  n = 'msie';
                }
                browser.version = v;
                browser.versionNumber = parseFloat(v);
                browser.name = n;
                browser[n] = true;
              }
            });
            if (browser.chrome)
              delete browser.webkit;
            if (browser.atom)
              delete browser.chrome;
          }
        },
        version: "0.9.25",
        getView: function() {
          return this.project && this.project.getView();
        },
        getPaper: function() {
          return this;
        },
        execute: function(code, url, options) {
          paper.PaperScript.execute(code, this, url, options);
          View.updateFocus();
        },
        install: function(scope) {
          var that = this;
          Base.each(['project', 'view', 'tool'], function(key) {
            Base.define(scope, key, {
              configurable: true,
              get: function() {
                return that[key];
              }
            });
          });
          for (var key in this)
            if (!/^_/.test(key) && this[key])
              scope[key] = this[key];
        },
        setup: function(element) {
          paper = this;
          this.project = new Project(element);
          return this;
        },
        activate: function() {
          paper = this;
        },
        clear: function() {
          for (var i = this.projects.length - 1; i >= 0; i--)
            this.projects[i].remove();
          for (var i = this.tools.length - 1; i >= 0; i--)
            this.tools[i].remove();
          for (var i = this.palettes.length - 1; i >= 0; i--)
            this.palettes[i].remove();
        },
        remove: function() {
          this.clear();
          delete PaperScope._scopes[this._id];
        },
        statics: new function() {
          function handleAttribute(name) {
            name += 'Attribute';
            return function(el, attr) {
              return el[name](attr) || el[name]('data-paper-' + attr);
            };
          }
          return {
            _scopes: {},
            _id: 0,
            get: function(id) {
              return this._scopes[id] || null;
            },
            getAttribute: handleAttribute('get'),
            hasAttribute: handleAttribute('has')
          };
        }
      });
      var PaperScopeItem = Base.extend(Emitter, {
        initialize: function(activate) {
          this._scope = paper;
          this._index = this._scope[this._list].push(this) - 1;
          if (activate || !this._scope[this._reference])
            this.activate();
        },
        activate: function() {
          if (!this._scope)
            return false;
          var prev = this._scope[this._reference];
          if (prev && prev !== this)
            prev.emit('deactivate');
          this._scope[this._reference] = this;
          this.emit('activate', prev);
          return true;
        },
        isActive: function() {
          return this._scope[this._reference] === this;
        },
        remove: function() {
          if (this._index == null)
            return false;
          Base.splice(this._scope[this._list], null, this._index, 1);
          if (this._scope[this._reference] == this)
            this._scope[this._reference] = null;
          this._scope = null;
          return true;
        }
      });
      var Formatter = Base.extend({
        initialize: function(precision) {
          this.precision = precision || 5;
          this.multiplier = Math.pow(10, this.precision);
        },
        number: function(val) {
          return Math.round(val * this.multiplier) / this.multiplier;
        },
        pair: function(val1, val2, separator) {
          return this.number(val1) + (separator || ',') + this.number(val2);
        },
        point: function(val, separator) {
          return this.number(val.x) + (separator || ',') + this.number(val.y);
        },
        size: function(val, separator) {
          return this.number(val.width) + (separator || ',') + this.number(val.height);
        },
        rectangle: function(val, separator) {
          return this.point(val, separator) + (separator || ',') + this.size(val, separator);
        }
      });
      Formatter.instance = new Formatter();
      var Numerical = new function() {
        var abscissas = [[0.5773502691896257645091488], [0, 0.7745966692414833770358531], [0.3399810435848562648026658, 0.8611363115940525752239465], [0, 0.5384693101056830910363144, 0.9061798459386639927976269], [0.2386191860831969086305017, 0.6612093864662645136613996, 0.9324695142031520278123016], [0, 0.4058451513773971669066064, 0.7415311855993944398638648, 0.9491079123427585245261897], [0.1834346424956498049394761, 0.5255324099163289858177390, 0.7966664774136267395915539, 0.9602898564975362316835609], [0, 0.3242534234038089290385380, 0.6133714327005903973087020, 0.8360311073266357942994298, 0.9681602395076260898355762], [0.1488743389816312108848260, 0.4333953941292471907992659, 0.6794095682990244062343274, 0.8650633666889845107320967, 0.9739065285171717200779640], [0, 0.2695431559523449723315320, 0.5190961292068118159257257, 0.7301520055740493240934163, 0.8870625997680952990751578, 0.9782286581460569928039380], [0.1252334085114689154724414, 0.3678314989981801937526915, 0.5873179542866174472967024, 0.7699026741943046870368938, 0.9041172563704748566784659, 0.9815606342467192506905491], [0, 0.2304583159551347940655281, 0.4484927510364468528779129, 0.6423493394403402206439846, 0.8015780907333099127942065, 0.9175983992229779652065478, 0.9841830547185881494728294], [0.1080549487073436620662447, 0.3191123689278897604356718, 0.5152486363581540919652907, 0.6872929048116854701480198, 0.8272013150697649931897947, 0.9284348836635735173363911, 0.9862838086968123388415973], [0, 0.2011940939974345223006283, 0.3941513470775633698972074, 0.5709721726085388475372267, 0.7244177313601700474161861, 0.8482065834104272162006483, 0.9372733924007059043077589, 0.9879925180204854284895657], [0.0950125098376374401853193, 0.2816035507792589132304605, 0.4580167776572273863424194, 0.6178762444026437484466718, 0.7554044083550030338951012, 0.8656312023878317438804679, 0.9445750230732325760779884, 0.9894009349916499325961542]];
        var weights = [[1], [0.8888888888888888888888889, 0.5555555555555555555555556], [0.6521451548625461426269361, 0.3478548451374538573730639], [0.5688888888888888888888889, 0.4786286704993664680412915, 0.2369268850561890875142640], [0.4679139345726910473898703, 0.3607615730481386075698335, 0.1713244923791703450402961], [0.4179591836734693877551020, 0.3818300505051189449503698, 0.2797053914892766679014678, 0.1294849661688696932706114], [0.3626837833783619829651504, 0.3137066458778872873379622, 0.2223810344533744705443560, 0.1012285362903762591525314], [0.3302393550012597631645251, 0.3123470770400028400686304, 0.2606106964029354623187429, 0.1806481606948574040584720, 0.0812743883615744119718922], [0.2955242247147528701738930, 0.2692667193099963550912269, 0.2190863625159820439955349, 0.1494513491505805931457763, 0.0666713443086881375935688], [0.2729250867779006307144835, 0.2628045445102466621806889, 0.2331937645919904799185237, 0.1862902109277342514260976, 0.1255803694649046246346943, 0.0556685671161736664827537], [0.2491470458134027850005624, 0.2334925365383548087608499, 0.2031674267230659217490645, 0.1600783285433462263346525, 0.1069393259953184309602547, 0.0471753363865118271946160], [0.2325515532308739101945895, 0.2262831802628972384120902, 0.2078160475368885023125232, 0.1781459807619457382800467, 0.1388735102197872384636018, 0.0921214998377284479144218, 0.0404840047653158795200216], [0.2152638534631577901958764, 0.2051984637212956039659241, 0.1855383974779378137417166, 0.1572031671581935345696019, 0.1215185706879031846894148, 0.0801580871597602098056333, 0.0351194603317518630318329], [0.2025782419255612728806202, 0.1984314853271115764561183, 0.1861610000155622110268006, 0.1662692058169939335532009, 0.1395706779261543144478048, 0.1071592204671719350118695, 0.0703660474881081247092674, 0.0307532419961172683546284], [0.1894506104550684962853967, 0.1826034150449235888667637, 0.1691565193950025381893121, 0.1495959888165767320815017, 0.1246289712555338720524763, 0.0951585116824927848099251, 0.0622535239386478928628438, 0.0271524594117540948517806]];
        var abs = Math.abs,
            sqrt = Math.sqrt,
            pow = Math.pow,
            EPSILON = 1e-12,
            MACHINE_EPSILON = 1.12e-16;
        function clip(value, min, max) {
          return value < min ? min : value > max ? max : value;
        }
        return {
          TOLERANCE: 1e-6,
          EPSILON: EPSILON,
          MACHINE_EPSILON: MACHINE_EPSILON,
          CURVETIME_EPSILON: 4e-7,
          GEOMETRIC_EPSILON: 2e-7,
          WINDING_EPSILON: 2e-7,
          TRIGONOMETRIC_EPSILON: 1e-7,
          CLIPPING_EPSILON: 1e-7,
          KAPPA: 4 * (sqrt(2) - 1) / 3,
          isZero: function(val) {
            return val >= -EPSILON && val <= EPSILON;
          },
          integrate: function(f, a, b, n) {
            var x = abscissas[n - 2],
                w = weights[n - 2],
                A = (b - a) * 0.5,
                B = A + a,
                i = 0,
                m = (n + 1) >> 1,
                sum = n & 1 ? w[i++] * f(B) : 0;
            while (i < m) {
              var Ax = A * x[i];
              sum += w[i++] * (f(B + Ax) + f(B - Ax));
            }
            return A * sum;
          },
          findRoot: function(f, df, x, a, b, n, tolerance) {
            for (var i = 0; i < n; i++) {
              var fx = f(x),
                  dx = fx / df(x),
                  nx = x - dx;
              if (abs(dx) < tolerance)
                return nx;
              if (fx > 0) {
                b = x;
                x = nx <= a ? (a + b) * 0.5 : nx;
              } else {
                a = x;
                x = nx >= b ? (a + b) * 0.5 : nx;
              }
            }
            return x;
          },
          solveQuadratic: function(a, b, c, roots, min, max) {
            var count = 0,
                eMin = min - EPSILON,
                eMax = max + EPSILON,
                x1,
                x2 = Infinity,
                B = b,
                D;
            b /= -2;
            D = b * b - a * c;
            if (D !== 0 && abs(D) < MACHINE_EPSILON) {
              var gmC = pow(abs(a * b * c), 1 / 3);
              if (gmC < 1e-8) {
                var mult = pow(10, abs(Math.floor(Math.log(gmC) * Math.LOG10E)));
                if (!isFinite(mult))
                  mult = 0;
                a *= mult;
                b *= mult;
                c *= mult;
                D = b * b - a * c;
              }
            }
            if (abs(a) < EPSILON) {
              if (abs(B) < EPSILON)
                return abs(c) < EPSILON ? -1 : 0;
              x1 = -c / B;
            } else if (D >= -MACHINE_EPSILON) {
              var Q = D < 0 ? 0 : sqrt(D),
                  R = b + (b < 0 ? -Q : Q);
              if (R === 0) {
                x1 = c / a;
                x2 = -x1;
              } else {
                x1 = R / a;
                x2 = c / R;
              }
            }
            if (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))
              roots[count++] = min == null ? x1 : clip(x1, min, max);
            if (x2 !== x1 && isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))
              roots[count++] = min == null ? x2 : clip(x2, min, max);
            return count;
          },
          solveCubic: function(a, b, c, d, roots, min, max) {
            var count = 0,
                x,
                b1,
                c2;
            if (abs(a) < EPSILON) {
              a = b;
              b1 = c;
              c2 = d;
              x = Infinity;
            } else if (abs(d) < EPSILON) {
              b1 = b;
              c2 = c;
              x = 0;
            } else {
              var ec = 1 + MACHINE_EPSILON,
                  x0,
                  q,
                  qd,
                  t,
                  r,
                  s,
                  tmp;
              x = -(b / a) / 3;
              tmp = a * x, b1 = tmp + b, c2 = b1 * x + c, qd = (tmp + b1) * x + c2, q = c2 * x + d;
              t = q / a;
              r = pow(abs(t), 1 / 3);
              s = t < 0 ? -1 : 1;
              t = -qd / a;
              r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
              x0 = x - s * r;
              if (x0 !== x) {
                do {
                  x = x0;
                  tmp = a * x, b1 = tmp + b, c2 = b1 * x + c, qd = (tmp + b1) * x + c2, q = c2 * x + d;
                  x0 = qd === 0 ? x : x - q / qd / ec;
                  if (x0 === x) {
                    x = x0;
                    break;
                  }
                } while (s * x0 > s * x);
                if (abs(a) * x * x > abs(d / x)) {
                  c2 = -d / x;
                  b1 = (c2 - c) / x;
                }
              }
            }
            var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
            if (isFinite(x) && (count === 0 || x !== roots[count - 1]) && (min == null || x > min - EPSILON && x < max + EPSILON))
              roots[count++] = min == null ? x : clip(x, min, max);
            return count;
          }
        };
      };
      var UID = {
        _id: 1,
        _pools: {},
        get: function(ctor) {
          if (ctor) {
            var name = ctor._class,
                pool = this._pools[name];
            if (!pool)
              pool = this._pools[name] = {_id: 1};
            return pool._id++;
          } else {
            return this._id++;
          }
        }
      };
      var Point = Base.extend({
        _class: 'Point',
        _readIndex: true,
        initialize: function Point(arg0, arg1) {
          var type = typeof arg0;
          if (type === 'number') {
            var hasY = typeof arg1 === 'number';
            this.x = arg0;
            this.y = hasY ? arg1 : arg0;
            if (this.__read)
              this.__read = hasY ? 2 : 1;
          } else if (type === 'undefined' || arg0 === null) {
            this.x = this.y = 0;
            if (this.__read)
              this.__read = arg0 === null ? 1 : 0;
          } else {
            if (Array.isArray(arg0)) {
              this.x = arg0[0];
              this.y = arg0.length > 1 ? arg0[1] : arg0[0];
            } else if (arg0.x != null) {
              this.x = arg0.x;
              this.y = arg0.y;
            } else if (arg0.width != null) {
              this.x = arg0.width;
              this.y = arg0.height;
            } else if (arg0.angle != null) {
              this.x = arg0.length;
              this.y = 0;
              this.setAngle(arg0.angle);
            } else {
              this.x = this.y = 0;
              if (this.__read)
                this.__read = 0;
            }
            if (this.__read)
              this.__read = 1;
          }
        },
        set: function(x, y) {
          this.x = x;
          this.y = y;
          return this;
        },
        equals: function(point) {
          return this === point || point && (this.x === point.x && this.y === point.y || Array.isArray(point) && this.x === point[0] && this.y === point[1]) || false;
        },
        clone: function() {
          return new Point(this.x, this.y);
        },
        toString: function() {
          var f = Formatter.instance;
          return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
        },
        _serialize: function(options) {
          var f = options.formatter;
          return [f.number(this.x), f.number(this.y)];
        },
        getLength: function() {
          return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        setLength: function(length) {
          if (this.isZero()) {
            var angle = this._angle || 0;
            this.set(Math.cos(angle) * length, Math.sin(angle) * length);
          } else {
            var scale = length / this.getLength();
            if (Numerical.isZero(scale))
              this.getAngle();
            this.set(this.x * scale, this.y * scale);
          }
        },
        getAngle: function() {
          return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
        },
        setAngle: function(angle) {
          this.setAngleInRadians.call(this, angle * Math.PI / 180);
        },
        getAngleInDegrees: '#getAngle',
        setAngleInDegrees: '#setAngle',
        getAngleInRadians: function() {
          if (!arguments.length) {
            return this.isZero() ? this._angle || 0 : this._angle = Math.atan2(this.y, this.x);
          } else {
            var point = Point.read(arguments),
                div = this.getLength() * point.getLength();
            if (Numerical.isZero(div)) {
              return NaN;
            } else {
              var a = this.dot(point) / div;
              return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
            }
          }
        },
        setAngleInRadians: function(angle) {
          this._angle = angle;
          if (!this.isZero()) {
            var length = this.getLength();
            this.set(Math.cos(angle) * length, Math.sin(angle) * length);
          }
        },
        getQuadrant: function() {
          return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
        }
      }, {
        beans: false,
        getDirectedAngle: function() {
          var point = Point.read(arguments);
          return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
        },
        getDistance: function() {
          var point = Point.read(arguments),
              x = point.x - this.x,
              y = point.y - this.y,
              d = x * x + y * y,
              squared = Base.read(arguments);
          return squared ? d : Math.sqrt(d);
        },
        normalize: function(length) {
          if (length === undefined)
            length = 1;
          var current = this.getLength(),
              scale = current !== 0 ? length / current : 0,
              point = new Point(this.x * scale, this.y * scale);
          if (scale >= 0)
            point._angle = this._angle;
          return point;
        },
        rotate: function(angle, center) {
          if (angle === 0)
            return this.clone();
          angle = angle * Math.PI / 180;
          var point = center ? this.subtract(center) : this,
              sin = Math.sin(angle),
              cos = Math.cos(angle);
          point = new Point(point.x * cos - point.y * sin, point.x * sin + point.y * cos);
          return center ? point.add(center) : point;
        },
        transform: function(matrix) {
          return matrix ? matrix._transformPoint(this) : this;
        },
        add: function() {
          var point = Point.read(arguments);
          return new Point(this.x + point.x, this.y + point.y);
        },
        subtract: function() {
          var point = Point.read(arguments);
          return new Point(this.x - point.x, this.y - point.y);
        },
        multiply: function() {
          var point = Point.read(arguments);
          return new Point(this.x * point.x, this.y * point.y);
        },
        divide: function() {
          var point = Point.read(arguments);
          return new Point(this.x / point.x, this.y / point.y);
        },
        modulo: function() {
          var point = Point.read(arguments);
          return new Point(this.x % point.x, this.y % point.y);
        },
        negate: function() {
          return new Point(-this.x, -this.y);
        },
        isInside: function() {
          return Rectangle.read(arguments).contains(this);
        },
        isClose: function() {
          var point = Point.read(arguments),
              tolerance = Base.read(arguments);
          return this.getDistance(point) < tolerance;
        },
        isCollinear: function() {
          var point = Point.read(arguments);
          return Point.isCollinear(this.x, this.y, point.x, point.y);
        },
        isColinear: '#isCollinear',
        isOrthogonal: function() {
          var point = Point.read(arguments);
          return Point.isOrthogonal(this.x, this.y, point.x, point.y);
        },
        isZero: function() {
          return Numerical.isZero(this.x) && Numerical.isZero(this.y);
        },
        isNaN: function() {
          return isNaN(this.x) || isNaN(this.y);
        },
        dot: function() {
          var point = Point.read(arguments);
          return this.x * point.x + this.y * point.y;
        },
        cross: function() {
          var point = Point.read(arguments);
          return this.x * point.y - this.y * point.x;
        },
        project: function() {
          var point = Point.read(arguments),
              scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
          return new Point(point.x * scale, point.y * scale);
        },
        statics: {
          min: function() {
            var point1 = Point.read(arguments),
                point2 = Point.read(arguments);
            return new Point(Math.min(point1.x, point2.x), Math.min(point1.y, point2.y));
          },
          max: function() {
            var point1 = Point.read(arguments),
                point2 = Point.read(arguments);
            return new Point(Math.max(point1.x, point2.x), Math.max(point1.y, point2.y));
          },
          random: function() {
            return new Point(Math.random(), Math.random());
          },
          isCollinear: function(x1, y1, x2, y2) {
            return Math.abs(x1 * y2 - y1 * x2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-7;
          },
          isOrthogonal: function(x1, y1, x2, y2) {
            return Math.abs(x1 * x2 + y1 * y2) <= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2)) * 1e-7;
          }
        }
      }, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
        var op = Math[name];
        this[name] = function() {
          return new Point(op(this.x), op(this.y));
        };
      }, {}));
      var LinkedPoint = Point.extend({
        initialize: function Point(x, y, owner, setter) {
          this._x = x;
          this._y = y;
          this._owner = owner;
          this._setter = setter;
        },
        set: function(x, y, _dontNotify) {
          this._x = x;
          this._y = y;
          if (!_dontNotify)
            this._owner[this._setter](this);
          return this;
        },
        getX: function() {
          return this._x;
        },
        setX: function(x) {
          this._x = x;
          this._owner[this._setter](this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(y) {
          this._y = y;
          this._owner[this._setter](this);
        }
      });
      var Size = Base.extend({
        _class: 'Size',
        _readIndex: true,
        initialize: function Size(arg0, arg1) {
          var type = typeof arg0;
          if (type === 'number') {
            var hasHeight = typeof arg1 === 'number';
            this.width = arg0;
            this.height = hasHeight ? arg1 : arg0;
            if (this.__read)
              this.__read = hasHeight ? 2 : 1;
          } else if (type === 'undefined' || arg0 === null) {
            this.width = this.height = 0;
            if (this.__read)
              this.__read = arg0 === null ? 1 : 0;
          } else {
            if (Array.isArray(arg0)) {
              this.width = arg0[0];
              this.height = arg0.length > 1 ? arg0[1] : arg0[0];
            } else if (arg0.width != null) {
              this.width = arg0.width;
              this.height = arg0.height;
            } else if (arg0.x != null) {
              this.width = arg0.x;
              this.height = arg0.y;
            } else {
              this.width = this.height = 0;
              if (this.__read)
                this.__read = 0;
            }
            if (this.__read)
              this.__read = 1;
          }
        },
        set: function(width, height) {
          this.width = width;
          this.height = height;
          return this;
        },
        equals: function(size) {
          return size === this || size && (this.width === size.width && this.height === size.height || Array.isArray(size) && this.width === size[0] && this.height === size[1]) || false;
        },
        clone: function() {
          return new Size(this.width, this.height);
        },
        toString: function() {
          var f = Formatter.instance;
          return '{ width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
        },
        _serialize: function(options) {
          var f = options.formatter;
          return [f.number(this.width), f.number(this.height)];
        },
        add: function() {
          var size = Size.read(arguments);
          return new Size(this.width + size.width, this.height + size.height);
        },
        subtract: function() {
          var size = Size.read(arguments);
          return new Size(this.width - size.width, this.height - size.height);
        },
        multiply: function() {
          var size = Size.read(arguments);
          return new Size(this.width * size.width, this.height * size.height);
        },
        divide: function() {
          var size = Size.read(arguments);
          return new Size(this.width / size.width, this.height / size.height);
        },
        modulo: function() {
          var size = Size.read(arguments);
          return new Size(this.width % size.width, this.height % size.height);
        },
        negate: function() {
          return new Size(-this.width, -this.height);
        },
        isZero: function() {
          return Numerical.isZero(this.width) && Numerical.isZero(this.height);
        },
        isNaN: function() {
          return isNaN(this.width) || isNaN(this.height);
        },
        statics: {
          min: function(size1, size2) {
            return new Size(Math.min(size1.width, size2.width), Math.min(size1.height, size2.height));
          },
          max: function(size1, size2) {
            return new Size(Math.max(size1.width, size2.width), Math.max(size1.height, size2.height));
          },
          random: function() {
            return new Size(Math.random(), Math.random());
          }
        }
      }, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
        var op = Math[name];
        this[name] = function() {
          return new Size(op(this.width), op(this.height));
        };
      }, {}));
      var LinkedSize = Size.extend({
        initialize: function Size(width, height, owner, setter) {
          this._width = width;
          this._height = height;
          this._owner = owner;
          this._setter = setter;
        },
        set: function(width, height, _dontNotify) {
          this._width = width;
          this._height = height;
          if (!_dontNotify)
            this._owner[this._setter](this);
          return this;
        },
        getWidth: function() {
          return this._width;
        },
        setWidth: function(width) {
          this._width = width;
          this._owner[this._setter](this);
        },
        getHeight: function() {
          return this._height;
        },
        setHeight: function(height) {
          this._height = height;
          this._owner[this._setter](this);
        }
      });
      var Rectangle = Base.extend({
        _class: 'Rectangle',
        _readIndex: true,
        beans: true,
        initialize: function Rectangle(arg0, arg1, arg2, arg3) {
          var type = typeof arg0,
              read = 0;
          if (type === 'number') {
            this.x = arg0;
            this.y = arg1;
            this.width = arg2;
            this.height = arg3;
            read = 4;
          } else if (type === 'undefined' || arg0 === null) {
            this.x = this.y = this.width = this.height = 0;
            read = arg0 === null ? 1 : 0;
          } else if (arguments.length === 1) {
            if (Array.isArray(arg0)) {
              this.x = arg0[0];
              this.y = arg0[1];
              this.width = arg0[2];
              this.height = arg0[3];
              read = 1;
            } else if (arg0.x !== undefined || arg0.width !== undefined) {
              this.x = arg0.x || 0;
              this.y = arg0.y || 0;
              this.width = arg0.width || 0;
              this.height = arg0.height || 0;
              read = 1;
            } else if (arg0.from === undefined && arg0.to === undefined) {
              this.x = this.y = this.width = this.height = 0;
              this._set(arg0);
              read = 1;
            }
          }
          if (!read) {
            var point = Point.readNamed(arguments, 'from'),
                next = Base.peek(arguments);
            this.x = point.x;
            this.y = point.y;
            if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
              var to = Point.readNamed(arguments, 'to');
              this.width = to.x - point.x;
              this.height = to.y - point.y;
              if (this.width < 0) {
                this.x = to.x;
                this.width = -this.width;
              }
              if (this.height < 0) {
                this.y = to.y;
                this.height = -this.height;
              }
            } else {
              var size = Size.read(arguments);
              this.width = size.width;
              this.height = size.height;
            }
            read = arguments.__index;
          }
          if (this.__read)
            this.__read = read;
        },
        set: function(x, y, width, height) {
          this.x = x;
          this.y = y;
          this.width = width;
          this.height = height;
          return this;
        },
        clone: function() {
          return new Rectangle(this.x, this.y, this.width, this.height);
        },
        equals: function(rect) {
          var rt = Base.isPlainValue(rect) ? Rectangle.read(arguments) : rect;
          return rt === this || rt && this.x === rt.x && this.y === rt.y && this.width === rt.width && this.height === rt.height || false;
        },
        toString: function() {
          var f = Formatter.instance;
          return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ', width: ' + f.number(this.width) + ', height: ' + f.number(this.height) + ' }';
        },
        _serialize: function(options) {
          var f = options.formatter;
          return [f.number(this.x), f.number(this.y), f.number(this.width), f.number(this.height)];
        },
        getPoint: function(_dontLink) {
          var ctor = _dontLink ? Point : LinkedPoint;
          return new ctor(this.x, this.y, this, 'setPoint');
        },
        setPoint: function() {
          var point = Point.read(arguments);
          this.x = point.x;
          this.y = point.y;
        },
        getSize: function(_dontLink) {
          var ctor = _dontLink ? Size : LinkedSize;
          return new ctor(this.width, this.height, this, 'setSize');
        },
        setSize: function() {
          var size = Size.read(arguments);
          if (this._fixX)
            this.x += (this.width - size.width) * this._fixX;
          if (this._fixY)
            this.y += (this.height - size.height) * this._fixY;
          this.width = size.width;
          this.height = size.height;
          this._fixW = 1;
          this._fixH = 1;
        },
        getLeft: function() {
          return this.x;
        },
        setLeft: function(left) {
          if (!this._fixW)
            this.width -= left - this.x;
          this.x = left;
          this._fixX = 0;
        },
        getTop: function() {
          return this.y;
        },
        setTop: function(top) {
          if (!this._fixH)
            this.height -= top - this.y;
          this.y = top;
          this._fixY = 0;
        },
        getRight: function() {
          return this.x + this.width;
        },
        setRight: function(right) {
          if (this._fixX !== undefined && this._fixX !== 1)
            this._fixW = 0;
          if (this._fixW)
            this.x = right - this.width;
          else
            this.width = right - this.x;
          this._fixX = 1;
        },
        getBottom: function() {
          return this.y + this.height;
        },
        setBottom: function(bottom) {
          if (this._fixY !== undefined && this._fixY !== 1)
            this._fixH = 0;
          if (this._fixH)
            this.y = bottom - this.height;
          else
            this.height = bottom - this.y;
          this._fixY = 1;
        },
        getCenterX: function() {
          return this.x + this.width * 0.5;
        },
        setCenterX: function(x) {
          this.x = x - this.width * 0.5;
          this._fixX = 0.5;
        },
        getCenterY: function() {
          return this.y + this.height * 0.5;
        },
        setCenterY: function(y) {
          this.y = y - this.height * 0.5;
          this._fixY = 0.5;
        },
        getCenter: function(_dontLink) {
          var ctor = _dontLink ? Point : LinkedPoint;
          return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
        },
        setCenter: function() {
          var point = Point.read(arguments);
          this.setCenterX(point.x);
          this.setCenterY(point.y);
          return this;
        },
        getArea: function() {
          return this.width * this.height;
        },
        isEmpty: function() {
          return this.width === 0 || this.height === 0;
        },
        contains: function(arg) {
          return arg && arg.width !== undefined || (Array.isArray(arg) ? arg : arguments).length == 4 ? this._containsRectangle(Rectangle.read(arguments)) : this._containsPoint(Point.read(arguments));
        },
        _containsPoint: function(point) {
          var x = point.x,
              y = point.y;
          return x >= this.x && y >= this.y && x <= this.x + this.width && y <= this.y + this.height;
        },
        _containsRectangle: function(rect) {
          var x = rect.x,
              y = rect.y;
          return x >= this.x && y >= this.y && x + rect.width <= this.x + this.width && y + rect.height <= this.y + this.height;
        },
        intersects: function() {
          var rect = Rectangle.read(arguments);
          return rect.x + rect.width > this.x && rect.y + rect.height > this.y && rect.x < this.x + this.width && rect.y < this.y + this.height;
        },
        touches: function() {
          var rect = Rectangle.read(arguments);
          return rect.x + rect.width >= this.x && rect.y + rect.height >= this.y && rect.x <= this.x + this.width && rect.y <= this.y + this.height;
        },
        intersect: function() {
          var rect = Rectangle.read(arguments),
              x1 = Math.max(this.x, rect.x),
              y1 = Math.max(this.y, rect.y),
              x2 = Math.min(this.x + this.width, rect.x + rect.width),
              y2 = Math.min(this.y + this.height, rect.y + rect.height);
          return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
        unite: function() {
          var rect = Rectangle.read(arguments),
              x1 = Math.min(this.x, rect.x),
              y1 = Math.min(this.y, rect.y),
              x2 = Math.max(this.x + this.width, rect.x + rect.width),
              y2 = Math.max(this.y + this.height, rect.y + rect.height);
          return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
        include: function() {
          var point = Point.read(arguments);
          var x1 = Math.min(this.x, point.x),
              y1 = Math.min(this.y, point.y),
              x2 = Math.max(this.x + this.width, point.x),
              y2 = Math.max(this.y + this.height, point.y);
          return new Rectangle(x1, y1, x2 - x1, y2 - y1);
        },
        expand: function() {
          var amount = Size.read(arguments),
              hor = amount.width,
              ver = amount.height;
          return new Rectangle(this.x - hor / 2, this.y - ver / 2, this.width + hor, this.height + ver);
        },
        scale: function(hor, ver) {
          return this.expand(this.width * hor - this.width, this.height * (ver === undefined ? hor : ver) - this.height);
        }
      }, Base.each([['Top', 'Left'], ['Top', 'Right'], ['Bottom', 'Left'], ['Bottom', 'Right'], ['Left', 'Center'], ['Top', 'Center'], ['Right', 'Center'], ['Bottom', 'Center']], function(parts, index) {
        var part = parts.join('');
        var xFirst = /^[RL]/.test(part);
        if (index >= 4)
          parts[1] += xFirst ? 'Y' : 'X';
        var x = parts[xFirst ? 0 : 1],
            y = parts[xFirst ? 1 : 0],
            getX = 'get' + x,
            getY = 'get' + y,
            setX = 'set' + x,
            setY = 'set' + y,
            get = 'get' + part,
            set = 'set' + part;
        this[get] = function(_dontLink) {
          var ctor = _dontLink ? Point : LinkedPoint;
          return new ctor(this[getX](), this[getY](), this, set);
        };
        this[set] = function() {
          var point = Point.read(arguments);
          this[setX](point.x);
          this[setY](point.y);
        };
      }, {beans: true}));
      var LinkedRectangle = Rectangle.extend({
        initialize: function Rectangle(x, y, width, height, owner, setter) {
          this.set(x, y, width, height, true);
          this._owner = owner;
          this._setter = setter;
        },
        set: function(x, y, width, height, _dontNotify) {
          this._x = x;
          this._y = y;
          this._width = width;
          this._height = height;
          if (!_dontNotify)
            this._owner[this._setter](this);
          return this;
        }
      }, new function() {
        var proto = Rectangle.prototype;
        return Base.each(['x', 'y', 'width', 'height'], function(key) {
          var part = Base.capitalize(key);
          var internal = '_' + key;
          this['get' + part] = function() {
            return this[internal];
          };
          this['set' + part] = function(value) {
            this[internal] = value;
            if (!this._dontNotify)
              this._owner[this._setter](this);
          };
        }, Base.each(['Point', 'Size', 'Center', 'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY', 'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'], function(key) {
          var name = 'set' + key;
          this[name] = function() {
            this._dontNotify = true;
            proto[name].apply(this, arguments);
            this._dontNotify = false;
            this._owner[this._setter](this);
          };
        }, {
          isSelected: function() {
            return this._owner._boundsSelected;
          },
          setSelected: function(selected) {
            var owner = this._owner;
            if (owner.setSelected) {
              owner._boundsSelected = selected;
              owner.setSelected(selected || owner._selectedSegmentState > 0);
            }
          }
        }));
      });
      var Matrix = Base.extend({
        _class: 'Matrix',
        initialize: function Matrix(arg) {
          var count = arguments.length,
              ok = true;
          if (count === 6) {
            this.set.apply(this, arguments);
          } else if (count === 1) {
            if (arg instanceof Matrix) {
              this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
            } else if (Array.isArray(arg)) {
              this.set.apply(this, arg);
            } else {
              ok = false;
            }
          } else if (count === 0) {
            this.reset();
          } else {
            ok = false;
          }
          if (!ok)
            throw new Error('Unsupported matrix parameters');
        },
        set: function(a, c, b, d, tx, ty, _dontNotify) {
          this._a = a;
          this._c = c;
          this._b = b;
          this._d = d;
          this._tx = tx;
          this._ty = ty;
          if (!_dontNotify)
            this._changed();
          return this;
        },
        _serialize: function(options) {
          return Base.serialize(this.getValues(), options);
        },
        _changed: function() {
          var owner = this._owner;
          if (owner) {
            if (owner._applyMatrix) {
              owner.transform(null, true);
            } else {
              owner._changed(9);
            }
          }
        },
        clone: function() {
          return new Matrix(this._a, this._c, this._b, this._d, this._tx, this._ty);
        },
        equals: function(mx) {
          return mx === this || mx && this._a === mx._a && this._b === mx._b && this._c === mx._c && this._d === mx._d && this._tx === mx._tx && this._ty === mx._ty || false;
        },
        toString: function() {
          var f = Formatter.instance;
          return '[[' + [f.number(this._a), f.number(this._b), f.number(this._tx)].join(', ') + '], [' + [f.number(this._c), f.number(this._d), f.number(this._ty)].join(', ') + ']]';
        },
        reset: function(_dontNotify) {
          this._a = this._d = 1;
          this._c = this._b = this._tx = this._ty = 0;
          if (!_dontNotify)
            this._changed();
          return this;
        },
        apply: function(recursively, _setApplyMatrix) {
          var owner = this._owner;
          if (owner) {
            owner.transform(null, true, Base.pick(recursively, true), _setApplyMatrix);
            return this.isIdentity();
          }
          return false;
        },
        translate: function() {
          var point = Point.read(arguments),
              x = point.x,
              y = point.y;
          this._tx += x * this._a + y * this._b;
          this._ty += x * this._c + y * this._d;
          this._changed();
          return this;
        },
        scale: function() {
          var scale = Point.read(arguments),
              center = Point.read(arguments, 0, {readNull: true});
          if (center)
            this.translate(center);
          this._a *= scale.x;
          this._c *= scale.x;
          this._b *= scale.y;
          this._d *= scale.y;
          if (center)
            this.translate(center.negate());
          this._changed();
          return this;
        },
        rotate: function(angle) {
          angle *= Math.PI / 180;
          var center = Point.read(arguments, 1),
              x = center.x,
              y = center.y,
              cos = Math.cos(angle),
              sin = Math.sin(angle),
              tx = x - x * cos + y * sin,
              ty = y - x * sin - y * cos,
              a = this._a,
              b = this._b,
              c = this._c,
              d = this._d;
          this._a = cos * a + sin * b;
          this._b = -sin * a + cos * b;
          this._c = cos * c + sin * d;
          this._d = -sin * c + cos * d;
          this._tx += tx * a + ty * b;
          this._ty += tx * c + ty * d;
          this._changed();
          return this;
        },
        shear: function() {
          var shear = Point.read(arguments),
              center = Point.read(arguments, 0, {readNull: true});
          if (center)
            this.translate(center);
          var a = this._a,
              c = this._c;
          this._a += shear.y * this._b;
          this._c += shear.y * this._d;
          this._b += shear.x * a;
          this._d += shear.x * c;
          if (center)
            this.translate(center.negate());
          this._changed();
          return this;
        },
        skew: function() {
          var skew = Point.read(arguments),
              center = Point.read(arguments, 0, {readNull: true}),
              toRadians = Math.PI / 180,
              shear = new Point(Math.tan(skew.x * toRadians), Math.tan(skew.y * toRadians));
          return this.shear(shear, center);
        },
        concatenate: function(mx) {
          var a1 = this._a,
              b1 = this._b,
              c1 = this._c,
              d1 = this._d,
              a2 = mx._a,
              b2 = mx._b,
              c2 = mx._c,
              d2 = mx._d,
              tx2 = mx._tx,
              ty2 = mx._ty;
          this._a = a2 * a1 + c2 * b1;
          this._b = b2 * a1 + d2 * b1;
          this._c = a2 * c1 + c2 * d1;
          this._d = b2 * c1 + d2 * d1;
          this._tx += tx2 * a1 + ty2 * b1;
          this._ty += tx2 * c1 + ty2 * d1;
          this._changed();
          return this;
        },
        preConcatenate: function(mx) {
          var a1 = this._a,
              b1 = this._b,
              c1 = this._c,
              d1 = this._d,
              tx1 = this._tx,
              ty1 = this._ty,
              a2 = mx._a,
              b2 = mx._b,
              c2 = mx._c,
              d2 = mx._d,
              tx2 = mx._tx,
              ty2 = mx._ty;
          this._a = a2 * a1 + b2 * c1;
          this._b = a2 * b1 + b2 * d1;
          this._c = c2 * a1 + d2 * c1;
          this._d = c2 * b1 + d2 * d1;
          this._tx = a2 * tx1 + b2 * ty1 + tx2;
          this._ty = c2 * tx1 + d2 * ty1 + ty2;
          this._changed();
          return this;
        },
        chain: function(mx) {
          var a1 = this._a,
              b1 = this._b,
              c1 = this._c,
              d1 = this._d,
              tx1 = this._tx,
              ty1 = this._ty,
              a2 = mx._a,
              b2 = mx._b,
              c2 = mx._c,
              d2 = mx._d,
              tx2 = mx._tx,
              ty2 = mx._ty;
          return new Matrix(a2 * a1 + c2 * b1, a2 * c1 + c2 * d1, b2 * a1 + d2 * b1, b2 * c1 + d2 * d1, tx1 + tx2 * a1 + ty2 * b1, ty1 + tx2 * c1 + ty2 * d1);
        },
        isIdentity: function() {
          return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1 && this._tx === 0 && this._ty === 0;
        },
        orNullIfIdentity: function() {
          return this.isIdentity() ? null : this;
        },
        isInvertible: function() {
          return !!this._getDeterminant();
        },
        isSingular: function() {
          return !this._getDeterminant();
        },
        transform: function(src, dst, count) {
          return arguments.length < 3 ? this._transformPoint(Point.read(arguments)) : this._transformCoordinates(src, dst, count);
        },
        _transformPoint: function(point, dest, _dontNotify) {
          var x = point.x,
              y = point.y;
          if (!dest)
            dest = new Point();
          return dest.set(x * this._a + y * this._b + this._tx, x * this._c + y * this._d + this._ty, _dontNotify);
        },
        _transformCoordinates: function(src, dst, count) {
          var i = 0,
              j = 0,
              max = 2 * count;
          while (i < max) {
            var x = src[i++],
                y = src[i++];
            dst[j++] = x * this._a + y * this._b + this._tx;
            dst[j++] = x * this._c + y * this._d + this._ty;
          }
          return dst;
        },
        _transformCorners: function(rect) {
          var x1 = rect.x,
              y1 = rect.y,
              x2 = x1 + rect.width,
              y2 = y1 + rect.height,
              coords = [x1, y1, x2, y1, x2, y2, x1, y2];
          return this._transformCoordinates(coords, coords, 4);
        },
        _transformBounds: function(bounds, dest, _dontNotify) {
          var coords = this._transformCorners(bounds),
              min = coords.slice(0, 2),
              max = min.slice();
          for (var i = 2; i < 8; i++) {
            var val = coords[i],
                j = i & 1;
            if (val < min[j])
              min[j] = val;
            else if (val > max[j])
              max[j] = val;
          }
          if (!dest)
            dest = new Rectangle();
          return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1], _dontNotify);
        },
        inverseTransform: function() {
          return this._inverseTransform(Point.read(arguments));
        },
        _getDeterminant: function() {
          var det = this._a * this._d - this._b * this._c;
          return isFinite(det) && !Numerical.isZero(det) && isFinite(this._tx) && isFinite(this._ty) ? det : null;
        },
        _inverseTransform: function(point, dest, _dontNotify) {
          var det = this._getDeterminant();
          if (!det)
            return null;
          var x = point.x - this._tx,
              y = point.y - this._ty;
          if (!dest)
            dest = new Point();
          return dest.set((x * this._d - y * this._b) / det, (y * this._a - x * this._c) / det, _dontNotify);
        },
        decompose: function() {
          var a = this._a,
              b = this._b,
              c = this._c,
              d = this._d;
          if (Numerical.isZero(a * d - b * c))
            return null;
          var scaleX = Math.sqrt(a * a + b * b);
          a /= scaleX;
          b /= scaleX;
          var shear = a * c + b * d;
          c -= a * shear;
          d -= b * shear;
          var scaleY = Math.sqrt(c * c + d * d);
          c /= scaleY;
          d /= scaleY;
          shear /= scaleY;
          if (a * d < b * c) {
            a = -a;
            b = -b;
            shear = -shear;
            scaleX = -scaleX;
          }
          return {
            scaling: new Point(scaleX, scaleY),
            rotation: -Math.atan2(b, a) * 180 / Math.PI,
            shearing: shear
          };
        },
        getValues: function() {
          return [this._a, this._c, this._b, this._d, this._tx, this._ty];
        },
        getTranslation: function() {
          return new Point(this._tx, this._ty);
        },
        getScaling: function() {
          return (this.decompose() || {}).scaling;
        },
        getRotation: function() {
          return (this.decompose() || {}).rotation;
        },
        inverted: function() {
          var det = this._getDeterminant();
          return det && new Matrix(this._d / det, -this._c / det, -this._b / det, this._a / det, (this._b * this._ty - this._d * this._tx) / det, (this._c * this._tx - this._a * this._ty) / det);
        },
        shiftless: function() {
          return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
        },
        applyToContext: function(ctx) {
          ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
        }
      }, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
        var part = Base.capitalize(name),
            prop = '_' + name;
        this['get' + part] = function() {
          return this[prop];
        };
        this['set' + part] = function(value) {
          this[prop] = value;
          this._changed();
        };
      }, {}));
      var Line = Base.extend({
        _class: 'Line',
        initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
          var asVector = false;
          if (arguments.length >= 4) {
            this._px = arg0;
            this._py = arg1;
            this._vx = arg2;
            this._vy = arg3;
            asVector = arg4;
          } else {
            this._px = arg0.x;
            this._py = arg0.y;
            this._vx = arg1.x;
            this._vy = arg1.y;
            asVector = arg2;
          }
          if (!asVector) {
            this._vx -= this._px;
            this._vy -= this._py;
          }
        },
        getPoint: function() {
          return new Point(this._px, this._py);
        },
        getVector: function() {
          return new Point(this._vx, this._vy);
        },
        getLength: function() {
          return this.getVector().getLength();
        },
        intersect: function(line, isInfinite) {
          return Line.intersect(this._px, this._py, this._vx, this._vy, line._px, line._py, line._vx, line._vy, true, isInfinite);
        },
        getSide: function(point, isInfinite) {
          return Line.getSide(this._px, this._py, this._vx, this._vy, point.x, point.y, true, isInfinite);
        },
        getDistance: function(point) {
          return Math.abs(Line.getSignedDistance(this._px, this._py, this._vx, this._vy, point.x, point.y, true));
        },
        isCollinear: function(line) {
          return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
        },
        isOrthogonal: function(line) {
          return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
        },
        statics: {
          intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector, isInfinite) {
            if (!asVector) {
              v1x -= p1x;
              v1y -= p1y;
              v2x -= p2x;
              v2y -= p2y;
            }
            var cross = v1x * v2y - v1y * v2x;
            if (!Numerical.isZero(cross)) {
              var dx = p1x - p2x,
                  dy = p1y - p2y,
                  u1 = (v2x * dy - v2y * dx) / cross,
                  u2 = (v1x * dy - v1y * dx) / cross,
                  epsilon = 1e-12,
                  uMin = -epsilon,
                  uMax = 1 + epsilon;
              if (isInfinite || uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
                if (!isInfinite) {
                  u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
                }
                return new Point(p1x + u1 * v1x, p1y + u1 * v1y);
              }
            }
          },
          getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
            if (!asVector) {
              vx -= px;
              vy -= py;
            }
            var v2x = x - px,
                v2y = y - py,
                ccw = v2x * vy - v2y * vx;
            if (ccw === 0 && !isInfinite) {
              ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
              if (ccw >= 0 && ccw <= 1)
                ccw = 0;
            }
            return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
          },
          getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
            if (!asVector) {
              vx -= px;
              vy -= py;
            }
            return vx === 0 ? vy > 0 ? x - px : px - x : vy === 0 ? vx < 0 ? y - py : py - y : ((x - px) * vy - (y - py) * vx) / Math.sqrt(vx * vx + vy * vy);
          }
        }
      });
      var Project = PaperScopeItem.extend({
        _class: 'Project',
        _list: 'projects',
        _reference: 'project',
        initialize: function Project(element) {
          PaperScopeItem.call(this, true);
          this.layers = [];
          this._activeLayer = null;
          this.symbols = [];
          this._currentStyle = new Style(null, null, this);
          this._view = View.create(this, element || CanvasProvider.getCanvas(1, 1));
          this._selectedItems = {};
          this._selectedItemCount = 0;
          this._updateVersion = 0;
        },
        _serialize: function(options, dictionary) {
          return Base.serialize(this.layers, options, true, dictionary);
        },
        clear: function() {
          for (var i = this.layers.length - 1; i >= 0; i--)
            this.layers[i].remove();
          this.symbols = [];
        },
        isEmpty: function() {
          return this.layers.length === 0;
        },
        remove: function remove() {
          if (!remove.base.call(this))
            return false;
          if (this._view)
            this._view.remove();
          return true;
        },
        getView: function() {
          return this._view;
        },
        getCurrentStyle: function() {
          return this._currentStyle;
        },
        setCurrentStyle: function(style) {
          this._currentStyle.initialize(style);
        },
        getIndex: function() {
          return this._index;
        },
        getOptions: function() {
          return this._scope.settings;
        },
        getActiveLayer: function() {
          return this._activeLayer || new Layer({project: this});
        },
        getSelectedItems: function() {
          var items = [];
          for (var id in this._selectedItems) {
            var item = this._selectedItems[id];
            if (item.isInserted())
              items.push(item);
          }
          return items;
        },
        insertChild: function(index, item, _preserve) {
          if (item instanceof Layer) {
            item._remove(false, true);
            Base.splice(this.layers, [item], index, 0);
            item._setProject(this, true);
            if (this._changes)
              item._changed(5);
            if (!this._activeLayer)
              this._activeLayer = item;
          } else if (item instanceof Item) {
            (this._activeLayer || this.insertChild(index, new Layer(Item.NO_INSERT))).insertChild(index, item, _preserve);
          } else {
            item = null;
          }
          return item;
        },
        addChild: function(item, _preserve) {
          return this.insertChild(undefined, item, _preserve);
        },
        _updateSelection: function(item) {
          var id = item._id,
              selectedItems = this._selectedItems;
          if (item._selected) {
            if (selectedItems[id] !== item) {
              this._selectedItemCount++;
              selectedItems[id] = item;
            }
          } else if (selectedItems[id] === item) {
            this._selectedItemCount--;
            delete selectedItems[id];
          }
        },
        selectAll: function() {
          var layers = this.layers;
          for (var i = 0,
              l = layers.length; i < l; i++)
            layers[i].setFullySelected(true);
        },
        deselectAll: function() {
          var selectedItems = this._selectedItems;
          for (var i in selectedItems)
            selectedItems[i].setFullySelected(false);
        },
        hitTest: function() {
          var point = Point.read(arguments),
              options = HitResult.getOptions(Base.read(arguments));
          for (var i = this.layers.length - 1; i >= 0; i--) {
            var res = this.layers[i]._hitTest(point, options);
            if (res)
              return res;
          }
          return null;
        },
        getItems: function(match) {
          return Item._getItems(this.layers, match);
        },
        getItem: function(match) {
          return Item._getItems(this.layers, match, null, null, true)[0] || null;
        },
        importJSON: function(json) {
          this.activate();
          var layer = this._activeLayer;
          return Base.importJSON(json, layer && layer.isEmpty() && layer);
        },
        draw: function(ctx, matrix, pixelRatio) {
          this._updateVersion++;
          ctx.save();
          matrix.applyToContext(ctx);
          var param = new Base({
            offset: new Point(0, 0),
            pixelRatio: pixelRatio,
            viewMatrix: matrix.isIdentity() ? null : matrix,
            matrices: [new Matrix()],
            updateMatrix: true
          });
          for (var i = 0,
              layers = this.layers,
              l = layers.length; i < l; i++)
            layers[i].draw(ctx, param);
          ctx.restore();
          if (this._selectedItemCount > 0) {
            ctx.save();
            ctx.strokeWidth = 1;
            var items = this._selectedItems,
                size = this._scope.settings.handleSize,
                version = this._updateVersion;
            for (var id in items)
              items[id]._drawSelection(ctx, matrix, size, items, version);
            ctx.restore();
          }
        }
      });
      var Symbol = Base.extend({
        _class: 'Symbol',
        initialize: function Symbol(item, dontCenter) {
          this._id = UID.get();
          this.project = paper.project;
          this.project.symbols.push(this);
          if (item)
            this.setDefinition(item, dontCenter);
        },
        _serialize: function(options, dictionary) {
          return dictionary.add(this, function() {
            return Base.serialize([this._class, this._definition], options, false, dictionary);
          });
        },
        _changed: function(flags) {
          if (flags & 8) {
            Item._clearBoundsCache(this);
          }
          if (flags & 1) {
            this.project._needsUpdate = true;
          }
        },
        getDefinition: function() {
          return this._definition;
        },
        setDefinition: function(item, _dontCenter) {
          if (item._parentSymbol)
            item = item.clone();
          if (this._definition)
            this._definition._parentSymbol = null;
          this._definition = item;
          item.remove();
          item.setSelected(false);
          if (!_dontCenter)
            item.setPosition(new Point());
          item._parentSymbol = this;
          this._changed(9);
        },
        place: function(position) {
          return new PlacedSymbol(this, position);
        },
        clone: function() {
          return new Symbol(this._definition.clone(false));
        },
        equals: function(symbol) {
          return symbol === this || symbol && this.definition.equals(symbol.definition) || false;
        }
      });
      var Item = Base.extend(Emitter, {
        statics: {
          extend: function extend(src) {
            if (src._serializeFields)
              src._serializeFields = new Base(this.prototype._serializeFields, src._serializeFields);
            return extend.base.apply(this, arguments);
          },
          NO_INSERT: {insert: false}
        },
        _class: 'Item',
        _applyMatrix: true,
        _canApplyMatrix: true,
        _boundsSelected: false,
        _selectChildren: false,
        _serializeFields: {
          name: null,
          applyMatrix: null,
          matrix: new Matrix(),
          pivot: null,
          locked: false,
          visible: true,
          blendMode: 'normal',
          opacity: 1,
          guide: false,
          selected: false,
          clipMask: false,
          data: {}
        },
        initialize: function Item() {},
        _initialize: function(props, point) {
          var hasProps = props && Base.isPlainObject(props),
              internal = hasProps && props.internal === true,
              matrix = this._matrix = new Matrix(),
              project = hasProps && props.project || paper.project;
          if (!internal)
            this._id = UID.get();
          this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
          if (point)
            matrix.translate(point);
          matrix._owner = this;
          this._style = new Style(project._currentStyle, this, project);
          if (!this._project) {
            if (internal || hasProps && props.insert === false) {
              this._setProject(project);
            } else if (hasProps && props.parent) {
              this.setParent(props.parent);
            } else {
              (project._activeLayer || new Layer()).addChild(this);
            }
          }
          if (hasProps && props !== Item.NO_INSERT)
            this._set(props, {
              insert: true,
              project: true,
              parent: true
            }, true);
          return hasProps;
        },
        _events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick', 'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'], function(name) {
          this[name] = {
            install: function(type) {
              this.getView()._installEvent(type);
            },
            uninstall: function(type) {
              this.getView()._uninstallEvent(type);
            }
          };
        }, {
          onFrame: {
            install: function() {
              this.getView()._animateItem(this, true);
            },
            uninstall: function() {
              this.getView()._animateItem(this, false);
            }
          },
          onLoad: {}
        }),
        _serialize: function(options, dictionary) {
          var props = {},
              that = this;
          function serialize(fields) {
            for (var key in fields) {
              var value = that[key];
              if (!Base.equals(value, key === 'leading' ? fields.fontSize * 1.2 : fields[key])) {
                props[key] = Base.serialize(value, options, key !== 'data', dictionary);
              }
            }
          }
          serialize(this._serializeFields);
          if (!(this instanceof Group))
            serialize(this._style._defaults);
          return [this._class, props];
        },
        _changed: function(flags) {
          var symbol = this._parentSymbol,
              cacheParent = this._parent || symbol,
              project = this._project;
          if (flags & 8) {
            this._bounds = this._position = this._decomposed = this._globalMatrix = this._currentPath = undefined;
          }
          if (cacheParent && (flags & 40)) {
            Item._clearBoundsCache(cacheParent);
          }
          if (flags & 2) {
            Item._clearBoundsCache(this);
          }
          if (project) {
            if (flags & 1) {
              project._needsUpdate = true;
            }
            if (project._changes) {
              var entry = project._changesById[this._id];
              if (entry) {
                entry.flags |= flags;
              } else {
                entry = {
                  item: this,
                  flags: flags
                };
                project._changesById[this._id] = entry;
                project._changes.push(entry);
              }
            }
          }
          if (symbol)
            symbol._changed(flags);
        },
        set: function(props) {
          if (props)
            this._set(props);
          return this;
        },
        getId: function() {
          return this._id;
        },
        getName: function() {
          return this._name;
        },
        setName: function(name, unique) {
          if (this._name)
            this._removeNamed();
          if (name === (+name) + '')
            throw new Error('Names consisting only of numbers are not supported.');
          var parent = this._parent;
          if (name && parent) {
            var children = parent._children,
                namedChildren = parent._namedChildren,
                orig = name,
                i = 1;
            while (unique && children[name])
              name = orig + ' ' + (i++);
            (namedChildren[name] = namedChildren[name] || []).push(this);
            children[name] = this;
          }
          this._name = name || undefined;
          this._changed(128);
        },
        getStyle: function() {
          return this._style;
        },
        setStyle: function(style) {
          this.getStyle().set(style);
        }
      }, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'], function(name) {
        var part = Base.capitalize(name),
            name = '_' + name;
        this['get' + part] = function() {
          return this[name];
        };
        this['set' + part] = function(value) {
          if (value != this[name]) {
            this[name] = value;
            this._changed(name === '_locked' ? 128 : 129);
          }
        };
      }, {}), {
        beans: true,
        _locked: false,
        _visible: true,
        _blendMode: 'normal',
        _opacity: 1,
        _guide: false,
        isSelected: function() {
          if (this._selectChildren) {
            var children = this._children;
            for (var i = 0,
                l = children.length; i < l; i++)
              if (children[i].isSelected())
                return true;
          }
          return this._selected;
        },
        setSelected: function(selected, noChildren) {
          if (!noChildren && this._selectChildren) {
            var children = this._children;
            for (var i = 0,
                l = children.length; i < l; i++)
              children[i].setSelected(selected);
          }
          if ((selected = !!selected) ^ this._selected) {
            this._selected = selected;
            this._project._updateSelection(this);
            this._changed(129);
          }
        },
        _selected: false,
        isFullySelected: function() {
          var children = this._children;
          if (children && this._selected) {
            for (var i = 0,
                l = children.length; i < l; i++)
              if (!children[i].isFullySelected())
                return false;
            return true;
          }
          return this._selected;
        },
        setFullySelected: function(selected) {
          var children = this._children;
          if (children) {
            for (var i = 0,
                l = children.length; i < l; i++)
              children[i].setFullySelected(selected);
          }
          this.setSelected(selected, true);
        },
        isClipMask: function() {
          return this._clipMask;
        },
        setClipMask: function(clipMask) {
          if (this._clipMask != (clipMask = !!clipMask)) {
            this._clipMask = clipMask;
            if (clipMask) {
              this.setFillColor(null);
              this.setStrokeColor(null);
            }
            this._changed(129);
            if (this._parent)
              this._parent._changed(1024);
          }
        },
        _clipMask: false,
        getData: function() {
          if (!this._data)
            this._data = {};
          return this._data;
        },
        setData: function(data) {
          this._data = data;
        },
        getPosition: function(_dontLink) {
          var position = this._position,
              ctor = _dontLink ? Point : LinkedPoint;
          if (!position) {
            var pivot = this._pivot;
            position = this._position = pivot ? this._matrix._transformPoint(pivot) : this.getBounds().getCenter(true);
          }
          return new ctor(position.x, position.y, this, 'setPosition');
        },
        setPosition: function() {
          this.translate(Point.read(arguments).subtract(this.getPosition(true)));
        },
        getPivot: function(_dontLink) {
          var pivot = this._pivot;
          if (pivot) {
            var ctor = _dontLink ? Point : LinkedPoint;
            pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
          }
          return pivot;
        },
        setPivot: function() {
          this._pivot = Point.read(arguments, 0, {
            clone: true,
            readNull: true
          });
          this._position = undefined;
        },
        _pivot: null
      }, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds', 'internalBounds', 'internalRoughBounds'], function(key) {
        var getter = 'get' + Base.capitalize(key),
            match = key.match(/^internal(.*)$/),
            internalGetter = match ? 'get' + match[1] : null;
        this[getter] = function(_matrix) {
          var boundsGetter = this._boundsGetter,
              name = !internalGetter && (typeof boundsGetter === 'string' ? boundsGetter : boundsGetter && boundsGetter[getter]) || getter,
              bounds = this._getCachedBounds(name, _matrix, this, internalGetter);
          return key === 'bounds' ? new LinkedRectangle(bounds.x, bounds.y, bounds.width, bounds.height, this, 'setBounds') : bounds;
        };
      }, {
        beans: true,
        _getBounds: function(getter, matrix, cacheItem) {
          var children = this._children;
          if (!children || children.length == 0)
            return new Rectangle();
          Item._updateBoundsCache(this, cacheItem);
          var x1 = Infinity,
              x2 = -x1,
              y1 = x1,
              y2 = x2;
          for (var i = 0,
              l = children.length; i < l; i++) {
            var child = children[i];
            if (child._visible && !child.isEmpty()) {
              var rect = child._getCachedBounds(getter, matrix && matrix.chain(child._matrix), cacheItem);
              x1 = Math.min(rect.x, x1);
              y1 = Math.min(rect.y, y1);
              x2 = Math.max(rect.x + rect.width, x2);
              y2 = Math.max(rect.y + rect.height, y2);
            }
          }
          return isFinite(x1) ? new Rectangle(x1, y1, x2 - x1, y2 - y1) : new Rectangle();
        },
        setBounds: function() {
          var rect = Rectangle.read(arguments),
              bounds = this.getBounds(),
              matrix = new Matrix(),
              center = rect.getCenter();
          matrix.translate(center);
          if (rect.width != bounds.width || rect.height != bounds.height) {
            matrix.scale(bounds.width != 0 ? rect.width / bounds.width : 1, bounds.height != 0 ? rect.height / bounds.height : 1);
          }
          center = bounds.getCenter();
          matrix.translate(-center.x, -center.y);
          this.transform(matrix);
        },
        _getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
          matrix = matrix && matrix.orNullIfIdentity();
          var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
              cache = (!matrix || matrix.equals(_matrix)) && getter;
          Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
          if (cache && this._bounds && this._bounds[cache])
            return this._bounds[cache].clone();
          var bounds = this._getBounds(internalGetter || getter, matrix || _matrix, cacheItem);
          if (cache) {
            if (!this._bounds)
              this._bounds = {};
            var cached = this._bounds[cache] = bounds.clone();
            cached._internal = !!internalGetter;
          }
          return bounds;
        },
        statics: {
          _updateBoundsCache: function(parent, item) {
            if (parent) {
              var id = item._id,
                  ref = parent._boundsCache = parent._boundsCache || {
                    ids: {},
                    list: []
                  };
              if (!ref.ids[id]) {
                ref.list.push(item);
                ref.ids[id] = item;
              }
            }
          },
          _clearBoundsCache: function(item) {
            var cache = item._boundsCache;
            if (cache) {
              item._bounds = item._position = item._boundsCache = undefined;
              for (var i = 0,
                  list = cache.list,
                  l = list.length; i < l; i++) {
                var other = list[i];
                if (other !== item) {
                  other._bounds = other._position = undefined;
                  if (other._boundsCache)
                    Item._clearBoundsCache(other);
                }
              }
            }
          }
        }
      }), {
        beans: true,
        _decompose: function() {
          return this._decomposed = this._matrix.decompose();
        },
        getRotation: function() {
          var decomposed = this._decomposed || this._decompose();
          return decomposed && decomposed.rotation;
        },
        setRotation: function(rotation) {
          var current = this.getRotation();
          if (current != null && rotation != null) {
            var decomposed = this._decomposed;
            this.rotate(rotation - current);
            decomposed.rotation = rotation;
            this._decomposed = decomposed;
          }
        },
        getScaling: function(_dontLink) {
          var decomposed = this._decomposed || this._decompose(),
              scaling = decomposed && decomposed.scaling,
              ctor = _dontLink ? Point : LinkedPoint;
          return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
        },
        setScaling: function() {
          var current = this.getScaling();
          if (current) {
            var scaling = Point.read(arguments, 0, {clone: true}),
                decomposed = this._decomposed;
            this.scale(scaling.x / current.x, scaling.y / current.y);
            decomposed.scaling = scaling;
            this._decomposed = decomposed;
          }
        },
        getMatrix: function() {
          return this._matrix;
        },
        setMatrix: function() {
          var matrix = this._matrix;
          matrix.initialize.apply(matrix, arguments);
          if (this._applyMatrix) {
            this.transform(null, true);
          } else {
            this._changed(9);
          }
        },
        getGlobalMatrix: function(_dontClone) {
          var matrix = this._globalMatrix,
              updateVersion = this._project._updateVersion;
          if (matrix && matrix._updateVersion !== updateVersion)
            matrix = null;
          if (!matrix) {
            matrix = this._globalMatrix = this._matrix.clone();
            var parent = this._parent;
            if (parent)
              matrix.preConcatenate(parent.getGlobalMatrix(true));
            matrix._updateVersion = updateVersion;
          }
          return _dontClone ? matrix : matrix.clone();
        },
        getApplyMatrix: function() {
          return this._applyMatrix;
        },
        setApplyMatrix: function(apply) {
          if (this._applyMatrix = this._canApplyMatrix && !!apply)
            this.transform(null, true);
        },
        getTransformContent: '#getApplyMatrix',
        setTransformContent: '#setApplyMatrix'
      }, {
        getProject: function() {
          return this._project;
        },
        _setProject: function(project, installEvents) {
          if (this._project !== project) {
            if (this._project)
              this._installEvents(false);
            this._project = project;
            var children = this._children;
            for (var i = 0,
                l = children && children.length; i < l; i++)
              children[i]._setProject(project);
            installEvents = true;
          }
          if (installEvents)
            this._installEvents(true);
        },
        getView: function() {
          return this._project.getView();
        },
        _installEvents: function _installEvents(install) {
          _installEvents.base.call(this, install);
          var children = this._children;
          for (var i = 0,
              l = children && children.length; i < l; i++)
            children[i]._installEvents(install);
        },
        getLayer: function() {
          var parent = this;
          while (parent = parent._parent) {
            if (parent instanceof Layer)
              return parent;
          }
          return null;
        },
        getParent: function() {
          return this._parent;
        },
        setParent: function(item) {
          return item.addChild(this);
        },
        getChildren: function() {
          return this._children;
        },
        setChildren: function(items) {
          this.removeChildren();
          this.addChildren(items);
        },
        getFirstChild: function() {
          return this._children && this._children[0] || null;
        },
        getLastChild: function() {
          return this._children && this._children[this._children.length - 1] || null;
        },
        getNextSibling: function() {
          return this._parent && this._parent._children[this._index + 1] || null;
        },
        getPreviousSibling: function() {
          return this._parent && this._parent._children[this._index - 1] || null;
        },
        getIndex: function() {
          return this._index;
        },
        equals: function(item) {
          return item === this || item && this._class === item._class && this._style.equals(item._style) && this._matrix.equals(item._matrix) && this._locked === item._locked && this._visible === item._visible && this._blendMode === item._blendMode && this._opacity === item._opacity && this._clipMask === item._clipMask && this._guide === item._guide && this._equals(item) || false;
        },
        _equals: function(item) {
          return Base.equals(this._children, item._children);
        },
        clone: function(insert) {
          return this._clone(new this.constructor(Item.NO_INSERT), insert);
        },
        _clone: function(copy, insert, includeMatrix) {
          var keys = ['_locked', '_visible', '_blendMode', '_opacity', '_clipMask', '_guide'],
              children = this._children;
          copy.setStyle(this._style);
          for (var i = 0,
              l = children && children.length; i < l; i++) {
            copy.addChild(children[i].clone(false), true);
          }
          for (var i = 0,
              l = keys.length; i < l; i++) {
            var key = keys[i];
            if (this.hasOwnProperty(key))
              copy[key] = this[key];
          }
          if (includeMatrix !== false)
            copy._matrix.initialize(this._matrix);
          copy.setApplyMatrix(this._applyMatrix);
          copy.setPivot(this._pivot);
          copy.setSelected(this._selected);
          copy._data = this._data ? Base.clone(this._data) : null;
          if (insert || insert === undefined)
            copy.insertAbove(this);
          if (this._name)
            copy.setName(this._name, true);
          return copy;
        },
        copyTo: function(itemOrProject) {
          return itemOrProject.addChild(this.clone(false));
        },
        rasterize: function(resolution) {
          var bounds = this.getStrokeBounds(),
              scale = (resolution || this.getView().getResolution()) / 72,
              topLeft = bounds.getTopLeft().floor(),
              bottomRight = bounds.getBottomRight().ceil(),
              size = new Size(bottomRight.subtract(topLeft)),
              canvas = CanvasProvider.getCanvas(size.multiply(scale)),
              ctx = canvas.getContext('2d'),
              matrix = new Matrix().scale(scale).translate(topLeft.negate());
          ctx.save();
          matrix.applyToContext(ctx);
          this.draw(ctx, new Base({matrices: [matrix]}));
          ctx.restore();
          var raster = new Raster(Item.NO_INSERT);
          raster.setCanvas(canvas);
          raster.transform(new Matrix().translate(topLeft.add(size.divide(2))).scale(1 / scale));
          raster.insertAbove(this);
          return raster;
        },
        contains: function() {
          return !!this._contains(this._matrix._inverseTransform(Point.read(arguments)));
        },
        _contains: function(point) {
          if (this._children) {
            for (var i = this._children.length - 1; i >= 0; i--) {
              if (this._children[i].contains(point))
                return true;
            }
            return false;
          }
          return point.isInside(this.getInternalBounds());
        },
        isInside: function() {
          return Rectangle.read(arguments).contains(this.getBounds());
        },
        _asPathItem: function() {
          return new Path.Rectangle({
            rectangle: this.getInternalBounds(),
            matrix: this._matrix,
            insert: false
          });
        },
        intersects: function(item, _matrix) {
          if (!(item instanceof Item))
            return false;
          return this._asPathItem().getIntersections(item._asPathItem(), null, _matrix || item._matrix, true).length > 0;
        },
        hitTest: function() {
          return this._hitTest(Point.read(arguments), HitResult.getOptions(Base.read(arguments)));
        },
        _hitTest: function(point, options) {
          if (this._locked || !this._visible || this._guide && !options.guides || this.isEmpty())
            return null;
          var matrix = this._matrix,
              parentTotalMatrix = options._totalMatrix,
              view = this.getView(),
              totalMatrix = options._totalMatrix = parentTotalMatrix ? parentTotalMatrix.chain(matrix) : this.getGlobalMatrix().preConcatenate(view._matrix),
              tolerancePadding = options._tolerancePadding = new Size(Path._getPenPadding(1, totalMatrix.inverted())).multiply(Math.max(options.tolerance, 1e-6));
          point = matrix._inverseTransform(point);
          if (!this._children && !this.getInternalRoughBounds().expand(tolerancePadding.multiply(2))._containsPoint(point))
            return null;
          var checkSelf = !(options.guides && !this._guide || options.selected && !this._selected || options.type && options.type !== Base.hyphenate(this._class) || options.class && !(this instanceof options.class)),
              that = this,
              res;
          function checkBounds(type, part) {
            var pt = bounds['get' + part]();
            if (point.subtract(pt).divide(tolerancePadding).length <= 1)
              return new HitResult(type, that, {
                name: Base.hyphenate(part),
                point: pt
              });
          }
          if (checkSelf && (options.center || options.bounds) && this._parent) {
            var bounds = this.getInternalBounds();
            if (options.center)
              res = checkBounds('center', 'Center');
            if (!res && options.bounds) {
              var points = ['TopLeft', 'TopRight', 'BottomLeft', 'BottomRight', 'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'];
              for (var i = 0; i < 8 && !res; i++)
                res = checkBounds('bounds', points[i]);
            }
          }
          var children = !res && this._children;
          if (children) {
            var opts = this._getChildHitTestOptions(options);
            for (var i = children.length - 1; i >= 0 && !res; i--)
              res = children[i]._hitTest(point, opts);
          }
          if (!res && checkSelf)
            res = this._hitTestSelf(point, options);
          if (res && res.point)
            res.point = matrix.transform(res.point);
          options._totalMatrix = parentTotalMatrix;
          return res;
        },
        _getChildHitTestOptions: function(options) {
          return options;
        },
        _hitTestSelf: function(point, options) {
          if (options.fill && this.hasFill() && this._contains(point))
            return new HitResult('fill', this);
        },
        matches: function(name, compare) {
          function matchObject(obj1, obj2) {
            for (var i in obj1) {
              if (obj1.hasOwnProperty(i)) {
                var val1 = obj1[i],
                    val2 = obj2[i];
                if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
                  if (!matchObject(val1, val2))
                    return false;
                } else if (!Base.equals(val1, val2)) {
                  return false;
                }
              }
            }
            return true;
          }
          var type = typeof name;
          if (type === 'object') {
            for (var key in name) {
              if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
                return false;
            }
          } else if (type === 'function') {
            return name(this);
          } else {
            var value = /^(empty|editable)$/.test(name) ? this['is' + Base.capitalize(name)]() : name === 'type' ? Base.hyphenate(this._class) : this[name];
            if (/^(constructor|class)$/.test(name)) {
              if (!(this instanceof compare))
                return false;
            } else if (compare instanceof RegExp) {
              if (!compare.test(value))
                return false;
            } else if (typeof compare === 'function') {
              if (!compare(value))
                return false;
            } else if (Base.isPlainObject(compare)) {
              if (!matchObject(compare, value))
                return false;
            } else if (!Base.equals(value, compare)) {
              return false;
            }
          }
          return true;
        },
        getItems: function(match) {
          return Item._getItems(this._children, match, this._matrix);
        },
        getItem: function(match) {
          return Item._getItems(this._children, match, this._matrix, null, true)[0] || null;
        },
        statics: {_getItems: function _getItems(children, match, matrix, param, firstOnly) {
            if (!param && typeof match === 'object') {
              var overlapping = match.overlapping,
                  inside = match.inside,
                  bounds = overlapping || inside,
                  rect = bounds && Rectangle.read([bounds]);
              param = {
                items: [],
                inside: !!inside,
                overlapping: !!overlapping,
                rect: rect,
                path: overlapping && new Path.Rectangle({
                  rectangle: rect,
                  insert: false
                })
              };
              if (bounds)
                match = Base.set({}, match, {
                  inside: true,
                  overlapping: true
                });
            }
            var items = param && param.items,
                rect = param && param.rect;
            matrix = rect && (matrix || new Matrix());
            for (var i = 0,
                l = children && children.length; i < l; i++) {
              var child = children[i],
                  childMatrix = matrix && matrix.chain(child._matrix),
                  add = true;
              if (rect) {
                var bounds = child.getBounds(childMatrix);
                if (!rect.intersects(bounds))
                  continue;
                if (!(param.inside && rect.contains(bounds)) && !(param.overlapping && (bounds.contains(rect) || param.path.intersects(child, childMatrix))))
                  add = false;
              }
              if (add && child.matches(match)) {
                items.push(child);
                if (firstOnly)
                  break;
              }
              _getItems(child._children, match, childMatrix, param, firstOnly);
              if (firstOnly && items.length > 0)
                break;
            }
            return items;
          }}
      }, {
        importJSON: function(json) {
          var res = Base.importJSON(json, this);
          return res !== this ? this.addChild(res) : res;
        },
        addChild: function(item, _preserve) {
          return this.insertChild(undefined, item, _preserve);
        },
        insertChild: function(index, item, _preserve) {
          var res = item ? this.insertChildren(index, [item], _preserve) : null;
          return res && res[0];
        },
        addChildren: function(items, _preserve) {
          return this.insertChildren(this._children.length, items, _preserve);
        },
        insertChildren: function(index, items, _preserve, _proto) {
          var children = this._children;
          if (children && items && items.length > 0) {
            items = Array.prototype.slice.apply(items);
            for (var i = items.length - 1; i >= 0; i--) {
              var item = items[i];
              if (_proto && !(item instanceof _proto)) {
                items.splice(i, 1);
              } else {
                var shift = item._parent === this && item._index < index;
                if (item._remove(false, true) && shift)
                  index--;
              }
            }
            Base.splice(children, items, index, 0);
            var project = this._project,
                notifySelf = project && project._changes;
            for (var i = 0,
                l = items.length; i < l; i++) {
              var item = items[i];
              item._parent = this;
              item._setProject(this._project, true);
              if (item._name)
                item.setName(item._name);
              if (notifySelf)
                this._changed(5);
            }
            this._changed(11);
          } else {
            items = null;
          }
          return items;
        },
        _insertSibling: function(index, item, _preserve) {
          return this._parent ? this._parent.insertChild(index, item, _preserve) : null;
        },
        insertAbove: function(item, _preserve) {
          return item._insertSibling(item._index + 1, this, _preserve);
        },
        insertBelow: function(item, _preserve) {
          return item._insertSibling(item._index, this, _preserve);
        },
        sendToBack: function() {
          return (this._parent || this instanceof Layer && this._project).insertChild(0, this);
        },
        bringToFront: function() {
          return (this._parent || this instanceof Layer && this._project).addChild(this);
        },
        appendTop: '#addChild',
        appendBottom: function(item) {
          return this.insertChild(0, item);
        },
        moveAbove: '#insertAbove',
        moveBelow: '#insertBelow',
        reduce: function() {
          if (this._children && this._children.length === 1) {
            var child = this._children[0].reduce();
            child.insertAbove(this);
            child.setStyle(this._style);
            this.remove();
            return child;
          }
          return this;
        },
        _removeNamed: function() {
          var parent = this._parent;
          if (parent) {
            var children = parent._children,
                namedChildren = parent._namedChildren,
                name = this._name,
                namedArray = namedChildren[name],
                index = namedArray ? namedArray.indexOf(this) : -1;
            if (index !== -1) {
              if (children[name] == this)
                delete children[name];
              namedArray.splice(index, 1);
              if (namedArray.length) {
                children[name] = namedArray[namedArray.length - 1];
              } else {
                delete namedChildren[name];
              }
            }
          }
        },
        _remove: function(notifySelf, notifyParent) {
          var parent = this._parent;
          if (parent) {
            if (this._name)
              this._removeNamed();
            if (this._index != null)
              Base.splice(parent._children, null, this._index, 1);
            this._installEvents(false);
            if (notifySelf) {
              var project = this._project;
              if (project && project._changes)
                this._changed(5);
            }
            if (notifyParent)
              parent._changed(11);
            this._parent = null;
            return true;
          }
          return false;
        },
        remove: function() {
          return this._remove(true, true);
        },
        replaceWith: function(item) {
          var ok = item && item.insertBelow(this);
          if (ok)
            this.remove();
          return ok;
        },
        removeChildren: function(from, to) {
          if (!this._children)
            return null;
          from = from || 0;
          to = Base.pick(to, this._children.length);
          var removed = Base.splice(this._children, null, from, to - from);
          for (var i = removed.length - 1; i >= 0; i--) {
            removed[i]._remove(true, false);
          }
          if (removed.length > 0)
            this._changed(11);
          return removed;
        },
        clear: '#removeChildren',
        reverseChildren: function() {
          if (this._children) {
            this._children.reverse();
            for (var i = 0,
                l = this._children.length; i < l; i++)
              this._children[i]._index = i;
            this._changed(11);
          }
        },
        isEmpty: function() {
          return !this._children || this._children.length === 0;
        },
        isEditable: function() {
          var item = this;
          while (item) {
            if (!item._visible || item._locked)
              return false;
            item = item._parent;
          }
          return true;
        },
        hasFill: function() {
          return this.getStyle().hasFill();
        },
        hasStroke: function() {
          return this.getStyle().hasStroke();
        },
        hasShadow: function() {
          return this.getStyle().hasShadow();
        },
        _getOrder: function(item) {
          function getList(item) {
            var list = [];
            do {
              list.unshift(item);
            } while (item = item._parent);
            return list;
          }
          var list1 = getList(this),
              list2 = getList(item);
          for (var i = 0,
              l = Math.min(list1.length, list2.length); i < l; i++) {
            if (list1[i] != list2[i]) {
              return list1[i]._index < list2[i]._index ? 1 : -1;
            }
          }
          return 0;
        },
        hasChildren: function() {
          return this._children && this._children.length > 0;
        },
        isInserted: function() {
          return this._parent ? this._parent.isInserted() : false;
        },
        isAbove: function(item) {
          return this._getOrder(item) === -1;
        },
        isBelow: function(item) {
          return this._getOrder(item) === 1;
        },
        isParent: function(item) {
          return this._parent === item;
        },
        isChild: function(item) {
          return item && item._parent === this;
        },
        isDescendant: function(item) {
          var parent = this;
          while (parent = parent._parent) {
            if (parent == item)
              return true;
          }
          return false;
        },
        isAncestor: function(item) {
          return item ? item.isDescendant(this) : false;
        },
        isSibling: function(item) {
          return this._parent === item._parent;
        },
        isGroupedWith: function(item) {
          var parent = this._parent;
          while (parent) {
            if (parent._parent && /^(Group|Layer|CompoundPath)$/.test(parent._class) && item.isDescendant(parent))
              return true;
            parent = parent._parent;
          }
          return false;
        },
        translate: function() {
          var mx = new Matrix();
          return this.transform(mx.translate.apply(mx, arguments));
        },
        rotate: function(angle) {
          return this.transform(new Matrix().rotate(angle, Point.read(arguments, 1, {readNull: true}) || this.getPosition(true)));
        }
      }, Base.each(['scale', 'shear', 'skew'], function(name) {
        this[name] = function() {
          var point = Point.read(arguments),
              center = Point.read(arguments, 0, {readNull: true});
          return this.transform(new Matrix()[name](point, center || this.getPosition(true)));
        };
      }, {}), {
        transform: function(matrix, _applyMatrix, _applyRecursively, _setApplyMatrix) {
          if (matrix && matrix.isIdentity())
            matrix = null;
          var _matrix = this._matrix,
              applyMatrix = (_applyMatrix || this._applyMatrix) && ((!_matrix.isIdentity() || matrix) || _applyMatrix && _applyRecursively && this._children);
          if (!matrix && !applyMatrix)
            return this;
          if (matrix)
            _matrix.preConcatenate(matrix);
          if (applyMatrix = applyMatrix && this._transformContent(_matrix, _applyRecursively, _setApplyMatrix)) {
            var pivot = this._pivot,
                style = this._style,
                fillColor = style.getFillColor(true),
                strokeColor = style.getStrokeColor(true);
            if (pivot)
              _matrix._transformPoint(pivot, pivot, true);
            if (fillColor)
              fillColor.transform(_matrix);
            if (strokeColor)
              strokeColor.transform(_matrix);
            _matrix.reset(true);
            if (_setApplyMatrix && this._canApplyMatrix)
              this._applyMatrix = true;
          }
          var bounds = this._bounds,
              position = this._position;
          this._changed(9);
          var decomp = bounds && matrix && matrix.decompose();
          if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
            for (var key in bounds) {
              var rect = bounds[key];
              if (applyMatrix || !rect._internal)
                matrix._transformBounds(rect, rect);
            }
            var getter = this._boundsGetter,
                rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
            if (rect)
              this._position = rect.getCenter(true);
            this._bounds = bounds;
          } else if (matrix && position) {
            this._position = matrix._transformPoint(position, position);
          }
          return this;
        },
        _transformContent: function(matrix, applyRecursively, setApplyMatrix) {
          var children = this._children;
          if (children) {
            for (var i = 0,
                l = children.length; i < l; i++)
              children[i].transform(matrix, true, applyRecursively, setApplyMatrix);
            return true;
          }
        },
        globalToLocal: function() {
          return this.getGlobalMatrix(true)._inverseTransform(Point.read(arguments));
        },
        localToGlobal: function() {
          return this.getGlobalMatrix(true)._transformPoint(Point.read(arguments));
        },
        parentToLocal: function() {
          return this._matrix._inverseTransform(Point.read(arguments));
        },
        localToParent: function() {
          return this._matrix._transformPoint(Point.read(arguments));
        },
        fitBounds: function(rectangle, fill) {
          rectangle = Rectangle.read(arguments);
          var bounds = this.getBounds(),
              itemRatio = bounds.height / bounds.width,
              rectRatio = rectangle.height / rectangle.width,
              scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio) ? rectangle.width / bounds.width : rectangle.height / bounds.height,
              newBounds = new Rectangle(new Point(), new Size(bounds.width * scale, bounds.height * scale));
          newBounds.setCenter(rectangle.getCenter());
          this.setBounds(newBounds);
        },
        _setStyles: function(ctx) {
          var style = this._style,
              fillColor = style.getFillColor(),
              strokeColor = style.getStrokeColor(),
              shadowColor = style.getShadowColor();
          if (fillColor)
            ctx.fillStyle = fillColor.toCanvasStyle(ctx);
          if (strokeColor) {
            var strokeWidth = style.getStrokeWidth();
            if (strokeWidth > 0) {
              ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
              ctx.lineWidth = strokeWidth;
              var strokeJoin = style.getStrokeJoin(),
                  strokeCap = style.getStrokeCap(),
                  miterLimit = style.getMiterLimit();
              if (strokeJoin)
                ctx.lineJoin = strokeJoin;
              if (strokeCap)
                ctx.lineCap = strokeCap;
              if (miterLimit)
                ctx.miterLimit = miterLimit;
              if (paper.support.nativeDash) {
                var dashArray = style.getDashArray(),
                    dashOffset = style.getDashOffset();
                if (dashArray && dashArray.length) {
                  if ('setLineDash' in ctx) {
                    ctx.setLineDash(dashArray);
                    ctx.lineDashOffset = dashOffset;
                  } else {
                    ctx.mozDash = dashArray;
                    ctx.mozDashOffset = dashOffset;
                  }
                }
              }
            }
          }
          if (shadowColor) {
            var shadowBlur = style.getShadowBlur();
            if (shadowBlur > 0) {
              ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
              ctx.shadowBlur = shadowBlur;
              var offset = this.getShadowOffset();
              ctx.shadowOffsetX = offset.x;
              ctx.shadowOffsetY = offset.y;
            }
          }
        },
        draw: function(ctx, param, parentStrokeMatrix) {
          var updateVersion = this._updateVersion = this._project._updateVersion;
          if (!this._visible || this._opacity === 0)
            return;
          var matrices = param.matrices,
              viewMatrix = param.viewMatrix,
              matrix = this._matrix,
              globalMatrix = matrices[matrices.length - 1].chain(matrix);
          if (!globalMatrix.isInvertible())
            return;
          function getViewMatrix(matrix) {
            return viewMatrix ? viewMatrix.chain(matrix) : matrix;
          }
          matrices.push(globalMatrix);
          if (param.updateMatrix) {
            globalMatrix._updateVersion = updateVersion;
            this._globalMatrix = globalMatrix;
          }
          var blendMode = this._blendMode,
              opacity = this._opacity,
              normalBlend = blendMode === 'normal',
              nativeBlend = BlendMode.nativeModes[blendMode],
              direct = normalBlend && opacity === 1 || param.dontStart || param.clip || (nativeBlend || normalBlend && opacity < 1) && this._canComposite(),
              pixelRatio = param.pixelRatio || 1,
              mainCtx,
              itemOffset,
              prevOffset;
          if (!direct) {
            var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
            if (!bounds.width || !bounds.height)
              return;
            prevOffset = param.offset;
            itemOffset = param.offset = bounds.getTopLeft().floor();
            mainCtx = ctx;
            ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1).multiply(pixelRatio));
            if (pixelRatio !== 1)
              ctx.scale(pixelRatio, pixelRatio);
          }
          ctx.save();
          var strokeMatrix = parentStrokeMatrix ? parentStrokeMatrix.chain(matrix) : !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
              clip = !direct && param.clipItem,
              transform = !strokeMatrix || clip;
          if (direct) {
            ctx.globalAlpha = opacity;
            if (nativeBlend)
              ctx.globalCompositeOperation = blendMode;
          } else if (transform) {
            ctx.translate(-itemOffset.x, -itemOffset.y);
          }
          if (transform)
            (direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
          if (clip)
            param.clipItem.draw(ctx, param.extend({clip: true}));
          if (strokeMatrix) {
            ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
            var offset = param.offset;
            if (offset)
              ctx.translate(-offset.x, -offset.y);
          }
          this._draw(ctx, param, strokeMatrix);
          ctx.restore();
          matrices.pop();
          if (param.clip && !param.dontFinish)
            ctx.clip();
          if (!direct) {
            BlendMode.process(blendMode, ctx, mainCtx, opacity, itemOffset.subtract(prevOffset).multiply(pixelRatio));
            CanvasProvider.release(ctx);
            param.offset = prevOffset;
          }
        },
        _isUpdated: function(updateVersion) {
          var parent = this._parent;
          if (parent instanceof CompoundPath)
            return parent._isUpdated(updateVersion);
          var updated = this._updateVersion === updateVersion;
          if (!updated && parent && parent._visible && parent._isUpdated(updateVersion)) {
            this._updateVersion = updateVersion;
            updated = true;
          }
          return updated;
        },
        _drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
          if ((this._drawSelected || this._boundsSelected) && this._isUpdated(updateVersion)) {
            var color = this.getSelectedColor(true) || this.getLayer().getSelectedColor(true),
                mx = matrix.chain(this.getGlobalMatrix(true));
            ctx.strokeStyle = ctx.fillStyle = color ? color.toCanvasStyle(ctx) : '#009dec';
            if (this._drawSelected)
              this._drawSelected(ctx, mx, selectedItems);
            if (this._boundsSelected) {
              var half = size / 2,
                  coords = mx._transformCorners(this.getInternalBounds());
              ctx.beginPath();
              for (var i = 0; i < 8; i++)
                ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
              ctx.closePath();
              ctx.stroke();
              for (var i = 0; i < 8; i++)
                ctx.fillRect(coords[i] - half, coords[++i] - half, size, size);
            }
          }
        },
        _canComposite: function() {
          return false;
        }
      }, Base.each(['down', 'drag', 'up', 'move'], function(name) {
        this['removeOn' + Base.capitalize(name)] = function() {
          var hash = {};
          hash[name] = true;
          return this.removeOn(hash);
        };
      }, {removeOn: function(obj) {
          for (var name in obj) {
            if (obj[name]) {
              var key = 'mouse' + name,
                  project = this._project,
                  sets = project._removeSets = project._removeSets || {};
              sets[key] = sets[key] || {};
              sets[key][this._id] = this;
            }
          }
          return this;
        }}));
      var Group = Item.extend({
        _class: 'Group',
        _selectChildren: true,
        _serializeFields: {children: []},
        initialize: function Group(arg) {
          this._children = [];
          this._namedChildren = {};
          if (!this._initialize(arg))
            this.addChildren(Array.isArray(arg) ? arg : arguments);
        },
        _changed: function _changed(flags) {
          _changed.base.call(this, flags);
          if (flags & 1026) {
            this._clipItem = undefined;
          }
        },
        _getClipItem: function() {
          var clipItem = this._clipItem;
          if (clipItem === undefined) {
            clipItem = null;
            for (var i = 0,
                l = this._children.length; i < l; i++) {
              var child = this._children[i];
              if (child._clipMask) {
                clipItem = child;
                break;
              }
            }
            this._clipItem = clipItem;
          }
          return clipItem;
        },
        isClipped: function() {
          return !!this._getClipItem();
        },
        setClipped: function(clipped) {
          var child = this.getFirstChild();
          if (child)
            child.setClipMask(clipped);
        },
        _draw: function(ctx, param) {
          var clip = param.clip,
              clipItem = !clip && this._getClipItem(),
              draw = true;
          param = param.extend({
            clipItem: clipItem,
            clip: false
          });
          if (clip) {
            if (this._currentPath) {
              ctx.currentPath = this._currentPath;
              draw = false;
            } else {
              ctx.beginPath();
              param.dontStart = param.dontFinish = true;
            }
          } else if (clipItem) {
            clipItem.draw(ctx, param.extend({clip: true}));
          }
          if (draw) {
            for (var i = 0,
                l = this._children.length; i < l; i++) {
              var item = this._children[i];
              if (item !== clipItem)
                item.draw(ctx, param);
            }
          }
          if (clip) {
            this._currentPath = ctx.currentPath;
          }
        }
      });
      var Layer = Group.extend({
        _class: 'Layer',
        initialize: function Layer(arg) {
          var props = Base.isPlainObject(arg) ? new Base(arg) : {children: Array.isArray(arg) ? arg : arguments},
              insert = props.insert;
          props.insert = false;
          Group.call(this, props);
          if (insert || insert === undefined) {
            this._project.addChild(this);
            this.activate();
          }
        },
        _remove: function _remove(notifySelf, notifyParent) {
          if (this._parent)
            return _remove.base.call(this, notifySelf, notifyParent);
          if (this._index != null) {
            var project = this._project;
            if (project._activeLayer === this)
              project._activeLayer = this.getNextSibling() || this.getPreviousSibling();
            Base.splice(project.layers, null, this._index, 1);
            this._installEvents(false);
            if (notifySelf && project._changes)
              this._changed(5);
            if (notifyParent) {
              project._needsUpdate = true;
            }
            return true;
          }
          return false;
        },
        getNextSibling: function getNextSibling() {
          return this._parent ? getNextSibling.base.call(this) : this._project.layers[this._index + 1] || null;
        },
        getPreviousSibling: function getPreviousSibling() {
          return this._parent ? getPreviousSibling.base.call(this) : this._project.layers[this._index - 1] || null;
        },
        isInserted: function isInserted() {
          return this._parent ? isInserted.base.call(this) : this._index != null;
        },
        activate: function() {
          this._project._activeLayer = this;
        },
        _insertSibling: function _insertSibling(index, item, _preserve) {
          return !this._parent ? this._project.insertChild(index, item, _preserve) : _insertSibling.base.call(this, index, item, _preserve);
        }
      });
      var Shape = Item.extend({
        _class: 'Shape',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _boundsSelected: true,
        _serializeFields: {
          type: null,
          size: null,
          radius: null
        },
        initialize: function Shape(props) {
          this._initialize(props);
        },
        _equals: function(item) {
          return this._type === item._type && this._size.equals(item._size) && Base.equals(this._radius, item._radius);
        },
        clone: function(insert) {
          var copy = new Shape(Item.NO_INSERT);
          copy.setType(this._type);
          copy.setSize(this._size);
          copy.setRadius(this._radius);
          return this._clone(copy, insert);
        },
        getType: function() {
          return this._type;
        },
        setType: function(type) {
          this._type = type;
        },
        getShape: '#getType',
        setShape: '#setType',
        getSize: function() {
          var size = this._size;
          return new LinkedSize(size.width, size.height, this, 'setSize');
        },
        setSize: function() {
          var size = Size.read(arguments);
          if (!this._size) {
            this._size = size.clone();
          } else if (!this._size.equals(size)) {
            var type = this._type,
                width = size.width,
                height = size.height;
            if (type === 'rectangle') {
              var radius = Size.min(this._radius, size.divide(2));
              this._radius.set(radius.width, radius.height);
            } else if (type === 'circle') {
              width = height = (width + height) / 2;
              this._radius = width / 2;
            } else if (type === 'ellipse') {
              this._radius.set(width / 2, height / 2);
            }
            this._size.set(width, height);
            this._changed(9);
          }
        },
        getRadius: function() {
          var rad = this._radius;
          return this._type === 'circle' ? rad : new LinkedSize(rad.width, rad.height, this, 'setRadius');
        },
        setRadius: function(radius) {
          var type = this._type;
          if (type === 'circle') {
            if (radius === this._radius)
              return;
            var size = radius * 2;
            this._radius = radius;
            this._size.set(size, size);
          } else {
            radius = Size.read(arguments);
            if (!this._radius) {
              this._radius = radius.clone();
            } else {
              if (this._radius.equals(radius))
                return;
              this._radius.set(radius.width, radius.height);
              if (type === 'rectangle') {
                var size = Size.max(this._size, radius.multiply(2));
                this._size.set(size.width, size.height);
              } else if (type === 'ellipse') {
                this._size.set(radius.width * 2, radius.height * 2);
              }
            }
          }
          this._changed(9);
        },
        isEmpty: function() {
          return false;
        },
        toPath: function(insert) {
          var path = this._clone(new Path[Base.capitalize(this._type)]({
            center: new Point(),
            size: this._size,
            radius: this._radius,
            insert: false
          }), insert);
          if (paper.settings.applyMatrix)
            path.setApplyMatrix(true);
          return path;
        },
        _draw: function(ctx, param, strokeMatrix) {
          var style = this._style,
              hasFill = style.hasFill(),
              hasStroke = style.hasStroke(),
              dontPaint = param.dontFinish || param.clip,
              untransformed = !strokeMatrix;
          if (hasFill || hasStroke || dontPaint) {
            var type = this._type,
                radius = this._radius,
                isCircle = type === 'circle';
            if (!param.dontStart)
              ctx.beginPath();
            if (untransformed && isCircle) {
              ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
            } else {
              var rx = isCircle ? radius : radius.width,
                  ry = isCircle ? radius : radius.height,
                  size = this._size,
                  width = size.width,
                  height = size.height;
              if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
                ctx.rect(-width / 2, -height / 2, width, height);
              } else {
                var x = width / 2,
                    y = height / 2,
                    kappa = 1 - 0.5522847498307936,
                    cx = rx * kappa,
                    cy = ry * kappa,
                    c = [-x, -y + ry, -x, -y + cy, -x + cx, -y, -x + rx, -y, x - rx, -y, x - cx, -y, x, -y + cy, x, -y + ry, x, y - ry, x, y - cy, x - cx, y, x - rx, y, -x + rx, y, -x + cx, y, -x, y - cy, -x, y - ry];
                if (strokeMatrix)
                  strokeMatrix.transform(c, c, 32);
                ctx.moveTo(c[0], c[1]);
                ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
                if (x !== rx)
                  ctx.lineTo(c[8], c[9]);
                ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
                if (y !== ry)
                  ctx.lineTo(c[16], c[17]);
                ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
                if (x !== rx)
                  ctx.lineTo(c[24], c[25]);
                ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
              }
            }
            ctx.closePath();
          }
          if (!dontPaint && (hasFill || hasStroke)) {
            this._setStyles(ctx);
            if (hasFill) {
              ctx.fill(style.getWindingRule());
              ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (hasStroke)
              ctx.stroke();
          }
        },
        _canComposite: function() {
          return !(this.hasFill() && this.hasStroke());
        },
        _getBounds: function(getter, matrix) {
          var rect = new Rectangle(this._size).setCenter(0, 0);
          if (getter !== 'getBounds' && this.hasStroke())
            rect = rect.expand(this.getStrokeWidth());
          return matrix ? matrix._transformBounds(rect) : rect;
        }
      }, new function() {
        function getCornerCenter(that, point, expand) {
          var radius = that._radius;
          if (!radius.isZero()) {
            var halfSize = that._size.divide(2);
            for (var i = 0; i < 4; i++) {
              var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
                  corner = dir.multiply(halfSize),
                  center = corner.subtract(dir.multiply(radius)),
                  rect = new Rectangle(corner, center);
              if ((expand ? rect.expand(expand) : rect).contains(point))
                return center;
            }
          }
        }
        function getEllipseRadius(point, radius) {
          var angle = point.getAngleInRadians(),
              width = radius.width * 2,
              height = radius.height * 2,
              x = width * Math.sin(angle),
              y = height * Math.cos(angle);
          return width * height / (2 * Math.sqrt(x * x + y * y));
        }
        return {
          _contains: function _contains(point) {
            if (this._type === 'rectangle') {
              var center = getCornerCenter(this, point);
              return center ? point.subtract(center).divide(this._radius).getLength() <= 1 : _contains.base.call(this, point);
            } else {
              return point.divide(this.size).getLength() <= 0.5;
            }
          },
          _hitTestSelf: function _hitTestSelf(point, options) {
            var hit = false;
            if (this.hasStroke()) {
              var type = this._type,
                  radius = this._radius,
                  strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
              if (type === 'rectangle') {
                var center = getCornerCenter(this, point, strokeWidth);
                if (center) {
                  var pt = point.subtract(center);
                  hit = 2 * Math.abs(pt.getLength() - getEllipseRadius(pt, radius)) <= strokeWidth;
                } else {
                  var rect = new Rectangle(this._size).setCenter(0, 0),
                      outer = rect.expand(strokeWidth),
                      inner = rect.expand(-strokeWidth);
                  hit = outer._containsPoint(point) && !inner._containsPoint(point);
                }
              } else {
                if (type === 'ellipse')
                  radius = getEllipseRadius(point, radius);
                hit = 2 * Math.abs(point.getLength() - radius) <= strokeWidth;
              }
            }
            return hit ? new HitResult('stroke', this) : _hitTestSelf.base.apply(this, arguments);
          }
        };
      }, {statics: new function() {
          function createShape(type, point, size, radius, args) {
            var item = new Shape(Base.getNamed(args));
            item._type = type;
            item._size = size;
            item._radius = radius;
            return item.translate(point);
          }
          return {
            Circle: function() {
              var center = Point.readNamed(arguments, 'center'),
                  radius = Base.readNamed(arguments, 'radius');
              return createShape('circle', center, new Size(radius * 2), radius, arguments);
            },
            Rectangle: function() {
              var rect = Rectangle.readNamed(arguments, 'rectangle'),
                  radius = Size.min(Size.readNamed(arguments, 'radius'), rect.getSize(true).divide(2));
              return createShape('rectangle', rect.getCenter(true), rect.getSize(true), radius, arguments);
            },
            Ellipse: function() {
              var ellipse = Shape._readEllipse(arguments),
                  radius = ellipse.radius;
              return createShape('ellipse', ellipse.center, radius.multiply(2), radius, arguments);
            },
            _readEllipse: function(args) {
              var center,
                  radius;
              if (Base.hasNamed(args, 'radius')) {
                center = Point.readNamed(args, 'center');
                radius = Size.readNamed(args, 'radius');
              } else {
                var rect = Rectangle.readNamed(args, 'rectangle');
                center = rect.getCenter(true);
                radius = rect.getSize(true).divide(2);
              }
              return {
                center: center,
                radius: radius
              };
            }
          };
        }});
      var Raster = Item.extend({
        _class: 'Raster',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _boundsGetter: 'getBounds',
        _boundsSelected: true,
        _serializeFields: {
          crossOrigin: null,
          source: null
        },
        initialize: function Raster(object, position) {
          if (!this._initialize(object, position !== undefined && Point.read(arguments, 1))) {
            if (typeof object === 'string') {
              this.setSource(object);
            } else {
              this.setImage(object);
            }
          }
          if (!this._size) {
            this._size = new Size();
            this._loaded = false;
          }
        },
        _equals: function(item) {
          return this.getSource() === item.getSource();
        },
        clone: function(insert) {
          var copy = new Raster(Item.NO_INSERT),
              image = this._image,
              canvas = this._canvas;
          if (image) {
            copy.setImage(image);
          } else if (canvas) {
            var copyCanvas = CanvasProvider.getCanvas(this._size);
            copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
            copy.setImage(copyCanvas);
          }
          copy._crossOrigin = this._crossOrigin;
          return this._clone(copy, insert);
        },
        getSize: function() {
          var size = this._size;
          return new LinkedSize(size ? size.width : 0, size ? size.height : 0, this, 'setSize');
        },
        setSize: function() {
          var size = Size.read(arguments);
          if (!size.equals(this._size)) {
            if (size.width > 0 && size.height > 0) {
              var element = this.getElement();
              this.setImage(CanvasProvider.getCanvas(size));
              if (element)
                this.getContext(true).drawImage(element, 0, 0, size.width, size.height);
            } else {
              if (this._canvas)
                CanvasProvider.release(this._canvas);
              this._size = size.clone();
            }
          }
        },
        getWidth: function() {
          return this._size ? this._size.width : 0;
        },
        setWidth: function(width) {
          this.setSize(width, this.getHeight());
        },
        getHeight: function() {
          return this._size ? this._size.height : 0;
        },
        setHeight: function(height) {
          this.setSize(this.getWidth(), height);
        },
        isEmpty: function() {
          var size = this._size;
          return !size || size.width === 0 && size.height === 0;
        },
        getResolution: function() {
          var matrix = this._matrix,
              orig = new Point(0, 0).transform(matrix),
              u = new Point(1, 0).transform(matrix).subtract(orig),
              v = new Point(0, 1).transform(matrix).subtract(orig);
          return new Size(72 / u.getLength(), 72 / v.getLength());
        },
        getPpi: '#getResolution',
        getImage: function() {
          return this._image;
        },
        setImage: function(image) {
          if (this._canvas)
            CanvasProvider.release(this._canvas);
          if (image && image.getContext) {
            this._image = null;
            this._canvas = image;
            this._loaded = true;
          } else {
            this._image = image;
            this._canvas = null;
            this._loaded = image && image.complete;
          }
          this._size = new Size(image ? image.naturalWidth || image.width : 0, image ? image.naturalHeight || image.height : 0);
          this._context = null;
          this._changed(521);
        },
        getCanvas: function() {
          if (!this._canvas) {
            var ctx = CanvasProvider.getContext(this._size);
            try {
              if (this._image)
                ctx.drawImage(this._image, 0, 0);
              this._canvas = ctx.canvas;
            } catch (e) {
              CanvasProvider.release(ctx);
            }
          }
          return this._canvas;
        },
        setCanvas: '#setImage',
        getContext: function(modify) {
          if (!this._context)
            this._context = this.getCanvas().getContext('2d');
          if (modify) {
            this._image = null;
            this._changed(513);
          }
          return this._context;
        },
        setContext: function(context) {
          this._context = context;
        },
        getSource: function() {
          return this._image && this._image.src || this.toDataURL();
        },
        setSource: function(src) {
          var that = this,
              crossOrigin = this._crossOrigin,
              image;
          function loaded() {
            var view = that.getView();
            if (view) {
              paper = view._scope;
              that.setImage(image);
              that.emit('load');
              view.update();
            }
          }
          image = document.getElementById(src) || new Image();
          if (crossOrigin)
            image.crossOrigin = crossOrigin;
          if (image.naturalWidth && image.naturalHeight) {
            setTimeout(loaded, 0);
          } else {
            DomEvent.add(image, {load: loaded});
            if (!image.src)
              image.src = src;
          }
          this.setImage(image);
        },
        getCrossOrigin: function() {
          return this._image && this._image.crossOrigin || this._crossOrigin || '';
        },
        setCrossOrigin: function(crossOrigin) {
          this._crossOrigin = crossOrigin;
          if (this._image)
            this._image.crossOrigin = crossOrigin;
        },
        getElement: function() {
          return this._canvas || this._loaded && this._image;
        }
      }, {
        beans: false,
        getSubCanvas: function() {
          var rect = Rectangle.read(arguments),
              ctx = CanvasProvider.getContext(rect.getSize());
          ctx.drawImage(this.getCanvas(), rect.x, rect.y, rect.width, rect.height, 0, 0, rect.width, rect.height);
          return ctx.canvas;
        },
        getSubRaster: function() {
          var rect = Rectangle.read(arguments),
              raster = new Raster(Item.NO_INSERT);
          raster.setImage(this.getSubCanvas(rect));
          raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
          raster._matrix.preConcatenate(this._matrix);
          raster.insertAbove(this);
          return raster;
        },
        toDataURL: function() {
          var src = this._image && this._image.src;
          if (/^data:/.test(src))
            return src;
          var canvas = this.getCanvas();
          return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
        },
        drawImage: function(image) {
          var point = Point.read(arguments, 1);
          this.getContext(true).drawImage(image, point.x, point.y);
        },
        getAverageColor: function(object) {
          var bounds,
              path;
          if (!object) {
            bounds = this.getBounds();
          } else if (object instanceof PathItem) {
            path = object;
            bounds = object.getBounds();
          } else if (object.width) {
            bounds = new Rectangle(object);
          } else if (object.x) {
            bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
          }
          var sampleSize = 32,
              width = Math.min(bounds.width, sampleSize),
              height = Math.min(bounds.height, sampleSize);
          var ctx = Raster._sampleContext;
          if (!ctx) {
            ctx = Raster._sampleContext = CanvasProvider.getContext(new Size(sampleSize));
          } else {
            ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
          }
          ctx.save();
          var matrix = new Matrix().scale(width / bounds.width, height / bounds.height).translate(-bounds.x, -bounds.y);
          matrix.applyToContext(ctx);
          if (path)
            path.draw(ctx, new Base({
              clip: true,
              matrices: [matrix]
            }));
          this._matrix.applyToContext(ctx);
          var element = this.getElement(),
              size = this._size;
          if (element)
            ctx.drawImage(element, -size.width / 2, -size.height / 2);
          ctx.restore();
          var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width), Math.ceil(height)).data,
              channels = [0, 0, 0],
              total = 0;
          for (var i = 0,
              l = pixels.length; i < l; i += 4) {
            var alpha = pixels[i + 3];
            total += alpha;
            alpha /= 255;
            channels[0] += pixels[i] * alpha;
            channels[1] += pixels[i + 1] * alpha;
            channels[2] += pixels[i + 2] * alpha;
          }
          for (var i = 0; i < 3; i++)
            channels[i] /= total;
          return total ? Color.read(channels) : null;
        },
        getPixel: function() {
          var point = Point.read(arguments);
          var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
          return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255], data[3] / 255);
        },
        setPixel: function() {
          var point = Point.read(arguments),
              color = Color.read(arguments),
              components = color._convert('rgb'),
              alpha = color._alpha,
              ctx = this.getContext(true),
              imageData = ctx.createImageData(1, 1),
              data = imageData.data;
          data[0] = components[0] * 255;
          data[1] = components[1] * 255;
          data[2] = components[2] * 255;
          data[3] = alpha != null ? alpha * 255 : 255;
          ctx.putImageData(imageData, point.x, point.y);
        },
        createImageData: function() {
          var size = Size.read(arguments);
          return this.getContext().createImageData(size.width, size.height);
        },
        getImageData: function() {
          var rect = Rectangle.read(arguments);
          if (rect.isEmpty())
            rect = new Rectangle(this._size);
          return this.getContext().getImageData(rect.x, rect.y, rect.width, rect.height);
        },
        setImageData: function(data) {
          var point = Point.read(arguments, 1);
          this.getContext(true).putImageData(data, point.x, point.y);
        },
        _getBounds: function(getter, matrix) {
          var rect = new Rectangle(this._size).setCenter(0, 0);
          return matrix ? matrix._transformBounds(rect) : rect;
        },
        _hitTestSelf: function(point) {
          if (this._contains(point)) {
            var that = this;
            return new HitResult('pixel', that, {
              offset: point.add(that._size.divide(2)).round(),
              color: {get: function() {
                  return that.getPixel(this.offset);
                }}
            });
          }
        },
        _draw: function(ctx) {
          var element = this.getElement();
          if (element) {
            ctx.globalAlpha = this._opacity;
            ctx.drawImage(element, -this._size.width / 2, -this._size.height / 2);
          }
        },
        _canComposite: function() {
          return true;
        }
      });
      var PlacedSymbol = Item.extend({
        _class: 'PlacedSymbol',
        _applyMatrix: false,
        _canApplyMatrix: false,
        _boundsGetter: {getBounds: 'getStrokeBounds'},
        _boundsSelected: true,
        _serializeFields: {symbol: null},
        initialize: function PlacedSymbol(arg0, arg1) {
          if (!this._initialize(arg0, arg1 !== undefined && Point.read(arguments, 1)))
            this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
        },
        _equals: function(item) {
          return this._symbol === item._symbol;
        },
        getSymbol: function() {
          return this._symbol;
        },
        setSymbol: function(symbol) {
          this._symbol = symbol;
          this._changed(9);
        },
        clone: function(insert) {
          var copy = new PlacedSymbol(Item.NO_INSERT);
          copy.setSymbol(this._symbol);
          return this._clone(copy, insert);
        },
        isEmpty: function() {
          return this._symbol._definition.isEmpty();
        },
        _getBounds: function(getter, matrix, cacheItem) {
          var definition = this.symbol._definition;
          return definition._getCachedBounds(getter, matrix && matrix.chain(definition._matrix), cacheItem);
        },
        _hitTestSelf: function(point, options) {
          var res = this._symbol._definition._hitTest(point, options);
          if (res)
            res.item = this;
          return res;
        },
        _draw: function(ctx, param) {
          this.symbol._definition.draw(ctx, param);
        }
      });
      var HitResult = Base.extend({
        _class: 'HitResult',
        initialize: function HitResult(type, item, values) {
          this.type = type;
          this.item = item;
          if (values) {
            values.enumerable = true;
            this.inject(values);
          }
        },
        statics: {getOptions: function(options) {
            return new Base({
              type: null,
              tolerance: paper.settings.hitTolerance,
              fill: !options,
              stroke: !options,
              segments: !options,
              handles: false,
              ends: false,
              center: false,
              bounds: false,
              guides: false,
              selected: false
            }, options);
          }}
      });
      var Segment = Base.extend({
        _class: 'Segment',
        beans: true,
        initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
          var count = arguments.length,
              point,
              handleIn,
              handleOut;
          if (count === 0) {} else if (count === 1) {
            if ('point' in arg0) {
              point = arg0.point;
              handleIn = arg0.handleIn;
              handleOut = arg0.handleOut;
            } else {
              point = arg0;
            }
          } else if (count === 2 && typeof arg0 === 'number') {
            point = arguments;
          } else if (count <= 3) {
            point = arg0;
            handleIn = arg1;
            handleOut = arg2;
          } else {
            point = arg0 !== undefined ? [arg0, arg1] : null;
            handleIn = arg2 !== undefined ? [arg2, arg3] : null;
            handleOut = arg4 !== undefined ? [arg4, arg5] : null;
          }
          new SegmentPoint(point, this, '_point');
          new SegmentPoint(handleIn, this, '_handleIn');
          new SegmentPoint(handleOut, this, '_handleOut');
        },
        _serialize: function(options) {
          return Base.serialize(this.hasHandles() ? [this._point, this._handleIn, this._handleOut] : this._point, options, true);
        },
        _changed: function(point) {
          var path = this._path;
          if (!path)
            return;
          var curves = path._curves,
              index = this._index,
              curve;
          if (curves) {
            if ((!point || point === this._point || point === this._handleIn) && (curve = index > 0 ? curves[index - 1] : path._closed ? curves[curves.length - 1] : null))
              curve._changed();
            if ((!point || point === this._point || point === this._handleOut) && (curve = curves[index]))
              curve._changed();
          }
          path._changed(25);
        },
        getPoint: function() {
          return this._point;
        },
        setPoint: function() {
          var point = Point.read(arguments);
          this._point.set(point.x, point.y);
        },
        getHandleIn: function() {
          return this._handleIn;
        },
        setHandleIn: function() {
          var point = Point.read(arguments);
          this._handleIn.set(point.x, point.y);
        },
        getHandleOut: function() {
          return this._handleOut;
        },
        setHandleOut: function() {
          var point = Point.read(arguments);
          this._handleOut.set(point.x, point.y);
        },
        hasHandles: function() {
          return !this._handleIn.isZero() || !this._handleOut.isZero();
        },
        clearHandles: function() {
          this._handleIn.set(0, 0);
          this._handleOut.set(0, 0);
        },
        _selectionState: 0,
        isSelected: function(_point) {
          var state = this._selectionState;
          return !_point ? !!(state & 7) : _point === this._point ? !!(state & 4) : _point === this._handleIn ? !!(state & 1) : _point === this._handleOut ? !!(state & 2) : false;
        },
        setSelected: function(selected, _point) {
          var path = this._path,
              selected = !!selected,
              state = this._selectionState,
              oldState = state,
              flag = !_point ? 7 : _point === this._point ? 4 : _point === this._handleIn ? 1 : _point === this._handleOut ? 2 : 0;
          if (selected) {
            state |= flag;
          } else {
            state &= ~flag;
          }
          this._selectionState = state;
          if (path && state !== oldState) {
            path._updateSelection(this, oldState, state);
            path._changed(129);
          }
        },
        getIndex: function() {
          return this._index !== undefined ? this._index : null;
        },
        getPath: function() {
          return this._path || null;
        },
        getCurve: function() {
          var path = this._path,
              index = this._index;
          if (path) {
            if (index > 0 && !path._closed && index === path._segments.length - 1)
              index--;
            return path.getCurves()[index] || null;
          }
          return null;
        },
        getLocation: function() {
          var curve = this.getCurve();
          return curve ? new CurveLocation(curve, this === curve._segment1 ? 0 : 1) : null;
        },
        getNext: function() {
          var segments = this._path && this._path._segments;
          return segments && (segments[this._index + 1] || this._path._closed && segments[0]) || null;
        },
        getPrevious: function() {
          var segments = this._path && this._path._segments;
          return segments && (segments[this._index - 1] || this._path._closed && segments[segments.length - 1]) || null;
        },
        isFirst: function() {
          return this._index === 0;
        },
        isLast: function() {
          var path = this._path;
          return path && this._index === path._segments.length - 1 || false;
        },
        reverse: function() {
          var handleIn = this._handleIn,
              handleOut = this._handleOut,
              inX = handleIn._x,
              inY = handleIn._y;
          handleIn.set(handleOut._x, handleOut._y);
          handleOut.set(inX, inY);
        },
        reversed: function() {
          return new Segment(this._point, this._handleOut, this._handleIn);
        },
        remove: function() {
          return this._path ? !!this._path.removeSegment(this._index) : false;
        },
        clone: function() {
          return new Segment(this._point, this._handleIn, this._handleOut);
        },
        equals: function(segment) {
          return segment === this || segment && this._class === segment._class && this._point.equals(segment._point) && this._handleIn.equals(segment._handleIn) && this._handleOut.equals(segment._handleOut) || false;
        },
        toString: function() {
          var parts = ['point: ' + this._point];
          if (!this._handleIn.isZero())
            parts.push('handleIn: ' + this._handleIn);
          if (!this._handleOut.isZero())
            parts.push('handleOut: ' + this._handleOut);
          return '{ ' + parts.join(', ') + ' }';
        },
        transform: function(matrix) {
          this._transformCoordinates(matrix, new Array(6), true);
          this._changed();
        },
        _transformCoordinates: function(matrix, coords, change) {
          var point = this._point,
              handleIn = !change || !this._handleIn.isZero() ? this._handleIn : null,
              handleOut = !change || !this._handleOut.isZero() ? this._handleOut : null,
              x = point._x,
              y = point._y,
              i = 2;
          coords[0] = x;
          coords[1] = y;
          if (handleIn) {
            coords[i++] = handleIn._x + x;
            coords[i++] = handleIn._y + y;
          }
          if (handleOut) {
            coords[i++] = handleOut._x + x;
            coords[i++] = handleOut._y + y;
          }
          if (matrix) {
            matrix._transformCoordinates(coords, coords, i / 2);
            x = coords[0];
            y = coords[1];
            if (change) {
              point._x = x;
              point._y = y;
              i = 2;
              if (handleIn) {
                handleIn._x = coords[i++] - x;
                handleIn._y = coords[i++] - y;
              }
              if (handleOut) {
                handleOut._x = coords[i++] - x;
                handleOut._y = coords[i++] - y;
              }
            } else {
              if (!handleIn) {
                coords[i++] = x;
                coords[i++] = y;
              }
              if (!handleOut) {
                coords[i++] = x;
                coords[i++] = y;
              }
            }
          }
          return coords;
        }
      });
      var SegmentPoint = Point.extend({
        initialize: function SegmentPoint(point, owner, key) {
          var x,
              y,
              selected;
          if (!point) {
            x = y = 0;
          } else if ((x = point[0]) !== undefined) {
            y = point[1];
          } else {
            var pt = point;
            if ((x = pt.x) === undefined) {
              pt = Point.read(arguments);
              x = pt.x;
            }
            y = pt.y;
            selected = pt.selected;
          }
          this._x = x;
          this._y = y;
          this._owner = owner;
          owner[key] = this;
          if (selected)
            this.setSelected(true);
        },
        set: function(x, y) {
          this._x = x;
          this._y = y;
          this._owner._changed(this);
          return this;
        },
        _serialize: function(options) {
          var f = options.formatter,
              x = f.number(this._x),
              y = f.number(this._y);
          return this.isSelected() ? {
            x: x,
            y: y,
            selected: true
          } : [x, y];
        },
        getX: function() {
          return this._x;
        },
        setX: function(x) {
          this._x = x;
          this._owner._changed(this);
        },
        getY: function() {
          return this._y;
        },
        setY: function(y) {
          this._y = y;
          this._owner._changed(this);
        },
        isZero: function() {
          return Numerical.isZero(this._x) && Numerical.isZero(this._y);
        },
        setSelected: function(selected) {
          this._owner.setSelected(selected, this);
        },
        isSelected: function() {
          return this._owner.isSelected(this);
        }
      });
      var Curve = Base.extend({
        _class: 'Curve',
        initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
          var count = arguments.length,
              seg1,
              seg2,
              point1,
              point2,
              handle1,
              handle2;
          if (count === 3) {
            this._path = arg0;
            seg1 = arg1;
            seg2 = arg2;
          } else if (count === 0) {
            seg1 = new Segment();
            seg2 = new Segment();
          } else if (count === 1) {
            if ('segment1' in arg0) {
              seg1 = new Segment(arg0.segment1);
              seg2 = new Segment(arg0.segment2);
            } else if ('point1' in arg0) {
              point1 = arg0.point1;
              handle1 = arg0.handle1;
              handle2 = arg0.handle2;
              point2 = arg0.point2;
            } else if (Array.isArray(arg0)) {
              point1 = [arg0[0], arg0[1]];
              point2 = [arg0[6], arg0[7]];
              handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
              handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
            }
          } else if (count === 2) {
            seg1 = new Segment(arg0);
            seg2 = new Segment(arg1);
          } else if (count === 4) {
            point1 = arg0;
            handle1 = arg1;
            handle2 = arg2;
            point2 = arg3;
          } else if (count === 8) {
            point1 = [arg0, arg1];
            point2 = [arg6, arg7];
            handle1 = [arg2 - arg0, arg3 - arg1];
            handle2 = [arg4 - arg6, arg5 - arg7];
          }
          this._segment1 = seg1 || new Segment(point1, null, handle1);
          this._segment2 = seg2 || new Segment(point2, handle2, null);
        },
        _serialize: function(options) {
          return Base.serialize(this.hasHandles() ? [this.getPoint1(), this.getHandle1(), this.getHandle2(), this.getPoint2()] : [this.getPoint1(), this.getPoint2()], options, true);
        },
        _changed: function() {
          this._length = this._bounds = undefined;
        },
        clone: function() {
          return new Curve(this._segment1, this._segment2);
        },
        toString: function() {
          var parts = ['point1: ' + this._segment1._point];
          if (!this._segment1._handleOut.isZero())
            parts.push('handle1: ' + this._segment1._handleOut);
          if (!this._segment2._handleIn.isZero())
            parts.push('handle2: ' + this._segment2._handleIn);
          parts.push('point2: ' + this._segment2._point);
          return '{ ' + parts.join(', ') + ' }';
        },
        remove: function() {
          var removed = false;
          if (this._path) {
            var segment2 = this._segment2,
                handleOut = segment2._handleOut;
            removed = segment2.remove();
            if (removed)
              this._segment1._handleOut.set(handleOut.x, handleOut.y);
          }
          return removed;
        },
        getPoint1: function() {
          return this._segment1._point;
        },
        setPoint1: function() {
          var point = Point.read(arguments);
          this._segment1._point.set(point.x, point.y);
        },
        getPoint2: function() {
          return this._segment2._point;
        },
        setPoint2: function() {
          var point = Point.read(arguments);
          this._segment2._point.set(point.x, point.y);
        },
        getHandle1: function() {
          return this._segment1._handleOut;
        },
        setHandle1: function() {
          var point = Point.read(arguments);
          this._segment1._handleOut.set(point.x, point.y);
        },
        getHandle2: function() {
          return this._segment2._handleIn;
        },
        setHandle2: function() {
          var point = Point.read(arguments);
          this._segment2._handleIn.set(point.x, point.y);
        },
        getSegment1: function() {
          return this._segment1;
        },
        getSegment2: function() {
          return this._segment2;
        },
        getPath: function() {
          return this._path;
        },
        getIndex: function() {
          return this._segment1._index;
        },
        getNext: function() {
          var curves = this._path && this._path._curves;
          return curves && (curves[this._segment1._index + 1] || this._path._closed && curves[0]) || null;
        },
        getPrevious: function() {
          var curves = this._path && this._path._curves;
          return curves && (curves[this._segment1._index - 1] || this._path._closed && curves[curves.length - 1]) || null;
        },
        isFirst: function() {
          return this._segment1._index === 0;
        },
        isLast: function() {
          var path = this._path;
          return path && this._segment1._index === path._curves.length - 1 || false;
        },
        isSelected: function() {
          return this.getPoint1().isSelected() && this.getHandle2().isSelected() && this.getHandle2().isSelected() && this.getPoint2().isSelected();
        },
        setSelected: function(selected) {
          this.getPoint1().setSelected(selected);
          this.getHandle1().setSelected(selected);
          this.getHandle2().setSelected(selected);
          this.getPoint2().setSelected(selected);
        },
        getValues: function(matrix) {
          return Curve.getValues(this._segment1, this._segment2, matrix);
        },
        getPoints: function() {
          var coords = this.getValues(),
              points = [];
          for (var i = 0; i < 8; i += 2)
            points.push(new Point(coords[i], coords[i + 1]));
          return points;
        },
        getLength: function() {
          if (this._length == null)
            this._length = Curve.getLength(this.getValues(), 0, 1);
          return this._length;
        },
        getArea: function() {
          return Curve.getArea(this.getValues());
        },
        getLine: function() {
          return new Line(this._segment1._point, this._segment2._point);
        },
        getPart: function(from, to) {
          return new Curve(Curve.getPart(this.getValues(), from, to));
        },
        getPartLength: function(from, to) {
          return Curve.getLength(this.getValues(), from, to);
        },
        getIntersections: function(curve) {
          return Curve._getIntersections(this.getValues(), curve && curve !== this ? curve.getValues() : null, this, curve, [], {});
        },
        _getParameter: function(offset, isParameter) {
          return isParameter ? offset : offset && offset.curve === this ? offset.parameter : offset === undefined && isParameter === undefined ? 0.5 : this.getParameterAt(offset, 0);
        },
        divide: function(offset, isParameter, _setHandles) {
          var parameter = this._getParameter(offset, isParameter),
              tMin = 4e-7,
              tMax = 1 - tMin,
              res = null;
          if (parameter >= tMin && parameter <= tMax) {
            var parts = Curve.subdivide(this.getValues(), parameter),
                left = parts[0],
                right = parts[1],
                setHandles = _setHandles || this.hasHandles(),
                segment1 = this._segment1,
                segment2 = this._segment2,
                path = this._path;
            if (setHandles) {
              segment1._handleOut.set(left[2] - left[0], left[3] - left[1]);
              segment2._handleIn.set(right[4] - right[6], right[5] - right[7]);
            }
            var x = left[6],
                y = left[7],
                segment = new Segment(new Point(x, y), setHandles && new Point(left[4] - x, left[5] - y), setHandles && new Point(right[2] - x, right[3] - y));
            if (path) {
              path.insert(segment1._index + 1, segment);
              res = this.getNext();
            } else {
              this._segment2 = segment;
              res = new Curve(segment, segment2);
            }
          }
          return res;
        },
        split: function(offset, isParameter) {
          return this._path ? this._path.split(this._segment1._index, this._getParameter(offset, isParameter)) : null;
        },
        reversed: function() {
          return new Curve(this._segment2.reversed(), this._segment1.reversed());
        },
        clearHandles: function() {
          this._segment1._handleOut.set(0, 0);
          this._segment2._handleIn.set(0, 0);
        },
        statics: {
          getValues: function(segment1, segment2, matrix) {
            var p1 = segment1._point,
                h1 = segment1._handleOut,
                h2 = segment2._handleIn,
                p2 = segment2._point,
                values = [p1._x, p1._y, p1._x + h1._x, p1._y + h1._y, p2._x + h2._x, p2._y + h2._y, p2._x, p2._y];
            if (matrix)
              matrix._transformCoordinates(values, values, 4);
            return values;
          },
          subdivide: function(v, t) {
            var p1x = v[0],
                p1y = v[1],
                c1x = v[2],
                c1y = v[3],
                c2x = v[4],
                c2y = v[5],
                p2x = v[6],
                p2y = v[7];
            if (t === undefined)
              t = 0.5;
            var u = 1 - t,
                p3x = u * p1x + t * c1x,
                p3y = u * p1y + t * c1y,
                p4x = u * c1x + t * c2x,
                p4y = u * c1y + t * c2y,
                p5x = u * c2x + t * p2x,
                p5y = u * c2y + t * p2y,
                p6x = u * p3x + t * p4x,
                p6y = u * p3y + t * p4y,
                p7x = u * p4x + t * p5x,
                p7y = u * p4y + t * p5y,
                p8x = u * p6x + t * p7x,
                p8y = u * p6y + t * p7y;
            return [[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y], [p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]];
          },
          solveCubic: function(v, coord, val, roots, min, max) {
            var p1 = v[coord],
                c1 = v[coord + 2],
                c2 = v[coord + 4],
                p2 = v[coord + 6],
                c = 3 * (c1 - p1),
                b = 3 * (c2 - c1) - c,
                a = p2 - p1 - c - b;
            return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
          },
          getParameterOf: function(v, point) {
            var p1 = new Point(v[0], v[1]),
                p2 = new Point(v[6], v[7]),
                epsilon = 1e-12,
                t = point.isClose(p1, epsilon) ? 0 : point.isClose(p2, epsilon) ? 1 : null;
            if (t !== null)
              return t;
            var coords = [point.x, point.y],
                roots = [],
                geomEpsilon = 2e-7;
            for (var c = 0; c < 2; c++) {
              var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
              for (var i = 0; i < count; i++) {
                t = roots[i];
                if (point.isClose(Curve.getPoint(v, t), geomEpsilon))
                  return t;
              }
            }
            return point.isClose(p1, geomEpsilon) ? 0 : point.isClose(p2, geomEpsilon) ? 1 : null;
          },
          getNearestParameter: function(v, point) {
            if (Curve.isStraight(v)) {
              var p1x = v[0],
                  p1y = v[1],
                  p2x = v[6],
                  p2y = v[7],
                  vx = p2x - p1x,
                  vy = p2y - p1y,
                  det = vx * vx + vy * vy;
              if (det === 0)
                return 0;
              var u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;
              return u < 1e-12 ? 0 : u > 0.999999999999 ? 1 : Curve.getParameterOf(v, new Point(p1x + u * vx, p1y + u * vy));
            }
            var count = 100,
                minDist = Infinity,
                minT = 0;
            function refine(t) {
              if (t >= 0 && t <= 1) {
                var dist = point.getDistance(Curve.getPoint(v, t), true);
                if (dist < minDist) {
                  minDist = dist;
                  minT = t;
                  return true;
                }
              }
            }
            for (var i = 0; i <= count; i++)
              refine(i / count);
            var step = 1 / (count * 2);
            while (step > 4e-7) {
              if (!refine(minT - step) && !refine(minT + step))
                step /= 2;
            }
            return minT;
          },
          getPart: function(v, from, to) {
            var flip = from > to;
            if (flip) {
              var tmp = from;
              from = to;
              to = tmp;
            }
            if (from > 0)
              v = Curve.subdivide(v, from)[1];
            if (to < 1)
              v = Curve.subdivide(v, (to - from) / (1 - from))[0];
            return flip ? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]] : v;
          },
          hasHandles: function(v) {
            var isZero = Numerical.isZero;
            return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3]) && isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
          },
          isFlatEnough: function(v, tolerance) {
            var p1x = v[0],
                p1y = v[1],
                c1x = v[2],
                c1y = v[3],
                c2x = v[4],
                c2y = v[5],
                p2x = v[6],
                p2y = v[7],
                ux = 3 * c1x - 2 * p1x - p2x,
                uy = 3 * c1y - 2 * p1y - p2y,
                vx = 3 * c2x - 2 * p2x - p1x,
                vy = 3 * c2y - 2 * p2y - p1y;
            return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy) < 10 * tolerance * tolerance;
          },
          getArea: function(v) {
            var p1x = v[0],
                p1y = v[1],
                p2x = v[6],
                p2y = v[7],
                h1x = (v[2] + p1x) / 2,
                h1y = (v[3] + p1y) / 2,
                h2x = (v[4] + v[6]) / 2,
                h2y = (v[5] + v[7]) / 2;
            return 6 * ((p1x - h1x) * (h1y + p1y) + (h1x - h2x) * (h2y + h1y) + (h2x - p2x) * (p2y + h2y)) / 10;
          },
          getBounds: function(v) {
            var min = v.slice(0, 2),
                max = min.slice(),
                roots = [0, 0];
            for (var i = 0; i < 2; i++)
              Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6], i, 0, min, max, roots);
            return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
          },
          _addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
            function add(value, padding) {
              var left = value - padding,
                  right = value + padding;
              if (left < min[coord])
                min[coord] = left;
              if (right > max[coord])
                max[coord] = right;
            }
            var a = 3 * (v1 - v2) - v0 + v3,
                b = 2 * (v0 + v2) - 4 * v1,
                c = v1 - v0,
                count = Numerical.solveQuadratic(a, b, c, roots),
                tMin = 4e-7,
                tMax = 1 - tMin;
            add(v3, 0);
            for (var i = 0; i < count; i++) {
              var t = roots[i],
                  u = 1 - t;
              if (tMin < t && t < tMax)
                add(u * u * u * v0 + 3 * u * u * t * v1 + 3 * u * t * t * v2 + t * t * t * v3, padding);
            }
          }
        }
      }, Base.each(['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'], function(name) {
        this[name] = function() {
          if (!this._bounds)
            this._bounds = {};
          var bounds = this._bounds[name];
          if (!bounds) {
            var path = this._path;
            bounds = this._bounds[name] = Path[name]([this._segment1, this._segment2], false, path && path.getStyle());
          }
          return bounds.clone();
        };
      }, {}), Base.each({
        isStraight: function(l, h1, h2) {
          if (h1.isZero() && h2.isZero()) {
            return true;
          } else if (l.isZero()) {
            return false;
          } else if (h1.isCollinear(l) && h2.isCollinear(l)) {
            var div = l.dot(l),
                p1 = l.dot(h1) / div,
                p2 = l.dot(h2) / div;
            return p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;
          }
          return false;
        },
        isLinear: function(l, h1, h2) {
          var third = l.divide(3);
          return h1.equals(third) && h2.negate().equals(third);
        }
      }, function(test, name) {
        this[name] = function() {
          var seg1 = this._segment1,
              seg2 = this._segment2;
          return test(seg2._point.subtract(seg1._point), seg1._handleOut, seg2._handleIn);
        };
        this.statics[name] = function(v) {
          var p1x = v[0],
              p1y = v[1],
              p2x = v[6],
              p2y = v[7];
          return test(new Point(p2x - p1x, p2y - p1y), new Point(v[2] - p1x, v[3] - p1y), new Point(v[4] - p2x, v[5] - p2y));
        };
      }, {
        statics: {},
        hasHandles: function() {
          return !this._segment1._handleOut.isZero() || !this._segment2._handleIn.isZero();
        },
        isCollinear: function(curve) {
          return curve && this.isStraight() && curve.isStraight() && this.getLine().isCollinear(curve.getLine());
        },
        isHorizontal: function() {
          return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y) < 1e-7;
        },
        isVertical: function() {
          return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x) < 1e-7;
        }
      }), {
        beans: false,
        getParameterAt: function(offset, start) {
          return Curve.getParameterAt(this.getValues(), offset, start);
        },
        getParameterOf: function() {
          return Curve.getParameterOf(this.getValues(), Point.read(arguments));
        },
        getLocationAt: function(offset, isParameter) {
          var t = isParameter ? offset : this.getParameterAt(offset);
          return t != null && t >= 0 && t <= 1 ? new CurveLocation(this, t) : null;
        },
        getLocationOf: function() {
          return this.getLocationAt(this.getParameterOf(Point.read(arguments)), true);
        },
        getOffsetOf: function() {
          var loc = this.getLocationOf.apply(this, arguments);
          return loc ? loc.getOffset() : null;
        },
        getNearestLocation: function() {
          var point = Point.read(arguments),
              values = this.getValues(),
              t = Curve.getNearestParameter(values, point),
              pt = Curve.getPoint(values, t);
          return new CurveLocation(this, t, pt, null, point.getDistance(pt));
        },
        getNearestPoint: function() {
          return this.getNearestLocation.apply(this, arguments).getPoint();
        }
      }, new function() {
        var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent', 'getWeightedNormal', 'getCurvature'];
        return Base.each(methods, function(name) {
          this[name + 'At'] = function(offset, isParameter) {
            var values = this.getValues();
            return Curve[name](values, isParameter ? offset : Curve.getParameterAt(values, offset, 0));
          };
        }, {statics: {evaluateMethods: methods}});
      }, new function() {
        function getLengthIntegrand(v) {
          var p1x = v[0],
              p1y = v[1],
              c1x = v[2],
              c1y = v[3],
              c2x = v[4],
              c2y = v[5],
              p2x = v[6],
              p2y = v[7],
              ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
              bx = 6 * (p1x + c2x) - 12 * c1x,
              cx = 3 * (c1x - p1x),
              ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
              by = 6 * (p1y + c2y) - 12 * c1y,
              cy = 3 * (c1y - p1y);
          return function(t) {
            var dx = (ax * t + bx) * t + cx,
                dy = (ay * t + by) * t + cy;
            return Math.sqrt(dx * dx + dy * dy);
          };
        }
        function getIterations(a, b) {
          return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
        }
        function evaluate(v, t, type, normalized) {
          if (t == null || t < 0 || t > 1)
            return null;
          var p1x = v[0],
              p1y = v[1],
              c1x = v[2],
              c1y = v[3],
              c2x = v[4],
              c2y = v[5],
              p2x = v[6],
              p2y = v[7],
              tMin = 4e-7,
              tMax = 1 - tMin,
              x,
              y;
          if (type === 0 && (t < tMin || t > tMax)) {
            var isZero = t < tMin;
            x = isZero ? p1x : p2x;
            y = isZero ? p1y : p2y;
          } else {
            var cx = 3 * (c1x - p1x),
                bx = 3 * (c2x - c1x) - cx,
                ax = p2x - p1x - cx - bx,
                cy = 3 * (c1y - p1y),
                by = 3 * (c2y - c1y) - cy,
                ay = p2y - p1y - cy - by;
            if (type === 0) {
              x = ((ax * t + bx) * t + cx) * t + p1x;
              y = ((ay * t + by) * t + cy) * t + p1y;
            } else {
              if (t < tMin) {
                x = cx;
                y = cy;
              } else if (t > tMax) {
                x = 3 * (p2x - c2x);
                y = 3 * (p2y - c2y);
              } else {
                x = (3 * ax * t + 2 * bx) * t + cx;
                y = (3 * ay * t + 2 * by) * t + cy;
              }
              if (normalized) {
                if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
                  x = c2x - c1x;
                  y = c2y - c1y;
                }
                var len = Math.sqrt(x * x + y * y);
                if (len) {
                  x /= len;
                  y /= len;
                }
              }
              if (type === 3) {
                var x2 = 6 * ax * t + 2 * bx,
                    y2 = 6 * ay * t + 2 * by,
                    d = Math.pow(x * x + y * y, 3 / 2);
                x = d !== 0 ? (x * y2 - y * x2) / d : 0;
                y = 0;
              }
            }
          }
          return type === 2 ? new Point(y, -x) : new Point(x, y);
        }
        return {statics: {
            getLength: function(v, a, b) {
              if (a === undefined)
                a = 0;
              if (b === undefined)
                b = 1;
              if (a === 0 && b === 1 && Curve.isStraight(v)) {
                var dx = v[6] - v[0],
                    dy = v[7] - v[1];
                return Math.sqrt(dx * dx + dy * dy);
              }
              var ds = getLengthIntegrand(v);
              return Numerical.integrate(ds, a, b, getIterations(a, b));
            },
            getParameterAt: function(v, offset, start) {
              if (start === undefined)
                start = offset < 0 ? 1 : 0;
              if (offset === 0)
                return start;
              var abs = Math.abs,
                  forward = offset > 0,
                  a = forward ? start : 0,
                  b = forward ? 1 : start,
                  ds = getLengthIntegrand(v),
                  rangeLength = Numerical.integrate(ds, a, b, getIterations(a, b));
              if (abs(offset - rangeLength) < 1e-12) {
                return forward ? b : a;
              } else if (abs(offset) > rangeLength) {
                return null;
              }
              var guess = offset / rangeLength,
                  length = 0;
              function f(t) {
                length += Numerical.integrate(ds, start, t, getIterations(start, t));
                start = t;
                return length - offset;
              }
              return Numerical.findRoot(f, ds, start + guess, a, b, 32, 1e-12);
            },
            getPoint: function(v, t) {
              return evaluate(v, t, 0, false);
            },
            getTangent: function(v, t) {
              return evaluate(v, t, 1, true);
            },
            getWeightedTangent: function(v, t) {
              return evaluate(v, t, 1, false);
            },
            getNormal: function(v, t) {
              return evaluate(v, t, 2, true);
            },
            getWeightedNormal: function(v, t) {
              return evaluate(v, t, 2, false);
            },
            getCurvature: function(v, t) {
              return evaluate(v, t, 3, false).x;
            }
          }};
      }, new function() {
        function addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2, overlap) {
          var startConnected = param.startConnected,
              endConnected = param.endConnected,
              tMin = 4e-7,
              tMax = 1 - tMin;
          if (t1 == null)
            t1 = Curve.getParameterOf(v1, p1);
          if (t1 !== null && t1 >= (startConnected ? tMin : 0) && t1 <= (endConnected ? tMax : 1)) {
            if (t2 == null)
              t2 = Curve.getParameterOf(v2, p2);
            if (t2 !== null && t2 >= (endConnected ? tMin : 0) && t2 <= (startConnected ? tMax : 1)) {
              var renormalize = param.renormalize;
              if (renormalize) {
                var res = renormalize(t1, t2);
                t1 = res[0];
                t2 = res[1];
              }
              var loc1 = new CurveLocation(c1, t1, p1 || Curve.getPoint(v1, t1), overlap),
                  loc2 = new CurveLocation(c2, t2, p2 || Curve.getPoint(v2, t2), overlap),
                  flip = loc1.getPath() === loc2.getPath() && loc1.getIndex() > loc2.getIndex(),
                  loc = flip ? loc2 : loc1,
                  include = param.include;
              loc1._intersection = loc2;
              loc2._intersection = loc1;
              if (!include || include(loc)) {
                CurveLocation.insert(locations, loc, true);
              }
            }
          }
        }
        function addCurveIntersections(v1, v2, c1, c2, locations, param, tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
          if (++recursion >= 24)
            return;
          var q0x = v2[0],
              q0y = v2[1],
              q3x = v2[6],
              q3y = v2[7],
              getSignedDistance = Line.getSignedDistance,
              d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
              d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
              factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
              dMin = factor * Math.min(0, d1, d2),
              dMax = factor * Math.max(0, d1, d2),
              dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
              dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
              dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
              dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
              hull = getConvexHull(dp0, dp1, dp2, dp3),
              top = hull[0],
              bottom = hull[1],
              tMinClip,
              tMaxClip;
          if ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null || (tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(), dMin, dMax)) == null)
            return;
          v1 = Curve.getPart(v1, tMinClip, tMaxClip);
          var tDiff = tMaxClip - tMinClip,
              tMinNew = tMin + (tMax - tMin) * tMinClip,
              tMaxNew = tMin + (tMax - tMin) * tMaxClip;
          if (oldTDiff > 0.5 && tDiff > 0.5) {
            if (tMaxNew - tMinNew > uMax - uMin) {
              var parts = Curve.subdivide(v1, 0.5),
                  t = tMinNew + (tMaxNew - tMinNew) / 2;
              addCurveIntersections(v2, parts[0], c2, c1, locations, param, uMin, uMax, tMinNew, t, tDiff, !reverse, recursion);
              addCurveIntersections(v2, parts[1], c2, c1, locations, param, uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
            } else {
              var parts = Curve.subdivide(v2, 0.5),
                  t = uMin + (uMax - uMin) / 2;
              addCurveIntersections(parts[0], v1, c2, c1, locations, param, uMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);
              addCurveIntersections(parts[1], v1, c2, c1, locations, param, t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
            }
          } else if (Math.max(uMax - uMin, tMaxNew - tMinNew) < 1e-7) {
            var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
                t2 = uMin + (uMax - uMin) / 2;
            v1 = c1.getValues();
            v2 = c2.getValues();
            addLocation(locations, param, reverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null, reverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);
          } else if (tDiff > 1e-12) {
            addCurveIntersections(v2, v1, c2, c1, locations, param, uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
          }
        }
        function getConvexHull(dq0, dq1, dq2, dq3) {
          var p0 = [0, dq0],
              p1 = [1 / 3, dq1],
              p2 = [2 / 3, dq2],
              p3 = [1, dq3],
              dist1 = dq1 - (2 * dq0 + dq3) / 3,
              dist2 = dq2 - (dq0 + 2 * dq3) / 3,
              hull;
          if (dist1 * dist2 < 0) {
            hull = [[p0, p1, p3], [p0, p2, p3]];
          } else {
            var distRatio = dist1 / dist2;
            hull = [distRatio >= 2 ? [p0, p1, p3] : distRatio <= .5 ? [p0, p2, p3] : [p0, p1, p2, p3], [p0, p3]];
          }
          return (dist1 || dist2) < 0 ? hull.reverse() : hull;
        }
        function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
          if (hullTop[0][1] < dMin) {
            return clipConvexHullPart(hullTop, true, dMin);
          } else if (hullBottom[0][1] > dMax) {
            return clipConvexHullPart(hullBottom, false, dMax);
          } else {
            return hullTop[0][0];
          }
        }
        function clipConvexHullPart(part, top, threshold) {
          var px = part[0][0],
              py = part[0][1];
          for (var i = 1,
              l = part.length; i < l; i++) {
            var qx = part[i][0],
                qy = part[i][1];
            if (top ? qy >= threshold : qy <= threshold) {
              return qy === threshold ? qx : px + (threshold - py) * (qx - px) / (qy - py);
            }
            px = qx;
            py = qy;
          }
          return null;
        }
        function addCurveLineIntersections(v1, v2, c1, c2, locations, param) {
          var flip = Curve.isStraight(v1),
              vc = flip ? v2 : v1,
              vl = flip ? v1 : v2,
              lx1 = vl[0],
              ly1 = vl[1],
              lx2 = vl[6],
              ly2 = vl[7],
              ldx = lx2 - lx1,
              ldy = ly2 - ly1,
              angle = Math.atan2(-ldy, ldx),
              sin = Math.sin(angle),
              cos = Math.cos(angle),
              rvc = [];
          for (var i = 0; i < 8; i += 2) {
            var x = vc[i] - lx1,
                y = vc[i + 1] - ly1;
            rvc.push(x * cos - y * sin, x * sin + y * cos);
          }
          var roots = [],
              count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
          for (var i = 0; i < count; i++) {
            var tc = roots[i],
                pc = Curve.getPoint(vc, tc),
                tl = Curve.getParameterOf(vl, pc);
            if (tl !== null) {
              var pl = Curve.getPoint(vl, tl),
                  t1 = flip ? tl : tc,
                  t2 = flip ? tc : tl;
              if (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {
                addLocation(locations, param, v1, c1, t1, flip ? pl : pc, v2, c2, t2, flip ? pc : pl);
              }
            }
          }
        }
        function addLineIntersection(v1, v2, c1, c2, locations, param) {
          var pt = Line.intersect(v1[0], v1[1], v1[6], v1[7], v2[0], v2[1], v2[6], v2[7]);
          if (pt) {
            addLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);
          }
        }
        return {statics: {
            _getIntersections: function(v1, v2, c1, c2, locations, param) {
              if (!v2) {
                return Curve._getSelfIntersection(v1, c1, locations, param);
              }
              var c1p1x = v1[0],
                  c1p1y = v1[1],
                  c1p2x = v1[6],
                  c1p2y = v1[7],
                  c2p1x = v2[0],
                  c2p1y = v2[1],
                  c2p2x = v2[6],
                  c2p2y = v2[7],
                  c1s1x = (3 * v1[2] + c1p1x) / 4,
                  c1s1y = (3 * v1[3] + c1p1y) / 4,
                  c1s2x = (3 * v1[4] + c1p2x) / 4,
                  c1s2y = (3 * v1[5] + c1p2y) / 4,
                  c2s1x = (3 * v2[2] + c2p1x) / 4,
                  c2s1y = (3 * v2[3] + c2p1y) / 4,
                  c2s2x = (3 * v2[4] + c2p2x) / 4,
                  c2s2y = (3 * v2[5] + c2p2y) / 4,
                  min = Math.min,
                  max = Math.max;
              if (!(max(c1p1x, c1s1x, c1s2x, c1p2x) >= min(c2p1x, c2s1x, c2s2x, c2p2x) && min(c1p1x, c1s1x, c1s2x, c1p2x) <= max(c2p1x, c2s1x, c2s2x, c2p2x) && max(c1p1y, c1s1y, c1s2y, c1p2y) >= min(c2p1y, c2s1y, c2s2y, c2p2y) && min(c1p1y, c1s1y, c1s2y, c1p2y) <= max(c2p1y, c2s1y, c2s2y, c2p2y)))
                return locations;
              if (!param.startConnected && !param.endConnected) {
                var overlaps = Curve.getOverlaps(v1, v2);
                if (overlaps) {
                  for (var i = 0; i < 2; i++) {
                    var overlap = overlaps[i];
                    addLocation(locations, param, v1, c1, overlap[0], null, v2, c2, overlap[1], null, true);
                  }
                  return locations;
                }
              }
              var straight1 = Curve.isStraight(v1),
                  straight2 = Curve.isStraight(v2),
                  straight = straight1 && straight2,
                  epsilon = 1e-12,
                  before = locations.length;
              (straight ? addLineIntersection : straight1 || straight2 ? addCurveLineIntersections : addCurveIntersections)(v1, v2, c1, c2, locations, param, 0, 1, 0, 1, 0, false, 0);
              if (straight && locations.length > before)
                return locations;
              var c1p1 = new Point(c1p1x, c1p1y),
                  c1p2 = new Point(c1p2x, c1p2y),
                  c2p1 = new Point(c2p1x, c2p1y),
                  c2p2 = new Point(c2p2x, c2p2y);
              if (c1p1.isClose(c2p1, epsilon))
                addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);
              if (!param.startConnected && c1p1.isClose(c2p2, epsilon))
                addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);
              if (!param.endConnected && c1p2.isClose(c2p1, epsilon))
                addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);
              if (c1p2.isClose(c2p2, epsilon))
                addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);
              return locations;
            },
            _getSelfIntersection: function(v1, c1, locations, param) {
              var p1x = v1[0],
                  p1y = v1[1],
                  h1x = v1[2],
                  h1y = v1[3],
                  h2x = v1[4],
                  h2y = v1[5],
                  p2x = v1[6],
                  p2y = v1[7];
              var line = new Line(p1x, p1y, p2x, p2y, false),
                  side1 = line.getSide(new Point(h1x, h1y), true),
                  side2 = line.getSide(new Point(h2x, h2y), true);
              if (side1 === side2) {
                var edgeSum = (p1x - h2x) * (h1y - p2y) + (h1x - p2x) * (h2y - p1y);
                if (edgeSum * side1 > 0)
                  return locations;
              }
              var ax = p2x - 3 * h2x + 3 * h1x - p1x,
                  bx = h2x - 2 * h1x + p1x,
                  cx = h1x - p1x,
                  ay = p2y - 3 * h2y + 3 * h1y - p1y,
                  by = h2y - 2 * h1y + p1y,
                  cy = h1y - p1y,
                  ac = ay * cx - ax * cy,
                  ab = ay * bx - ax * by,
                  bc = by * cx - bx * cy;
              if (ac * ac - 4 * ab * bc < 0) {
                var roots = [],
                    tSplit,
                    count = Numerical.solveCubic(ax * ax + ay * ay, 3 * (ax * bx + ay * by), 2 * (bx * bx + by * by) + ax * cx + ay * cy, bx * cx + by * cy, roots, 0, 1);
                if (count > 0) {
                  for (var i = 0,
                      maxCurvature = 0; i < count; i++) {
                    var curvature = Math.abs(c1.getCurvatureAt(roots[i], true));
                    if (curvature > maxCurvature) {
                      maxCurvature = curvature;
                      tSplit = roots[i];
                    }
                  }
                  var parts = Curve.subdivide(v1, tSplit);
                  param.endConnected = true;
                  param.renormalize = function(t1, t2) {
                    return [t1 * tSplit, t2 * (1 - tSplit) + tSplit];
                  };
                  Curve._getIntersections(parts[0], parts[1], c1, c1, locations, param);
                }
              }
              return locations;
            },
            getOverlaps: function(v1, v2) {
              var abs = Math.abs,
                  timeEpsilon = 4e-7,
                  geomEpsilon = 2e-7,
                  straight1 = Curve.isStraight(v1),
                  straight2 = Curve.isStraight(v2),
                  straight = straight1 && straight2;
              function getLineLengthSquared(v) {
                var x = v[6] - v[0],
                    y = v[7] - v[1];
                return x * x + y * y;
              }
              if (straight) {
                var flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),
                    l1 = flip ? v2 : v1,
                    l2 = flip ? v1 : v2,
                    line = new Line(l1[0], l1[1], l1[6], l1[7]);
                if (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon || line.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)
                  return null;
              } else if (straight1 ^ straight2) {
                return null;
              }
              var v = [v1, v2],
                  pairs = [];
              for (var i = 0,
                  t1 = 0; i < 2 && pairs.length < 2; i += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {
                var t2 = Curve.getParameterOf(v[i ^ 1], new Point(v[i][t1 === 0 ? 0 : 6], v[i][t1 === 0 ? 1 : 7]));
                if (t2 != null) {
                  var pair = i === 0 ? [t1, t2] : [t2, t1];
                  if (pairs.length === 0 || abs(pair[0] - pairs[0][0]) > timeEpsilon && abs(pair[1] - pairs[0][1]) > timeEpsilon)
                    pairs.push(pair);
                }
                if (i === 1 && pairs.length === 0)
                  break;
              }
              if (pairs.length !== 2) {
                pairs = null;
              } else if (!straight) {
                var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
                    o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
                if (abs(o2[2] - o1[2]) > geomEpsilon || abs(o2[3] - o1[3]) > geomEpsilon || abs(o2[4] - o1[4]) > geomEpsilon || abs(o2[5] - o1[5]) > geomEpsilon)
                  pairs = null;
              }
              return pairs;
            }
          }};
      });
      var CurveLocation = Base.extend({
        _class: 'CurveLocation',
        beans: true,
        initialize: function CurveLocation(curve, parameter, point, _overlap, _distance) {
          if (parameter > 0.9999996) {
            var next = curve.getNext();
            if (next) {
              parameter = 0;
              curve = next;
            }
          }
          this._id = UID.get(CurveLocation);
          this._setCurve(curve);
          this._parameter = parameter;
          this._point = point || curve.getPointAt(parameter, true);
          this._overlap = _overlap;
          this._distance = _distance;
          this._intersection = this._next = this._prev = null;
        },
        _setCurve: function(curve) {
          var path = curve._path;
          this._version = path ? path._version : 0;
          this._curve = curve;
          this._segment = null;
          this._segment1 = curve._segment1;
          this._segment2 = curve._segment2;
        },
        _setSegment: function(segment) {
          this._setCurve(segment.getCurve());
          this._segment = segment;
          this._parameter = segment === this._segment1 ? 0 : 1;
          this._point = segment._point.clone();
        },
        getSegment: function() {
          var curve = this.getCurve(),
              segment = this._segment;
          if (!segment) {
            var parameter = this.getParameter();
            if (parameter === 0) {
              segment = curve._segment1;
            } else if (parameter === 1) {
              segment = curve._segment2;
            } else if (parameter != null) {
              segment = curve.getPartLength(0, parameter) < curve.getPartLength(parameter, 1) ? curve._segment1 : curve._segment2;
            }
            this._segment = segment;
          }
          return segment;
        },
        getCurve: function() {
          var curve = this._curve,
              path = curve && curve._path,
              that = this;
          if (path && path._version !== this._version) {
            curve = this._parameter = this._curve = this._offset = null;
          }
          function trySegment(segment) {
            var curve = segment && segment.getCurve();
            if (curve && (that._parameter = curve.getParameterOf(that._point)) != null) {
              that._setCurve(curve);
              that._segment = segment;
              return curve;
            }
          }
          return curve || trySegment(this._segment) || trySegment(this._segment1) || trySegment(this._segment2.getPrevious());
        },
        getPath: function() {
          var curve = this.getCurve();
          return curve && curve._path;
        },
        getIndex: function() {
          var curve = this.getCurve();
          return curve && curve.getIndex();
        },
        getParameter: function() {
          var curve = this.getCurve(),
              parameter = this._parameter;
          return curve && parameter == null ? this._parameter = curve.getParameterOf(this._point) : parameter;
        },
        getPoint: function() {
          return this._point;
        },
        getOffset: function() {
          var offset = this._offset;
          if (offset == null) {
            offset = 0;
            var path = this.getPath(),
                index = this.getIndex();
            if (path && index != null) {
              var curves = path.getCurves();
              for (var i = 0; i < index; i++)
                offset += curves[i].getLength();
            }
            this._offset = offset += this.getCurveOffset();
          }
          return offset;
        },
        getCurveOffset: function() {
          var curve = this.getCurve(),
              parameter = this.getParameter();
          return parameter != null && curve && curve.getPartLength(0, parameter);
        },
        getIntersection: function() {
          return this._intersection;
        },
        getDistance: function() {
          return this._distance;
        },
        divide: function() {
          var curve = this.getCurve(),
              res = null;
          if (curve) {
            res = curve.divide(this.getParameter(), true);
            if (res)
              this._setSegment(res._segment1);
          }
          return res;
        },
        split: function() {
          var curve = this.getCurve();
          return curve ? curve.split(this.getParameter(), true) : null;
        },
        equals: function(loc, _ignoreOther) {
          var res = this === loc,
              epsilon = 2e-7;
          if (!res && loc instanceof CurveLocation && this.getPath() === loc.getPath() && this.getPoint().isClose(loc.getPoint(), epsilon)) {
            var c1 = this.getCurve(),
                c2 = loc.getCurve(),
                abs = Math.abs,
                diff = abs(((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex()) + this.getParameter()) - ((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex()) + loc.getParameter()));
            res = (diff < 4e-7 || ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon || abs(this.getPath().getLength() - diff) < epsilon)) && (_ignoreOther || (!this._intersection && !loc._intersection || this._intersection && this._intersection.equals(loc._intersection, true)));
          }
          return res;
        },
        toString: function() {
          var parts = [],
              point = this.getPoint(),
              f = Formatter.instance;
          if (point)
            parts.push('point: ' + point);
          var index = this.getIndex();
          if (index != null)
            parts.push('index: ' + index);
          var parameter = this.getParameter();
          if (parameter != null)
            parts.push('parameter: ' + f.number(parameter));
          if (this._distance != null)
            parts.push('distance: ' + f.number(this._distance));
          return '{ ' + parts.join(', ') + ' }';
        },
        isTouching: function() {
          var inter = this._intersection;
          if (inter && this.getTangent().isCollinear(inter.getTangent())) {
            var curve1 = this.getCurve(),
                curve2 = inter.getCurve();
            return !(curve1.isStraight() && curve2.isStraight() && curve1.getLine().intersect(curve2.getLine()));
          }
          return false;
        },
        isCrossing: function() {
          var inter = this._intersection;
          if (!inter)
            return false;
          var t1 = this.getParameter(),
              t2 = inter.getParameter(),
              tMin = 4e-7,
              tMax = 1 - tMin;
          if (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)
            return !this.isTouching();
          var c2 = this.getCurve(),
              c1 = c2.getPrevious(),
              c4 = inter.getCurve(),
              c3 = c4.getPrevious(),
              PI = Math.PI;
          if (!c1 || !c3)
            return false;
          function isInRange(angle, min, max) {
            return min < max ? angle > min && angle < max : angle > min && angle <= PI || angle >= -PI && angle < max;
          }
          var a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),
              a2 = c2.getTangentAt(tMin, true).getAngleInRadians(),
              a3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),
              a4 = c4.getTangentAt(tMin, true).getAngleInRadians();
          return (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2)) && (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
        },
        isOverlap: function() {
          return !!this._overlap;
        }
      }, Base.each(Curve.evaluateMethods, function(name) {
        var get = name + 'At';
        this[name] = function() {
          var parameter = this.getParameter(),
              curve = this.getCurve();
          return parameter != null && curve && curve[get](parameter, true);
        };
      }, {preserve: true}), new function() {
        function insert(locations, loc, merge) {
          var length = locations.length,
              l = 0,
              r = length - 1;
          function search(index, dir) {
            for (var i = index + dir; i >= -1 && i <= length; i += dir) {
              var loc2 = locations[((i % length) + length) % length];
              if (!loc.getPoint().isClose(loc2.getPoint(), 2e-7))
                break;
              if (loc.equals(loc2))
                return loc2;
            }
            return null;
          }
          while (l <= r) {
            var m = (l + r) >>> 1,
                loc2 = locations[m],
                found;
            if (merge && (found = loc.equals(loc2) ? loc2 : (search(m, -1) || search(m, 1)))) {
              if (loc._overlap) {
                found._overlap = found._intersection._overlap = true;
              }
              return found;
            }
            var path1 = loc.getPath(),
                path2 = loc2.getPath(),
                diff = path1 === path2 ? (loc.getIndex() + loc.getParameter()) - (loc2.getIndex() + loc2.getParameter()) : path1._id - path2._id;
            if (diff < 0) {
              r = m - 1;
            } else {
              l = m + 1;
            }
          }
          locations.splice(l, 0, loc);
          return loc;
        }
        return {statics: {
            insert: insert,
            expand: function(locations) {
              var expanded = locations.slice();
              for (var i = 0,
                  l = locations.length; i < l; i++) {
                insert(expanded, locations[i]._intersection, false);
              }
              return expanded;
            }
          }};
      });
      var PathItem = Item.extend({
        _class: 'PathItem',
        initialize: function PathItem() {},
        getIntersections: function(path, include, _matrix, _returnFirst) {
          var self = this === path || !path,
              matrix1 = this._matrix.orNullIfIdentity(),
              matrix2 = self ? matrix1 : (_matrix || path._matrix).orNullIfIdentity();
          if (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
            return [];
          var curves1 = this.getCurves(),
              curves2 = self ? curves1 : path.getCurves(),
              length1 = curves1.length,
              length2 = self ? length1 : curves2.length,
              values2 = [],
              arrays = [],
              locations,
              path;
          for (var i = 0; i < length2; i++)
            values2[i] = curves2[i].getValues(matrix2);
          for (var i = 0; i < length1; i++) {
            var curve1 = curves1[i],
                values1 = self ? values2[i] : curve1.getValues(matrix1),
                path1 = curve1.getPath();
            if (path1 !== path) {
              path = path1;
              locations = [];
              arrays.push(locations);
            }
            if (self) {
              Curve._getSelfIntersection(values1, curve1, locations, {
                include: include,
                startConnected: length1 === 1 && curve1.getPoint1().equals(curve1.getPoint2())
              });
            }
            for (var j = self ? i + 1 : 0; j < length2; j++) {
              if (_returnFirst && locations.length)
                return locations;
              var curve2 = curves2[j];
              Curve._getIntersections(values1, values2[j], curve1, curve2, locations, {
                include: include,
                startConnected: self && curve1.getPrevious() === curve2,
                endConnected: self && curve1.getNext() === curve2
              });
            }
          }
          locations = [];
          for (var i = 0,
              l = arrays.length; i < l; i++) {
            locations.push.apply(locations, arrays[i]);
          }
          return locations;
        },
        getCrossings: function(path) {
          return this.getIntersections(path, function(inter) {
            return inter.isCrossing();
          });
        },
        _asPathItem: function() {
          return this;
        },
        setPathData: function(data) {
          var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
              coords,
              relative = false,
              previous,
              control,
              current = new Point(),
              start = new Point();
          function getCoord(index, coord) {
            var val = +coords[index];
            if (relative)
              val += current[coord];
            return val;
          }
          function getPoint(index) {
            return new Point(getCoord(index, 'x'), getCoord(index + 1, 'y'));
          }
          this.clear();
          for (var i = 0,
              l = parts && parts.length; i < l; i++) {
            var part = parts[i],
                command = part[0],
                lower = command.toLowerCase();
            coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
            var length = coords && coords.length;
            relative = command === lower;
            if (previous === 'z' && !/[mz]/.test(lower))
              this.moveTo(current = start);
            switch (lower) {
              case 'm':
              case 'l':
                var move = lower === 'm';
                for (var j = 0; j < length; j += 2)
                  this[j === 0 && move ? 'moveTo' : 'lineTo'](current = getPoint(j));
                control = current;
                if (move)
                  start = current;
                break;
              case 'h':
              case 'v':
                var coord = lower === 'h' ? 'x' : 'y';
                for (var j = 0; j < length; j++) {
                  current[coord] = getCoord(j, coord);
                  this.lineTo(current);
                }
                control = current;
                break;
              case 'c':
                for (var j = 0; j < length; j += 6) {
                  this.cubicCurveTo(getPoint(j), control = getPoint(j + 2), current = getPoint(j + 4));
                }
                break;
              case 's':
                for (var j = 0; j < length; j += 4) {
                  this.cubicCurveTo(/[cs]/.test(previous) ? current.multiply(2).subtract(control) : current, control = getPoint(j), current = getPoint(j + 2));
                  previous = lower;
                }
                break;
              case 'q':
                for (var j = 0; j < length; j += 4) {
                  this.quadraticCurveTo(control = getPoint(j), current = getPoint(j + 2));
                }
                break;
              case 't':
                for (var j = 0; j < length; j += 2) {
                  this.quadraticCurveTo(control = (/[qt]/.test(previous) ? current.multiply(2).subtract(control) : current), current = getPoint(j));
                  previous = lower;
                }
                break;
              case 'a':
                for (var j = 0; j < length; j += 7) {
                  this.arcTo(current = getPoint(j + 5), new Size(+coords[j], +coords[j + 1]), +coords[j + 2], +coords[j + 4], +coords[j + 3]);
                }
                break;
              case 'z':
                this.closePath(true);
                break;
            }
            previous = lower;
          }
        },
        _canComposite: function() {
          return !(this.hasFill() && this.hasStroke());
        },
        _contains: function(point) {
          var winding = this._getWinding(point, false, true);
          return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
        }
      });
      var Path = PathItem.extend({
        _class: 'Path',
        _serializeFields: {
          segments: [],
          closed: false
        },
        initialize: function Path(arg) {
          this._closed = false;
          this._segments = [];
          this._version = 0;
          var segments = Array.isArray(arg) ? typeof arg[0] === 'object' ? arg : arguments : arg && (arg.size === undefined && (arg.x !== undefined || arg.point !== undefined)) ? arguments : null;
          if (segments && segments.length > 0) {
            this.setSegments(segments);
          } else {
            this._curves = undefined;
            this._selectedSegmentState = 0;
            if (!segments && typeof arg === 'string') {
              this.setPathData(arg);
              arg = null;
            }
          }
          this._initialize(!segments && arg);
        },
        _equals: function(item) {
          return this._closed === item._closed && Base.equals(this._segments, item._segments);
        },
        clone: function(insert) {
          var copy = new Path(Item.NO_INSERT);
          copy.setSegments(this._segments);
          copy._closed = this._closed;
          if (this._clockwise !== undefined)
            copy._clockwise = this._clockwise;
          return this._clone(copy, insert);
        },
        _changed: function _changed(flags) {
          _changed.base.call(this, flags);
          if (flags & 8) {
            var parent = this._parent;
            if (parent)
              parent._currentPath = undefined;
            this._length = this._area = this._clockwise = this._monoCurves = undefined;
            if (flags & 16) {
              this._version++;
            } else if (this._curves) {
              for (var i = 0,
                  l = this._curves.length; i < l; i++)
                this._curves[i]._changed();
            }
          } else if (flags & 32) {
            this._bounds = undefined;
          }
        },
        getStyle: function() {
          var parent = this._parent;
          return (parent instanceof CompoundPath ? parent : this)._style;
        },
        getSegments: function() {
          return this._segments;
        },
        setSegments: function(segments) {
          var fullySelected = this.isFullySelected();
          this._segments.length = 0;
          this._selectedSegmentState = 0;
          this._curves = undefined;
          if (segments && segments.length > 0)
            this._add(Segment.readAll(segments));
          if (fullySelected)
            this.setFullySelected(true);
        },
        getFirstSegment: function() {
          return this._segments[0];
        },
        getLastSegment: function() {
          return this._segments[this._segments.length - 1];
        },
        getCurves: function() {
          var curves = this._curves,
              segments = this._segments;
          if (!curves) {
            var length = this._countCurves();
            curves = this._curves = new Array(length);
            for (var i = 0; i < length; i++)
              curves[i] = new Curve(this, segments[i], segments[i + 1] || segments[0]);
          }
          return curves;
        },
        getFirstCurve: function() {
          return this.getCurves()[0];
        },
        getLastCurve: function() {
          var curves = this.getCurves();
          return curves[curves.length - 1];
        },
        isClosed: function() {
          return this._closed;
        },
        setClosed: function(closed) {
          if (this._closed != (closed = !!closed)) {
            this._closed = closed;
            if (this._curves) {
              var length = this._curves.length = this._countCurves();
              if (closed)
                this._curves[length - 1] = new Curve(this, this._segments[length - 1], this._segments[0]);
            }
            this._changed(25);
          }
        }
      }, {
        beans: true,
        getPathData: function(_matrix, _precision) {
          var segments = this._segments,
              length = segments.length,
              f = new Formatter(_precision),
              coords = new Array(6),
              first = true,
              curX,
              curY,
              prevX,
              prevY,
              inX,
              inY,
              outX,
              outY,
              parts = [];
          function addSegment(segment, skipLine) {
            segment._transformCoordinates(_matrix, coords, false);
            curX = coords[0];
            curY = coords[1];
            if (first) {
              parts.push('M' + f.pair(curX, curY));
              first = false;
            } else {
              inX = coords[2];
              inY = coords[3];
              if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                if (!skipLine)
                  parts.push('l' + f.pair(curX - prevX, curY - prevY));
              } else {
                parts.push('c' + f.pair(outX - prevX, outY - prevY) + ' ' + f.pair(inX - prevX, inY - prevY) + ' ' + f.pair(curX - prevX, curY - prevY));
              }
            }
            prevX = curX;
            prevY = curY;
            outX = coords[4];
            outY = coords[5];
          }
          if (length === 0)
            return '';
          for (var i = 0; i < length; i++)
            addSegment(segments[i]);
          if (this._closed && length > 0) {
            addSegment(segments[0], true);
            parts.push('z');
          }
          return parts.join('');
        }
      }, {
        isEmpty: function() {
          return this._segments.length === 0;
        },
        _transformContent: function(matrix) {
          var coords = new Array(6);
          for (var i = 0,
              l = this._segments.length; i < l; i++)
            this._segments[i]._transformCoordinates(matrix, coords, true);
          return true;
        },
        _add: function(segs, index) {
          var segments = this._segments,
              curves = this._curves,
              amount = segs.length,
              append = index == null,
              index = append ? segments.length : index;
          for (var i = 0; i < amount; i++) {
            var segment = segs[i];
            if (segment._path)
              segment = segs[i] = segment.clone();
            segment._path = this;
            segment._index = index + i;
            if (segment._selectionState)
              this._updateSelection(segment, 0, segment._selectionState);
          }
          if (append) {
            segments.push.apply(segments, segs);
          } else {
            segments.splice.apply(segments, [index, 0].concat(segs));
            for (var i = index + amount,
                l = segments.length; i < l; i++)
              segments[i]._index = i;
          }
          if (curves) {
            var total = this._countCurves(),
                from = index + amount - 1 === total ? index - 1 : index,
                start = from,
                to = Math.min(from + amount, total);
            if (segs._curves) {
              curves.splice.apply(curves, [from, 0].concat(segs._curves));
              start += segs._curves.length;
            }
            for (var i = start; i < to; i++)
              curves.splice(i, 0, new Curve(this, null, null));
            this._adjustCurves(from, to);
          }
          this._changed(25);
          return segs;
        },
        _adjustCurves: function(from, to) {
          var segments = this._segments,
              curves = this._curves,
              curve;
          for (var i = from; i < to; i++) {
            curve = curves[i];
            curve._path = this;
            curve._segment1 = segments[i];
            curve._segment2 = segments[i + 1] || segments[0];
            curve._changed();
          }
          if (curve = curves[this._closed && from === 0 ? segments.length - 1 : from - 1]) {
            curve._segment2 = segments[from] || segments[0];
            curve._changed();
          }
          if (curve = curves[to]) {
            curve._segment1 = segments[to];
            curve._changed();
          }
        },
        _countCurves: function() {
          var length = this._segments.length;
          return !this._closed && length > 0 ? length - 1 : length;
        },
        add: function(segment1) {
          return arguments.length > 1 && typeof segment1 !== 'number' ? this._add(Segment.readAll(arguments)) : this._add([Segment.read(arguments)])[0];
        },
        insert: function(index, segment1) {
          return arguments.length > 2 && typeof segment1 !== 'number' ? this._add(Segment.readAll(arguments, 1), index) : this._add([Segment.read(arguments, 1)], index)[0];
        },
        addSegment: function() {
          return this._add([Segment.read(arguments)])[0];
        },
        insertSegment: function(index) {
          return this._add([Segment.read(arguments, 1)], index)[0];
        },
        addSegments: function(segments) {
          return this._add(Segment.readAll(segments));
        },
        insertSegments: function(index, segments) {
          return this._add(Segment.readAll(segments), index);
        },
        removeSegment: function(index) {
          return this.removeSegments(index, index + 1)[0] || null;
        },
        removeSegments: function(from, to, _includeCurves) {
          from = from || 0;
          to = Base.pick(to, this._segments.length);
          var segments = this._segments,
              curves = this._curves,
              count = segments.length,
              removed = segments.splice(from, to - from),
              amount = removed.length;
          if (!amount)
            return removed;
          for (var i = 0; i < amount; i++) {
            var segment = removed[i];
            if (segment._selectionState)
              this._updateSelection(segment, segment._selectionState, 0);
            segment._index = segment._path = null;
          }
          for (var i = from,
              l = segments.length; i < l; i++)
            segments[i]._index = i;
          if (curves) {
            var index = from > 0 && to === count + (this._closed ? 1 : 0) ? from - 1 : from,
                curves = curves.splice(index, amount);
            if (_includeCurves)
              removed._curves = curves.slice(1);
            this._adjustCurves(index, index);
          }
          this._changed(25);
          return removed;
        },
        clear: '#removeSegments',
        hasHandles: function() {
          var segments = this._segments;
          for (var i = 0,
              l = segments.length; i < l; i++) {
            if (segments[i].hasHandles())
              return true;
          }
          return false;
        },
        clearHandles: function() {
          var segments = this._segments;
          for (var i = 0,
              l = segments.length; i < l; i++)
            segments[i].clearHandles();
        },
        getLength: function() {
          if (this._length == null) {
            var curves = this.getCurves(),
                length = 0;
            for (var i = 0,
                l = curves.length; i < l; i++)
              length += curves[i].getLength();
            this._length = length;
          }
          return this._length;
        },
        getArea: function() {
          if (this._area == null) {
            var segments = this._segments,
                count = segments.length,
                last = count - 1,
                area = 0;
            for (var i = 0,
                l = this._closed ? count : last; i < l; i++) {
              area += Curve.getArea(Curve.getValues(segments[i], segments[i < last ? i + 1 : 0]));
            }
            this._area = area;
          }
          return this._area;
        },
        isClockwise: function() {
          if (this._clockwise !== undefined)
            return this._clockwise;
          return this.getArea() >= 0;
        },
        setClockwise: function(clockwise) {
          if (this.isClockwise() != (clockwise = !!clockwise))
            this.reverse();
          this._clockwise = clockwise;
        },
        isFullySelected: function() {
          var length = this._segments.length;
          return this._selected && length > 0 && this._selectedSegmentState === length * 7;
        },
        setFullySelected: function(selected) {
          if (selected)
            this._selectSegments(true);
          this.setSelected(selected);
        },
        setSelected: function setSelected(selected) {
          if (!selected)
            this._selectSegments(false);
          setSelected.base.call(this, selected);
        },
        _selectSegments: function(selected) {
          var length = this._segments.length;
          this._selectedSegmentState = selected ? length * 7 : 0;
          for (var i = 0; i < length; i++)
            this._segments[i]._selectionState = selected ? 7 : 0;
        },
        _updateSelection: function(segment, oldState, newState) {
          segment._selectionState = newState;
          var total = this._selectedSegmentState += newState - oldState;
          if (total > 0)
            this.setSelected(true);
        },
        flatten: function(maxDistance) {
          var iterator = new PathIterator(this, 64, 0.1),
              pos = 0,
              step = iterator.length / Math.ceil(iterator.length / maxDistance),
              end = iterator.length + (this._closed ? -step : step) / 2;
          var segments = [];
          while (pos <= end) {
            segments.push(new Segment(iterator.getPointAt(pos)));
            pos += step;
          }
          this.setSegments(segments);
        },
        reduce: function() {
          var curves = this.getCurves();
          for (var i = curves.length - 1; i >= 0; i--) {
            var curve = curves[i];
            if (!curve.hasHandles() && (curve.getLength() === 0 || curve.isCollinear(curve.getNext())))
              curve.remove();
          }
          return this;
        },
        simplify: function(tolerance) {
          if (this._segments.length > 2) {
            var fitter = new PathFitter(this, tolerance || 2.5);
            this.setSegments(fitter.fit());
          }
        },
        split: function(index, parameter) {
          if (parameter === null)
            return null;
          if (arguments.length === 1) {
            var arg = index;
            if (typeof arg === 'number')
              arg = this.getLocationAt(arg);
            if (!arg)
              return null;
            index = arg.index;
            parameter = arg.parameter;
          }
          var tMin = 4e-7,
              tMax = 1 - tMin;
          if (parameter >= tMax) {
            index++;
            parameter--;
          }
          var curves = this.getCurves();
          if (index >= 0 && index < curves.length) {
            if (parameter >= tMin) {
              curves[index++].divide(parameter, true);
            }
            var segs = this.removeSegments(index, this._segments.length, true),
                path;
            if (this._closed) {
              this.setClosed(false);
              path = this;
            } else {
              path = new Path(Item.NO_INSERT);
              path.insertAbove(this, true);
              this._clone(path);
            }
            path._add(segs, 0);
            this.addSegment(segs[0]);
            return path;
          }
          return null;
        },
        reverse: function() {
          this._segments.reverse();
          for (var i = 0,
              l = this._segments.length; i < l; i++) {
            var segment = this._segments[i];
            var handleIn = segment._handleIn;
            segment._handleIn = segment._handleOut;
            segment._handleOut = handleIn;
            segment._index = i;
          }
          this._curves = null;
          if (this._clockwise !== undefined)
            this._clockwise = !this._clockwise;
          this._changed(9);
        },
        join: function(path) {
          if (path) {
            var segments = path._segments,
                last1 = this.getLastSegment(),
                last2 = path.getLastSegment();
            if (!last2)
              return this;
            if (last1 && last1._point.equals(last2._point))
              path.reverse();
            var first2 = path.getFirstSegment();
            if (last1 && last1._point.equals(first2._point)) {
              last1.setHandleOut(first2._handleOut);
              this._add(segments.slice(1));
            } else {
              var first1 = this.getFirstSegment();
              if (first1 && first1._point.equals(first2._point))
                path.reverse();
              last2 = path.getLastSegment();
              if (first1 && first1._point.equals(last2._point)) {
                first1.setHandleIn(last2._handleIn);
                this._add(segments.slice(0, segments.length - 1), 0);
              } else {
                this._add(segments.slice());
              }
            }
            if (path._closed)
              this._add([segments[0]]);
            path.remove();
          }
          var first = this.getFirstSegment(),
              last = this.getLastSegment();
          if (first !== last && first._point.equals(last._point)) {
            first.setHandleIn(last._handleIn);
            last.remove();
            this.setClosed(true);
          }
          return this;
        },
        toShape: function(insert) {
          if (!this._closed)
            return null;
          var segments = this._segments,
              type,
              size,
              radius,
              topCenter;
          function isCollinear(i, j) {
            var seg1 = segments[i],
                seg2 = seg1.getNext(),
                seg3 = segments[j],
                seg4 = seg3.getNext();
            return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg3._handleOut.isZero() && seg4._handleIn.isZero() && seg2._point.subtract(seg1._point).isCollinear(seg4._point.subtract(seg3._point));
          }
          function isOrthogonal(i) {
            var seg2 = segments[i],
                seg1 = seg2.getPrevious(),
                seg3 = seg2.getNext();
            return seg1._handleOut.isZero() && seg2._handleIn.isZero() && seg2._handleOut.isZero() && seg3._handleIn.isZero() && seg2._point.subtract(seg1._point).isOrthogonal(seg3._point.subtract(seg2._point));
          }
          function isArc(i) {
            var seg1 = segments[i],
                seg2 = seg1.getNext(),
                handle1 = seg1._handleOut,
                handle2 = seg2._handleIn,
                kappa = 0.5522847498307936;
            if (handle1.isOrthogonal(handle2)) {
              var pt1 = seg1._point,
                  pt2 = seg2._point,
                  corner = new Line(pt1, handle1, true).intersect(new Line(pt2, handle2, true), true);
              return corner && Numerical.isZero(handle1.getLength() / corner.subtract(pt1).getLength() - kappa) && Numerical.isZero(handle2.getLength() / corner.subtract(pt2).getLength() - kappa);
            }
            return false;
          }
          function getDistance(i, j) {
            return segments[i]._point.getDistance(segments[j]._point);
          }
          if (!this.hasHandles() && segments.length === 4 && isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
            type = Shape.Rectangle;
            size = new Size(getDistance(0, 3), getDistance(0, 1));
            topCenter = segments[1]._point.add(segments[2]._point).divide(2);
          } else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4) && isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
            type = Shape.Rectangle;
            size = new Size(getDistance(1, 6), getDistance(0, 3));
            radius = size.subtract(new Size(getDistance(0, 7), getDistance(1, 2))).divide(2);
            topCenter = segments[3]._point.add(segments[4]._point).divide(2);
          } else if (segments.length === 4 && isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
            if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
              type = Shape.Circle;
              radius = getDistance(0, 2) / 2;
            } else {
              type = Shape.Ellipse;
              radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
            }
            topCenter = segments[1]._point;
          }
          if (type) {
            var center = this.getPosition(true),
                shape = this._clone(new type({
                  center: center,
                  size: size,
                  radius: radius,
                  insert: false
                }), insert, false);
            shape.rotate(topCenter.subtract(center).getAngle() + 90);
            return shape;
          }
          return null;
        },
        _hitTestSelf: function(point, options) {
          var that = this,
              style = this.getStyle(),
              segments = this._segments,
              numSegments = segments.length,
              closed = this._closed,
              tolerancePadding = options._tolerancePadding,
              strokePadding = tolerancePadding,
              join,
              cap,
              miterLimit,
              area,
              loc,
              res,
              hitStroke = options.stroke && style.hasStroke(),
              hitFill = options.fill && style.hasFill(),
              hitCurves = options.curves,
              radius = hitStroke ? style.getStrokeWidth() / 2 : hitFill && options.tolerance > 0 || hitCurves ? 0 : null;
          if (radius !== null) {
            if (radius > 0) {
              join = style.getStrokeJoin();
              cap = style.getStrokeCap();
              miterLimit = radius * style.getMiterLimit();
              strokePadding = tolerancePadding.add(new Point(radius, radius));
            } else {
              join = cap = 'round';
            }
          }
          function isCloseEnough(pt, padding) {
            return point.subtract(pt).divide(padding).length <= 1;
          }
          function checkSegmentPoint(seg, pt, name) {
            if (!options.selected || pt.isSelected()) {
              var anchor = seg._point;
              if (pt !== anchor)
                pt = pt.add(anchor);
              if (isCloseEnough(pt, strokePadding)) {
                return new HitResult(name, that, {
                  segment: seg,
                  point: pt
                });
              }
            }
          }
          function checkSegmentPoints(seg, ends) {
            return (ends || options.segments) && checkSegmentPoint(seg, seg._point, 'segment') || (!ends && options.handles) && (checkSegmentPoint(seg, seg._handleIn, 'handle-in') || checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
          }
          function addToArea(point) {
            area.add(point);
          }
          function checkSegmentStroke(segment) {
            if (join !== 'round' || cap !== 'round') {
              area = new Path({
                internal: true,
                closed: true
              });
              if (closed || segment._index > 0 && segment._index < numSegments - 1) {
                if (join !== 'round' && (segment._handleIn.isZero() || segment._handleOut.isZero()))
                  Path._addBevelJoin(segment, join, radius, miterLimit, addToArea, true);
              } else if (cap !== 'round') {
                Path._addSquareCap(segment, cap, radius, addToArea, true);
              }
              if (!area.isEmpty()) {
                var loc;
                return area.contains(point) || (loc = area.getNearestLocation(point)) && isCloseEnough(loc.getPoint(), tolerancePadding);
              }
            }
            return isCloseEnough(segment._point, strokePadding);
          }
          if (options.ends && !options.segments && !closed) {
            if (res = checkSegmentPoints(segments[0], true) || checkSegmentPoints(segments[numSegments - 1], true))
              return res;
          } else if (options.segments || options.handles) {
            for (var i = 0; i < numSegments; i++)
              if (res = checkSegmentPoints(segments[i]))
                return res;
          }
          if (radius !== null) {
            loc = this.getNearestLocation(point);
            if (loc) {
              var parameter = loc.getParameter();
              if (parameter === 0 || parameter === 1 && numSegments > 1) {
                if (!checkSegmentStroke(loc.getSegment()))
                  loc = null;
              } else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
                loc = null;
              }
            }
            if (!loc && join === 'miter' && numSegments > 1) {
              for (var i = 0; i < numSegments; i++) {
                var segment = segments[i];
                if (point.getDistance(segment._point) <= miterLimit && checkSegmentStroke(segment)) {
                  loc = segment.getLocation();
                  break;
                }
              }
            }
          }
          return !loc && hitFill && this._contains(point) || loc && !hitStroke && !hitCurves ? new HitResult('fill', this) : loc ? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
            location: loc,
            point: loc.getPoint()
          }) : null;
        }
      }, Base.each(Curve.evaluateMethods, function(name) {
        this[name + 'At'] = function(offset, isParameter) {
          var loc = this.getLocationAt(offset, isParameter);
          return loc && loc[name]();
        };
      }, {
        beans: false,
        getLocationOf: function() {
          var point = Point.read(arguments),
              curves = this.getCurves();
          for (var i = 0,
              l = curves.length; i < l; i++) {
            var loc = curves[i].getLocationOf(point);
            if (loc)
              return loc;
          }
          return null;
        },
        getOffsetOf: function() {
          var loc = this.getLocationOf.apply(this, arguments);
          return loc ? loc.getOffset() : null;
        },
        getLocationAt: function(offset, isParameter) {
          var curves = this.getCurves(),
              length = 0;
          if (isParameter) {
            var index = ~~offset,
                curve = curves[index];
            return curve ? curve.getLocationAt(offset - index, true) : null;
          }
          for (var i = 0,
              l = curves.length; i < l; i++) {
            var start = length,
                curve = curves[i];
            length += curve.getLength();
            if (length > offset) {
              return curve.getLocationAt(offset - start);
            }
          }
          if (curves.length > 0 && offset <= this.getLength())
            return new CurveLocation(curves[curves.length - 1], 1);
          return null;
        },
        getNearestLocation: function() {
          var point = Point.read(arguments),
              curves = this.getCurves(),
              minDist = Infinity,
              minLoc = null;
          for (var i = 0,
              l = curves.length; i < l; i++) {
            var loc = curves[i].getNearestLocation(point);
            if (loc._distance < minDist) {
              minDist = loc._distance;
              minLoc = loc;
            }
          }
          return minLoc;
        },
        getNearestPoint: function() {
          return this.getNearestLocation.apply(this, arguments).getPoint();
        }
      }), new function() {
        function drawHandles(ctx, segments, matrix, size) {
          var half = size / 2;
          function drawHandle(index) {
            var hX = coords[index],
                hY = coords[index + 1];
            if (pX != hX || pY != hY) {
              ctx.beginPath();
              ctx.moveTo(pX, pY);
              ctx.lineTo(hX, hY);
              ctx.stroke();
              ctx.beginPath();
              ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
              ctx.fill();
            }
          }
          var coords = new Array(6);
          for (var i = 0,
              l = segments.length; i < l; i++) {
            var segment = segments[i];
            segment._transformCoordinates(matrix, coords, false);
            var state = segment._selectionState,
                pX = coords[0],
                pY = coords[1];
            if (state & 1)
              drawHandle(2);
            if (state & 2)
              drawHandle(4);
            ctx.fillRect(pX - half, pY - half, size, size);
            if (!(state & 4)) {
              var fillStyle = ctx.fillStyle;
              ctx.fillStyle = '#ffffff';
              ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
              ctx.fillStyle = fillStyle;
            }
          }
        }
        function drawSegments(ctx, path, matrix) {
          var segments = path._segments,
              length = segments.length,
              coords = new Array(6),
              first = true,
              curX,
              curY,
              prevX,
              prevY,
              inX,
              inY,
              outX,
              outY;
          function drawSegment(segment) {
            if (matrix) {
              segment._transformCoordinates(matrix, coords, false);
              curX = coords[0];
              curY = coords[1];
            } else {
              var point = segment._point;
              curX = point._x;
              curY = point._y;
            }
            if (first) {
              ctx.moveTo(curX, curY);
              first = false;
            } else {
              if (matrix) {
                inX = coords[2];
                inY = coords[3];
              } else {
                var handle = segment._handleIn;
                inX = curX + handle._x;
                inY = curY + handle._y;
              }
              if (inX === curX && inY === curY && outX === prevX && outY === prevY) {
                ctx.lineTo(curX, curY);
              } else {
                ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
              }
            }
            prevX = curX;
            prevY = curY;
            if (matrix) {
              outX = coords[4];
              outY = coords[5];
            } else {
              var handle = segment._handleOut;
              outX = prevX + handle._x;
              outY = prevY + handle._y;
            }
          }
          for (var i = 0; i < length; i++)
            drawSegment(segments[i]);
          if (path._closed && length > 0)
            drawSegment(segments[0]);
        }
        return {
          _draw: function(ctx, param, strokeMatrix) {
            var dontStart = param.dontStart,
                dontPaint = param.dontFinish || param.clip,
                style = this.getStyle(),
                hasFill = style.hasFill(),
                hasStroke = style.hasStroke(),
                dashArray = style.getDashArray(),
                dashLength = !paper.support.nativeDash && hasStroke && dashArray && dashArray.length;
            if (!dontStart)
              ctx.beginPath();
            if (!dontStart && this._currentPath) {
              ctx.currentPath = this._currentPath;
            } else if (hasFill || hasStroke && !dashLength || dontPaint) {
              drawSegments(ctx, this, strokeMatrix);
              if (this._closed)
                ctx.closePath();
              if (!dontStart)
                this._currentPath = ctx.currentPath;
            }
            function getOffset(i) {
              return dashArray[((i % dashLength) + dashLength) % dashLength];
            }
            if (!dontPaint && (hasFill || hasStroke)) {
              this._setStyles(ctx);
              if (hasFill) {
                ctx.fill(style.getWindingRule());
                ctx.shadowColor = 'rgba(0,0,0,0)';
              }
              if (hasStroke) {
                if (dashLength) {
                  if (!dontStart)
                    ctx.beginPath();
                  var iterator = new PathIterator(this, 32, 0.25, strokeMatrix),
                      length = iterator.length,
                      from = -style.getDashOffset(),
                      to,
                      i = 0;
                  from = from % length;
                  while (from > 0) {
                    from -= getOffset(i--) + getOffset(i--);
                  }
                  while (from < length) {
                    to = from + getOffset(i++);
                    if (from > 0 || to > 0)
                      iterator.drawPart(ctx, Math.max(from, 0), Math.max(to, 0));
                    from = to + getOffset(i++);
                  }
                }
                ctx.stroke();
              }
            }
          },
          _drawSelected: function(ctx, matrix) {
            ctx.beginPath();
            drawSegments(ctx, this, matrix);
            ctx.stroke();
            drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
          }
        };
      }, new function() {
        function getFirstControlPoints(rhs) {
          var n = rhs.length,
              x = [],
              tmp = [],
              b = 2;
          x[0] = rhs[0] / b;
          for (var i = 1; i < n; i++) {
            tmp[i] = 1 / b;
            b = (i < n - 1 ? 4 : 2) - tmp[i];
            x[i] = (rhs[i] - x[i - 1]) / b;
          }
          for (var i = 1; i < n; i++) {
            x[n - i - 1] -= tmp[n - i] * x[n - i];
          }
          return x;
        }
        return {smooth: function() {
            var segments = this._segments,
                size = segments.length,
                closed = this._closed,
                n = size,
                overlap = 0;
            if (size <= 2)
              return;
            if (closed) {
              overlap = Math.min(size, 4);
              n += Math.min(size, overlap) * 2;
            }
            var knots = [];
            for (var i = 0; i < size; i++)
              knots[i + overlap] = segments[i]._point;
            if (closed) {
              for (var i = 0; i < overlap; i++) {
                knots[i] = segments[i + size - overlap]._point;
                knots[i + size + overlap] = segments[i]._point;
              }
            } else {
              n--;
            }
            var rhs = [];
            for (var i = 1; i < n - 1; i++)
              rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
            rhs[0] = knots[0]._x + 2 * knots[1]._x;
            rhs[n - 1] = 3 * knots[n - 1]._x;
            var x = getFirstControlPoints(rhs);
            for (var i = 1; i < n - 1; i++)
              rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
            rhs[0] = knots[0]._y + 2 * knots[1]._y;
            rhs[n - 1] = 3 * knots[n - 1]._y;
            var y = getFirstControlPoints(rhs);
            if (closed) {
              for (var i = 0,
                  j = size; i < overlap; i++, j++) {
                var f1 = i / overlap,
                    f2 = 1 - f1,
                    ie = i + overlap,
                    je = j + overlap;
                x[j] = x[i] * f1 + x[j] * f2;
                y[j] = y[i] * f1 + y[j] * f2;
                x[je] = x[ie] * f2 + x[je] * f1;
                y[je] = y[ie] * f2 + y[je] * f1;
              }
              n--;
            }
            var handleIn = null;
            for (var i = overlap; i <= n - overlap; i++) {
              var segment = segments[i - overlap];
              if (handleIn)
                segment.setHandleIn(handleIn.subtract(segment._point));
              if (i < n) {
                segment.setHandleOut(new Point(x[i], y[i]).subtract(segment._point));
                handleIn = i < n - 1 ? new Point(2 * knots[i + 1]._x - x[i + 1], 2 * knots[i + 1]._y - y[i + 1]) : new Point((knots[n]._x + x[n - 1]) / 2, (knots[n]._y + y[n - 1]) / 2);
              }
            }
            if (closed && handleIn) {
              var segment = this._segments[0];
              segment.setHandleIn(handleIn.subtract(segment._point));
            }
          }};
      }, new function() {
        function getCurrentSegment(that) {
          var segments = that._segments;
          if (segments.length === 0)
            throw new Error('Use a moveTo() command first');
          return segments[segments.length - 1];
        }
        return {
          moveTo: function() {
            var segments = this._segments;
            if (segments.length === 1)
              this.removeSegment(0);
            if (!segments.length)
              this._add([new Segment(Point.read(arguments))]);
          },
          moveBy: function() {
            throw new Error('moveBy() is unsupported on Path items.');
          },
          lineTo: function() {
            this._add([new Segment(Point.read(arguments))]);
          },
          cubicCurveTo: function() {
            var handle1 = Point.read(arguments),
                handle2 = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this);
            current.setHandleOut(handle1.subtract(current._point));
            this._add([new Segment(to, handle2.subtract(to))]);
          },
          quadraticCurveTo: function() {
            var handle = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.cubicCurveTo(handle.add(current.subtract(handle).multiply(1 / 3)), handle.add(to.subtract(handle).multiply(1 / 3)), to);
          },
          curveTo: function() {
            var through = Point.read(arguments),
                to = Point.read(arguments),
                t = Base.pick(Base.read(arguments), 0.5),
                t1 = 1 - t,
                current = getCurrentSegment(this)._point,
                handle = through.subtract(current.multiply(t1 * t1)).subtract(to.multiply(t * t)).divide(2 * t * t1);
            if (handle.isNaN())
              throw new Error('Cannot put a curve through points with parameter = ' + t);
            this.quadraticCurveTo(handle, to);
          },
          arcTo: function() {
            var current = getCurrentSegment(this),
                from = current._point,
                to = Point.read(arguments),
                through,
                peek = Base.peek(arguments),
                clockwise = Base.pick(peek, true),
                center,
                extent,
                vector,
                matrix;
            if (typeof clockwise === 'boolean') {
              var middle = from.add(to).divide(2),
                  through = middle.add(middle.subtract(from).rotate(clockwise ? -90 : 90));
            } else if (Base.remain(arguments) <= 2) {
              through = to;
              to = Point.read(arguments);
            } else {
              var radius = Size.read(arguments);
              if (radius.isZero())
                return this.lineTo(to);
              var rotation = Base.read(arguments),
                  clockwise = !!Base.read(arguments),
                  large = !!Base.read(arguments),
                  middle = from.add(to).divide(2),
                  pt = from.subtract(middle).rotate(-rotation),
                  x = pt.x,
                  y = pt.y,
                  abs = Math.abs,
                  rx = abs(radius.width),
                  ry = abs(radius.height),
                  rxSq = rx * rx,
                  rySq = ry * ry,
                  xSq = x * x,
                  ySq = y * y;
              var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
              if (factor > 1) {
                rx *= factor;
                ry *= factor;
                rxSq = rx * rx;
                rySq = ry * ry;
              }
              factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) / (rxSq * ySq + rySq * xSq);
              if (abs(factor) < 1e-12)
                factor = 0;
              if (factor < 0)
                throw new Error('Cannot create an arc with the given arguments');
              center = new Point(rx * y / ry, -ry * x / rx).multiply((large === clockwise ? -1 : 1) * Math.sqrt(factor)).rotate(rotation).add(middle);
              matrix = new Matrix().translate(center).rotate(rotation).scale(rx, ry);
              vector = matrix._inverseTransform(from);
              extent = vector.getDirectedAngle(matrix._inverseTransform(to));
              if (!clockwise && extent > 0)
                extent -= 360;
              else if (clockwise && extent < 0)
                extent += 360;
            }
            if (through) {
              var l1 = new Line(from.add(through).divide(2), through.subtract(from).rotate(90), true),
                  l2 = new Line(through.add(to).divide(2), to.subtract(through).rotate(90), true),
                  line = new Line(from, to),
                  throughSide = line.getSide(through);
              center = l1.intersect(l2, true);
              if (!center) {
                if (!throughSide)
                  return this.lineTo(to);
                throw new Error('Cannot create an arc with the given arguments');
              }
              vector = from.subtract(center);
              extent = vector.getDirectedAngle(to.subtract(center));
              var centerSide = line.getSide(center);
              if (centerSide === 0) {
                extent = throughSide * Math.abs(extent);
              } else if (throughSide === centerSide) {
                extent += extent < 0 ? 360 : -360;
              }
            }
            var ext = Math.abs(extent),
                count = ext >= 360 ? 4 : Math.ceil(ext / 90),
                inc = extent / count,
                half = inc * Math.PI / 360,
                z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
                segments = [];
            for (var i = 0; i <= count; i++) {
              var pt = to,
                  out = null;
              if (i < count) {
                out = vector.rotate(90).multiply(z);
                if (matrix) {
                  pt = matrix._transformPoint(vector);
                  out = matrix._transformPoint(vector.add(out)).subtract(pt);
                } else {
                  pt = center.add(vector);
                }
              }
              if (i === 0) {
                current.setHandleOut(out);
              } else {
                var _in = vector.rotate(-90).multiply(z);
                if (matrix) {
                  _in = matrix._transformPoint(vector.add(_in)).subtract(pt);
                }
                segments.push(new Segment(pt, _in, out));
              }
              vector = vector.rotate(inc);
            }
            this._add(segments);
          },
          lineBy: function() {
            var to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.lineTo(current.add(to));
          },
          curveBy: function() {
            var through = Point.read(arguments),
                to = Point.read(arguments),
                parameter = Base.read(arguments),
                current = getCurrentSegment(this)._point;
            this.curveTo(current.add(through), current.add(to), parameter);
          },
          cubicCurveBy: function() {
            var handle1 = Point.read(arguments),
                handle2 = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.cubicCurveTo(current.add(handle1), current.add(handle2), current.add(to));
          },
          quadraticCurveBy: function() {
            var handle = Point.read(arguments),
                to = Point.read(arguments),
                current = getCurrentSegment(this)._point;
            this.quadraticCurveTo(current.add(handle), current.add(to));
          },
          arcBy: function() {
            var current = getCurrentSegment(this)._point,
                point = current.add(Point.read(arguments)),
                clockwise = Base.pick(Base.peek(arguments), true);
            if (typeof clockwise === 'boolean') {
              this.arcTo(point, clockwise);
            } else {
              this.arcTo(point, current.add(Point.read(arguments)));
            }
          },
          closePath: function(join) {
            this.setClosed(true);
            if (join)
              this.join();
          }
        };
      }, {
        _getBounds: function(getter, matrix) {
          return Path[getter](this._segments, this._closed, this.getStyle(), matrix);
        },
        statics: {
          getBounds: function(segments, closed, style, matrix, strokePadding) {
            var first = segments[0];
            if (!first)
              return new Rectangle();
            var coords = new Array(6),
                prevCoords = first._transformCoordinates(matrix, new Array(6), false),
                min = prevCoords.slice(0, 2),
                max = min.slice(),
                roots = new Array(2);
            function processSegment(segment) {
              segment._transformCoordinates(matrix, coords, false);
              for (var i = 0; i < 2; i++) {
                Curve._addBounds(prevCoords[i], prevCoords[i + 4], coords[i + 2], coords[i], i, strokePadding ? strokePadding[i] : 0, min, max, roots);
              }
              var tmp = prevCoords;
              prevCoords = coords;
              coords = tmp;
            }
            for (var i = 1,
                l = segments.length; i < l; i++)
              processSegment(segments[i]);
            if (closed)
              processSegment(first);
            return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
          },
          getStrokeBounds: function(segments, closed, style, matrix) {
            if (!style.hasStroke())
              return Path.getBounds(segments, closed, style, matrix);
            var length = segments.length - (closed ? 0 : 1),
                radius = style.getStrokeWidth() / 2,
                padding = Path._getPenPadding(radius, matrix),
                bounds = Path.getBounds(segments, closed, style, matrix, padding),
                join = style.getStrokeJoin(),
                cap = style.getStrokeCap(),
                miterLimit = radius * style.getMiterLimit();
            var joinBounds = new Rectangle(new Size(padding).multiply(2));
            function add(point) {
              bounds = bounds.include(matrix ? matrix._transformPoint(point, point) : point);
            }
            function addRound(segment) {
              bounds = bounds.unite(joinBounds.setCenter(matrix ? matrix._transformPoint(segment._point) : segment._point));
            }
            function addJoin(segment, join) {
              var handleIn = segment._handleIn,
                  handleOut = segment._handleOut;
              if (join === 'round' || !handleIn.isZero() && !handleOut.isZero() && handleIn.isCollinear(handleOut)) {
                addRound(segment);
              } else {
                Path._addBevelJoin(segment, join, radius, miterLimit, add);
              }
            }
            function addCap(segment, cap) {
              if (cap === 'round') {
                addRound(segment);
              } else {
                Path._addSquareCap(segment, cap, radius, add);
              }
            }
            for (var i = 1; i < length; i++)
              addJoin(segments[i], join);
            if (closed) {
              addJoin(segments[0], join);
            } else if (length > 0) {
              addCap(segments[0], cap);
              addCap(segments[segments.length - 1], cap);
            }
            return bounds;
          },
          _getPenPadding: function(radius, matrix) {
            if (!matrix)
              return [radius, radius];
            var mx = matrix.shiftless(),
                hor = mx.transform(new Point(radius, 0)),
                ver = mx.transform(new Point(0, radius)),
                phi = hor.getAngleInRadians(),
                a = hor.getLength(),
                b = ver.getLength();
            var sin = Math.sin(phi),
                cos = Math.cos(phi),
                tan = Math.tan(phi),
                tx = -Math.atan(b * tan / a),
                ty = Math.atan(b / (tan * a));
            return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin), Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
          },
          _addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
            var curve2 = segment.getCurve(),
                curve1 = curve2.getPrevious(),
                point = curve2.getPointAt(0, true),
                normal1 = curve1.getNormalAt(1, true),
                normal2 = curve2.getNormalAt(0, true),
                step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
            normal1.setLength(step);
            normal2.setLength(step);
            if (area) {
              addPoint(point);
              addPoint(point.add(normal1));
            }
            if (join === 'miter') {
              var corner = new Line(point.add(normal1), new Point(-normal1.y, normal1.x), true).intersect(new Line(point.add(normal2), new Point(-normal2.y, normal2.x), true), true);
              if (corner && point.getDistance(corner) <= miterLimit) {
                addPoint(corner);
                if (!area)
                  return;
              }
            }
            if (!area)
              addPoint(point.add(normal1));
            addPoint(point.add(normal2));
          },
          _addSquareCap: function(segment, cap, radius, addPoint, area) {
            var point = segment._point,
                loc = segment.getLocation(),
                normal = loc.getNormal().multiply(radius);
            if (area) {
              addPoint(point.subtract(normal));
              addPoint(point.add(normal));
            }
            if (cap === 'square')
              point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
            addPoint(point.add(normal));
            addPoint(point.subtract(normal));
          },
          getHandleBounds: function(segments, closed, style, matrix, strokePadding, joinPadding) {
            var coords = new Array(6),
                x1 = Infinity,
                x2 = -x1,
                y1 = x1,
                y2 = x2;
            for (var i = 0,
                l = segments.length; i < l; i++) {
              var segment = segments[i];
              segment._transformCoordinates(matrix, coords, false);
              for (var j = 0; j < 6; j += 2) {
                var padding = j === 0 ? joinPadding : strokePadding,
                    paddingX = padding ? padding[0] : 0,
                    paddingY = padding ? padding[1] : 0,
                    x = coords[j],
                    y = coords[j + 1],
                    xn = x - paddingX,
                    xx = x + paddingX,
                    yn = y - paddingY,
                    yx = y + paddingY;
                if (xn < x1)
                  x1 = xn;
                if (xx > x2)
                  x2 = xx;
                if (yn < y1)
                  y1 = yn;
                if (yx > y2)
                  y2 = yx;
              }
            }
            return new Rectangle(x1, y1, x2 - x1, y2 - y1);
          },
          getRoughBounds: function(segments, closed, style, matrix) {
            var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
                joinRadius = strokeRadius;
            if (strokeRadius > 0) {
              if (style.getStrokeJoin() === 'miter')
                joinRadius = strokeRadius * style.getMiterLimit();
              if (style.getStrokeCap() === 'square')
                joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
            }
            return Path.getHandleBounds(segments, closed, style, matrix, Path._getPenPadding(strokeRadius, matrix), Path._getPenPadding(joinRadius, matrix));
          }
        }
      });
      Path.inject({statics: new function() {
          var kappa = 0.5522847498307936,
              ellipseSegments = [new Segment([-1, 0], [0, kappa], [0, -kappa]), new Segment([0, -1], [-kappa, 0], [kappa, 0]), new Segment([1, 0], [0, -kappa], [0, kappa]), new Segment([0, 1], [kappa, 0], [-kappa, 0])];
          function createPath(segments, closed, args) {
            var props = Base.getNamed(args),
                path = new Path(props && props.insert === false && Item.NO_INSERT);
            path._add(segments);
            path._closed = closed;
            return path.set(props);
          }
          function createEllipse(center, radius, args) {
            var segments = new Array(4);
            for (var i = 0; i < 4; i++) {
              var segment = ellipseSegments[i];
              segments[i] = new Segment(segment._point.multiply(radius).add(center), segment._handleIn.multiply(radius), segment._handleOut.multiply(radius));
            }
            return createPath(segments, true, args);
          }
          return {
            Line: function() {
              return createPath([new Segment(Point.readNamed(arguments, 'from')), new Segment(Point.readNamed(arguments, 'to'))], false, arguments);
            },
            Circle: function() {
              var center = Point.readNamed(arguments, 'center'),
                  radius = Base.readNamed(arguments, 'radius');
              return createEllipse(center, new Size(radius), arguments);
            },
            Rectangle: function() {
              var rect = Rectangle.readNamed(arguments, 'rectangle'),
                  radius = Size.readNamed(arguments, 'radius', 0, {readNull: true}),
                  bl = rect.getBottomLeft(true),
                  tl = rect.getTopLeft(true),
                  tr = rect.getTopRight(true),
                  br = rect.getBottomRight(true),
                  segments;
              if (!radius || radius.isZero()) {
                segments = [new Segment(bl), new Segment(tl), new Segment(tr), new Segment(br)];
              } else {
                radius = Size.min(radius, rect.getSize(true).divide(2));
                var rx = radius.width,
                    ry = radius.height,
                    hx = rx * kappa,
                    hy = ry * kappa;
                segments = [new Segment(bl.add(rx, 0), null, [-hx, 0]), new Segment(bl.subtract(0, ry), [0, hy]), new Segment(tl.add(0, ry), null, [0, -hy]), new Segment(tl.add(rx, 0), [-hx, 0], null), new Segment(tr.subtract(rx, 0), null, [hx, 0]), new Segment(tr.add(0, ry), [0, -hy], null), new Segment(br.subtract(0, ry), null, [0, hy]), new Segment(br.subtract(rx, 0), [hx, 0])];
              }
              return createPath(segments, true, arguments);
            },
            RoundRectangle: '#Rectangle',
            Ellipse: function() {
              var ellipse = Shape._readEllipse(arguments);
              return createEllipse(ellipse.center, ellipse.radius, arguments);
            },
            Oval: '#Ellipse',
            Arc: function() {
              var from = Point.readNamed(arguments, 'from'),
                  through = Point.readNamed(arguments, 'through'),
                  to = Point.readNamed(arguments, 'to'),
                  props = Base.getNamed(arguments),
                  path = new Path(props && props.insert === false && Item.NO_INSERT);
              path.moveTo(from);
              path.arcTo(through, to);
              return path.set(props);
            },
            RegularPolygon: function() {
              var center = Point.readNamed(arguments, 'center'),
                  sides = Base.readNamed(arguments, 'sides'),
                  radius = Base.readNamed(arguments, 'radius'),
                  step = 360 / sides,
                  three = !(sides % 3),
                  vector = new Point(0, three ? -radius : radius),
                  offset = three ? -1 : 0.5,
                  segments = new Array(sides);
              for (var i = 0; i < sides; i++)
                segments[i] = new Segment(center.add(vector.rotate((i + offset) * step)));
              return createPath(segments, true, arguments);
            },
            Star: function() {
              var center = Point.readNamed(arguments, 'center'),
                  points = Base.readNamed(arguments, 'points') * 2,
                  radius1 = Base.readNamed(arguments, 'radius1'),
                  radius2 = Base.readNamed(arguments, 'radius2'),
                  step = 360 / points,
                  vector = new Point(0, -1),
                  segments = new Array(points);
              for (var i = 0; i < points; i++)
                segments[i] = new Segment(center.add(vector.rotate(step * i).multiply(i % 2 ? radius2 : radius1)));
              return createPath(segments, true, arguments);
            }
          };
        }});
      var CompoundPath = PathItem.extend({
        _class: 'CompoundPath',
        _serializeFields: {children: []},
        initialize: function CompoundPath(arg) {
          this._children = [];
          this._namedChildren = {};
          if (!this._initialize(arg)) {
            if (typeof arg === 'string') {
              this.setPathData(arg);
            } else {
              this.addChildren(Array.isArray(arg) ? arg : arguments);
            }
          }
        },
        insertChildren: function insertChildren(index, items, _preserve) {
          for (var i = items.length - 1; i >= 0; i--) {
            var item = items[i];
            if (item instanceof CompoundPath) {
              items.splice.apply(items, [i, 1].concat(item.removeChildren()));
              item.remove();
            }
          }
          items = insertChildren.base.call(this, index, items, _preserve, Path);
          for (var i = 0,
              l = !_preserve && items && items.length; i < l; i++) {
            var item = items[i];
            if (item._clockwise === undefined)
              item.setClockwise(item._index === 0);
          }
          return items;
        },
        reverse: function() {
          var children = this._children;
          for (var i = 0,
              l = children.length; i < l; i++)
            children[i].reverse();
        },
        smooth: function() {
          for (var i = 0,
              l = this._children.length; i < l; i++)
            this._children[i].smooth();
        },
        reduce: function reduce() {
          var children = this._children;
          for (var i = children.length - 1; i >= 0; i--) {
            var path = children[i].reduce();
            if (path.isEmpty())
              children.splice(i, 1);
          }
          if (children.length === 0) {
            var path = new Path(Item.NO_INSERT);
            path.insertAbove(this);
            path.setStyle(this._style);
            this.remove();
            return path;
          }
          return reduce.base.call(this);
        },
        isClockwise: function() {
          var child = this.getFirstChild();
          return child && child.isClockwise();
        },
        setClockwise: function(clockwise) {
          if (this.isClockwise() !== !!clockwise)
            this.reverse();
        },
        getFirstSegment: function() {
          var first = this.getFirstChild();
          return first && first.getFirstSegment();
        },
        getLastSegment: function() {
          var last = this.getLastChild();
          return last && last.getLastSegment();
        },
        getCurves: function() {
          var children = this._children,
              curves = [];
          for (var i = 0,
              l = children.length; i < l; i++)
            curves.push.apply(curves, children[i].getCurves());
          return curves;
        },
        getFirstCurve: function() {
          var first = this.getFirstChild();
          return first && first.getFirstCurve();
        },
        getLastCurve: function() {
          var last = this.getLastChild();
          return last && last.getFirstCurve();
        },
        getArea: function() {
          var children = this._children,
              area = 0;
          for (var i = 0,
              l = children.length; i < l; i++)
            area += children[i].getArea();
          return area;
        }
      }, {
        beans: true,
        getPathData: function(_matrix, _precision) {
          var children = this._children,
              paths = [];
          for (var i = 0,
              l = children.length; i < l; i++) {
            var child = children[i],
                mx = child._matrix;
            paths.push(child.getPathData(_matrix && !mx.isIdentity() ? _matrix.chain(mx) : _matrix, _precision));
          }
          return paths.join(' ');
        }
      }, {
        _getChildHitTestOptions: function(options) {
          return options.class === Path || options.type === 'path' ? options : new Base(options, {fill: false});
        },
        _draw: function(ctx, param, strokeMatrix) {
          var children = this._children;
          if (children.length === 0)
            return;
          if (this._currentPath) {
            ctx.currentPath = this._currentPath;
          } else {
            param = param.extend({
              dontStart: true,
              dontFinish: true
            });
            ctx.beginPath();
            for (var i = 0,
                l = children.length; i < l; i++)
              children[i].draw(ctx, param, strokeMatrix);
            this._currentPath = ctx.currentPath;
          }
          if (!param.clip) {
            this._setStyles(ctx);
            var style = this._style;
            if (style.hasFill()) {
              ctx.fill(style.getWindingRule());
              ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (style.hasStroke())
              ctx.stroke();
          }
        },
        _drawSelected: function(ctx, matrix, selectedItems) {
          var children = this._children;
          for (var i = 0,
              l = children.length; i < l; i++) {
            var child = children[i],
                mx = child._matrix;
            if (!selectedItems[child._id])
              child._drawSelected(ctx, mx.isIdentity() ? matrix : matrix.chain(mx));
          }
        }
      }, new function() {
        function getCurrentPath(that, check) {
          var children = that._children;
          if (check && children.length === 0)
            throw new Error('Use a moveTo() command first');
          return children[children.length - 1];
        }
        var fields = {
          moveTo: function() {
            var current = getCurrentPath(this),
                path = current && current.isEmpty() ? current : new Path(Item.NO_INSERT);
            if (path !== current)
              this.addChild(path);
            path.moveTo.apply(path, arguments);
          },
          moveBy: function() {
            var current = getCurrentPath(this, true),
                last = current && current.getLastSegment(),
                point = Point.read(arguments);
            this.moveTo(last ? point.add(last._point) : point);
          },
          closePath: function(join) {
            getCurrentPath(this, true).closePath(join);
          }
        };
        Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo', 'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'], function(key) {
          fields[key] = function() {
            var path = getCurrentPath(this, true);
            path[key].apply(path, arguments);
          };
        });
        return fields;
      });
      PathItem.inject(new function() {
        var operators = {
          unite: function(w) {
            return w === 1 || w === 0;
          },
          intersect: function(w) {
            return w === 2;
          },
          subtract: function(w) {
            return w === 1;
          },
          exclude: function(w) {
            return w === 1;
          }
        };
        function preparePath(path, resolve) {
          var res = path.clone(false).reduce().transform(null, true, true);
          return resolve ? res.resolveCrossings().reorient() : res;
        }
        function finishBoolean(ctor, paths, path1, path2, reduce) {
          var result = new ctor(Item.NO_INSERT);
          result.addChildren(paths, true);
          if (reduce)
            result = result.reduce();
          result.insertAbove(path2 && path1.isSibling(path2) && path1.getIndex() < path2.getIndex() ? path2 : path1);
          result.setStyle(path1._style);
          return result;
        }
        function computeBoolean(path1, path2, operation) {
          if (!path1._children && !path1._closed)
            return computeOpenBoolean(path1, path2, operation);
          var _path1 = preparePath(path1, true),
              _path2 = path2 && path1 !== path2 && preparePath(path2, true);
          if (_path2 && /^(subtract|exclude)$/.test(operation) ^ (_path2.isClockwise() !== _path1.isClockwise()))
            _path2.reverse();
          var intersections = CurveLocation.expand(_path1.getIntersections(_path2, function(inter) {
            return _path2 && inter.isOverlap() || inter.isCrossing();
          }));
          divideLocations(intersections);
          var segments = [],
              monoCurves = [];
          function collect(paths) {
            for (var i = 0,
                l = paths.length; i < l; i++) {
              var path = paths[i];
              segments.push.apply(segments, path._segments);
              monoCurves.push.apply(monoCurves, path._getMonoCurves());
            }
          }
          collect(_path1._children || [_path1]);
          if (_path2)
            collect(_path2._children || [_path2]);
          for (var i = 0,
              l = intersections.length; i < l; i++) {
            propagateWinding(intersections[i]._segment, _path1, _path2, monoCurves, operation);
          }
          for (var i = 0,
              l = segments.length; i < l; i++) {
            var segment = segments[i];
            if (segment._winding == null) {
              propagateWinding(segment, _path1, _path2, monoCurves, operation);
            }
          }
          return finishBoolean(CompoundPath, tracePaths(segments, operation), path1, path2, true);
        }
        function computeOpenBoolean(path1, path2, operation) {
          if (!path2 || !path2._children && !path2._closed || !/^(subtract|intersect)$/.test(operation))
            return null;
          var _path1 = preparePath(path1, false),
              _path2 = preparePath(path2, false),
              intersections = _path1.getIntersections(_path2, function(inter) {
                return inter.isOverlap() || inter.isCrossing();
              }),
              sub = operation === 'subtract',
              paths = [];
          function addPath(path) {
            if (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {
              paths.unshift(path);
              return true;
            }
          }
          for (var i = intersections.length - 1; i >= 0; i--) {
            var path = intersections[i].split();
            if (path) {
              if (addPath(path))
                path.getFirstSegment().setHandleIn(0, 0);
              _path1.getLastSegment().setHandleOut(0, 0);
            }
          }
          addPath(_path1);
          return finishBoolean(Group, paths, path1, path2);
        }
        function linkIntersections(from, to) {
          var prev = from;
          while (prev) {
            if (prev === to)
              return;
            prev = prev._prev;
          }
          while (from._next && from._next !== to)
            from = from._next;
          if (!from._next) {
            while (to._prev)
              to = to._prev;
            from._next = to;
            to._prev = from;
          }
        }
        function divideLocations(locations) {
          var tMin = 4e-7,
              tMax = 1 - tMin,
              noHandles = false,
              clearSegments = [],
              prevCurve,
              prevT;
          for (var i = locations.length - 1; i >= 0; i--) {
            var loc = locations[i],
                curve = loc._curve,
                t = loc._parameter,
                origT = t;
            if (curve !== prevCurve) {
              noHandles = !curve.hasHandles();
            } else if (prevT > 0) {
              t /= prevT;
            }
            var segment;
            if (t < tMin) {
              segment = curve._segment1;
            } else if (t > tMax) {
              segment = curve._segment2;
            } else {
              segment = curve.divide(t, true, true)._segment1;
              if (noHandles)
                clearSegments.push(segment);
            }
            loc._setSegment(segment);
            var inter = segment._intersection,
                dest = loc._intersection;
            if (inter) {
              linkIntersections(inter, dest);
              var other = inter;
              while (other) {
                linkIntersections(other._intersection, inter);
                other = other._next;
              }
            } else {
              segment._intersection = dest;
            }
            prevCurve = curve;
            prevT = origT;
          }
          for (var i = 0,
              l = clearSegments.length; i < l; i++) {
            clearSegments[i].clearHandles();
          }
        }
        function getWinding(point, curves, horizontal, testContains) {
          var epsilon = 2e-7,
              tMin = 4e-7,
              tMax = 1 - tMin,
              px = point.x,
              py = point.y,
              windLeft = 0,
              windRight = 0,
              roots = [],
              abs = Math.abs;
          if (horizontal) {
            var yTop = -Infinity,
                yBottom = Infinity,
                yBefore = py - epsilon,
                yAfter = py + epsilon;
            for (var i = 0,
                l = curves.length; i < l; i++) {
              var values = curves[i].values;
              if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
                for (var j = roots.length - 1; j >= 0; j--) {
                  var y = Curve.getPoint(values, roots[j]).y;
                  if (y < yBefore && y > yTop) {
                    yTop = y;
                  } else if (y > yAfter && y < yBottom) {
                    yBottom = y;
                  }
                }
              }
            }
            yTop = (yTop + py) / 2;
            yBottom = (yBottom + py) / 2;
            if (yTop > -Infinity)
              windLeft = getWinding(new Point(px, yTop), curves, false, testContains);
            if (yBottom < Infinity)
              windRight = getWinding(new Point(px, yBottom), curves, false, testContains);
          } else {
            var xBefore = px - epsilon,
                xAfter = px + epsilon;
            var startCounted = false,
                prevCurve,
                prevT;
            for (var i = 0,
                l = curves.length; i < l; i++) {
              var curve = curves[i],
                  values = curve.values,
                  winding = curve.winding;
              if (winding && (winding === 1 && py >= values[1] && py <= values[7] || py >= values[7] && py <= values[1]) && Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
                var t = roots[0];
                if (!(t > tMax && startCounted && curve.next !== curves[i + 1] || t < tMin && prevT > tMax && curve.previous === prevCurve)) {
                  var x = Curve.getPoint(values, t).x,
                      slope = Curve.getTangent(values, t).y,
                      counted = false;
                  if (Numerical.isZero(slope) && !Curve.isStraight(values) || t < tMin && slope * Curve.getTangent(curve.previous.values, 1).y < 0 || t > tMax && slope * Curve.getTangent(curve.next.values, 0).y < 0) {
                    if (testContains && x >= xBefore && x <= xAfter) {
                      ++windLeft;
                      ++windRight;
                      counted = true;
                    }
                  } else if (x <= xBefore) {
                    windLeft += winding;
                    counted = true;
                  } else if (x >= xAfter) {
                    windRight += winding;
                    counted = true;
                  }
                  if (curve.previous !== curves[i - 1])
                    startCounted = t < tMin && counted;
                }
                prevCurve = curve;
                prevT = t;
              }
            }
          }
          return Math.max(abs(windLeft), abs(windRight));
        }
        function propagateWinding(segment, path1, path2, monoCurves, operation) {
          var epsilon = 2e-7,
              chain = [],
              start = segment,
              totalLength = 0,
              windingSum = 0;
          do {
            var curve = segment.getCurve(),
                length = curve.getLength();
            chain.push({
              segment: segment,
              curve: curve,
              length: length
            });
            totalLength += length;
            segment = segment.getNext();
          } while (segment && !segment._intersection && segment !== start);
          for (var i = 0; i < 3; i++) {
            var length = totalLength * (i + 1) / 4;
            for (var k = 0,
                m = chain.length; k < m; k++) {
              var node = chain[k],
                  curveLength = node.length;
              if (length <= curveLength) {
                if (length < epsilon || curveLength - length < epsilon)
                  length = curveLength / 2;
                var curve = node.curve,
                    path = curve._path,
                    parent = path._parent,
                    pt = curve.getPointAt(length),
                    hor = curve.isHorizontal();
                if (parent instanceof CompoundPath)
                  path = parent;
                windingSum += operation === 'subtract' && path2 && (path === path1 && path2._getWinding(pt, hor) || path === path2 && !path1._getWinding(pt, hor)) ? 0 : getWinding(pt, monoCurves, hor);
                break;
              }
              length -= curveLength;
            }
          }
          var winding = Math.round(windingSum / 3);
          for (var j = chain.length - 1; j >= 0; j--)
            chain[j].segment._winding = winding;
        }
        function tracePaths(segments, operation) {
          var paths = [],
              start,
              otherStart,
              operator = operators[operation],
              overlapWinding = {
                unite: {1: 2},
                intersect: {2: 1}
              }[operation];
          function isValid(seg, adjusted) {
            if (seg._visited)
              return false;
            if (!operator)
              return true;
            var winding = seg._winding,
                inter = seg._intersection;
            if (inter && adjusted && overlapWinding && inter.isOverlap())
              winding = overlapWinding[winding] || winding;
            return operator(winding);
          }
          function isStart(seg) {
            return seg === start || seg === otherStart;
          }
          function findBestIntersection(inter, strict) {
            if (!inter._next)
              return inter;
            while (inter) {
              var seg = inter._segment,
                  nextSeg = seg.getNext(),
                  nextInter = nextSeg._intersection;
              if (isStart(nextSeg) || !seg._visited && !nextSeg._visited && (!operator || (!strict || isValid(seg)) && (!(strict && nextInter && nextInter.isOverlap()) && isValid(nextSeg) || !strict && nextInter && isValid(nextInter._segment))))
                return inter;
              inter = inter._next;
            }
            return null;
          }
          function findStartSegment(inter, next) {
            while (inter) {
              var seg = inter._segment;
              if (isStart(seg))
                return seg;
              inter = inter[next ? '_next' : '_prev'];
            }
          }
          for (var i = 0,
              l = segments.length; i < l; i++) {
            var seg = segments[i],
                path = null,
                finished = false;
            if (!isValid(seg, true))
              continue;
            start = otherStart = null;
            while (!finished) {
              var inter = seg._intersection,
                  handleIn = path && seg._handleIn;
              inter = inter && (findBestIntersection(inter, true) || findBestIntersection(inter, false)) || inter;
              var other = inter && inter._segment;
              if (other && isValid(other))
                seg = other;
              if (seg._visited) {
                finished = isStart(seg);
                if (!finished && inter) {
                  var found = findStartSegment(inter, true) || findStartSegment(inter, false);
                  if (found) {
                    seg = found;
                    finished = true;
                  }
                }
                break;
              }
              if (!path) {
                path = new Path(Item.NO_INSERT);
                start = seg;
                otherStart = other;
              }
              path.add(new Segment(seg._point, handleIn, seg._handleOut));
              seg._visited = true;
              seg = seg.getNext();
              finished = isStart(seg);
            }
            if (finished) {
              path.firstSegment.setHandleIn(seg._handleIn);
              path.setClosed(true);
            } else if (path) {
              console.error('Boolean operation resulted in open path', 'segments =', path._segments.length, 'length =', path.getLength());
              path = null;
            }
            if (path && (path._segments.length > 8 || !Numerical.isZero(path.getArea()))) {
              paths.push(path);
              path = null;
            }
          }
          return paths;
        }
        return {
          _getWinding: function(point, horizontal, testContains) {
            return getWinding(point, this._getMonoCurves(), horizontal, testContains);
          },
          unite: function(path) {
            return computeBoolean(this, path, 'unite');
          },
          intersect: function(path) {
            return computeBoolean(this, path, 'intersect');
          },
          subtract: function(path) {
            return computeBoolean(this, path, 'subtract');
          },
          exclude: function(path) {
            return computeBoolean(this, path, 'exclude');
          },
          divide: function(path) {
            return finishBoolean(Group, [this.subtract(path), this.intersect(path)], this, path, true);
          },
          resolveCrossings: function() {
            var crossings = this.getCrossings();
            if (!crossings.length)
              return this;
            divideLocations(CurveLocation.expand(crossings));
            var paths = this._children || [this],
                segments = [];
            for (var i = 0,
                l = paths.length; i < l; i++) {
              segments.push.apply(segments, paths[i]._segments);
            }
            return finishBoolean(CompoundPath, tracePaths(segments), this, null, false);
          }
        };
      });
      Path.inject({
        _getMonoCurves: function() {
          var monoCurves = this._monoCurves,
              prevCurve;
          function insertCurve(v) {
            var y0 = v[1],
                y1 = v[7],
                curve = {
                  values: v,
                  winding: y0 === y1 ? 0 : y0 > y1 ? -1 : 1,
                  previous: prevCurve,
                  next: null
                };
            if (prevCurve)
              prevCurve.next = curve;
            monoCurves.push(curve);
            prevCurve = curve;
          }
          function handleCurve(v) {
            if (Curve.getLength(v) === 0)
              return;
            var y0 = v[1],
                y1 = v[3],
                y2 = v[5],
                y3 = v[7];
            if (Curve.isStraight(v)) {
              insertCurve(v);
            } else {
              var a = 3 * (y1 - y2) - y0 + y3,
                  b = 2 * (y0 + y2) - 4 * y1,
                  c = y1 - y0,
                  tMin = 4e-7,
                  tMax = 1 - tMin,
                  roots = [],
                  n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
              if (n === 0) {
                insertCurve(v);
              } else {
                roots.sort();
                var t = roots[0],
                    parts = Curve.subdivide(v, t);
                insertCurve(parts[0]);
                if (n > 1) {
                  t = (roots[1] - t) / (1 - t);
                  parts = Curve.subdivide(parts[1], t);
                  insertCurve(parts[0]);
                }
                insertCurve(parts[1]);
              }
            }
          }
          if (!monoCurves) {
            monoCurves = this._monoCurves = [];
            var curves = this.getCurves(),
                segments = this._segments;
            for (var i = 0,
                l = curves.length; i < l; i++)
              handleCurve(curves[i].getValues());
            if (!this._closed && segments.length > 1) {
              var p1 = segments[segments.length - 1]._point,
                  p2 = segments[0]._point,
                  p1x = p1._x,
                  p1y = p1._y,
                  p2x = p2._x,
                  p2y = p2._y;
              handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
            }
            if (monoCurves.length > 0) {
              var first = monoCurves[0],
                  last = monoCurves[monoCurves.length - 1];
              first.previous = last;
              last.next = first;
            }
          }
          return monoCurves;
        },
        getInteriorPoint: function() {
          var bounds = this.getBounds(),
              point = bounds.getCenter(true);
          if (!this.contains(point)) {
            var curves = this._getMonoCurves(),
                roots = [],
                y = point.y,
                xIntercepts = [];
            for (var i = 0,
                l = curves.length; i < l; i++) {
              var values = curves[i].values;
              if ((curves[i].winding === 1 && y >= values[1] && y <= values[7] || y >= values[7] && y <= values[1]) && Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
                for (var j = roots.length - 1; j >= 0; j--)
                  xIntercepts.push(Curve.getPoint(values, roots[j]).x);
              }
              if (xIntercepts.length > 1)
                break;
            }
            point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
          }
          return point;
        },
        reorient: function() {
          this.setClockwise(true);
          return this;
        }
      });
      CompoundPath.inject({
        _getMonoCurves: function() {
          var children = this._children,
              monoCurves = [];
          for (var i = 0,
              l = children.length; i < l; i++)
            monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
          return monoCurves;
        },
        reorient: function() {
          var children = this.removeChildren().sort(function(a, b) {
            return b.getBounds().getArea() - a.getBounds().getArea();
          });
          if (children.length > 0) {
            this.addChildren(children);
            var clockwise = children[0].isClockwise();
            for (var i = 1,
                l = children.length; i < l; i++) {
              var point = children[i].getInteriorPoint(),
                  counters = 0;
              for (var j = i - 1; j >= 0; j--) {
                if (children[j].contains(point))
                  counters++;
              }
              children[i].setClockwise(counters % 2 === 0 && clockwise);
            }
          }
          return this;
        }
      });
      var PathIterator = Base.extend({
        _class: 'PathIterator',
        initialize: function(path, maxRecursion, tolerance, matrix) {
          var curves = [],
              parts = [],
              length = 0,
              minDifference = 1 / (maxRecursion || 32),
              segments = path._segments,
              segment1 = segments[0],
              segment2;
          function addCurve(segment1, segment2) {
            var curve = Curve.getValues(segment1, segment2, matrix);
            curves.push(curve);
            computeParts(curve, segment1._index, 0, 1);
          }
          function computeParts(curve, index, minT, maxT) {
            if ((maxT - minT) > minDifference && !Curve.isFlatEnough(curve, tolerance || 0.25)) {
              var split = Curve.subdivide(curve, 0.5),
                  halfT = (minT + maxT) / 2;
              computeParts(split[0], index, minT, halfT);
              computeParts(split[1], index, halfT, maxT);
            } else {
              var x = curve[6] - curve[0],
                  y = curve[7] - curve[1],
                  dist = Math.sqrt(x * x + y * y);
              if (dist > 1e-6) {
                length += dist;
                parts.push({
                  offset: length,
                  value: maxT,
                  index: index
                });
              }
            }
          }
          for (var i = 1,
              l = segments.length; i < l; i++) {
            segment2 = segments[i];
            addCurve(segment1, segment2);
            segment1 = segment2;
          }
          if (path._closed)
            addCurve(segment2, segments[0]);
          this.curves = curves;
          this.parts = parts;
          this.length = length;
          this.index = 0;
        },
        getParameterAt: function(offset) {
          var i,
              j = this.index;
          for (; ; ) {
            i = j;
            if (j == 0 || this.parts[--j].offset < offset)
              break;
          }
          for (var l = this.parts.length; i < l; i++) {
            var part = this.parts[i];
            if (part.offset >= offset) {
              this.index = i;
              var prev = this.parts[i - 1];
              var prevVal = prev && prev.index == part.index ? prev.value : 0,
                  prevLen = prev ? prev.offset : 0;
              return {
                value: prevVal + (part.value - prevVal) * (offset - prevLen) / (part.offset - prevLen),
                index: part.index
              };
            }
          }
          var part = this.parts[this.parts.length - 1];
          return {
            value: 1,
            index: part.index
          };
        },
        drawPart: function(ctx, from, to) {
          from = this.getParameterAt(from);
          to = this.getParameterAt(to);
          for (var i = from.index; i <= to.index; i++) {
            var curve = Curve.getPart(this.curves[i], i == from.index ? from.value : 0, i == to.index ? to.value : 1);
            if (i == from.index)
              ctx.moveTo(curve[0], curve[1]);
            ctx.bezierCurveTo.apply(ctx, curve.slice(2));
          }
        }
      }, Base.each(Curve.evaluateMethods, function(name) {
        this[name + 'At'] = function(offset, weighted) {
          var param = this.getParameterAt(offset);
          return Curve[name](this.curves[param.index], param.value, weighted);
        };
      }, {}));
      var PathFitter = Base.extend({
        initialize: function(path, error) {
          var points = this.points = [],
              segments = path._segments,
              prev;
          for (var i = 0,
              l = segments.length; i < l; i++) {
            var point = segments[i].point.clone();
            if (!prev || !prev.equals(point)) {
              points.push(point);
              prev = point;
            }
          }
          if (path._closed) {
            this.closed = true;
            points.unshift(points[points.length - 1]);
            points.push(points[1]);
          }
          this.error = error;
        },
        fit: function() {
          var points = this.points,
              length = points.length,
              segments = this.segments = length > 0 ? [new Segment(points[0])] : [];
          if (length > 1)
            this.fitCubic(0, length - 1, points[1].subtract(points[0]).normalize(), points[length - 2].subtract(points[length - 1]).normalize());
          if (this.closed) {
            segments.shift();
            segments.pop();
          }
          return segments;
        },
        fitCubic: function(first, last, tan1, tan2) {
          if (last - first == 1) {
            var pt1 = this.points[first],
                pt2 = this.points[last],
                dist = pt1.getDistance(pt2) / 3;
            this.addCurve([pt1, pt1.add(tan1.normalize(dist)), pt2.add(tan2.normalize(dist)), pt2]);
            return;
          }
          var uPrime = this.chordLengthParameterize(first, last),
              maxError = Math.max(this.error, this.error * this.error),
              split,
              parametersInOrder = true;
          for (var i = 0; i <= 4; i++) {
            var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
            var max = this.findMaxError(first, last, curve, uPrime);
            if (max.error < this.error && parametersInOrder) {
              this.addCurve(curve);
              return;
            }
            split = max.index;
            if (max.error >= maxError)
              break;
            parametersInOrder = this.reparameterize(first, last, uPrime, curve);
            maxError = max.error;
          }
          var V1 = this.points[split - 1].subtract(this.points[split]),
              V2 = this.points[split].subtract(this.points[split + 1]),
              tanCenter = V1.add(V2).divide(2).normalize();
          this.fitCubic(first, split, tan1, tanCenter);
          this.fitCubic(split, last, tanCenter.negate(), tan2);
        },
        addCurve: function(curve) {
          var prev = this.segments[this.segments.length - 1];
          prev.setHandleOut(curve[1].subtract(curve[0]));
          this.segments.push(new Segment(curve[3], curve[2].subtract(curve[3])));
        },
        generateBezier: function(first, last, uPrime, tan1, tan2) {
          var epsilon = 1e-12,
              pt1 = this.points[first],
              pt2 = this.points[last],
              C = [[0, 0], [0, 0]],
              X = [0, 0];
          for (var i = 0,
              l = last - first + 1; i < l; i++) {
            var u = uPrime[i],
                t = 1 - u,
                b = 3 * u * t,
                b0 = t * t * t,
                b1 = b * t,
                b2 = b * u,
                b3 = u * u * u,
                a1 = tan1.normalize(b1),
                a2 = tan2.normalize(b2),
                tmp = this.points[first + i].subtract(pt1.multiply(b0 + b1)).subtract(pt2.multiply(b2 + b3));
            C[0][0] += a1.dot(a1);
            C[0][1] += a1.dot(a2);
            C[1][0] = C[0][1];
            C[1][1] += a2.dot(a2);
            X[0] += a1.dot(tmp);
            X[1] += a2.dot(tmp);
          }
          var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
              alpha1,
              alpha2;
          if (Math.abs(detC0C1) > epsilon) {
            var detC0X = C[0][0] * X[1] - C[1][0] * X[0],
                detXC1 = X[0] * C[1][1] - X[1] * C[0][1];
            alpha1 = detXC1 / detC0C1;
            alpha2 = detC0X / detC0C1;
          } else {
            var c0 = C[0][0] + C[0][1],
                c1 = C[1][0] + C[1][1];
            if (Math.abs(c0) > epsilon) {
              alpha1 = alpha2 = X[0] / c0;
            } else if (Math.abs(c1) > epsilon) {
              alpha1 = alpha2 = X[1] / c1;
            } else {
              alpha1 = alpha2 = 0;
            }
          }
          var segLength = pt2.getDistance(pt1),
              eps = epsilon * segLength,
              handle1,
              handle2;
          if (alpha1 < eps || alpha2 < eps) {
            alpha1 = alpha2 = segLength / 3;
          } else {
            var line = pt2.subtract(pt1);
            handle1 = tan1.normalize(alpha1);
            handle2 = tan2.normalize(alpha2);
            if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
              alpha1 = alpha2 = segLength / 3;
              handle1 = handle2 = null;
            }
          }
          return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)), pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
        },
        reparameterize: function(first, last, u, curve) {
          for (var i = first; i <= last; i++) {
            u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
          }
          for (var i = 1,
              l = u.length; i < l; i++) {
            if (u[i] <= u[i - 1])
              return false;
          }
          return true;
        },
        findRoot: function(curve, point, u) {
          var curve1 = [],
              curve2 = [];
          for (var i = 0; i <= 2; i++) {
            curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
          }
          for (var i = 0; i <= 1; i++) {
            curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
          }
          var pt = this.evaluate(3, curve, u),
              pt1 = this.evaluate(2, curve1, u),
              pt2 = this.evaluate(1, curve2, u),
              diff = pt.subtract(point),
              df = pt1.dot(pt1) + diff.dot(pt2);
          if (Math.abs(df) < 1e-6)
            return u;
          return u - diff.dot(pt1) / df;
        },
        evaluate: function(degree, curve, t) {
          var tmp = curve.slice();
          for (var i = 1; i <= degree; i++) {
            for (var j = 0; j <= degree - i; j++) {
              tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
            }
          }
          return tmp[0];
        },
        chordLengthParameterize: function(first, last) {
          var u = [0];
          for (var i = first + 1; i <= last; i++) {
            u[i - first] = u[i - first - 1] + this.points[i].getDistance(this.points[i - 1]);
          }
          for (var i = 1,
              m = last - first; i <= m; i++) {
            u[i] /= u[m];
          }
          return u;
        },
        findMaxError: function(first, last, curve, u) {
          var index = Math.floor((last - first + 1) / 2),
              maxDist = 0;
          for (var i = first + 1; i < last; i++) {
            var P = this.evaluate(3, curve, u[i - first]);
            var v = P.subtract(this.points[i]);
            var dist = v.x * v.x + v.y * v.y;
            if (dist >= maxDist) {
              maxDist = dist;
              index = i;
            }
          }
          return {
            error: maxDist,
            index: index
          };
        }
      });
      var TextItem = Item.extend({
        _class: 'TextItem',
        _boundsSelected: true,
        _applyMatrix: false,
        _canApplyMatrix: false,
        _serializeFields: {content: null},
        _boundsGetter: 'getBounds',
        initialize: function TextItem(arg) {
          this._content = '';
          this._lines = [];
          var hasProps = arg && Base.isPlainObject(arg) && arg.x === undefined && arg.y === undefined;
          this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
        },
        _equals: function(item) {
          return this._content === item._content;
        },
        _clone: function _clone(copy, insert, includeMatrix) {
          copy.setContent(this._content);
          return _clone.base.call(this, copy, insert, includeMatrix);
        },
        getContent: function() {
          return this._content;
        },
        setContent: function(content) {
          this._content = '' + content;
          this._lines = this._content.split(/\r\n|\n|\r/mg);
          this._changed(265);
        },
        isEmpty: function() {
          return !this._content;
        },
        getCharacterStyle: '#getStyle',
        setCharacterStyle: '#setStyle',
        getParagraphStyle: '#getStyle',
        setParagraphStyle: '#setStyle'
      });
      var PointText = TextItem.extend({
        _class: 'PointText',
        initialize: function PointText() {
          TextItem.apply(this, arguments);
        },
        clone: function(insert) {
          return this._clone(new PointText(Item.NO_INSERT), insert);
        },
        getPoint: function() {
          var point = this._matrix.getTranslation();
          return new LinkedPoint(point.x, point.y, this, 'setPoint');
        },
        setPoint: function() {
          var point = Point.read(arguments);
          this.translate(point.subtract(this._matrix.getTranslation()));
        },
        _draw: function(ctx) {
          if (!this._content)
            return;
          this._setStyles(ctx);
          var style = this._style,
              lines = this._lines,
              leading = style.getLeading(),
              shadowColor = ctx.shadowColor;
          ctx.font = style.getFontStyle();
          ctx.textAlign = style.getJustification();
          for (var i = 0,
              l = lines.length; i < l; i++) {
            ctx.shadowColor = shadowColor;
            var line = lines[i];
            if (style.hasFill()) {
              ctx.fillText(line, 0, 0);
              ctx.shadowColor = 'rgba(0,0,0,0)';
            }
            if (style.hasStroke())
              ctx.strokeText(line, 0, 0);
            ctx.translate(0, leading);
          }
        },
        _getBounds: function(getter, matrix) {
          var style = this._style,
              lines = this._lines,
              numLines = lines.length,
              justification = style.getJustification(),
              leading = style.getLeading(),
              width = this.getView().getTextWidth(style.getFontStyle(), lines),
              x = 0;
          if (justification !== 'left')
            x -= width / (justification === 'center' ? 2 : 1);
          var bounds = new Rectangle(x, numLines ? -0.75 * leading : 0, width, numLines * leading);
          return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
        }
      });
      var Color = Base.extend(new function() {
        var types = {
          gray: ['gray'],
          rgb: ['red', 'green', 'blue'],
          hsb: ['hue', 'saturation', 'brightness'],
          hsl: ['hue', 'saturation', 'lightness'],
          gradient: ['gradient', 'origin', 'destination', 'highlight']
        };
        var componentParsers = {},
            colorCache = {},
            colorCtx;
        function fromCSS(string) {
          var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
              components;
          if (match) {
            components = [0, 0, 0];
            for (var i = 0; i < 3; i++) {
              var value = match[i + 1];
              components[i] = parseInt(value.length == 1 ? value + value : value, 16) / 255;
            }
          } else if (match = string.match(/^rgba?\((.*)\)$/)) {
            components = match[1].split(',');
            for (var i = 0,
                l = components.length; i < l; i++) {
              var value = +components[i];
              components[i] = i < 3 ? value / 255 : value;
            }
          } else {
            var cached = colorCache[string];
            if (!cached) {
              if (!colorCtx) {
                colorCtx = CanvasProvider.getContext(1, 1);
                colorCtx.globalCompositeOperation = 'copy';
              }
              colorCtx.fillStyle = 'rgba(0,0,0,0)';
              colorCtx.fillStyle = string;
              colorCtx.fillRect(0, 0, 1, 1);
              var data = colorCtx.getImageData(0, 0, 1, 1).data;
              cached = colorCache[string] = [data[0] / 255, data[1] / 255, data[2] / 255];
            }
            components = cached.slice();
          }
          return components;
        }
        var hsbIndices = [[0, 3, 1], [2, 0, 1], [1, 0, 3], [1, 2, 0], [3, 1, 0], [0, 1, 2]];
        var converters = {
          'rgb-hsb': function(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                h = delta === 0 ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60;
            return [h, max === 0 ? 0 : delta / max, max];
          },
          'hsb-rgb': function(h, s, b) {
            h = (((h / 60) % 6) + 6) % 6;
            var i = Math.floor(h),
                f = h - i,
                i = hsbIndices[i],
                v = [b, b * (1 - s), b * (1 - s * f), b * (1 - s * (1 - f))];
            return [v[i[0]], v[i[1]], v[i[2]]];
          },
          'rgb-hsl': function(r, g, b) {
            var max = Math.max(r, g, b),
                min = Math.min(r, g, b),
                delta = max - min,
                achromatic = delta === 0,
                h = achromatic ? 0 : (max == r ? (g - b) / delta + (g < b ? 6 : 0) : max == g ? (b - r) / delta + 2 : (r - g) / delta + 4) * 60,
                l = (max + min) / 2,
                s = achromatic ? 0 : l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
            return [h, s, l];
          },
          'hsl-rgb': function(h, s, l) {
            h = (((h / 360) % 1) + 1) % 1;
            if (s === 0)
              return [l, l, l];
            var t3s = [h + 1 / 3, h, h - 1 / 3],
                t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
                t1 = 2 * l - t2,
                c = [];
            for (var i = 0; i < 3; i++) {
              var t3 = t3s[i];
              if (t3 < 0)
                t3 += 1;
              if (t3 > 1)
                t3 -= 1;
              c[i] = 6 * t3 < 1 ? t1 + (t2 - t1) * 6 * t3 : 2 * t3 < 1 ? t2 : 3 * t3 < 2 ? t1 + (t2 - t1) * ((2 / 3) - t3) * 6 : t1;
            }
            return c;
          },
          'rgb-gray': function(r, g, b) {
            return [r * 0.2989 + g * 0.587 + b * 0.114];
          },
          'gray-rgb': function(g) {
            return [g, g, g];
          },
          'gray-hsb': function(g) {
            return [0, 0, g];
          },
          'gray-hsl': function(g) {
            return [0, 0, g];
          },
          'gradient-rgb': function() {
            return [];
          },
          'rgb-gradient': function() {
            return [];
          }
        };
        return Base.each(types, function(properties, type) {
          componentParsers[type] = [];
          Base.each(properties, function(name, index) {
            var part = Base.capitalize(name),
                hasOverlap = /^(hue|saturation)$/.test(name),
                parser = componentParsers[type][index] = name === 'gradient' ? function(value) {
                  var current = this._components[0];
                  value = Gradient.read(Array.isArray(value) ? value : arguments, 0, {readNull: true});
                  if (current !== value) {
                    if (current)
                      current._removeOwner(this);
                    if (value)
                      value._addOwner(this);
                  }
                  return value;
                } : type === 'gradient' ? function() {
                  return Point.read(arguments, 0, {
                    readNull: name === 'highlight',
                    clone: true
                  });
                } : function(value) {
                  return value == null || isNaN(value) ? 0 : value;
                };
            this['get' + part] = function() {
              return this._type === type || hasOverlap && /^hs[bl]$/.test(this._type) ? this._components[index] : this._convert(type)[index];
            };
            this['set' + part] = function(value) {
              if (this._type !== type && !(hasOverlap && /^hs[bl]$/.test(this._type))) {
                this._components = this._convert(type);
                this._properties = types[type];
                this._type = type;
              }
              this._components[index] = parser.call(this, value);
              this._changed();
            };
          }, this);
        }, {
          _class: 'Color',
          _readIndex: true,
          initialize: function Color(arg) {
            var slice = Array.prototype.slice,
                args = arguments,
                read = 0,
                type,
                components,
                alpha,
                values;
            if (Array.isArray(arg)) {
              args = arg;
              arg = args[0];
            }
            var argType = arg != null && typeof arg;
            if (argType === 'string' && arg in types) {
              type = arg;
              arg = args[1];
              if (Array.isArray(arg)) {
                components = arg;
                alpha = args[2];
              } else {
                if (this.__read)
                  read = 1;
                args = slice.call(args, 1);
                argType = typeof arg;
              }
            }
            if (!components) {
              values = argType === 'number' ? args : argType === 'object' && arg.length != null ? arg : null;
              if (values) {
                if (!type)
                  type = values.length >= 3 ? 'rgb' : 'gray';
                var length = types[type].length;
                alpha = values[length];
                if (this.__read)
                  read += values === arguments ? length + (alpha != null ? 1 : 0) : 1;
                if (values.length > length)
                  values = slice.call(values, 0, length);
              } else if (argType === 'string') {
                type = 'rgb';
                components = fromCSS(arg);
                if (components.length === 4) {
                  alpha = components[3];
                  components.length--;
                }
              } else if (argType === 'object') {
                if (arg.constructor === Color) {
                  type = arg._type;
                  components = arg._components.slice();
                  alpha = arg._alpha;
                  if (type === 'gradient') {
                    for (var i = 1,
                        l = components.length; i < l; i++) {
                      var point = components[i];
                      if (point)
                        components[i] = point.clone();
                    }
                  }
                } else if (arg.constructor === Gradient) {
                  type = 'gradient';
                  values = args;
                } else {
                  type = 'hue' in arg ? 'lightness' in arg ? 'hsl' : 'hsb' : 'gradient' in arg || 'stops' in arg || 'radial' in arg ? 'gradient' : 'gray' in arg ? 'gray' : 'rgb';
                  var properties = types[type],
                      parsers = componentParsers[type];
                  this._components = components = [];
                  for (var i = 0,
                      l = properties.length; i < l; i++) {
                    var value = arg[properties[i]];
                    if (value == null && i === 0 && type === 'gradient' && 'stops' in arg) {
                      value = {
                        stops: arg.stops,
                        radial: arg.radial
                      };
                    }
                    value = parsers[i].call(this, value);
                    if (value != null)
                      components[i] = value;
                  }
                  alpha = arg.alpha;
                }
              }
              if (this.__read && type)
                read = 1;
            }
            this._type = type || 'rgb';
            this._id = UID.get(Color);
            if (!components) {
              this._components = components = [];
              var parsers = componentParsers[this._type];
              for (var i = 0,
                  l = parsers.length; i < l; i++) {
                var value = parsers[i].call(this, values && values[i]);
                if (value != null)
                  components[i] = value;
              }
            }
            this._components = components;
            this._properties = types[this._type];
            this._alpha = alpha;
            if (this.__read)
              this.__read = read;
          },
          _serialize: function(options, dictionary) {
            var components = this.getComponents();
            return Base.serialize(/^(gray|rgb)$/.test(this._type) ? components : [this._type].concat(components), options, true, dictionary);
          },
          _changed: function() {
            this._canvasStyle = null;
            if (this._owner)
              this._owner._changed(65);
          },
          _convert: function(type) {
            var converter;
            return this._type === type ? this._components.slice() : (converter = converters[this._type + '-' + type]) ? converter.apply(this, this._components) : converters['rgb-' + type].apply(this, converters[this._type + '-rgb'].apply(this, this._components));
          },
          convert: function(type) {
            return new Color(type, this._convert(type), this._alpha);
          },
          getType: function() {
            return this._type;
          },
          setType: function(type) {
            this._components = this._convert(type);
            this._properties = types[type];
            this._type = type;
          },
          getComponents: function() {
            var components = this._components.slice();
            if (this._alpha != null)
              components.push(this._alpha);
            return components;
          },
          getAlpha: function() {
            return this._alpha != null ? this._alpha : 1;
          },
          setAlpha: function(alpha) {
            this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
            this._changed();
          },
          hasAlpha: function() {
            return this._alpha != null;
          },
          equals: function(color) {
            var col = Base.isPlainValue(color, true) ? Color.read(arguments) : color;
            return col === this || col && this._class === col._class && this._type === col._type && this._alpha === col._alpha && Base.equals(this._components, col._components) || false;
          },
          toString: function() {
            var properties = this._properties,
                parts = [],
                isGradient = this._type === 'gradient',
                f = Formatter.instance;
            for (var i = 0,
                l = properties.length; i < l; i++) {
              var value = this._components[i];
              if (value != null)
                parts.push(properties[i] + ': ' + (isGradient ? value : f.number(value)));
            }
            if (this._alpha != null)
              parts.push('alpha: ' + f.number(this._alpha));
            return '{ ' + parts.join(', ') + ' }';
          },
          toCSS: function(hex) {
            var components = this._convert('rgb'),
                alpha = hex || this._alpha == null ? 1 : this._alpha;
            function convert(val) {
              return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
            }
            components = [convert(components[0]), convert(components[1]), convert(components[2])];
            if (alpha < 1)
              components.push(alpha < 0 ? 0 : alpha);
            return hex ? '#' + ((1 << 24) + (components[0] << 16) + (components[1] << 8) + components[2]).toString(16).slice(1) : (components.length == 4 ? 'rgba(' : 'rgb(') + components.join(',') + ')';
          },
          toCanvasStyle: function(ctx) {
            if (this._canvasStyle)
              return this._canvasStyle;
            if (this._type !== 'gradient')
              return this._canvasStyle = this.toCSS();
            var components = this._components,
                gradient = components[0],
                stops = gradient._stops,
                origin = components[1],
                destination = components[2],
                canvasGradient;
            if (gradient._radial) {
              var radius = destination.getDistance(origin),
                  highlight = components[3];
              if (highlight) {
                var vector = highlight.subtract(origin);
                if (vector.getLength() > radius)
                  highlight = origin.add(vector.normalize(radius - 0.1));
              }
              var start = highlight || origin;
              canvasGradient = ctx.createRadialGradient(start.x, start.y, 0, origin.x, origin.y, radius);
            } else {
              canvasGradient = ctx.createLinearGradient(origin.x, origin.y, destination.x, destination.y);
            }
            for (var i = 0,
                l = stops.length; i < l; i++) {
              var stop = stops[i];
              canvasGradient.addColorStop(stop._rampPoint, stop._color.toCanvasStyle());
            }
            return this._canvasStyle = canvasGradient;
          },
          transform: function(matrix) {
            if (this._type === 'gradient') {
              var components = this._components;
              for (var i = 1,
                  l = components.length; i < l; i++) {
                var point = components[i];
                matrix._transformPoint(point, point, true);
              }
              this._changed();
            }
          },
          statics: {
            _types: types,
            random: function() {
              var random = Math.random;
              return new Color(random(), random(), random());
            }
          }
        });
      }, new function() {
        var operators = {
          add: function(a, b) {
            return a + b;
          },
          subtract: function(a, b) {
            return a - b;
          },
          multiply: function(a, b) {
            return a * b;
          },
          divide: function(a, b) {
            return a / b;
          }
        };
        return Base.each(operators, function(operator, name) {
          this[name] = function(color) {
            color = Color.read(arguments);
            var type = this._type,
                components1 = this._components,
                components2 = color._convert(type);
            for (var i = 0,
                l = components1.length; i < l; i++)
              components2[i] = operator(components1[i], components2[i]);
            return new Color(type, components2, this._alpha != null ? operator(this._alpha, color.getAlpha()) : null);
          };
        }, {});
      });
      var Gradient = Base.extend({
        _class: 'Gradient',
        initialize: function Gradient(stops, radial) {
          this._id = UID.get();
          if (stops && this._set(stops))
            stops = radial = null;
          if (!this._stops)
            this.setStops(stops || ['white', 'black']);
          if (this._radial == null)
            this.setRadial(typeof radial === 'string' && radial === 'radial' || radial || false);
        },
        _serialize: function(options, dictionary) {
          return dictionary.add(this, function() {
            return Base.serialize([this._stops, this._radial], options, true, dictionary);
          });
        },
        _changed: function() {
          for (var i = 0,
              l = this._owners && this._owners.length; i < l; i++)
            this._owners[i]._changed();
        },
        _addOwner: function(color) {
          if (!this._owners)
            this._owners = [];
          this._owners.push(color);
        },
        _removeOwner: function(color) {
          var index = this._owners ? this._owners.indexOf(color) : -1;
          if (index != -1) {
            this._owners.splice(index, 1);
            if (this._owners.length === 0)
              this._owners = undefined;
          }
        },
        clone: function() {
          var stops = [];
          for (var i = 0,
              l = this._stops.length; i < l; i++)
            stops[i] = this._stops[i].clone();
          return new Gradient(stops, this._radial);
        },
        getStops: function() {
          return this._stops;
        },
        setStops: function(stops) {
          if (this.stops) {
            for (var i = 0,
                l = this._stops.length; i < l; i++)
              this._stops[i]._owner = undefined;
          }
          if (stops.length < 2)
            throw new Error('Gradient stop list needs to contain at least two stops.');
          this._stops = GradientStop.readAll(stops, 0, {clone: true});
          for (var i = 0,
              l = this._stops.length; i < l; i++) {
            var stop = this._stops[i];
            stop._owner = this;
            if (stop._defaultRamp)
              stop.setRampPoint(i / (l - 1));
          }
          this._changed();
        },
        getRadial: function() {
          return this._radial;
        },
        setRadial: function(radial) {
          this._radial = radial;
          this._changed();
        },
        equals: function(gradient) {
          if (gradient === this)
            return true;
          if (gradient && this._class === gradient._class && this._stops.length === gradient._stops.length) {
            for (var i = 0,
                l = this._stops.length; i < l; i++) {
              if (!this._stops[i].equals(gradient._stops[i]))
                return false;
            }
            return true;
          }
          return false;
        }
      });
      var GradientStop = Base.extend({
        _class: 'GradientStop',
        initialize: function GradientStop(arg0, arg1) {
          if (arg0) {
            var color,
                rampPoint;
            if (arg1 === undefined && Array.isArray(arg0)) {
              color = arg0[0];
              rampPoint = arg0[1];
            } else if (arg0.color) {
              color = arg0.color;
              rampPoint = arg0.rampPoint;
            } else {
              color = arg0;
              rampPoint = arg1;
            }
            this.setColor(color);
            this.setRampPoint(rampPoint);
          }
        },
        clone: function() {
          return new GradientStop(this._color.clone(), this._rampPoint);
        },
        _serialize: function(options, dictionary) {
          return Base.serialize([this._color, this._rampPoint], options, true, dictionary);
        },
        _changed: function() {
          if (this._owner)
            this._owner._changed(65);
        },
        getRampPoint: function() {
          return this._rampPoint;
        },
        setRampPoint: function(rampPoint) {
          this._defaultRamp = rampPoint == null;
          this._rampPoint = rampPoint || 0;
          this._changed();
        },
        getColor: function() {
          return this._color;
        },
        setColor: function(color) {
          this._color = Color.read(arguments);
          if (this._color === color)
            this._color = color.clone();
          this._color._owner = this;
          this._changed();
        },
        equals: function(stop) {
          return stop === this || stop && this._class === stop._class && this._color.equals(stop._color) && this._rampPoint == stop._rampPoint || false;
        }
      });
      var Style = Base.extend(new function() {
        var defaults = {
          fillColor: undefined,
          strokeColor: undefined,
          strokeWidth: 1,
          strokeCap: 'butt',
          strokeJoin: 'miter',
          strokeScaling: true,
          miterLimit: 10,
          dashOffset: 0,
          dashArray: [],
          windingRule: 'nonzero',
          shadowColor: undefined,
          shadowBlur: 0,
          shadowOffset: new Point(),
          selectedColor: undefined,
          fontFamily: 'sans-serif',
          fontWeight: 'normal',
          fontSize: 12,
          font: 'sans-serif',
          leading: null,
          justification: 'left'
        };
        var flags = {
          strokeWidth: 97,
          strokeCap: 97,
          strokeJoin: 97,
          strokeScaling: 105,
          miterLimit: 97,
          fontFamily: 9,
          fontWeight: 9,
          fontSize: 9,
          font: 9,
          leading: 9,
          justification: 9
        };
        var item = {beans: true},
            fields = {
              _defaults: defaults,
              _textDefaults: new Base(defaults, {fillColor: new Color()}),
              beans: true
            };
        Base.each(defaults, function(value, key) {
          var isColor = /Color$/.test(key),
              isPoint = key === 'shadowOffset',
              part = Base.capitalize(key),
              flag = flags[key],
              set = 'set' + part,
              get = 'get' + part;
          fields[set] = function(value) {
            var owner = this._owner,
                children = owner && owner._children;
            if (children && children.length > 0 && !(owner instanceof CompoundPath)) {
              for (var i = 0,
                  l = children.length; i < l; i++)
                children[i]._style[set](value);
            } else {
              var old = this._values[key];
              if (old !== value) {
                if (isColor) {
                  if (old)
                    old._owner = undefined;
                  if (value && value.constructor === Color) {
                    if (value._owner)
                      value = value.clone();
                    value._owner = owner;
                  }
                }
                this._values[key] = value;
                if (owner)
                  owner._changed(flag || 65);
              }
            }
          };
          fields[get] = function(_dontMerge) {
            var owner = this._owner,
                children = owner && owner._children,
                value;
            if (!children || children.length === 0 || _dontMerge || owner instanceof CompoundPath) {
              var value = this._values[key];
              if (value === undefined) {
                value = this._defaults[key];
                if (value && value.clone)
                  value = value.clone();
              } else {
                var ctor = isColor ? Color : isPoint ? Point : null;
                if (ctor && !(value && value.constructor === ctor)) {
                  this._values[key] = value = ctor.read([value], 0, {
                    readNull: true,
                    clone: true
                  });
                  if (value && isColor)
                    value._owner = owner;
                }
              }
              return value;
            }
            for (var i = 0,
                l = children.length; i < l; i++) {
              var childValue = children[i]._style[get]();
              if (i === 0) {
                value = childValue;
              } else if (!Base.equals(value, childValue)) {
                return undefined;
              }
            }
            return value;
          };
          item[get] = function(_dontMerge) {
            return this._style[get](_dontMerge);
          };
          item[set] = function(value) {
            this._style[set](value);
          };
        });
        Item.inject(item);
        return fields;
      }, {
        _class: 'Style',
        initialize: function Style(style, _owner, _project) {
          this._values = {};
          this._owner = _owner;
          this._project = _owner && _owner._project || _project || paper.project;
          if (_owner instanceof TextItem)
            this._defaults = this._textDefaults;
          if (style)
            this.set(style);
        },
        set: function(style) {
          var isStyle = style instanceof Style,
              values = isStyle ? style._values : style;
          if (values) {
            for (var key in values) {
              if (key in this._defaults) {
                var value = values[key];
                this[key] = value && isStyle && value.clone ? value.clone() : value;
              }
            }
          }
        },
        equals: function(style) {
          return style === this || style && this._class === style._class && Base.equals(this._values, style._values) || false;
        },
        hasFill: function() {
          return !!this.getFillColor();
        },
        hasStroke: function() {
          return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
        },
        hasShadow: function() {
          return !!this.getShadowColor() && this.getShadowBlur() > 0;
        },
        getView: function() {
          return this._project.getView();
        },
        getFontStyle: function() {
          var fontSize = this.getFontSize();
          return this.getFontWeight() + ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ') + this.getFontFamily();
        },
        getFont: '#getFontFamily',
        setFont: '#setFontFamily',
        getLeading: function getLeading() {
          var leading = getLeading.base.call(this),
              fontSize = this.getFontSize();
          if (/pt|em|%|px/.test(fontSize))
            fontSize = this.getView().getPixelSize(fontSize);
          return leading != null ? leading : fontSize * 1.2;
        }
      });
      var DomElement = new function() {
        function handlePrefix(el, name, set, value) {
          var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
              suffix = name[0].toUpperCase() + name.substring(1);
          for (var i = 0; i < 6; i++) {
            var prefix = prefixes[i],
                key = prefix ? prefix + suffix : name;
            if (key in el) {
              if (set) {
                el[key] = value;
              } else {
                return el[key];
              }
              break;
            }
          }
        }
        return {
          getStyles: function(el) {
            var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
                view = doc && doc.defaultView;
            return view && view.getComputedStyle(el, '');
          },
          getBounds: function(el, viewport) {
            var doc = el.ownerDocument,
                body = doc.body,
                html = doc.documentElement,
                rect;
            try {
              rect = el.getBoundingClientRect();
            } catch (e) {
              rect = {
                left: 0,
                top: 0,
                width: 0,
                height: 0
              };
            }
            var x = rect.left - (html.clientLeft || body.clientLeft || 0),
                y = rect.top - (html.clientTop || body.clientTop || 0);
            if (!viewport) {
              var view = doc.defaultView;
              x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
              y += view.pageYOffset || html.scrollTop || body.scrollTop;
            }
            return new Rectangle(x, y, rect.width, rect.height);
          },
          getViewportBounds: function(el) {
            var doc = el.ownerDocument,
                view = doc.defaultView,
                html = doc.documentElement;
            return new Rectangle(0, 0, view.innerWidth || html.clientWidth, view.innerHeight || html.clientHeight);
          },
          getOffset: function(el, viewport) {
            return DomElement.getBounds(el, viewport).getPoint();
          },
          getSize: function(el) {
            return DomElement.getBounds(el, true).getSize();
          },
          isInvisible: function(el) {
            return DomElement.getSize(el).equals(new Size(0, 0));
          },
          isInView: function(el) {
            return !DomElement.isInvisible(el) && DomElement.getViewportBounds(el).intersects(DomElement.getBounds(el, true));
          },
          getPrefixed: function(el, name) {
            return handlePrefix(el, name);
          },
          setPrefixed: function(el, name, value) {
            if (typeof name === 'object') {
              for (var key in name)
                handlePrefix(el, key, true, name[key]);
            } else {
              handlePrefix(el, name, true, value);
            }
          }
        };
      };
      var DomEvent = {
        add: function(el, events) {
          for (var type in events) {
            var func = events[type],
                parts = type.split(/[\s,]+/g);
            for (var i = 0,
                l = parts.length; i < l; i++)
              el.addEventListener(parts[i], func, false);
          }
        },
        remove: function(el, events) {
          for (var type in events) {
            var func = events[type],
                parts = type.split(/[\s,]+/g);
            for (var i = 0,
                l = parts.length; i < l; i++)
              el.removeEventListener(parts[i], func, false);
          }
        },
        getPoint: function(event) {
          var pos = event.targetTouches ? event.targetTouches.length ? event.targetTouches[0] : event.changedTouches[0] : event;
          return new Point(pos.pageX || pos.clientX + document.documentElement.scrollLeft, pos.pageY || pos.clientY + document.documentElement.scrollTop);
        },
        getTarget: function(event) {
          return event.target || event.srcElement;
        },
        getRelatedTarget: function(event) {
          return event.relatedTarget || event.toElement;
        },
        getOffset: function(event, target) {
          return DomEvent.getPoint(event).subtract(DomElement.getOffset(target || DomEvent.getTarget(event)));
        },
        stop: function(event) {
          event.stopPropagation();
          event.preventDefault();
        }
      };
      DomEvent.requestAnimationFrame = new function() {
        var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
            requested = false,
            callbacks = [],
            focused = true,
            timer;
        DomEvent.add(window, {
          focus: function() {
            focused = true;
          },
          blur: function() {
            focused = false;
          }
        });
        function handleCallbacks() {
          for (var i = callbacks.length - 1; i >= 0; i--) {
            var entry = callbacks[i],
                func = entry[0],
                el = entry[1];
            if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true' || focused) && DomElement.isInView(el)) {
              callbacks.splice(i, 1);
              func();
            }
          }
          if (nativeRequest) {
            if (callbacks.length) {
              nativeRequest(handleCallbacks);
            } else {
              requested = false;
            }
          }
        }
        return function(callback, element) {
          callbacks.push([callback, element]);
          if (nativeRequest) {
            if (!requested) {
              nativeRequest(handleCallbacks);
              requested = true;
            }
          } else if (!timer) {
            timer = setInterval(handleCallbacks, 1000 / 60);
          }
        };
      };
      var View = Base.extend(Emitter, {
        _class: 'View',
        initialize: function View(project, element) {
          this._project = project;
          this._scope = project._scope;
          this._element = element;
          var size;
          if (!this._pixelRatio)
            this._pixelRatio = window.devicePixelRatio || 1;
          this._id = element.getAttribute('id');
          if (this._id == null)
            element.setAttribute('id', this._id = 'view-' + View._id++);
          DomEvent.add(element, this._viewEvents);
          var none = 'none';
          DomElement.setPrefixed(element.style, {
            userSelect: none,
            touchAction: none,
            touchCallout: none,
            contentZooming: none,
            userDrag: none,
            tapHighlightColor: 'rgba(0,0,0,0)'
          });
          function getSize(name) {
            return element[name] || parseInt(element.getAttribute(name), 10);
          }
          ;
          function getCanvasSize() {
            var size = DomElement.getSize(element);
            return size.isNaN() || size.isZero() ? new Size(getSize('width'), getSize('height')) : size;
          }
          ;
          if (PaperScope.hasAttribute(element, 'resize')) {
            var that = this;
            DomEvent.add(window, this._windowEvents = {resize: function() {
                that.setViewSize(getCanvasSize());
              }});
          }
          this._setViewSize(size = getCanvasSize());
          if (PaperScope.hasAttribute(element, 'stats') && typeof Stats !== 'undefined') {
            this._stats = new Stats();
            var stats = this._stats.domElement,
                style = stats.style,
                offset = DomElement.getOffset(element);
            style.position = 'absolute';
            style.left = offset.x + 'px';
            style.top = offset.y + 'px';
            document.body.appendChild(stats);
          }
          View._views.push(this);
          View._viewsById[this._id] = this;
          this._viewSize = size;
          (this._matrix = new Matrix())._owner = this;
          this._zoom = 1;
          if (!View._focused)
            View._focused = this;
          this._frameItems = {};
          this._frameItemCount = 0;
        },
        remove: function() {
          if (!this._project)
            return false;
          if (View._focused === this)
            View._focused = null;
          View._views.splice(View._views.indexOf(this), 1);
          delete View._viewsById[this._id];
          if (this._project._view === this)
            this._project._view = null;
          DomEvent.remove(this._element, this._viewEvents);
          DomEvent.remove(window, this._windowEvents);
          this._element = this._project = null;
          this.off('frame');
          this._animate = false;
          this._frameItems = {};
          return true;
        },
        _events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'], function(name) {
          this[name] = {
            install: function(type) {
              this._installEvent(type);
            },
            uninstall: function(type) {
              this._uninstallEvent(type);
            }
          };
        }, {onFrame: {
            install: function() {
              this.play();
            },
            uninstall: function() {
              this.pause();
            }
          }}),
        _animate: false,
        _time: 0,
        _count: 0,
        _requestFrame: function() {
          var that = this;
          DomEvent.requestAnimationFrame(function() {
            that._requested = false;
            if (!that._animate)
              return;
            that._requestFrame();
            that._handleFrame();
          }, this._element);
          this._requested = true;
        },
        _handleFrame: function() {
          paper = this._scope;
          var now = Date.now() / 1000,
              delta = this._before ? now - this._before : 0;
          this._before = now;
          this._handlingFrame = true;
          this.emit('frame', new Base({
            delta: delta,
            time: this._time += delta,
            count: this._count++
          }));
          if (this._stats)
            this._stats.update();
          this._handlingFrame = false;
          this.update();
        },
        _animateItem: function(item, animate) {
          var items = this._frameItems;
          if (animate) {
            items[item._id] = {
              item: item,
              time: 0,
              count: 0
            };
            if (++this._frameItemCount === 1)
              this.on('frame', this._handleFrameItems);
          } else {
            delete items[item._id];
            if (--this._frameItemCount === 0) {
              this.off('frame', this._handleFrameItems);
            }
          }
        },
        _handleFrameItems: function(event) {
          for (var i in this._frameItems) {
            var entry = this._frameItems[i];
            entry.item.emit('frame', new Base(event, {
              time: entry.time += event.delta,
              count: entry.count++
            }));
          }
        },
        _update: function() {
          this._project._needsUpdate = true;
          if (this._handlingFrame)
            return;
          if (this._animate) {
            this._handleFrame();
          } else {
            this.update();
          }
        },
        _changed: function(flags) {
          if (flags & 1)
            this._project._needsUpdate = true;
        },
        _transform: function(matrix) {
          this._matrix.concatenate(matrix);
          this._bounds = null;
          this._update();
        },
        getElement: function() {
          return this._element;
        },
        getPixelRatio: function() {
          return this._pixelRatio;
        },
        getResolution: function() {
          return this._pixelRatio * 72;
        },
        getViewSize: function() {
          var size = this._viewSize;
          return new LinkedSize(size.width, size.height, this, 'setViewSize');
        },
        setViewSize: function() {
          var size = Size.read(arguments),
              delta = size.subtract(this._viewSize);
          if (delta.isZero())
            return;
          this._viewSize.set(size.width, size.height);
          this._setViewSize(size);
          this._bounds = null;
          this.emit('resize', {
            size: size,
            delta: delta
          });
          this._update();
        },
        _setViewSize: function(size) {
          var element = this._element;
          element.width = size.width;
          element.height = size.height;
        },
        getBounds: function() {
          if (!this._bounds)
            this._bounds = this._matrix.inverted()._transformBounds(new Rectangle(new Point(), this._viewSize));
          return this._bounds;
        },
        getSize: function() {
          return this.getBounds().getSize();
        },
        getCenter: function() {
          return this.getBounds().getCenter();
        },
        setCenter: function() {
          var center = Point.read(arguments);
          this.scrollBy(center.subtract(this.getCenter()));
        },
        getZoom: function() {
          return this._zoom;
        },
        setZoom: function(zoom) {
          this._transform(new Matrix().scale(zoom / this._zoom, this.getCenter()));
          this._zoom = zoom;
        },
        isVisible: function() {
          return DomElement.isInView(this._element);
        },
        scrollBy: function() {
          this._transform(new Matrix().translate(Point.read(arguments).negate()));
        },
        play: function() {
          this._animate = true;
          if (!this._requested)
            this._requestFrame();
        },
        pause: function() {
          this._animate = false;
        },
        draw: function() {
          this.update();
        },
        projectToView: function() {
          return this._matrix._transformPoint(Point.read(arguments));
        },
        viewToProject: function() {
          return this._matrix._inverseTransform(Point.read(arguments));
        }
      }, {statics: {
          _views: [],
          _viewsById: {},
          _id: 0,
          create: function(project, element) {
            if (typeof element === 'string')
              element = document.getElementById(element);
            return new CanvasView(project, element);
          }
        }}, new function() {
        var tool,
            prevFocus,
            tempFocus,
            dragging = false;
        function getView(event) {
          var target = DomEvent.getTarget(event);
          return target.getAttribute && View._viewsById[target.getAttribute('id')];
        }
        function viewToProject(view, event) {
          return view.viewToProject(DomEvent.getOffset(event, view._element));
        }
        function updateFocus() {
          if (!View._focused || !View._focused.isVisible()) {
            for (var i = 0,
                l = View._views.length; i < l; i++) {
              var view = View._views[i];
              if (view && view.isVisible()) {
                View._focused = tempFocus = view;
                break;
              }
            }
          }
        }
        function handleMouseMove(view, point, event) {
          view._handleEvent('mousemove', point, event);
          var tool = view._scope.tool;
          if (tool) {
            tool._handleEvent(dragging && tool.responds('mousedrag') ? 'mousedrag' : 'mousemove', point, event);
          }
          view.update();
          return tool;
        }
        var navigator = window.navigator,
            mousedown,
            mousemove,
            mouseup;
        if (navigator.pointerEnabled || navigator.msPointerEnabled) {
          mousedown = 'pointerdown MSPointerDown';
          mousemove = 'pointermove MSPointerMove';
          mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
        } else {
          mousedown = 'touchstart';
          mousemove = 'touchmove';
          mouseup = 'touchend touchcancel';
          if (!('ontouchstart' in window && navigator.userAgent.match(/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
            mousedown += ' mousedown';
            mousemove += ' mousemove';
            mouseup += ' mouseup';
          }
        }
        var viewEvents = {'selectstart dragstart': function(event) {
            if (dragging)
              event.preventDefault();
          }};
        var docEvents = {
          mouseout: function(event) {
            var view = View._focused,
                target = DomEvent.getRelatedTarget(event);
            if (view && (!target || target.nodeName === 'HTML'))
              handleMouseMove(view, viewToProject(view, event), event);
          },
          scroll: updateFocus
        };
        viewEvents[mousedown] = function(event) {
          var view = View._focused = getView(event),
              point = viewToProject(view, event);
          dragging = true;
          view._handleEvent('mousedown', point, event);
          if (tool = view._scope.tool)
            tool._handleEvent('mousedown', point, event);
          view.update();
        };
        docEvents[mousemove] = function(event) {
          var view = View._focused;
          if (!dragging) {
            var target = getView(event);
            if (target) {
              if (view !== target)
                handleMouseMove(view, viewToProject(view, event), event);
              prevFocus = view;
              view = View._focused = tempFocus = target;
            } else if (tempFocus && tempFocus === view) {
              view = View._focused = prevFocus;
              updateFocus();
            }
          }
          if (view) {
            var point = viewToProject(view, event);
            if (dragging || view.getBounds().contains(point))
              tool = handleMouseMove(view, point, event);
          }
        };
        docEvents[mouseup] = function(event) {
          var view = View._focused;
          if (!view || !dragging)
            return;
          var point = viewToProject(view, event);
          dragging = false;
          view._handleEvent('mouseup', point, event);
          if (tool)
            tool._handleEvent('mouseup', point, event);
          view.update();
        };
        DomEvent.add(document, docEvents);
        DomEvent.add(window, {load: updateFocus});
        var mouseFlags = {
          mousedown: {
            mousedown: 1,
            mousedrag: 1,
            click: 1,
            doubleclick: 1
          },
          mouseup: {
            mouseup: 1,
            mousedrag: 1,
            click: 1,
            doubleclick: 1
          },
          mousemove: {
            mousedrag: 1,
            mousemove: 1,
            mouseenter: 1,
            mouseleave: 1
          }
        };
        return {
          _viewEvents: viewEvents,
          _handleEvent: function() {},
          _installEvent: function(type) {
            var counters = this._eventCounters;
            if (counters) {
              for (var key in mouseFlags) {
                counters[key] = (counters[key] || 0) + (mouseFlags[key][type] || 0);
              }
            }
          },
          _uninstallEvent: function(type) {
            var counters = this._eventCounters;
            if (counters) {
              for (var key in mouseFlags)
                counters[key] -= mouseFlags[key][type] || 0;
            }
          },
          statics: {updateFocus: updateFocus}
        };
      });
      var CanvasView = View.extend({
        _class: 'CanvasView',
        initialize: function CanvasView(project, canvas) {
          if (!(canvas instanceof HTMLCanvasElement)) {
            var size = Size.read(arguments, 1);
            if (size.isZero())
              throw new Error('Cannot create CanvasView with the provided argument: ' + [].slice.call(arguments, 1));
            canvas = CanvasProvider.getCanvas(size);
          }
          this._context = canvas.getContext('2d');
          this._eventCounters = {};
          this._pixelRatio = 1;
          if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
            var deviceRatio = window.devicePixelRatio || 1,
                backingStoreRatio = DomElement.getPrefixed(this._context, 'backingStorePixelRatio') || 1;
            this._pixelRatio = deviceRatio / backingStoreRatio;
          }
          View.call(this, project, canvas);
        },
        _setViewSize: function(size) {
          var element = this._element,
              pixelRatio = this._pixelRatio,
              width = size.width,
              height = size.height;
          element.width = width * pixelRatio;
          element.height = height * pixelRatio;
          if (pixelRatio !== 1) {
            if (!PaperScope.hasAttribute(element, 'resize')) {
              var style = element.style;
              style.width = width + 'px';
              style.height = height + 'px';
            }
            this._context.scale(pixelRatio, pixelRatio);
          }
        },
        getPixelSize: function(size) {
          var browser = paper.browser,
              pixels;
          if (browser && browser.firefox) {
            var parent = this._element.parentNode,
                temp = document.createElement('div');
            temp.style.fontSize = size;
            parent.appendChild(temp);
            pixels = parseFloat(DomElement.getStyles(temp).fontSize);
            parent.removeChild(temp);
          } else {
            var ctx = this._context,
                prevFont = ctx.font;
            ctx.font = size + ' serif';
            pixels = parseFloat(ctx.font);
            ctx.font = prevFont;
          }
          return pixels;
        },
        getTextWidth: function(font, lines) {
          var ctx = this._context,
              prevFont = ctx.font,
              width = 0;
          ctx.font = font;
          for (var i = 0,
              l = lines.length; i < l; i++)
            width = Math.max(width, ctx.measureText(lines[i]).width);
          ctx.font = prevFont;
          return width;
        },
        update: function(force) {
          var project = this._project;
          if (!project || !force && !project._needsUpdate)
            return false;
          var ctx = this._context,
              size = this._viewSize;
          ctx.clearRect(0, 0, size.width + 1, size.height + 1);
          project.draw(ctx, this._matrix, this._pixelRatio);
          project._needsUpdate = false;
          return true;
        }
      }, new function() {
        var downPoint,
            lastPoint,
            overPoint,
            downItem,
            lastItem,
            overItem,
            dragItem,
            dblClick,
            clickTime;
        function callEvent(view, type, event, point, target, lastPoint) {
          var item = target,
              mouseEvent;
          function call(obj) {
            if (obj.responds(type)) {
              if (!mouseEvent) {
                mouseEvent = new MouseEvent(type, event, point, target, lastPoint ? point.subtract(lastPoint) : null);
              }
              if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
                event.preventDefault();
                return true;
              }
            }
          }
          while (item) {
            if (call(item))
              return true;
            item = item.getParent();
          }
          if (call(view))
            return true;
          return false;
        }
        return {_handleEvent: function(type, point, event) {
            if (!this._eventCounters[type])
              return;
            var project = this._project,
                hit = project.hitTest(point, {
                  tolerance: 0,
                  fill: true,
                  stroke: true
                }),
                item = hit && hit.item,
                stopped = false;
            switch (type) {
              case 'mousedown':
                stopped = callEvent(this, type, event, point, item);
                dblClick = lastItem == item && (Date.now() - clickTime < 300);
                downItem = lastItem = item;
                downPoint = lastPoint = overPoint = point;
                dragItem = !stopped && item;
                while (dragItem && !dragItem.responds('mousedrag'))
                  dragItem = dragItem._parent;
                break;
              case 'mouseup':
                stopped = callEvent(this, type, event, point, item, downPoint);
                if (dragItem) {
                  if (lastPoint && !lastPoint.equals(point))
                    callEvent(this, 'mousedrag', event, point, dragItem, lastPoint);
                  if (item !== dragItem) {
                    overPoint = point;
                    callEvent(this, 'mousemove', event, point, item, overPoint);
                  }
                }
                if (!stopped && item && item === downItem) {
                  clickTime = Date.now();
                  callEvent(this, dblClick && downItem.responds('doubleclick') ? 'doubleclick' : 'click', event, downPoint, item);
                  dblClick = false;
                }
                downItem = dragItem = null;
                break;
              case 'mousemove':
                if (dragItem)
                  stopped = callEvent(this, 'mousedrag', event, point, dragItem, lastPoint);
                if (!stopped) {
                  if (item !== overItem)
                    overPoint = point;
                  stopped = callEvent(this, type, event, point, item, overPoint);
                }
                lastPoint = overPoint = point;
                if (item !== overItem) {
                  callEvent(this, 'mouseleave', event, point, overItem);
                  overItem = item;
                  callEvent(this, 'mouseenter', event, point, item);
                }
                break;
            }
            return stopped;
          }};
      });
      var Event = Base.extend({
        _class: 'Event',
        initialize: function Event(event) {
          this.event = event;
        },
        isPrevented: false,
        isStopped: false,
        preventDefault: function() {
          this.isPrevented = true;
          this.event.preventDefault();
        },
        stopPropagation: function() {
          this.isStopped = true;
          this.event.stopPropagation();
        },
        stop: function() {
          this.stopPropagation();
          this.preventDefault();
        },
        getModifiers: function() {
          return Key.modifiers;
        }
      });
      var KeyEvent = Event.extend({
        _class: 'KeyEvent',
        initialize: function KeyEvent(down, key, character, event) {
          Event.call(this, event);
          this.type = down ? 'keydown' : 'keyup';
          this.key = key;
          this.character = character;
        },
        toString: function() {
          return "{ type: '" + this.type + "', key: '" + this.key + "', character: '" + this.character + "', modifiers: " + this.getModifiers() + " }";
        }
      });
      var Key = new function() {
        var specialKeys = {
          8: 'backspace',
          9: 'tab',
          13: 'enter',
          16: 'shift',
          17: 'control',
          18: 'option',
          19: 'pause',
          20: 'caps-lock',
          27: 'escape',
          32: 'space',
          35: 'end',
          36: 'home',
          37: 'left',
          38: 'up',
          39: 'right',
          40: 'down',
          46: 'delete',
          91: 'command',
          93: 'command',
          224: 'command'
        },
            specialChars = {
              9: true,
              13: true,
              32: true
            },
            modifiers = new Base({
              shift: false,
              control: false,
              option: false,
              command: false,
              capsLock: false,
              space: false
            }),
            charCodeMap = {},
            keyMap = {},
            commandFixMap,
            downCode;
        function handleKey(down, keyCode, charCode, event) {
          var character = charCode ? String.fromCharCode(charCode) : '',
              specialKey = specialKeys[keyCode],
              key = specialKey || character.toLowerCase(),
              type = down ? 'keydown' : 'keyup',
              view = View._focused,
              scope = view && view.isVisible() && view._scope,
              tool = scope && scope.tool,
              name;
          keyMap[key] = down;
          if (down) {
            charCodeMap[keyCode] = charCode;
          } else {
            delete charCodeMap[keyCode];
          }
          if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
            modifiers[name] = down;
            var browser = paper.browser;
            if (name === 'command' && browser && browser.mac) {
              if (down) {
                commandFixMap = {};
              } else {
                for (var code in commandFixMap) {
                  if (code in charCodeMap)
                    handleKey(false, code, commandFixMap[code], event);
                }
                commandFixMap = null;
              }
            }
          } else if (down && commandFixMap) {
            commandFixMap[keyCode] = charCode;
          }
          if (tool && tool.responds(type)) {
            paper = scope;
            tool.emit(type, new KeyEvent(down, key, character, event));
            if (view)
              view.update();
          }
        }
        DomEvent.add(document, {
          keydown: function(event) {
            var code = event.which || event.keyCode;
            if (code in specialKeys || modifiers.command) {
              handleKey(true, code, code in specialChars || modifiers.command ? code : 0, event);
            } else {
              downCode = code;
            }
          },
          keypress: function(event) {
            if (downCode != null) {
              handleKey(true, downCode, event.which || event.keyCode, event);
              downCode = null;
            }
          },
          keyup: function(event) {
            var code = event.which || event.keyCode;
            if (code in charCodeMap)
              handleKey(false, code, charCodeMap[code], event);
          }
        });
        DomEvent.add(window, {blur: function(event) {
            for (var code in charCodeMap)
              handleKey(false, code, charCodeMap[code], event);
          }});
        return {
          modifiers: modifiers,
          isDown: function(key) {
            return !!keyMap[key];
          }
        };
      };
      var MouseEvent = Event.extend({
        _class: 'MouseEvent',
        initialize: function MouseEvent(type, event, point, target, delta) {
          Event.call(this, event);
          this.type = type;
          this.point = point;
          this.target = target;
          this.delta = delta;
        },
        toString: function() {
          return "{ type: '" + this.type + "', point: " + this.point + ', target: ' + this.target + (this.delta ? ', delta: ' + this.delta : '') + ', modifiers: ' + this.getModifiers() + ' }';
        }
      });
      var ToolEvent = Event.extend({
        _class: 'ToolEvent',
        _item: null,
        initialize: function ToolEvent(tool, type, event) {
          this.tool = tool;
          this.type = type;
          this.event = event;
        },
        _choosePoint: function(point, toolPoint) {
          return point ? point : toolPoint ? toolPoint.clone() : null;
        },
        getPoint: function() {
          return this._choosePoint(this._point, this.tool._point);
        },
        setPoint: function(point) {
          this._point = point;
        },
        getLastPoint: function() {
          return this._choosePoint(this._lastPoint, this.tool._lastPoint);
        },
        setLastPoint: function(lastPoint) {
          this._lastPoint = lastPoint;
        },
        getDownPoint: function() {
          return this._choosePoint(this._downPoint, this.tool._downPoint);
        },
        setDownPoint: function(downPoint) {
          this._downPoint = downPoint;
        },
        getMiddlePoint: function() {
          if (!this._middlePoint && this.tool._lastPoint) {
            return this.tool._point.add(this.tool._lastPoint).divide(2);
          }
          return this._middlePoint;
        },
        setMiddlePoint: function(middlePoint) {
          this._middlePoint = middlePoint;
        },
        getDelta: function() {
          return !this._delta && this.tool._lastPoint ? this.tool._point.subtract(this.tool._lastPoint) : this._delta;
        },
        setDelta: function(delta) {
          this._delta = delta;
        },
        getCount: function() {
          return /^mouse(down|up)$/.test(this.type) ? this.tool._downCount : this.tool._count;
        },
        setCount: function(count) {
          this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count'] = count;
        },
        getItem: function() {
          if (!this._item) {
            var result = this.tool._scope.project.hitTest(this.getPoint());
            if (result) {
              var item = result.item,
                  parent = item._parent;
              while (/^(Group|CompoundPath)$/.test(parent._class)) {
                item = parent;
                parent = parent._parent;
              }
              this._item = item;
            }
          }
          return this._item;
        },
        setItem: function(item) {
          this._item = item;
        },
        toString: function() {
          return '{ type: ' + this.type + ', point: ' + this.getPoint() + ', count: ' + this.getCount() + ', modifiers: ' + this.getModifiers() + ' }';
        }
      });
      var Tool = PaperScopeItem.extend({
        _class: 'Tool',
        _list: 'tools',
        _reference: 'tool',
        _events: ['onActivate', 'onDeactivate', 'onEditOptions', 'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove', 'onKeyDown', 'onKeyUp'],
        initialize: function Tool(props) {
          PaperScopeItem.call(this);
          this._firstMove = true;
          this._count = 0;
          this._downCount = 0;
          this._set(props);
        },
        getMinDistance: function() {
          return this._minDistance;
        },
        setMinDistance: function(minDistance) {
          this._minDistance = minDistance;
          if (minDistance != null && this._maxDistance != null && minDistance > this._maxDistance) {
            this._maxDistance = minDistance;
          }
        },
        getMaxDistance: function() {
          return this._maxDistance;
        },
        setMaxDistance: function(maxDistance) {
          this._maxDistance = maxDistance;
          if (this._minDistance != null && maxDistance != null && maxDistance < this._minDistance) {
            this._minDistance = maxDistance;
          }
        },
        getFixedDistance: function() {
          return this._minDistance == this._maxDistance ? this._minDistance : null;
        },
        setFixedDistance: function(distance) {
          this._minDistance = this._maxDistance = distance;
        },
        _updateEvent: function(type, point, minDistance, maxDistance, start, needsChange, matchMaxDistance) {
          if (!start) {
            if (minDistance != null || maxDistance != null) {
              var minDist = minDistance != null ? minDistance : 0,
                  vector = point.subtract(this._point),
                  distance = vector.getLength();
              if (distance < minDist)
                return false;
              if (maxDistance != null && maxDistance != 0) {
                if (distance > maxDistance) {
                  point = this._point.add(vector.normalize(maxDistance));
                } else if (matchMaxDistance) {
                  return false;
                }
              }
            }
            if (needsChange && point.equals(this._point))
              return false;
          }
          this._lastPoint = start && type == 'mousemove' ? point : this._point;
          this._point = point;
          switch (type) {
            case 'mousedown':
              this._lastPoint = this._downPoint;
              this._downPoint = this._point;
              this._downCount++;
              break;
            case 'mouseup':
              this._lastPoint = this._downPoint;
              break;
          }
          this._count = start ? 0 : this._count + 1;
          return true;
        },
        _fireEvent: function(type, event) {
          var sets = paper.project._removeSets;
          if (sets) {
            if (type === 'mouseup')
              sets.mousedrag = null;
            var set = sets[type];
            if (set) {
              for (var id in set) {
                var item = set[id];
                for (var key in sets) {
                  var other = sets[key];
                  if (other && other != set)
                    delete other[item._id];
                }
                item.remove();
              }
              sets[type] = null;
            }
          }
          return this.responds(type) && this.emit(type, new ToolEvent(this, type, event));
        },
        _handleEvent: function(type, point, event) {
          paper = this._scope;
          var called = false;
          switch (type) {
            case 'mousedown':
              this._updateEvent(type, point, null, null, true, false, false);
              called = this._fireEvent(type, event);
              break;
            case 'mousedrag':
              var needsChange = false,
                  matchMaxDistance = false;
              while (this._updateEvent(type, point, this.minDistance, this.maxDistance, false, needsChange, matchMaxDistance)) {
                called = this._fireEvent(type, event) || called;
                needsChange = true;
                matchMaxDistance = true;
              }
              break;
            case 'mouseup':
              if (!point.equals(this._point) && this._updateEvent('mousedrag', point, this.minDistance, this.maxDistance, false, false, false)) {
                called = this._fireEvent('mousedrag', event);
              }
              this._updateEvent(type, point, null, this.maxDistance, false, false, false);
              called = this._fireEvent(type, event) || called;
              this._updateEvent(type, point, null, null, true, false, false);
              this._firstMove = true;
              break;
            case 'mousemove':
              while (this._updateEvent(type, point, this.minDistance, this.maxDistance, this._firstMove, true, false)) {
                called = this._fireEvent(type, event) || called;
                this._firstMove = false;
              }
              break;
          }
          if (called)
            event.preventDefault();
          return called;
        }
      });
      var Http = {request: function(method, url, callback, async) {
          async = (async === undefined) ? true : async;
          var xhr = new (window.ActiveXObject || XMLHttpRequest)('Microsoft.XMLHTTP');
          xhr.open(method.toUpperCase(), url, async);
          if ('overrideMimeType' in xhr)
            xhr.overrideMimeType('text/plain');
          xhr.onreadystatechange = function() {
            if (xhr.readyState === 4) {
              var status = xhr.status;
              if (status === 0 || status === 200) {
                callback.call(xhr, xhr.responseText);
              } else {
                throw new Error('Could not load ' + url + ' (Error ' + status + ')');
              }
            }
          };
          return xhr.send(null);
        }};
      var CanvasProvider = {
        canvases: [],
        getCanvas: function(width, height) {
          var canvas,
              clear = true;
          if (typeof width === 'object') {
            height = width.height;
            width = width.width;
          }
          if (this.canvases.length) {
            canvas = this.canvases.pop();
          } else {
            canvas = document.createElement('canvas');
          }
          var ctx = canvas.getContext('2d');
          if (canvas.width === width && canvas.height === height) {
            if (clear)
              ctx.clearRect(0, 0, width + 1, height + 1);
          } else {
            canvas.width = width;
            canvas.height = height;
          }
          ctx.save();
          return canvas;
        },
        getContext: function(width, height) {
          return this.getCanvas(width, height).getContext('2d');
        },
        release: function(obj) {
          var canvas = obj.canvas ? obj.canvas : obj;
          canvas.getContext('2d').restore();
          this.canvases.push(canvas);
        }
      };
      var BlendMode = new function() {
        var min = Math.min,
            max = Math.max,
            abs = Math.abs,
            sr,
            sg,
            sb,
            sa,
            br,
            bg,
            bb,
            ba,
            dr,
            dg,
            db;
        function getLum(r, g, b) {
          return 0.2989 * r + 0.587 * g + 0.114 * b;
        }
        function setLum(r, g, b, l) {
          var d = l - getLum(r, g, b);
          dr = r + d;
          dg = g + d;
          db = b + d;
          var l = getLum(dr, dg, db),
              mn = min(dr, dg, db),
              mx = max(dr, dg, db);
          if (mn < 0) {
            var lmn = l - mn;
            dr = l + (dr - l) * l / lmn;
            dg = l + (dg - l) * l / lmn;
            db = l + (db - l) * l / lmn;
          }
          if (mx > 255) {
            var ln = 255 - l,
                mxl = mx - l;
            dr = l + (dr - l) * ln / mxl;
            dg = l + (dg - l) * ln / mxl;
            db = l + (db - l) * ln / mxl;
          }
        }
        function getSat(r, g, b) {
          return max(r, g, b) - min(r, g, b);
        }
        function setSat(r, g, b, s) {
          var col = [r, g, b],
              mx = max(r, g, b),
              mn = min(r, g, b),
              md;
          mn = mn === r ? 0 : mn === g ? 1 : 2;
          mx = mx === r ? 0 : mx === g ? 1 : 2;
          md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
          if (col[mx] > col[mn]) {
            col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
            col[mx] = s;
          } else {
            col[md] = col[mx] = 0;
          }
          col[mn] = 0;
          dr = col[0];
          dg = col[1];
          db = col[2];
        }
        var modes = {
          multiply: function() {
            dr = br * sr / 255;
            dg = bg * sg / 255;
            db = bb * sb / 255;
          },
          screen: function() {
            dr = br + sr - (br * sr / 255);
            dg = bg + sg - (bg * sg / 255);
            db = bb + sb - (bb * sb / 255);
          },
          overlay: function() {
            dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
            dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
            db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
          },
          'soft-light': function() {
            var t = sr * br / 255;
            dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
            t = sg * bg / 255;
            dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
            t = sb * bb / 255;
            db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
          },
          'hard-light': function() {
            dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
            dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
            db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
          },
          'color-dodge': function() {
            dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
            dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
            db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
          },
          'color-burn': function() {
            dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
            dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
            db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
          },
          darken: function() {
            dr = br < sr ? br : sr;
            dg = bg < sg ? bg : sg;
            db = bb < sb ? bb : sb;
          },
          lighten: function() {
            dr = br > sr ? br : sr;
            dg = bg > sg ? bg : sg;
            db = bb > sb ? bb : sb;
          },
          difference: function() {
            dr = br - sr;
            if (dr < 0)
              dr = -dr;
            dg = bg - sg;
            if (dg < 0)
              dg = -dg;
            db = bb - sb;
            if (db < 0)
              db = -db;
          },
          exclusion: function() {
            dr = br + sr * (255 - br - br) / 255;
            dg = bg + sg * (255 - bg - bg) / 255;
            db = bb + sb * (255 - bb - bb) / 255;
          },
          hue: function() {
            setSat(sr, sg, sb, getSat(br, bg, bb));
            setLum(dr, dg, db, getLum(br, bg, bb));
          },
          saturation: function() {
            setSat(br, bg, bb, getSat(sr, sg, sb));
            setLum(dr, dg, db, getLum(br, bg, bb));
          },
          luminosity: function() {
            setLum(br, bg, bb, getLum(sr, sg, sb));
          },
          color: function() {
            setLum(sr, sg, sb, getLum(br, bg, bb));
          },
          add: function() {
            dr = min(br + sr, 255);
            dg = min(bg + sg, 255);
            db = min(bb + sb, 255);
          },
          subtract: function() {
            dr = max(br - sr, 0);
            dg = max(bg - sg, 0);
            db = max(bb - sb, 0);
          },
          average: function() {
            dr = (br + sr) / 2;
            dg = (bg + sg) / 2;
            db = (bb + sb) / 2;
          },
          negation: function() {
            dr = 255 - abs(255 - sr - br);
            dg = 255 - abs(255 - sg - bg);
            db = 255 - abs(255 - sb - bb);
          }
        };
        var nativeModes = this.nativeModes = Base.each(['source-over', 'source-in', 'source-out', 'source-atop', 'destination-over', 'destination-in', 'destination-out', 'destination-atop', 'lighter', 'darker', 'copy', 'xor'], function(mode) {
          this[mode] = true;
        }, {});
        var ctx = CanvasProvider.getContext(1, 1);
        Base.each(modes, function(func, mode) {
          var darken = mode === 'darken',
              ok = false;
          ctx.save();
          try {
            ctx.fillStyle = darken ? '#300' : '#a00';
            ctx.fillRect(0, 0, 1, 1);
            ctx.globalCompositeOperation = mode;
            if (ctx.globalCompositeOperation === mode) {
              ctx.fillStyle = darken ? '#a00' : '#300';
              ctx.fillRect(0, 0, 1, 1);
              ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
            }
          } catch (e) {}
          ctx.restore();
          nativeModes[mode] = ok;
        });
        CanvasProvider.release(ctx);
        this.process = function(mode, srcContext, dstContext, alpha, offset) {
          var srcCanvas = srcContext.canvas,
              normal = mode === 'normal';
          if (normal || nativeModes[mode]) {
            dstContext.save();
            dstContext.setTransform(1, 0, 0, 1, 0, 0);
            dstContext.globalAlpha = alpha;
            if (!normal)
              dstContext.globalCompositeOperation = mode;
            dstContext.drawImage(srcCanvas, offset.x, offset.y);
            dstContext.restore();
          } else {
            var process = modes[mode];
            if (!process)
              return;
            var dstData = dstContext.getImageData(offset.x, offset.y, srcCanvas.width, srcCanvas.height),
                dst = dstData.data,
                src = srcContext.getImageData(0, 0, srcCanvas.width, srcCanvas.height).data;
            for (var i = 0,
                l = dst.length; i < l; i += 4) {
              sr = src[i];
              br = dst[i];
              sg = src[i + 1];
              bg = dst[i + 1];
              sb = src[i + 2];
              bb = dst[i + 2];
              sa = src[i + 3];
              ba = dst[i + 3];
              process();
              var a1 = sa * alpha / 255,
                  a2 = 1 - a1;
              dst[i] = a1 * dr + a2 * br;
              dst[i + 1] = a1 * dg + a2 * bg;
              dst[i + 2] = a1 * db + a2 * bb;
              dst[i + 3] = sa * alpha + a2 * ba;
            }
            dstContext.putImageData(dstData, offset.x, offset.y);
          }
        };
      };
      var SVGStyles = Base.each({
        fillColor: ['fill', 'color'],
        strokeColor: ['stroke', 'color'],
        strokeWidth: ['stroke-width', 'number'],
        strokeCap: ['stroke-linecap', 'string'],
        strokeJoin: ['stroke-linejoin', 'string'],
        strokeScaling: ['vector-effect', 'lookup', {
          true: 'none',
          false: 'non-scaling-stroke'
        }, function(item, value) {
          return !value && (item instanceof PathItem || item instanceof Shape || item instanceof TextItem);
        }],
        miterLimit: ['stroke-miterlimit', 'number'],
        dashArray: ['stroke-dasharray', 'array'],
        dashOffset: ['stroke-dashoffset', 'number'],
        fontFamily: ['font-family', 'string'],
        fontWeight: ['font-weight', 'string'],
        fontSize: ['font-size', 'number'],
        justification: ['text-anchor', 'lookup', {
          left: 'start',
          center: 'middle',
          right: 'end'
        }],
        opacity: ['opacity', 'number'],
        blendMode: ['mix-blend-mode', 'string']
      }, function(entry, key) {
        var part = Base.capitalize(key),
            lookup = entry[2];
        this[key] = {
          type: entry[1],
          property: key,
          attribute: entry[0],
          toSVG: lookup,
          fromSVG: lookup && Base.each(lookup, function(value, name) {
            this[value] = name;
          }, {}),
          exportFilter: entry[3],
          get: 'get' + part,
          set: 'set' + part
        };
      }, {});
      var SVGNamespaces = {
        href: 'http://www.w3.org/1999/xlink',
        xlink: 'http://www.w3.org/2000/xmlns'
      };
      new function() {
        var formatter;
        function setAttributes(node, attrs) {
          for (var key in attrs) {
            var val = attrs[key],
                namespace = SVGNamespaces[key];
            if (typeof val === 'number')
              val = formatter.number(val);
            if (namespace) {
              node.setAttributeNS(namespace, key, val);
            } else {
              node.setAttribute(key, val);
            }
          }
          return node;
        }
        function createElement(tag, attrs) {
          return setAttributes(document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
        }
        function getTransform(matrix, coordinates, center) {
          var attrs = new Base(),
              trans = matrix.getTranslation();
          if (coordinates) {
            matrix = matrix.shiftless();
            var point = matrix._inverseTransform(trans);
            attrs[center ? 'cx' : 'x'] = point.x;
            attrs[center ? 'cy' : 'y'] = point.y;
            trans = null;
          }
          if (!matrix.isIdentity()) {
            var decomposed = matrix.decompose();
            if (decomposed && !decomposed.shearing) {
              var parts = [],
                  angle = decomposed.rotation,
                  scale = decomposed.scaling;
              if (trans && !trans.isZero())
                parts.push('translate(' + formatter.point(trans) + ')');
              if (!Numerical.isZero(scale.x - 1) || !Numerical.isZero(scale.y - 1))
                parts.push('scale(' + formatter.point(scale) + ')');
              if (angle)
                parts.push('rotate(' + formatter.number(angle) + ')');
              attrs.transform = parts.join(' ');
            } else {
              attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
            }
          }
          return attrs;
        }
        function exportGroup(item, options) {
          var attrs = getTransform(item._matrix),
              children = item._children;
          var node = createElement('g', attrs);
          for (var i = 0,
              l = children.length; i < l; i++) {
            var child = children[i];
            var childNode = exportSVG(child, options);
            if (childNode) {
              if (child.isClipMask()) {
                var clip = createElement('clipPath');
                clip.appendChild(childNode);
                setDefinition(child, clip, 'clip');
                setAttributes(node, {'clip-path': 'url(#' + clip.id + ')'});
              } else {
                node.appendChild(childNode);
              }
            }
          }
          return node;
        }
        function exportRaster(item, options) {
          var attrs = getTransform(item._matrix, true),
              size = item.getSize(),
              image = item.getImage();
          attrs.x -= size.width / 2;
          attrs.y -= size.height / 2;
          attrs.width = size.width;
          attrs.height = size.height;
          attrs.href = options.embedImages === false && image && image.src || item.toDataURL();
          return createElement('image', attrs);
        }
        function exportPath(item, options) {
          var matchShapes = options.matchShapes;
          if (matchShapes) {
            var shape = item.toShape(false);
            if (shape)
              return exportShape(shape, options);
          }
          var segments = item._segments,
              type,
              attrs = getTransform(item._matrix);
          if (segments.length === 0)
            return null;
          if (matchShapes && !item.hasHandles()) {
            if (segments.length >= 3) {
              type = item._closed ? 'polygon' : 'polyline';
              var parts = [];
              for (var i = 0,
                  l = segments.length; i < l; i++)
                parts.push(formatter.point(segments[i]._point));
              attrs.points = parts.join(' ');
            } else {
              type = 'line';
              var first = segments[0]._point,
                  last = segments[segments.length - 1]._point;
              attrs.set({
                x1: first.x,
                y1: first.y,
                x2: last.x,
                y2: last.y
              });
            }
          } else {
            type = 'path';
            attrs.d = item.getPathData(null, options.precision);
          }
          return createElement(type, attrs);
        }
        function exportShape(item) {
          var type = item._type,
              radius = item._radius,
              attrs = getTransform(item._matrix, true, type !== 'rectangle');
          if (type === 'rectangle') {
            type = 'rect';
            var size = item._size,
                width = size.width,
                height = size.height;
            attrs.x -= width / 2;
            attrs.y -= height / 2;
            attrs.width = width;
            attrs.height = height;
            if (radius.isZero())
              radius = null;
          }
          if (radius) {
            if (type === 'circle') {
              attrs.r = radius;
            } else {
              attrs.rx = radius.width;
              attrs.ry = radius.height;
            }
          }
          return createElement(type, attrs);
        }
        function exportCompoundPath(item, options) {
          var attrs = getTransform(item._matrix);
          var data = item.getPathData(null, options.precision);
          if (data)
            attrs.d = data;
          return createElement('path', attrs);
        }
        function exportPlacedSymbol(item, options) {
          var attrs = getTransform(item._matrix, true),
              symbol = item.getSymbol(),
              symbolNode = getDefinition(symbol, 'symbol'),
              definition = symbol.getDefinition(),
              bounds = definition.getBounds();
          if (!symbolNode) {
            symbolNode = createElement('symbol', {viewBox: formatter.rectangle(bounds)});
            symbolNode.appendChild(exportSVG(definition, options));
            setDefinition(symbol, symbolNode, 'symbol');
          }
          attrs.href = '#' + symbolNode.id;
          attrs.x += bounds.x;
          attrs.y += bounds.y;
          attrs.width = formatter.number(bounds.width);
          attrs.height = formatter.number(bounds.height);
          attrs.overflow = 'visible';
          return createElement('use', attrs);
        }
        function exportGradient(color) {
          var gradientNode = getDefinition(color, 'color');
          if (!gradientNode) {
            var gradient = color.getGradient(),
                radial = gradient._radial,
                origin = color.getOrigin().transform(),
                destination = color.getDestination().transform(),
                attrs;
            if (radial) {
              attrs = {
                cx: origin.x,
                cy: origin.y,
                r: origin.getDistance(destination)
              };
              var highlight = color.getHighlight();
              if (highlight) {
                highlight = highlight.transform();
                attrs.fx = highlight.x;
                attrs.fy = highlight.y;
              }
            } else {
              attrs = {
                x1: origin.x,
                y1: origin.y,
                x2: destination.x,
                y2: destination.y
              };
            }
            attrs.gradientUnits = 'userSpaceOnUse';
            gradientNode = createElement((radial ? 'radial' : 'linear') + 'Gradient', attrs);
            var stops = gradient._stops;
            for (var i = 0,
                l = stops.length; i < l; i++) {
              var stop = stops[i],
                  stopColor = stop._color,
                  alpha = stopColor.getAlpha();
              attrs = {
                offset: stop._rampPoint,
                'stop-color': stopColor.toCSS(true)
              };
              if (alpha < 1)
                attrs['stop-opacity'] = alpha;
              gradientNode.appendChild(createElement('stop', attrs));
            }
            setDefinition(color, gradientNode, 'color');
          }
          return 'url(#' + gradientNode.id + ')';
        }
        function exportText(item) {
          var node = createElement('text', getTransform(item._matrix, true));
          node.textContent = item._content;
          return node;
        }
        var exporters = {
          Group: exportGroup,
          Layer: exportGroup,
          Raster: exportRaster,
          Path: exportPath,
          Shape: exportShape,
          CompoundPath: exportCompoundPath,
          PlacedSymbol: exportPlacedSymbol,
          PointText: exportText
        };
        function applyStyle(item, node, isRoot) {
          var attrs = {},
              parent = !isRoot && item.getParent();
          if (item._name != null)
            attrs.id = item._name;
          Base.each(SVGStyles, function(entry) {
            var get = entry.get,
                type = entry.type,
                value = item[get]();
            if (entry.exportFilter ? entry.exportFilter(item, value) : !parent || !Base.equals(parent[get](), value)) {
              if (type === 'color' && value != null) {
                var alpha = value.getAlpha();
                if (alpha < 1)
                  attrs[entry.attribute + '-opacity'] = alpha;
              }
              attrs[entry.attribute] = value == null ? 'none' : type === 'number' ? formatter.number(value) : type === 'color' ? value.gradient ? exportGradient(value, item) : value.toCSS(true) : type === 'array' ? value.join(',') : type === 'lookup' ? entry.toSVG[value] : value;
            }
          });
          if (attrs.opacity === 1)
            delete attrs.opacity;
          if (!item._visible)
            attrs.visibility = 'hidden';
          return setAttributes(node, attrs);
        }
        var definitions;
        function getDefinition(item, type) {
          if (!definitions)
            definitions = {
              ids: {},
              svgs: {}
            };
          return item && definitions.svgs[type + '-' + item._id];
        }
        function setDefinition(item, node, type) {
          if (!definitions)
            getDefinition();
          var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
          node.id = type + '-' + id;
          definitions.svgs[type + '-' + item._id] = node;
        }
        function exportDefinitions(node, options) {
          var svg = node,
              defs = null;
          if (definitions) {
            svg = node.nodeName.toLowerCase() === 'svg' && node;
            for (var i in definitions.svgs) {
              if (!defs) {
                if (!svg) {
                  svg = createElement('svg');
                  svg.appendChild(node);
                }
                defs = svg.insertBefore(createElement('defs'), svg.firstChild);
              }
              defs.appendChild(definitions.svgs[i]);
            }
            definitions = null;
          }
          return options.asString ? new XMLSerializer().serializeToString(svg) : svg;
        }
        function exportSVG(item, options, isRoot) {
          var exporter = exporters[item._class],
              node = exporter && exporter(item, options);
          if (node) {
            var onExport = options.onExport;
            if (onExport)
              node = onExport(item, node, options) || node;
            var data = JSON.stringify(item._data);
            if (data && data !== '{}' && data !== 'null')
              node.setAttribute('data-paper-data', data);
          }
          return node && applyStyle(item, node, isRoot);
        }
        function setOptions(options) {
          if (!options)
            options = {};
          formatter = new Formatter(options.precision);
          return options;
        }
        Item.inject({exportSVG: function(options) {
            options = setOptions(options);
            return exportDefinitions(exportSVG(this, options, true), options);
          }});
        Project.inject({exportSVG: function(options) {
            options = setOptions(options);
            var layers = this.layers,
                view = this.getView(),
                size = view.getViewSize(),
                node = createElement('svg', {
                  x: 0,
                  y: 0,
                  width: size.width,
                  height: size.height,
                  version: '1.1',
                  xmlns: 'http://www.w3.org/2000/svg',
                  'xmlns:xlink': 'http://www.w3.org/1999/xlink'
                }),
                parent = node,
                matrix = view._matrix;
            if (!matrix.isIdentity())
              parent = node.appendChild(createElement('g', getTransform(matrix)));
            for (var i = 0,
                l = layers.length; i < l; i++)
              parent.appendChild(exportSVG(layers[i], options, true));
            return exportDefinitions(node, options);
          }});
      };
      new function() {
        function getValue(node, name, isString, allowNull) {
          var namespace = SVGNamespaces[name],
              value = namespace ? node.getAttributeNS(namespace, name) : node.getAttribute(name);
          if (value === 'null')
            value = null;
          return value == null ? allowNull ? null : isString ? '' : 0 : isString ? value : parseFloat(value);
        }
        function getPoint(node, x, y, allowNull) {
          x = getValue(node, x, false, allowNull);
          y = getValue(node, y, false, allowNull);
          return allowNull && (x == null || y == null) ? null : new Point(x, y);
        }
        function getSize(node, w, h, allowNull) {
          w = getValue(node, w, false, allowNull);
          h = getValue(node, h, false, allowNull);
          return allowNull && (w == null || h == null) ? null : new Size(w, h);
        }
        function convertValue(value, type, lookup) {
          return value === 'none' ? null : type === 'number' ? parseFloat(value) : type === 'array' ? value ? value.split(/[\s,]+/g).map(parseFloat) : [] : type === 'color' ? getDefinition(value) || value : type === 'lookup' ? lookup[value] : value;
        }
        function importGroup(node, type, options, isRoot) {
          var nodes = node.childNodes,
              isClip = type === 'clippath',
              item = new Group(),
              project = item._project,
              currentStyle = project._currentStyle,
              children = [];
          if (!isClip) {
            item = applyAttributes(item, node, isRoot);
            project._currentStyle = item._style.clone();
          }
          if (isRoot) {
            var defs = node.querySelectorAll('defs');
            for (var i = 0,
                l = defs.length; i < l; i++) {
              importSVG(defs[i], options, false);
            }
          }
          for (var i = 0,
              l = nodes.length; i < l; i++) {
            var childNode = nodes[i],
                child;
            if (childNode.nodeType === 1 && childNode.nodeName.toLowerCase() !== 'defs' && (child = importSVG(childNode, options, false)) && !(child instanceof Symbol))
              children.push(child);
          }
          item.addChildren(children);
          if (isClip)
            item = applyAttributes(item.reduce(), node, isRoot);
          project._currentStyle = currentStyle;
          if (isClip || type === 'defs') {
            item.remove();
            item = null;
          }
          return item;
        }
        function importPoly(node, type) {
          var coords = node.getAttribute('points').match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
              points = [];
          for (var i = 0,
              l = coords.length; i < l; i += 2)
            points.push(new Point(parseFloat(coords[i]), parseFloat(coords[i + 1])));
          var path = new Path(points);
          if (type === 'polygon')
            path.closePath();
          return path;
        }
        function importPath(node) {
          var data = node.getAttribute('d'),
              param = {pathData: data};
          return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data) ? new CompoundPath(param) : new Path(param);
        }
        function importGradient(node, type) {
          var id = (getValue(node, 'href', true) || '').substring(1),
              isRadial = type === 'radialgradient',
              gradient;
          if (id) {
            gradient = definitions[id].getGradient();
          } else {
            var nodes = node.childNodes,
                stops = [];
            for (var i = 0,
                l = nodes.length; i < l; i++) {
              var child = nodes[i];
              if (child.nodeType === 1)
                stops.push(applyAttributes(new GradientStop(), child));
            }
            gradient = new Gradient(stops, isRadial);
          }
          var origin,
              destination,
              highlight;
          if (isRadial) {
            origin = getPoint(node, 'cx', 'cy');
            destination = origin.add(getValue(node, 'r'), 0);
            highlight = getPoint(node, 'fx', 'fy', true);
          } else {
            origin = getPoint(node, 'x1', 'y1');
            destination = getPoint(node, 'x2', 'y2');
          }
          applyAttributes(new Color(gradient, origin, destination, highlight), node);
          return null;
        }
        var importers = {
          '#document': function(node, type, options, isRoot) {
            var nodes = node.childNodes;
            for (var i = 0,
                l = nodes.length; i < l; i++) {
              var child = nodes[i];
              if (child.nodeType === 1) {
                var next = child.nextSibling;
                document.body.appendChild(child);
                var item = importSVG(child, options, isRoot);
                if (next) {
                  node.insertBefore(child, next);
                } else {
                  node.appendChild(child);
                }
                return item;
              }
            }
          },
          g: importGroup,
          svg: importGroup,
          clippath: importGroup,
          polygon: importPoly,
          polyline: importPoly,
          path: importPath,
          lineargradient: importGradient,
          radialgradient: importGradient,
          image: function(node) {
            var raster = new Raster(getValue(node, 'href', true));
            raster.on('load', function() {
              var size = getSize(node, 'width', 'height');
              this.setSize(size);
              var center = this._matrix._transformPoint(getPoint(node, 'x', 'y').add(size.divide(2)));
              this.translate(center);
            });
            return raster;
          },
          symbol: function(node, type, options, isRoot) {
            return new Symbol(importGroup(node, type, options, isRoot), true);
          },
          defs: importGroup,
          use: function(node) {
            var id = (getValue(node, 'href', true) || '').substring(1),
                definition = definitions[id],
                point = getPoint(node, 'x', 'y');
            return definition ? definition instanceof Symbol ? definition.place(point) : definition.clone().translate(point) : null;
          },
          circle: function(node) {
            return new Shape.Circle(getPoint(node, 'cx', 'cy'), getValue(node, 'r'));
          },
          ellipse: function(node) {
            return new Shape.Ellipse({
              center: getPoint(node, 'cx', 'cy'),
              radius: getSize(node, 'rx', 'ry')
            });
          },
          rect: function(node) {
            var point = getPoint(node, 'x', 'y'),
                size = getSize(node, 'width', 'height'),
                radius = getSize(node, 'rx', 'ry');
            return new Shape.Rectangle(new Rectangle(point, size), radius);
          },
          line: function(node) {
            return new Path.Line(getPoint(node, 'x1', 'y1'), getPoint(node, 'x2', 'y2'));
          },
          text: function(node) {
            var text = new PointText(getPoint(node, 'x', 'y').add(getPoint(node, 'dx', 'dy')));
            text.setContent(node.textContent.trim() || '');
            return text;
          }
        };
        function applyTransform(item, value, name, node) {
          var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
              matrix = new Matrix();
          for (var i = 0,
              l = transforms.length; i < l; i++) {
            var transform = transforms[i];
            if (!transform)
              break;
            var parts = transform.split(/\(\s*/),
                command = parts[0],
                v = parts[1].split(/[\s,]+/g);
            for (var j = 0,
                m = v.length; j < m; j++)
              v[j] = parseFloat(v[j]);
            switch (command) {
              case 'matrix':
                matrix.concatenate(new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
                break;
              case 'rotate':
                matrix.rotate(v[0], v[1], v[2]);
                break;
              case 'translate':
                matrix.translate(v[0], v[1]);
                break;
              case 'scale':
                matrix.scale(v);
                break;
              case 'skewX':
                matrix.skew(v[0], 0);
                break;
              case 'skewY':
                matrix.skew(0, v[0]);
                break;
            }
          }
          item.transform(matrix);
        }
        function applyOpacity(item, value, name) {
          var color = item[name === 'fill-opacity' ? 'getFillColor' : 'getStrokeColor']();
          if (color)
            color.setAlpha(parseFloat(value));
        }
        var attributes = Base.set(Base.each(SVGStyles, function(entry) {
          this[entry.attribute] = function(item, value) {
            item[entry.set](convertValue(value, entry.type, entry.fromSVG));
            if (entry.type === 'color' && item instanceof Shape) {
              var color = item[entry.get]();
              if (color)
                color.transform(new Matrix().translate(item.getPosition(true).negate()));
            }
          };
        }, {}), {
          id: function(item, value) {
            definitions[value] = item;
            if (item.setName)
              item.setName(value);
          },
          'clip-path': function(item, value) {
            var clip = getDefinition(value);
            if (clip) {
              clip = clip.clone();
              clip.setClipMask(true);
              if (item instanceof Group) {
                item.insertChild(0, clip);
              } else {
                return new Group(clip, item);
              }
            }
          },
          gradientTransform: applyTransform,
          transform: applyTransform,
          'fill-opacity': applyOpacity,
          'stroke-opacity': applyOpacity,
          visibility: function(item, value) {
            item.setVisible(value === 'visible');
          },
          display: function(item, value) {
            item.setVisible(value !== null);
          },
          'stop-color': function(item, value) {
            if (item.setColor)
              item.setColor(value);
          },
          'stop-opacity': function(item, value) {
            if (item._color)
              item._color.setAlpha(parseFloat(value));
          },
          offset: function(item, value) {
            var percentage = value.match(/(.*)%$/);
            item.setRampPoint(percentage ? percentage[1] / 100 : parseFloat(value));
          },
          viewBox: function(item, value, name, node, styles) {
            var rect = new Rectangle(convertValue(value, 'array')),
                size = getSize(node, 'width', 'height', true);
            if (item instanceof Group) {
              var scale = size ? rect.getSize().divide(size) : 1,
                  matrix = new Matrix().translate(rect.getPoint()).scale(scale);
              item.transform(matrix.inverted());
            } else if (item instanceof Symbol) {
              if (size)
                rect.setSize(size);
              var clip = getAttribute(node, 'overflow', styles) != 'visible',
                  group = item._definition;
              if (clip && !rect.contains(group.getBounds())) {
                clip = new Shape.Rectangle(rect).transform(group._matrix);
                clip.setClipMask(true);
                group.addChild(clip);
              }
            }
          }
        });
        function getAttribute(node, name, styles) {
          var attr = node.attributes[name],
              value = attr && attr.value;
          if (!value) {
            var style = Base.camelize(name);
            value = node.style[style];
            if (!value && styles.node[style] !== styles.parent[style])
              value = styles.node[style];
          }
          return !value ? undefined : value === 'none' ? null : value;
        }
        function applyAttributes(item, node, isRoot) {
          var styles = {
            node: DomElement.getStyles(node) || {},
            parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
          };
          Base.each(attributes, function(apply, name) {
            var value = getAttribute(node, name, styles);
            if (value !== undefined)
              item = Base.pick(apply(item, value, name, node, styles), item);
          });
          return item;
        }
        var definitions = {};
        function getDefinition(value) {
          var match = value && value.match(/\((?:#|)([^)']+)/);
          return match && definitions[match[1]];
        }
        function importSVG(source, options, isRoot) {
          if (!source)
            return null;
          if (!options) {
            options = {};
          } else if (typeof options === 'function') {
            options = {onLoad: options};
          }
          var node = source,
              scope = paper;
          function onLoadCallback(svg) {
            paper = scope;
            var item = importSVG(svg, options, isRoot),
                onLoad = options.onLoad,
                view = scope.project && scope.getView();
            if (onLoad)
              onLoad.call(this, item);
            view.update();
          }
          if (isRoot) {
            if (typeof source === 'string' && !/^.*</.test(source)) {
              node = document.getElementById(source);
              if (node) {
                source = null;
              } else {
                return Http.request('get', source, onLoadCallback);
              }
            } else if (typeof File !== 'undefined' && source instanceof File) {
              var reader = new FileReader();
              reader.onload = function() {
                onLoadCallback(reader.result);
              };
              return reader.readAsText(source);
            }
          }
          if (typeof source === 'string')
            node = new DOMParser().parseFromString(source, 'image/svg+xml');
          if (!node.nodeName)
            throw new Error('Unsupported SVG source: ' + source);
          var type = node.nodeName.toLowerCase(),
              importer = importers[type],
              item,
              data = node.getAttribute && node.getAttribute('data-paper-data'),
              settings = scope.settings,
              applyMatrix = settings.applyMatrix;
          settings.applyMatrix = false;
          item = importer && importer(node, type, options, isRoot) || null;
          settings.applyMatrix = applyMatrix;
          if (item) {
            if (type !== '#document' && !(item instanceof Group))
              item = applyAttributes(item, node, isRoot);
            var onImport = options.onImport;
            if (onImport)
              item = onImport(node, item, options) || item;
            if (options.expandShapes && item instanceof Shape) {
              item.remove();
              item = item.toPath();
            }
            if (data)
              item._data = JSON.parse(data);
          }
          if (isRoot) {
            definitions = {};
            if (item && Base.pick(options.applyMatrix, applyMatrix))
              item.matrix.apply(true, true);
          }
          return item;
        }
        Item.inject({importSVG: function(node, options) {
            return this.addChild(importSVG(node, options, true));
          }});
        Project.inject({importSVG: function(node, options) {
            this.activate();
            return importSVG(node, options, true);
          }});
      };
      Base.exports.PaperScript = (function() {
        var exports,
            define,
            scope = this;
        !function(e, r) {
          return "object" == typeof exports && "object" == typeof module ? r(exports) : "function" == typeof define && define.amd ? define(["exports"], r) : (r(e.acorn || (e.acorn = {})), void 0);
        }(this, function(e) {
          "use strict";
          function r(e) {
            fr = e || {};
            for (var r in mr)
              Object.prototype.hasOwnProperty.call(fr, r) || (fr[r] = mr[r]);
            hr = fr.sourceFile || null;
          }
          function t(e, r) {
            var t = vr(dr, e);
            r += " (" + t.line + ":" + t.column + ")";
            var n = new SyntaxError(r);
            throw n.pos = e, n.loc = t, n.raisedAt = br, n;
          }
          function n(e) {
            function r(e) {
              if (1 == e.length)
                return t += "return str === " + JSON.stringify(e[0]) + ";";
              t += "switch(str){";
              for (var r = 0; r < e.length; ++r)
                t += "case " + JSON.stringify(e[r]) + ":";
              t += "return true}return false;";
            }
            e = e.split(" ");
            var t = "",
                n = [];
            e: for (var a = 0; a < e.length; ++a) {
              for (var o = 0; o < n.length; ++o)
                if (n[o][0].length == e[a].length) {
                  n[o].push(e[a]);
                  continue e;
                }
              n.push([e[a]]);
            }
            if (n.length > 3) {
              n.sort(function(e, r) {
                return r.length - e.length;
              }), t += "switch(str.length){";
              for (var a = 0; a < n.length; ++a) {
                var i = n[a];
                t += "case " + i[0].length + ":", r(i);
              }
              t += "}";
            } else
              r(e);
            return new Function("str", t);
          }
          function a() {
            this.line = Ar, this.column = br - Sr;
          }
          function o() {
            Ar = 1, br = Sr = 0, Er = !0, u();
          }
          function i(e, r) {
            gr = br, fr.locations && (kr = new a), wr = e, u(), Cr = r, Er = e.beforeExpr;
          }
          function s() {
            var e = fr.onComment && fr.locations && new a,
                r = br,
                n = dr.indexOf("*/", br += 2);
            if (-1 === n && t(br - 2, "Unterminated comment"), br = n + 2, fr.locations) {
              Kt.lastIndex = r;
              for (var o; (o = Kt.exec(dr)) && o.index < br; )
                ++Ar, Sr = o.index + o[0].length;
            }
            fr.onComment && fr.onComment(!0, dr.slice(r + 2, n), r, br, e, fr.locations && new a);
          }
          function c() {
            for (var e = br,
                r = fr.onComment && fr.locations && new a,
                t = dr.charCodeAt(br += 2); pr > br && 10 !== t && 13 !== t && 8232 !== t && 8233 !== t; )
              ++br, t = dr.charCodeAt(br);
            fr.onComment && fr.onComment(!1, dr.slice(e + 2, br), e, br, r, fr.locations && new a);
          }
          function u() {
            for (; pr > br; ) {
              var e = dr.charCodeAt(br);
              if (32 === e)
                ++br;
              else if (13 === e) {
                ++br;
                var r = dr.charCodeAt(br);
                10 === r && ++br, fr.locations && (++Ar, Sr = br);
              } else if (10 === e || 8232 === e || 8233 === e)
                ++br, fr.locations && (++Ar, Sr = br);
              else if (e > 8 && 14 > e)
                ++br;
              else if (47 === e) {
                var r = dr.charCodeAt(br + 1);
                if (42 === r)
                  s();
                else {
                  if (47 !== r)
                    break;
                  c();
                }
              } else if (160 === e)
                ++br;
              else {
                if (!(e >= 5760 && Jt.test(String.fromCharCode(e))))
                  break;
                ++br;
              }
            }
          }
          function l() {
            var e = dr.charCodeAt(br + 1);
            return e >= 48 && 57 >= e ? E(!0) : (++br, i(xt));
          }
          function f() {
            var e = dr.charCodeAt(br + 1);
            return Er ? (++br, k()) : 61 === e ? x(Et, 2) : x(wt, 1);
          }
          function d() {
            var e = dr.charCodeAt(br + 1);
            return 61 === e ? x(Et, 2) : x(Dt, 1);
          }
          function p(e) {
            var r = dr.charCodeAt(br + 1);
            return r === e ? x(124 === e ? Lt : Ut, 2) : 61 === r ? x(Et, 2) : x(124 === e ? Rt : Tt, 1);
          }
          function h() {
            var e = dr.charCodeAt(br + 1);
            return 61 === e ? x(Et, 2) : x(Vt, 1);
          }
          function m(e) {
            var r = dr.charCodeAt(br + 1);
            return r === e ? 45 == r && 62 == dr.charCodeAt(br + 2) && Gt.test(dr.slice(Lr, br)) ? (br += 3, c(), u(), g()) : x(St, 2) : 61 === r ? x(Et, 2) : x(At, 1);
          }
          function v(e) {
            var r = dr.charCodeAt(br + 1),
                t = 1;
            return r === e ? (t = 62 === e && 62 === dr.charCodeAt(br + 2) ? 3 : 2, 61 === dr.charCodeAt(br + t) ? x(Et, t + 1) : x(jt, t)) : 33 == r && 60 == e && 45 == dr.charCodeAt(br + 2) && 45 == dr.charCodeAt(br + 3) ? (br += 4, c(), u(), g()) : (61 === r && (t = 61 === dr.charCodeAt(br + 2) ? 3 : 2), x(Ot, t));
          }
          function b(e) {
            var r = dr.charCodeAt(br + 1);
            return 61 === r ? x(qt, 61 === dr.charCodeAt(br + 2) ? 3 : 2) : x(61 === e ? Ct : It, 1);
          }
          function y(e) {
            switch (e) {
              case 46:
                return l();
              case 40:
                return ++br, i(mt);
              case 41:
                return ++br, i(vt);
              case 59:
                return ++br, i(yt);
              case 44:
                return ++br, i(bt);
              case 91:
                return ++br, i(ft);
              case 93:
                return ++br, i(dt);
              case 123:
                return ++br, i(pt);
              case 125:
                return ++br, i(ht);
              case 58:
                return ++br, i(gt);
              case 63:
                return ++br, i(kt);
              case 48:
                var r = dr.charCodeAt(br + 1);
                if (120 === r || 88 === r)
                  return C();
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return E(!1);
              case 34:
              case 39:
                return A(e);
              case 47:
                return f(e);
              case 37:
              case 42:
                return d();
              case 124:
              case 38:
                return p(e);
              case 94:
                return h();
              case 43:
              case 45:
                return m(e);
              case 60:
              case 62:
                return v(e);
              case 61:
              case 33:
                return b(e);
              case 126:
                return x(It, 1);
            }
            return !1;
          }
          function g(e) {
            if (e ? br = yr + 1 : yr = br, fr.locations && (xr = new a), e)
              return k();
            if (br >= pr)
              return i(Br);
            var r = dr.charCodeAt(br);
            if (Qt(r) || 92 === r)
              return L();
            var n = y(r);
            if (n === !1) {
              var o = String.fromCharCode(r);
              if ("\\" === o || $t.test(o))
                return L();
              t(br, "Unexpected character '" + o + "'");
            }
            return n;
          }
          function x(e, r) {
            var t = dr.slice(br, br + r);
            br += r, i(e, t);
          }
          function k() {
            for (var e,
                r,
                n = "",
                a = br; ; ) {
              br >= pr && t(a, "Unterminated regular expression");
              var o = dr.charAt(br);
              if (Gt.test(o) && t(a, "Unterminated regular expression"), e)
                e = !1;
              else {
                if ("[" === o)
                  r = !0;
                else if ("]" === o && r)
                  r = !1;
                else if ("/" === o && !r)
                  break;
                e = "\\" === o;
              }
              ++br;
            }
            var n = dr.slice(a, br);
            ++br;
            var s = I();
            return s && !/^[gmsiy]*$/.test(s) && t(a, "Invalid regexp flag"), i(jr, new RegExp(n, s));
          }
          function w(e, r) {
            for (var t = br,
                n = 0,
                a = 0,
                o = null == r ? 1 / 0 : r; o > a; ++a) {
              var i,
                  s = dr.charCodeAt(br);
              if (i = s >= 97 ? s - 97 + 10 : s >= 65 ? s - 65 + 10 : s >= 48 && 57 >= s ? s - 48 : 1 / 0, i >= e)
                break;
              ++br, n = n * e + i;
            }
            return br === t || null != r && br - t !== r ? null : n;
          }
          function C() {
            br += 2;
            var e = w(16);
            return null == e && t(yr + 2, "Expected hexadecimal number"), Qt(dr.charCodeAt(br)) && t(br, "Identifier directly after number"), i(Or, e);
          }
          function E(e) {
            var r = br,
                n = !1,
                a = 48 === dr.charCodeAt(br);
            e || null !== w(10) || t(r, "Invalid number"), 46 === dr.charCodeAt(br) && (++br, w(10), n = !0);
            var o = dr.charCodeAt(br);
            (69 === o || 101 === o) && (o = dr.charCodeAt(++br), (43 === o || 45 === o) && ++br, null === w(10) && t(r, "Invalid number"), n = !0), Qt(dr.charCodeAt(br)) && t(br, "Identifier directly after number");
            var s,
                c = dr.slice(r, br);
            return n ? s = parseFloat(c) : a && 1 !== c.length ? /[89]/.test(c) || Tr ? t(r, "Invalid number") : s = parseInt(c, 8) : s = parseInt(c, 10), i(Or, s);
          }
          function A(e) {
            br++;
            for (var r = ""; ; ) {
              br >= pr && t(yr, "Unterminated string constant");
              var n = dr.charCodeAt(br);
              if (n === e)
                return ++br, i(Dr, r);
              if (92 === n) {
                n = dr.charCodeAt(++br);
                var a = /^[0-7]+/.exec(dr.slice(br, br + 3));
                for (a && (a = a[0]); a && parseInt(a, 8) > 255; )
                  a = a.slice(0, a.length - 1);
                if ("0" === a && (a = null), ++br, a)
                  Tr && t(br - 2, "Octal literal in strict mode"), r += String.fromCharCode(parseInt(a, 8)), br += a.length - 1;
                else
                  switch (n) {
                    case 110:
                      r += "\n";
                      break;
                    case 114:
                      r += "\r";
                      break;
                    case 120:
                      r += String.fromCharCode(S(2));
                      break;
                    case 117:
                      r += String.fromCharCode(S(4));
                      break;
                    case 85:
                      r += String.fromCharCode(S(8));
                      break;
                    case 116:
                      r += "	";
                      break;
                    case 98:
                      r += "\b";
                      break;
                    case 118:
                      r += "";
                      break;
                    case 102:
                      r += "\f";
                      break;
                    case 48:
                      r += "\0";
                      break;
                    case 13:
                      10 === dr.charCodeAt(br) && ++br;
                    case 10:
                      fr.locations && (Sr = br, ++Ar);
                      break;
                    default:
                      r += String.fromCharCode(n);
                  }
              } else
                (13 === n || 10 === n || 8232 === n || 8233 === n) && t(yr, "Unterminated string constant"), r += String.fromCharCode(n), ++br;
            }
          }
          function S(e) {
            var r = w(16, e);
            return null === r && t(yr, "Bad character escape sequence"), r;
          }
          function I() {
            Bt = !1;
            for (var e,
                r = !0,
                n = br; ; ) {
              var a = dr.charCodeAt(br);
              if (Yt(a))
                Bt && (e += dr.charAt(br)), ++br;
              else {
                if (92 !== a)
                  break;
                Bt || (e = dr.slice(n, br)), Bt = !0, 117 != dr.charCodeAt(++br) && t(br, "Expecting Unicode escape sequence \\uXXXX"), ++br;
                var o = S(4),
                    i = String.fromCharCode(o);
                i || t(br - 1, "Invalid Unicode escape"), (r ? Qt(o) : Yt(o)) || t(br - 4, "Invalid Unicode escape"), e += i;
              }
              r = !1;
            }
            return Bt ? e : dr.slice(n, br);
          }
          function L() {
            var e = I(),
                r = Fr;
            return Bt || (Wt(e) ? r = lt[e] : (fr.forbidReserved && (3 === fr.ecmaVersion ? Mt : zt)(e) || Tr && Xt(e)) && t(yr, "The keyword '" + e + "' is reserved")), i(r, e);
          }
          function U() {
            Ir = yr, Lr = gr, Ur = kr, g();
          }
          function R(e) {
            if (Tr = e, br = Lr, fr.locations)
              for (; Sr > br; )
                Sr = dr.lastIndexOf("\n", Sr - 2) + 1, --Ar;
            u(), g();
          }
          function V() {
            this.type = null, this.start = yr, this.end = null;
          }
          function T() {
            this.start = xr, this.end = null, null !== hr && (this.source = hr);
          }
          function q() {
            var e = new V;
            return fr.locations && (e.loc = new T), fr.ranges && (e.range = [yr, 0]), e;
          }
          function O(e) {
            var r = new V;
            return r.start = e.start, fr.locations && (r.loc = new T, r.loc.start = e.loc.start), fr.ranges && (r.range = [e.range[0], 0]), r;
          }
          function j(e, r) {
            return e.type = r, e.end = Lr, fr.locations && (e.loc.end = Ur), fr.ranges && (e.range[1] = Lr), e;
          }
          function D(e) {
            return fr.ecmaVersion >= 5 && "ExpressionStatement" === e.type && "Literal" === e.expression.type && "use strict" === e.expression.value;
          }
          function F(e) {
            return wr === e ? (U(), !0) : void 0;
          }
          function B() {
            return !fr.strictSemicolons && (wr === Br || wr === ht || Gt.test(dr.slice(Lr, yr)));
          }
          function M() {
            F(yt) || B() || X();
          }
          function z(e) {
            wr === e ? U() : X();
          }
          function X() {
            t(yr, "Unexpected token");
          }
          function N(e) {
            "Identifier" !== e.type && "MemberExpression" !== e.type && t(e.start, "Assigning to rvalue"), Tr && "Identifier" === e.type && Nt(e.name) && t(e.start, "Assigning to " + e.name + " in strict mode");
          }
          function W(e) {
            Ir = Lr = br, fr.locations && (Ur = new a), Rr = Tr = null, Vr = [], g();
            var r = e || q(),
                t = !0;
            for (e || (r.body = []); wr !== Br; ) {
              var n = J();
              r.body.push(n), t && D(n) && R(!0), t = !1;
            }
            return j(r, "Program");
          }
          function J() {
            (wr === wt || wr === Et && "/=" == Cr) && g(!0);
            var e = wr,
                r = q();
            switch (e) {
              case Mr:
              case Nr:
                U();
                var n = e === Mr;
                F(yt) || B() ? r.label = null : wr !== Fr ? X() : (r.label = lr(), M());
                for (var a = 0; a < Vr.length; ++a) {
                  var o = Vr[a];
                  if (null == r.label || o.name === r.label.name) {
                    if (null != o.kind && (n || "loop" === o.kind))
                      break;
                    if (r.label && n)
                      break;
                  }
                }
                return a === Vr.length && t(r.start, "Unsyntactic " + e.keyword), j(r, n ? "BreakStatement" : "ContinueStatement");
              case Wr:
                return U(), M(), j(r, "DebuggerStatement");
              case Pr:
                return U(), Vr.push(Zt), r.body = J(), Vr.pop(), z(tt), r.test = P(), M(), j(r, "DoWhileStatement");
              case _r:
                if (U(), Vr.push(Zt), z(mt), wr === yt)
                  return $(r, null);
                if (wr === rt) {
                  var i = q();
                  return U(), G(i, !0), j(i, "VariableDeclaration"), 1 === i.declarations.length && F(ut) ? _(r, i) : $(r, i);
                }
                var i = K(!1, !0);
                return F(ut) ? (N(i), _(r, i)) : $(r, i);
              case Gr:
                return U(), cr(r, !0);
              case Kr:
                return U(), r.test = P(), r.consequent = J(), r.alternate = F(Hr) ? J() : null, j(r, "IfStatement");
              case Qr:
                return Rr || t(yr, "'return' outside of function"), U(), F(yt) || B() ? r.argument = null : (r.argument = K(), M()), j(r, "ReturnStatement");
              case Yr:
                U(), r.discriminant = P(), r.cases = [], z(pt), Vr.push(en);
                for (var s,
                    c; wr != ht; )
                  if (wr === zr || wr === Jr) {
                    var u = wr === zr;
                    s && j(s, "SwitchCase"), r.cases.push(s = q()), s.consequent = [], U(), u ? s.test = K() : (c && t(Ir, "Multiple default clauses"), c = !0, s.test = null), z(gt);
                  } else
                    s || X(), s.consequent.push(J());
                return s && j(s, "SwitchCase"), U(), Vr.pop(), j(r, "SwitchStatement");
              case Zr:
                return U(), Gt.test(dr.slice(Lr, yr)) && t(Lr, "Illegal newline after throw"), r.argument = K(), M(), j(r, "ThrowStatement");
              case et:
                if (U(), r.block = H(), r.handler = null, wr === Xr) {
                  var l = q();
                  U(), z(mt), l.param = lr(), Tr && Nt(l.param.name) && t(l.param.start, "Binding " + l.param.name + " in strict mode"), z(vt), l.guard = null, l.body = H(), r.handler = j(l, "CatchClause");
                }
                return r.guardedHandlers = qr, r.finalizer = F($r) ? H() : null, r.handler || r.finalizer || t(r.start, "Missing catch or finally clause"), j(r, "TryStatement");
              case rt:
                return U(), G(r), M(), j(r, "VariableDeclaration");
              case tt:
                return U(), r.test = P(), Vr.push(Zt), r.body = J(), Vr.pop(), j(r, "WhileStatement");
              case nt:
                return Tr && t(yr, "'with' in strict mode"), U(), r.object = P(), r.body = J(), j(r, "WithStatement");
              case pt:
                return H();
              case yt:
                return U(), j(r, "EmptyStatement");
              default:
                var f = Cr,
                    d = K();
                if (e === Fr && "Identifier" === d.type && F(gt)) {
                  for (var a = 0; a < Vr.length; ++a)
                    Vr[a].name === f && t(d.start, "Label '" + f + "' is already declared");
                  var p = wr.isLoop ? "loop" : wr === Yr ? "switch" : null;
                  return Vr.push({
                    name: f,
                    kind: p
                  }), r.body = J(), Vr.pop(), r.label = d, j(r, "LabeledStatement");
                }
                return r.expression = d, M(), j(r, "ExpressionStatement");
            }
          }
          function P() {
            z(mt);
            var e = K();
            return z(vt), e;
          }
          function H(e) {
            var r,
                t = q(),
                n = !0,
                a = !1;
            for (t.body = [], z(pt); !F(ht); ) {
              var o = J();
              t.body.push(o), n && e && D(o) && (r = a, R(a = !0)), n = !1;
            }
            return a && !r && R(!1), j(t, "BlockStatement");
          }
          function $(e, r) {
            return e.init = r, z(yt), e.test = wr === yt ? null : K(), z(yt), e.update = wr === vt ? null : K(), z(vt), e.body = J(), Vr.pop(), j(e, "ForStatement");
          }
          function _(e, r) {
            return e.left = r, e.right = K(), z(vt), e.body = J(), Vr.pop(), j(e, "ForInStatement");
          }
          function G(e, r) {
            for (e.declarations = [], e.kind = "var"; ; ) {
              var n = q();
              if (n.id = lr(), Tr && Nt(n.id.name) && t(n.id.start, "Binding " + n.id.name + " in strict mode"), n.init = F(Ct) ? K(!0, r) : null, e.declarations.push(j(n, "VariableDeclarator")), !F(bt))
                break;
            }
            return e;
          }
          function K(e, r) {
            var t = Q(r);
            if (!e && wr === bt) {
              var n = O(t);
              for (n.expressions = [t]; F(bt); )
                n.expressions.push(Q(r));
              return j(n, "SequenceExpression");
            }
            return t;
          }
          function Q(e) {
            var r = Y(e);
            if (wr.isAssign) {
              var t = O(r);
              return t.operator = Cr, t.left = r, U(), t.right = Q(e), N(r), j(t, "AssignmentExpression");
            }
            return r;
          }
          function Y(e) {
            var r = Z(e);
            if (F(kt)) {
              var t = O(r);
              return t.test = r, t.consequent = K(!0), z(gt), t.alternate = K(!0, e), j(t, "ConditionalExpression");
            }
            return r;
          }
          function Z(e) {
            return er(rr(), -1, e);
          }
          function er(e, r, t) {
            var n = wr.binop;
            if (null != n && (!t || wr !== ut) && n > r) {
              var a = O(e);
              a.left = e, a.operator = Cr, U(), a.right = er(rr(), n, t);
              var o = j(a, /&&|\|\|/.test(a.operator) ? "LogicalExpression" : "BinaryExpression");
              return er(o, r, t);
            }
            return e;
          }
          function rr() {
            if (wr.prefix) {
              var e = q(),
                  r = wr.isUpdate;
              return e.operator = Cr, e.prefix = !0, Er = !0, U(), e.argument = rr(), r ? N(e.argument) : Tr && "delete" === e.operator && "Identifier" === e.argument.type && t(e.start, "Deleting local variable in strict mode"), j(e, r ? "UpdateExpression" : "UnaryExpression");
            }
            for (var n = tr(); wr.postfix && !B(); ) {
              var e = O(n);
              e.operator = Cr, e.prefix = !1, e.argument = n, N(n), U(), n = j(e, "UpdateExpression");
            }
            return n;
          }
          function tr() {
            return nr(ar());
          }
          function nr(e, r) {
            if (F(xt)) {
              var t = O(e);
              return t.object = e, t.property = lr(!0), t.computed = !1, nr(j(t, "MemberExpression"), r);
            }
            if (F(ft)) {
              var t = O(e);
              return t.object = e, t.property = K(), t.computed = !0, z(dt), nr(j(t, "MemberExpression"), r);
            }
            if (!r && F(mt)) {
              var t = O(e);
              return t.callee = e, t.arguments = ur(vt, !1), nr(j(t, "CallExpression"), r);
            }
            return e;
          }
          function ar() {
            switch (wr) {
              case ot:
                var e = q();
                return U(), j(e, "ThisExpression");
              case Fr:
                return lr();
              case Or:
              case Dr:
              case jr:
                var e = q();
                return e.value = Cr, e.raw = dr.slice(yr, gr), U(), j(e, "Literal");
              case it:
              case st:
              case ct:
                var e = q();
                return e.value = wr.atomValue, e.raw = wr.keyword, U(), j(e, "Literal");
              case mt:
                var r = xr,
                    t = yr;
                U();
                var n = K();
                return n.start = t, n.end = gr, fr.locations && (n.loc.start = r, n.loc.end = kr), fr.ranges && (n.range = [t, gr]), z(vt), n;
              case ft:
                var e = q();
                return U(), e.elements = ur(dt, !0, !0), j(e, "ArrayExpression");
              case pt:
                return ir();
              case Gr:
                var e = q();
                return U(), cr(e, !1);
              case at:
                return or();
              default:
                X();
            }
          }
          function or() {
            var e = q();
            return U(), e.callee = nr(ar(), !0), e.arguments = F(mt) ? ur(vt, !1) : qr, j(e, "NewExpression");
          }
          function ir() {
            var e = q(),
                r = !0,
                n = !1;
            for (e.properties = [], U(); !F(ht); ) {
              if (r)
                r = !1;
              else if (z(bt), fr.allowTrailingCommas && F(ht))
                break;
              var a,
                  o = {key: sr()},
                  i = !1;
              if (F(gt) ? (o.value = K(!0), a = o.kind = "init") : fr.ecmaVersion >= 5 && "Identifier" === o.key.type && ("get" === o.key.name || "set" === o.key.name) ? (i = n = !0, a = o.kind = o.key.name, o.key = sr(), wr !== mt && X(), o.value = cr(q(), !1)) : X(), "Identifier" === o.key.type && (Tr || n))
                for (var s = 0; s < e.properties.length; ++s) {
                  var c = e.properties[s];
                  if (c.key.name === o.key.name) {
                    var u = a == c.kind || i && "init" === c.kind || "init" === a && ("get" === c.kind || "set" === c.kind);
                    u && !Tr && "init" === a && "init" === c.kind && (u = !1), u && t(o.key.start, "Redefinition of property");
                  }
                }
              e.properties.push(o);
            }
            return j(e, "ObjectExpression");
          }
          function sr() {
            return wr === Or || wr === Dr ? ar() : lr(!0);
          }
          function cr(e, r) {
            wr === Fr ? e.id = lr() : r ? X() : e.id = null, e.params = [];
            var n = !0;
            for (z(mt); !F(vt); )
              n ? n = !1 : z(bt), e.params.push(lr());
            var a = Rr,
                o = Vr;
            if (Rr = !0, Vr = [], e.body = H(!0), Rr = a, Vr = o, Tr || e.body.body.length && D(e.body.body[0]))
              for (var i = e.id ? -1 : 0; i < e.params.length; ++i) {
                var s = 0 > i ? e.id : e.params[i];
                if ((Xt(s.name) || Nt(s.name)) && t(s.start, "Defining '" + s.name + "' in strict mode"), i >= 0)
                  for (var c = 0; i > c; ++c)
                    s.name === e.params[c].name && t(s.start, "Argument name clash in strict mode");
              }
            return j(e, r ? "FunctionDeclaration" : "FunctionExpression");
          }
          function ur(e, r, t) {
            for (var n = [],
                a = !0; !F(e); ) {
              if (a)
                a = !1;
              else if (z(bt), r && fr.allowTrailingCommas && F(e))
                break;
              t && wr === bt ? n.push(null) : n.push(K(!0));
            }
            return n;
          }
          function lr(e) {
            var r = q();
            return r.name = wr === Fr ? Cr : e && !fr.forbidReserved && wr.keyword || X(), Er = !1, U(), j(r, "Identifier");
          }
          e.version = "0.4.0";
          var fr,
              dr,
              pr,
              hr;
          e.parse = function(e, t) {
            return dr = String(e), pr = dr.length, r(t), o(), W(fr.program);
          };
          var mr = e.defaultOptions = {
            ecmaVersion: 5,
            strictSemicolons: !1,
            allowTrailingCommas: !0,
            forbidReserved: !1,
            locations: !1,
            onComment: null,
            ranges: !1,
            program: null,
            sourceFile: null
          },
              vr = e.getLineInfo = function(e, r) {
                for (var t = 1,
                    n = 0; ; ) {
                  Kt.lastIndex = n;
                  var a = Kt.exec(e);
                  if (!(a && a.index < r))
                    break;
                  ++t, n = a.index + a[0].length;
                }
                return {
                  line: t,
                  column: r - n
                };
              };
          e.tokenize = function(e, t) {
            function n(e) {
              return g(e), a.start = yr, a.end = gr, a.startLoc = xr, a.endLoc = kr, a.type = wr, a.value = Cr, a;
            }
            dr = String(e), pr = dr.length, r(t), o();
            var a = {};
            return n.jumpTo = function(e, r) {
              if (br = e, fr.locations) {
                Ar = 1, Sr = Kt.lastIndex = 0;
                for (var t; (t = Kt.exec(dr)) && t.index < e; )
                  ++Ar, Sr = t.index + t[0].length;
              }
              Er = r, u();
            }, n;
          };
          var br,
              yr,
              gr,
              xr,
              kr,
              wr,
              Cr,
              Er,
              Ar,
              Sr,
              Ir,
              Lr,
              Ur,
              Rr,
              Vr,
              Tr,
              qr = [],
              Or = {type: "num"},
              jr = {type: "regexp"},
              Dr = {type: "string"},
              Fr = {type: "name"},
              Br = {type: "eof"},
              Mr = {keyword: "break"},
              zr = {
                keyword: "case",
                beforeExpr: !0
              },
              Xr = {keyword: "catch"},
              Nr = {keyword: "continue"},
              Wr = {keyword: "debugger"},
              Jr = {keyword: "default"},
              Pr = {
                keyword: "do",
                isLoop: !0
              },
              Hr = {
                keyword: "else",
                beforeExpr: !0
              },
              $r = {keyword: "finally"},
              _r = {
                keyword: "for",
                isLoop: !0
              },
              Gr = {keyword: "function"},
              Kr = {keyword: "if"},
              Qr = {
                keyword: "return",
                beforeExpr: !0
              },
              Yr = {keyword: "switch"},
              Zr = {
                keyword: "throw",
                beforeExpr: !0
              },
              et = {keyword: "try"},
              rt = {keyword: "var"},
              tt = {
                keyword: "while",
                isLoop: !0
              },
              nt = {keyword: "with"},
              at = {
                keyword: "new",
                beforeExpr: !0
              },
              ot = {keyword: "this"},
              it = {
                keyword: "null",
                atomValue: null
              },
              st = {
                keyword: "true",
                atomValue: !0
              },
              ct = {
                keyword: "false",
                atomValue: !1
              },
              ut = {
                keyword: "in",
                binop: 7,
                beforeExpr: !0
              },
              lt = {
                "break": Mr,
                "case": zr,
                "catch": Xr,
                "continue": Nr,
                "debugger": Wr,
                "default": Jr,
                "do": Pr,
                "else": Hr,
                "finally": $r,
                "for": _r,
                "function": Gr,
                "if": Kr,
                "return": Qr,
                "switch": Yr,
                "throw": Zr,
                "try": et,
                "var": rt,
                "while": tt,
                "with": nt,
                "null": it,
                "true": st,
                "false": ct,
                "new": at,
                "in": ut,
                "instanceof": {
                  keyword: "instanceof",
                  binop: 7,
                  beforeExpr: !0
                },
                "this": ot,
                "typeof": {
                  keyword: "typeof",
                  prefix: !0,
                  beforeExpr: !0
                },
                "void": {
                  keyword: "void",
                  prefix: !0,
                  beforeExpr: !0
                },
                "delete": {
                  keyword: "delete",
                  prefix: !0,
                  beforeExpr: !0
                }
              },
              ft = {
                type: "[",
                beforeExpr: !0
              },
              dt = {type: "]"},
              pt = {
                type: "{",
                beforeExpr: !0
              },
              ht = {type: "}"},
              mt = {
                type: "(",
                beforeExpr: !0
              },
              vt = {type: ")"},
              bt = {
                type: ",",
                beforeExpr: !0
              },
              yt = {
                type: ";",
                beforeExpr: !0
              },
              gt = {
                type: ":",
                beforeExpr: !0
              },
              xt = {type: "."},
              kt = {
                type: "?",
                beforeExpr: !0
              },
              wt = {
                binop: 10,
                beforeExpr: !0
              },
              Ct = {
                isAssign: !0,
                beforeExpr: !0
              },
              Et = {
                isAssign: !0,
                beforeExpr: !0
              },
              At = {
                binop: 9,
                prefix: !0,
                beforeExpr: !0
              },
              St = {
                postfix: !0,
                prefix: !0,
                isUpdate: !0
              },
              It = {
                prefix: !0,
                beforeExpr: !0
              },
              Lt = {
                binop: 1,
                beforeExpr: !0
              },
              Ut = {
                binop: 2,
                beforeExpr: !0
              },
              Rt = {
                binop: 3,
                beforeExpr: !0
              },
              Vt = {
                binop: 4,
                beforeExpr: !0
              },
              Tt = {
                binop: 5,
                beforeExpr: !0
              },
              qt = {
                binop: 6,
                beforeExpr: !0
              },
              Ot = {
                binop: 7,
                beforeExpr: !0
              },
              jt = {
                binop: 8,
                beforeExpr: !0
              },
              Dt = {
                binop: 10,
                beforeExpr: !0
              };
          e.tokTypes = {
            bracketL: ft,
            bracketR: dt,
            braceL: pt,
            braceR: ht,
            parenL: mt,
            parenR: vt,
            comma: bt,
            semi: yt,
            colon: gt,
            dot: xt,
            question: kt,
            slash: wt,
            eq: Ct,
            name: Fr,
            eof: Br,
            num: Or,
            regexp: jr,
            string: Dr
          };
          for (var Ft in lt)
            e.tokTypes["_" + Ft] = lt[Ft];
          var Bt,
              Mt = n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),
              zt = n("class enum extends super const export import"),
              Xt = n("implements interface let package private protected public static yield"),
              Nt = n("eval arguments"),
              Wt = n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),
              Jt = /[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,
              Pt = "\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",
              Ht = "\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",
              $t = new RegExp("[" + Pt + "]"),
              _t = new RegExp("[" + Pt + Ht + "]"),
              Gt = /[\n\r\u2028\u2029]/,
              Kt = /\r\n|[\n\r\u2028\u2029]/g,
              Qt = e.isIdentifierStart = function(e) {
                return 65 > e ? 36 === e : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && $t.test(String.fromCharCode(e));
              },
              Yt = e.isIdentifierChar = function(e) {
                return 48 > e ? 36 === e : 58 > e ? !0 : 65 > e ? !1 : 91 > e ? !0 : 97 > e ? 95 === e : 123 > e ? !0 : e >= 170 && _t.test(String.fromCharCode(e));
              },
              Zt = {kind: "loop"},
              en = {kind: "switch"};
        });
        var binaryOperators = {
          '+': '__add',
          '-': '__subtract',
          '*': '__multiply',
          '/': '__divide',
          '%': '__modulo',
          '==': 'equals',
          '!=': 'equals'
        };
        var unaryOperators = {
          '-': '__negate',
          '+': null
        };
        var fields = Base.each(['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'], function(name) {
          this['__' + name] = '#' + name;
        }, {});
        Point.inject(fields);
        Size.inject(fields);
        Color.inject(fields);
        function __$__(left, operator, right) {
          var handler = binaryOperators[operator];
          if (left && left[handler]) {
            var res = left[handler](right);
            return operator === '!=' ? !res : res;
          }
          switch (operator) {
            case '+':
              return left + right;
            case '-':
              return left - right;
            case '*':
              return left * right;
            case '/':
              return left / right;
            case '%':
              return left % right;
            case '==':
              return left == right;
            case '!=':
              return left != right;
          }
        }
        function $__(operator, value) {
          var handler = unaryOperators[operator];
          if (handler && value && value[handler])
            return value[handler]();
          switch (operator) {
            case '+':
              return +value;
            case '-':
              return -value;
          }
        }
        function parse(code, options) {
          return scope.acorn.parse(code, options);
        }
        function compile(code, url, options) {
          if (!code)
            return '';
          options = options || {};
          url = url || '';
          var insertions = [];
          function getOffset(offset) {
            for (var i = 0,
                l = insertions.length; i < l; i++) {
              var insertion = insertions[i];
              if (insertion[0] >= offset)
                break;
              offset += insertion[1];
            }
            return offset;
          }
          function getCode(node) {
            return code.substring(getOffset(node.range[0]), getOffset(node.range[1]));
          }
          function getBetween(left, right) {
            return code.substring(getOffset(left.range[1]), getOffset(right.range[0]));
          }
          function replaceCode(node, str) {
            var start = getOffset(node.range[0]),
                end = getOffset(node.range[1]),
                insert = 0;
            for (var i = insertions.length - 1; i >= 0; i--) {
              if (start > insertions[i][0]) {
                insert = i + 1;
                break;
              }
            }
            insertions.splice(insert, 0, [start, str.length - end + start]);
            code = code.substring(0, start) + str + code.substring(end);
          }
          function walkAST(node, parent) {
            if (!node)
              return;
            for (var key in node) {
              if (key === 'range' || key === 'loc')
                continue;
              var value = node[key];
              if (Array.isArray(value)) {
                for (var i = 0,
                    l = value.length; i < l; i++)
                  walkAST(value[i], node);
              } else if (value && typeof value === 'object') {
                walkAST(value, node);
              }
            }
            switch (node.type) {
              case 'UnaryExpression':
                if (node.operator in unaryOperators && node.argument.type !== 'Literal') {
                  var arg = getCode(node.argument);
                  replaceCode(node, '$__("' + node.operator + '", ' + arg + ')');
                }
                break;
              case 'BinaryExpression':
                if (node.operator in binaryOperators && node.left.type !== 'Literal') {
                  var left = getCode(node.left),
                      right = getCode(node.right),
                      between = getBetween(node.left, node.right),
                      operator = node.operator;
                  replaceCode(node, '__$__(' + left + ',' + between.replace(new RegExp('\\' + operator), '"' + operator + '"') + ', ' + right + ')');
                }
                break;
              case 'UpdateExpression':
              case 'AssignmentExpression':
                var parentType = parent && parent.type;
                if (!(parentType === 'ForStatement' || parentType === 'BinaryExpression' && /^[=!<>]/.test(parent.operator) || parentType === 'MemberExpression' && parent.computed)) {
                  if (node.type === 'UpdateExpression') {
                    var arg = getCode(node.argument),
                        exp = '__$__(' + arg + ', "' + node.operator[0] + '", 1)',
                        str = arg + ' = ' + exp;
                    if (!node.prefix && (parentType === 'AssignmentExpression' || parentType === 'VariableDeclarator')) {
                      if (getCode(parent.left || parent.id) === arg)
                        str = exp;
                      str = arg + '; ' + str;
                    }
                    replaceCode(node, str);
                  } else {
                    if (/^.=$/.test(node.operator) && node.left.type !== 'Literal') {
                      var left = getCode(node.left),
                          right = getCode(node.right);
                      replaceCode(node, left + ' = __$__(' + left + ', "' + node.operator[0] + '", ' + right + ')');
                    }
                  }
                }
                break;
            }
          }
          var sourceMap = null,
              browser = paper.browser,
              version = browser.versionNumber,
              lineBreaks = /\r\n|\n|\r/mg;
          if (browser.chrome && version >= 30 || browser.webkit && version >= 537.76 || browser.firefox && version >= 23) {
            var offset = 0;
            if (window.location.href.indexOf(url) === 0) {
              var html = document.getElementsByTagName('html')[0].innerHTML;
              offset = html.substr(0, html.indexOf(code) + 1).match(lineBreaks).length + 1;
            }
            var mappings = ['AAAA'];
            mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
            sourceMap = {
              version: 3,
              file: url,
              names: [],
              mappings: mappings.join(';AACA'),
              sourceRoot: '',
              sources: [url]
            };
            var source = options.source || !url && code;
            if (source)
              sourceMap.sourcesContent = [source];
          }
          walkAST(parse(code, {ranges: true}));
          if (sourceMap) {
            code = new Array(offset + 1).join('\n') + code + "\n" + (btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))))) + "\n//# sourceURL=" + (url || 'paperscript');
          }
          return code;
        }
        function execute(code, scope, url, options) {
          paper = scope;
          var view = scope.getView(),
              tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code) ? new Tool() : null,
              toolHandlers = tool ? tool._events : [],
              handlers = ['onFrame', 'onResize'].concat(toolHandlers),
              params = [],
              args = [],
              func;
          code = compile(code, url, options);
          function expose(scope, hidden) {
            for (var key in scope) {
              if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)' + key.replace(/\$/g, '\\$') + '\\b').test(code)) {
                params.push(key);
                args.push(scope[key]);
              }
            }
          }
          expose({
            __$__: __$__,
            $__: $__,
            paper: scope,
            view: view,
            tool: tool
          }, true);
          expose(scope);
          handlers = Base.each(handlers, function(key) {
            if (new RegExp('\\s+' + key + '\\b').test(code)) {
              params.push(key);
              this.push(key + ': ' + key);
            }
          }, []).join(', ');
          if (handlers)
            code += '\nreturn { ' + handlers + ' };';
          var browser = paper.browser;
          if (browser.chrome || browser.firefox) {
            var script = document.createElement('script'),
                head = document.head || document.getElementsByTagName('head')[0];
            if (browser.firefox)
              code = '\n' + code;
            script.appendChild(document.createTextNode('paper._execute = function(' + params + ') {' + code + '\n}'));
            head.appendChild(script);
            func = paper._execute;
            delete paper._execute;
            head.removeChild(script);
          } else {
            func = Function(params, code);
          }
          var res = func.apply(scope, args) || {};
          Base.each(toolHandlers, function(key) {
            var value = res[key];
            if (value)
              tool[key] = value;
          });
          if (view) {
            if (res.onResize)
              view.setOnResize(res.onResize);
            view.emit('resize', {
              size: view.size,
              delta: new Point()
            });
            if (res.onFrame)
              view.setOnFrame(res.onFrame);
            view.update();
          }
        }
        function loadScript(script) {
          if (/^text\/(?:x-|)paperscript$/.test(script.type) && PaperScope.getAttribute(script, 'ignore') !== 'true') {
            var canvasId = PaperScope.getAttribute(script, 'canvas'),
                canvas = document.getElementById(canvasId),
                src = script.src || script.getAttribute('data-src'),
                async = PaperScope.hasAttribute(script, 'async'),
                scopeAttribute = 'data-paper-scope';
            if (!canvas)
              throw new Error('Unable to find canvas with id "' + canvasId + '"');
            var scope = PaperScope.get(canvas.getAttribute(scopeAttribute)) || new PaperScope().setup(canvas);
            canvas.setAttribute(scopeAttribute, scope._id);
            if (src) {
              Http.request('get', src, function(code) {
                execute(code, scope, src);
              }, async);
            } else {
              execute(script.innerHTML, scope, script.baseURI);
            }
            script.setAttribute('data-paper-ignore', 'true');
            return scope;
          }
        }
        function loadAll() {
          Base.each(document.getElementsByTagName('script'), loadScript);
        }
        function load(script) {
          return script ? loadScript(script) : loadAll();
        }
        if (document.readyState === 'complete') {
          setTimeout(loadAll);
        } else {
          DomEvent.add(window, {load: loadAll});
        }
        return {
          compile: compile,
          execute: execute,
          load: load,
          parse: parse
        };
      }).call(this);
      paper = new (PaperScope.inject(Base.exports, {
        enumerable: true,
        Base: Base,
        Numerical: Numerical,
        Key: Key
      }))();
      if (typeof define === 'function' && define.amd) {
        define('paper', paper);
      } else if (typeof module === 'object' && module) {
        module.exports = paper;
      }
      return paper;
    };
  })($__require('22'));
  return module.exports;
});

$__System.registerDynamic("13", ["21"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('21');
  return module.exports;
});

$__System.register('f', ['3', '10', '11', '12', '13', '14', '15', '16', '17', '20'], function (_export) {
    var $, Configuration, RODAN_EVENTS, GUI_EVENTS, paper, _get, _inherits, _createClass, _classCallCheck, Radio, itemMap, BaseItem;

    return {
        setters: [function (_5) {
            $ = _5['default'];
        }, function (_8) {
            Configuration = _8['default'];
        }, function (_9) {
            RODAN_EVENTS = _9['default'];
        }, function (_10) {
            GUI_EVENTS = _10['default'];
        }, function (_7) {
            paper = _7['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }],
        execute: function () {
            'use strict';

            itemMap = null;

            /**
             * Base Item in WorkflowBuilder
             */

            BaseItem = (function (_paper$Path) {
                _inherits(BaseItem, _paper$Path);

                _createClass(BaseItem, null, [{
                    key: 'getAssociatedItem',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC STATIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns associated item given a URL.
                     */
                    value: function getAssociatedItem(url) {
                        if (!itemMap) {
                            itemMap = {};
                        }
                        return itemMap[url];
                    }

                    /**
                     * Associates given item with URL.
                     */
                }, {
                    key: 'associateItemWithUrl',
                    value: function associateItemWithUrl(item, url) {
                        if (!itemMap) {
                            itemMap = {};
                        }
                        itemMap[url] = item;
                    }

                    /**
                     * Removes item from map witht he provided URL.
                     */
                }, {
                    key: 'removeItemFromMap',
                    value: function removeItemFromMap(url) {
                        if (!itemMap) {
                            itemMap = {};
                        }
                        if (itemMap[url]) {
                            delete itemMap[url];
                        }
                    }

                    /**
                     * Update all items.
                     */
                }, {
                    key: 'updateItems',
                    value: function updateItems() {
                        if (!itemMap) {
                            itemMap = {};
                        }
                        for (var url in itemMap) {
                            var item = itemMap[url];
                            item.update();
                        }
                    }

                    /**
                     * Clears the map.
                     */
                }, {
                    key: 'clearMap',
                    value: function clearMap() {
                        itemMap = {};
                    }

                    /**
                     * Returns context menu data for multiple items of this class.
                     */
                }, {
                    key: 'getContextMenuDataMultiple',
                    value: function getContextMenuDataMultiple() {
                        return [{ channel: 'rodan-client_gui', label: 'Cancel', radiorequest: GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_HIDE_CONTEXTMENU }];
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Constructor.
                     */
                }]);

                function BaseItem(options) {
                    _classCallCheck(this, BaseItem);

                    _get(Object.getPrototypeOf(BaseItem.prototype), 'constructor', this).call(this, options.segments);
                    this._initializeRadio(options);
                    this._initializeAppearance(options);
                    this._initializeModelBinding(options);
                    this._initializeText(options);
                    this._initializeInputEventHandlers(options);
                }

                /**
                 * Returns associated model.
                 */

                _createClass(BaseItem, [{
                    key: 'getModel',
                    value: function getModel() {
                        return this._model;
                    }

                    /**
                     * Returns context menu data for single item of this class.
                     */
                }, {
                    key: 'getContextMenuDataSingle',
                    value: function getContextMenuDataSingle() {
                        var menuItems = [];
                        if (this.menuItems) {
                            menuItems = this.menuItems;
                        }
                        return menuItems;
                    }

                    /**
                     * Return true iff this item can be moved by itself.
                     */
                }, {
                    key: 'isMoveable',
                    value: function isMoveable() {
                        return true;
                    }

                    /**
                     * Moves the item.
                     */
                }, {
                    key: 'move',
                    value: function move(delta) {
                        this.position.x += delta.x;
                        this.position.y += delta.y;
                        if (this._text !== null) {
                            this._text.position = this.bounds.center;
                        }
                        this._hasMoved = true;
                    }

                    /**
                     * Set position.
                     */
                }, {
                    key: 'setPosition',
                    value: function setPosition(point) {
                        this.position = point;
                        if (this._text !== null) {
                            this._text.position = this.bounds.center;
                        }
                        this._hasMoved = true;
                    }

                    /**
                     * Set visibility.
                     */
                }, {
                    key: 'setVisible',
                    value: function setVisible(visible) {
                        this.visible = visible;
                        this._text.visible = this._useText && this.visible;
                    }

                    /**
                     * Destroy.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        BaseItem.removeItemFromMap(this._modelURL);
                        this._text.remove();
                        this.remove();
                    }

                    /**
                     * Updates the position to the server.
                     */
                }, {
                    key: 'updatePositionToServer',
                    value: function updatePositionToServer() {
                        if (this.isMoveable() && this._hasMoved) {
                            // If an ID exists, we know it exists on the server, so we can patch it.
                            // Else if we haven't tried saving it before, do it. This should create
                            // a new model on the server.
                            if (this._coordinateSetModel.id || !this._coordinateSetSaveAttempted) {
                                this._coordinateSetSaveAttempted = true;
                                var x = this.position.x / paper.view.zoom / paper.view.size.width;
                                var y = this.position.y / paper.view.zoom / paper.view.size.height;
                                var coordinates = { x: x, y: y };
                                this._coordinateSetModel.set({ 'data': coordinates });
                                this._coordinateSetModel.save();
                                this._hasMoved = false;
                            }
                        }
                    }

                    /**
                     * Gets coordinates from server.
                     */
                }, {
                    key: 'loadCoordinates',
                    value: function loadCoordinates() {
                        var _this = this;

                        // Create query.
                        var query = {};
                        query[this.coordinateSetInfo['url']] = this._modelId;
                        query['user_agent'] = Configuration.USER_AGENT;

                        // Create callback.
                        var callback = function callback(coordinates) {
                            return _this._handleCoordinateLoadSuccess(coordinates);
                        };

                        // Create model and fetch.
                        var name = this.coordinateSetInfo['class'];
                        var options = {};
                        options[this.coordinateSetInfo['url']] = this._modelURL;
                        options['user_agent'] = Configuration.WORKFLOWBUILDERGUI.USER_AGENT;
                        this._coordinateSetModel = new name(options);
                        this._coordinateSetModel.fetch({ data: query, success: callback, error: callback });
                    }

                    /**
                     * Returns associated model ID.
                     */
                }, {
                    key: 'getModelID',
                    value: function getModelID() {
                        return this._modelId;
                    }

                    /**
                     * Returns associated model URL.
                     */
                }, {
                    key: 'getModelURL',
                    value: function getModelURL() {
                        return this._modelURL;
                    }

                    /**
                     * Highlights this object.
                     */
                }, {
                    key: 'setHighlight',
                    value: function setHighlight(highlighted) {
                        this.strokeColor = highlighted ? Configuration.WORKFLOWBUILDERGUI.STROKE_COLOR_SELECTED : Configuration.WORKFLOWBUILDERGUI.STROKE_COLOR;
                        this.strokeWidth = highlighted ? Configuration.WORKFLOWBUILDERGUI.STROKE_WIDTH_SELECTED : Configuration.WORKFLOWBUILDERGUI.STROKE_WIDTH;
                    }

                    /**
                     * Gets description.
                     */
                }, {
                    key: 'getDescription',
                    value: function getDescription() {
                        if (this._description && this._description !== '') {
                            return this._description;
                        } else {
                            return 'no description available';
                        }
                    }

                    /**
                     * Sets temporary color.
                     */
                }, {
                    key: 'setTemporaryColor',
                    value: function setTemporaryColor(color) {
                        this._temporaryColor = color;
                    }

                    /**
                     * Clears temporary color.
                     */
                }, {
                    key: 'clearTemporaryColor',
                    value: function clearTemporaryColor() {
                        this._temporaryColor = null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // ABSTRACT METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Abstract method. Update.
                     */
                }, {
                    key: 'update',
                    value: function update() {
                        // TODO - better way to do abstract methods
                        console.error('This must be defined in sub-class.');
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Backbone event handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event model sync.
                     */
                }, {
                    key: '_handleEventModelSync',
                    value: function _handleEventModelSync(options) {
                        this._model = options.model;
                        switch (options.options.task) {
                            case 'save':
                                {
                                    this._text.content = this._model.get('name');
                                    this._description = this._model.getDescription();
                                    break;
                                }

                            case 'destroy':
                                {
                                    this.destroy();
                                    break;
                                }

                            default:
                                {
                                    break;
                                }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize hover.
                     */
                }, {
                    key: '_initializeHover',
                    value: function _initializeHover(options) {
                        this._timerEvent = null;
                        this._popup = new paper.PointText(new paper.Point(0, 0));
                    }

                    /**
                     * Initialize appearance.
                     */
                }, {
                    key: '_initializeAppearance',
                    value: function _initializeAppearance(options) {
                        this.strokeColor = Configuration.WORKFLOWBUILDERGUI.STROKE_COLOR;
                        this.strokeJoin = 'round';
                        this.strokeWidth = Configuration.WORKFLOWBUILDERGUI.STROKE_WIDTH;
                        this.fillColor = Configuration.WORKFLOWBUILDERGUI.FILL_COLOR;
                        this._temporaryColor = null;
                    }

                    /**
                     * Initialize model binding.
                     */
                }, {
                    key: '_initializeModelBinding',
                    value: function _initializeModelBinding(options) {
                        this._model = options.model ? options.model : null;
                        this._modelId = options.model ? options.model.id : null;
                        this._modelURL = options.model ? options.model.get('url') : null;
                        this._description = options.model ? options.model.getDescription() : null;
                        BaseItem.associateItemWithUrl(this, this._modelURL);

                        // This is the coordinate set model settings. Should be overridden if want to save.
                        this.coordinateSetInfo = null;
                        this._coordinateSetModel = null;
                        this._coordinateSetSaveAttempted = false;
                    }

                    /**
                     * Initialize event handlers.
                     */
                }, {
                    key: '_initializeInputEventHandlers',
                    value: function _initializeInputEventHandlers(options) {
                        var _this2 = this;

                        this.onMouseDown = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this.onMouseUp = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this.onClick = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this.onMouseEnter = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this.onMouseLeave = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this.onDoubleClick = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onMouseDown = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onMouseUp = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onClick = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onMouseEnter = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onMouseLeave = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                        this._text.onDoubleClick = function (event) {
                            return _this2._handleMouseEvent(event);
                        };
                    }

                    /**
                     * Initialize text.
                     */
                }, {
                    key: '_initializeText',
                    value: function _initializeText(options) {
                        this._useText = options.hasOwnProperty('text') && options.text === true;
                        this._text = new paper.PointText(new paper.Point(0, 0));
                        this._text.justification = 'center';
                        this._text.fillColor = Configuration.WORKFLOWBUILDERGUI.STROKE_COLOR;
                        this._text.fontSize = Configuration.WORKFLOWBUILDERGUI.FONT_SIZE;
                        this._text.content = '';
                        this._text.position = this.bounds.center;
                        this.addChild(this._text);
                        if (options.model) {
                            this._text.content = options.model.get('name');
                        }
                    }

                    /**
                     * Initialize radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio(options) {
                        var _this3 = this;

                        this.guiChannel = Radio.channel('rodan-client_gui');
                        this.rodanChannel = Radio.channel('rodan');
                        if (options && options.model) {
                            this.rodanChannel.on(RODAN_EVENTS.EVENT__MODEL_SYNC + options.model.get('url'), function (options) {
                                return _this3._handleEventModelSync(options);
                            });
                        }
                    }

                    /**
                     * Handle coordinate load success.
                     */
                }, {
                    key: '_handleCoordinateLoadSuccess',
                    value: function _handleCoordinateLoadSuccess(coordinateSet) {
                        var coordinates = coordinateSet.get('data');
                        if (coordinates) {
                            this._coordinateSetModel = coordinateSet;
                            this.position = new paper.Point(coordinates.x * paper.view.size.width * paper.view.zoom, coordinates.y * paper.view.size.height * paper.view.zoom);
                        }
                    }

                    /**
                     * Shows popup.
                     */
                }, {
                    key: '_showPopup',
                    value: function _showPopup(event) {
                        if ($('div#canvas-tooltip')) {
                            var description = this.getDescription();
                            var tooltip = $('div#canvas-tooltip');
                            tooltip.css('visibility', 'visible');
                            tooltip.css('top', event.event.y);
                            tooltip.css('left', event.event.x);
                            tooltip.text(description);
                        }
                    }

                    /**
                     * Hide popup.
                     */
                }, {
                    key: '_hidePopup',
                    value: function _hidePopup() {
                        if ($('div#canvas-tooltip')) {
                            $('div#canvas-tooltip').css('visibility', 'hidden');
                        }
                    }

                    /**
                     * Handle mouse event.
                     */
                }, {
                    key: '_handleMouseEvent',
                    value: function _handleMouseEvent(event) {
                        var _this4 = this;

                        // We do this because paperjs doesn't bubble up events.
                        // This line guarantees that events caught by the TEXT actually get to the parent base item.
                        event.target = this;

                        switch (event.type) {
                            case 'mouseenter':
                                {
                                    this._timerEvent = setTimeout(function () {
                                        return _this4._showPopup(event);
                                    }, Configuration.WORKFLOWBUILDERGUI.HOVER_TIME);
                                    paper.handleMouseEvent(event);
                                    break;
                                }

                            case 'mouseleave':
                                {
                                    this._hidePopup();
                                    clearTimeout(this._timerEvent);
                                    paper.handleMouseEvent(event);
                                    break;
                                }

                            case 'mouseup':
                                {
                                    this._handleMouseUp(event);
                                    break;
                                }

                            case 'mousedown':
                                {
                                    this._handleMouseDown(event);
                                    break;
                                }

                            case 'click':
                                {
                                    this._handleClick(event);
                                    break;
                                }

                            case 'doubleclick':
                                {
                                    this._handleDoubleClick(event);
                                    break;
                                }

                            default:
                                {
                                    paper.handleMouseEvent(event);
                                    break;
                                }
                        }
                    }

                    /**
                     * Handle mouse enter.
                     */
                }, {
                    key: '_handleMouseEnter',
                    value: function _handleMouseEnter(mouseEvent) {
                        var _this5 = this;

                        this._timerEvent = setTimeout(function () {
                            return _this5._showPopup(mouseEvent);
                        }, Configuration.WORKFLOWBUILDERGUI.HOVER_TIME);
                        paper.handleMouseEvent(mouseEvent);
                    }

                    /**
                     * Handle mouse leave.
                     */
                }, {
                    key: '_handleMouseLeave',
                    value: function _handleMouseLeave(mouseEvent) {
                        this._hidePopup();
                        clearTimeout(this._timerEvent);
                        paper.handleMouseEvent(mouseEvent);
                    }

                    /**
                     * Handle mouse up.
                     */
                }, {
                    key: '_handleMouseUp',
                    value: function _handleMouseUp(mouseEvent) {
                        paper.handleMouseEvent(mouseEvent);
                    }

                    /**
                     * Handle mouse down.
                     */
                }, {
                    key: '_handleMouseDown',
                    value: function _handleMouseDown(mouseEvent) {
                        paper.handleMouseEvent(mouseEvent);
                    }

                    /**
                     * Handle mouse click.
                     */
                }, {
                    key: '_handleClick',
                    value: function _handleClick(mouseEvent) {
                        paper.handleMouseEvent(mouseEvent);
                    }

                    /**
                     * Handle mouse double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick(mouseEvent) {
                        paper.handleMouseEvent(mouseEvent);
                    }
                }]);

                return BaseItem;
            })(paper.Path);

            _export('default', BaseItem);
        }
    };
});

$__System.register('1f', ['13', '14', '15', '16', '17', 'f'], function (_export) {
    var paper, _get, _inherits, _createClass, _classCallCheck, BaseItem, BaseWorkflowJobItem;

    return {
        setters: [function (_5) {
            paper = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }],
        execute: function () {

            /**
             * BaseWorkflowJob item. 
             */
            'use strict';

            BaseWorkflowJobItem = (function (_BaseItem) {
                _inherits(BaseWorkflowJobItem, _BaseItem);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function BaseWorkflowJobItem(options) {
                    var _this = this;

                    _classCallCheck(this, BaseWorkflowJobItem);

                    _get(Object.getPrototypeOf(BaseWorkflowJobItem.prototype), 'constructor', this).call(this, options);
                    this._paperGroupInputPorts = new paper.Group();
                    this.addChild(this._paperGroupInputPorts);
                    this._paperGroupOutputPorts = new paper.Group();
                    this.addChild(this._paperGroupOutputPorts);
                    this.onDoubleClick = function (event) {
                        return _this._handleDoubleClick(event);
                    };
                }

                /**
                 * Update.
                 */

                _createClass(BaseWorkflowJobItem, [{
                    key: 'update',
                    value: function update() {
                        if (this.visible) {
                            this.bounds.width = this._text.bounds.width + 10;
                            this._text.position = this.bounds.center;
                            this._paperGroupInputPorts.position = this.bounds.topCenter;
                            this._paperGroupOutputPorts.position = this.bounds.bottomCenter;
                            this._positionPortItems(this._paperGroupInputPorts, this.bounds.top);
                            this._positionPortItems(this._paperGroupOutputPorts, this.bounds.bottom);
                        }
                        this._updatePortItemVisibility(this._paperGroupInputPorts);
                        this._updatePortItemVisibility(this._paperGroupOutputPorts);
                    }

                    /**
                     * Adds input port item.
                     */
                }, {
                    key: 'addInputPortItem',
                    value: function addInputPortItem(inputPortItem) {
                        this._paperGroupInputPorts.addChild(inputPortItem);
                    }

                    /**
                     * Adds output port item.
                     */
                }, {
                    key: 'addOutputPortItem',
                    value: function addOutputPortItem(outputPortItem) {
                        this._paperGroupOutputPorts.addChild(outputPortItem);
                    }

                    /**
                     * Deletes input port item.
                     */
                }, {
                    key: 'deleteInputPortItem',
                    value: function deleteInputPortItem(inputPortItem) {
                        this._deletePortItem(this._paperGroupInputPorts, inputPortItem);
                    }

                    /**
                     * Deletes output port item.
                     */
                }, {
                    key: 'deleteOutputPortItem',
                    value: function deleteOutputPortItem(outputPortItem) {
                        this._deletePortItem(this._paperGroupOutputPorts, outputPortItem);
                    }

                    /**
                     * Destroy cleanup.
                     */
                }, {
                    key: 'destroy',
                    value: function destroy() {
                        _get(Object.getPrototypeOf(BaseWorkflowJobItem.prototype), 'destroy', this).call(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Positions ports.
                     */
                }, {
                    key: '_positionPortItems',
                    value: function _positionPortItems(group, positionY) {
                        if (group.isEmpty()) {
                            return;
                        }

                        // Get port width and height.
                        var portWidth = group.children[0].bounds.width;
                        var portHeight = group.children[0].bounds.height;
                        var groupWidth = group.children.length * portWidth;

                        // Get position parameters.
                        var offsetX = group.children[0].bounds.width;
                        var farLeft = this.position.x - groupWidth / 2;

                        for (var i = 0; i < group.children.length; i++) {
                            var port = group.children[i];
                            var positionX = farLeft + offsetX * (i + 1) - group.children[i].bounds.width / 2;
                            var newPosition = new paper.Point(positionX, positionY);
                            port.position = newPosition;
                        }
                    }

                    /**
                     * Updates port item visibility.
                     */
                }, {
                    key: '_updatePortItemVisibility',
                    value: function _updatePortItemVisibility(group) {
                        for (var i = 0; i < group.children.length; i++) {
                            var port = group.children[i];
                            group.children[i].setVisible(this.visible);
                        }
                    }

                    /**
                     * Deletes a port item.
                     */
                }, {
                    key: '_deletePortItem',
                    value: function _deletePortItem(group, portItem) {
                        for (var i = 0; i < group.children.length; i++) {
                            if (portItem === group.children[i]) {
                                group.removeChildren(i, i + 1);
                                return;
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick(mouseEvent) {
                        // TODO - better way to do abstract methods
                        console.error('This must be defined in sub-class.');
                    }
                }]);

                return BaseWorkflowJobItem;
            })(BaseItem);

            _export('default', BaseWorkflowJobItem);
        }
    };
});

$__System.register('23', ['14', '15', '16', '17', '1d'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseModel, WorkflowJobCoordinateSet;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * WorkflowJobCoordinateSet.
             */
            'use strict';

            WorkflowJobCoordinateSet = (function (_BaseModel) {
                _inherits(WorkflowJobCoordinateSet, _BaseModel);

                function WorkflowJobCoordinateSet() {
                    _classCallCheck(this, WorkflowJobCoordinateSet);

                    _get(Object.getPrototypeOf(WorkflowJobCoordinateSet.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(WorkflowJobCoordinateSet, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this.routeName = 'workflowjobcoordinatesets';
                    }

                    /**
                     * Parse response from server.
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        if (!response.results) {
                            return response;
                        } else if (response.results.length > 1) {
                            throw new Error('received multiple results for individual model');
                        }
                        return response.results[0];
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                }]);

                return WorkflowJobCoordinateSet;
            })(BaseModel);

            _export('default', WorkflowJobCoordinateSet);
        }
    };
});

$__System.register('24', ['11', '12', '14', '15', '16', '17', '20', '23', '1f'], function (_export) {
    var RODAN_EVENTS, GUI_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, WorkflowJobCoordinateSet, BaseWorkflowJobItem, WorkflowJobItem;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_7) {
            GUI_EVENTS = _7['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            Radio = _5['default'];
        }, function (_8) {
            WorkflowJobCoordinateSet = _8['default'];
        }, function (_f) {
            BaseWorkflowJobItem = _f['default'];
        }],
        execute: function () {

            /**
             * WorkflowJob item.
             */
            'use strict';

            WorkflowJobItem = (function (_BaseWorkflowJobItem) {
                _inherits(WorkflowJobItem, _BaseWorkflowJobItem);

                _createClass(WorkflowJobItem, null, [{
                    key: 'getContextMenuDataMultiple',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC STATIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns context menu data for multiple items of this class.
                     * Takes in URLs of multiple selections.
                     *
                     * The menu data is simply an array of objects. Objects should be:
                     *
                     * {
                     *      label: [string] // The text that should appear
                     *      radiorequest: RODAN_EVENTS.?  // The Request to make. NOT A RADIO EVENT, rather a REQUEST.
                     *      options: Object holding any options for Event
                     * }
                     */
                    value: function getContextMenuDataMultiple() {
                        var workflowJobs = Radio.channel('rodan-client_gui').request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_SELECTED_WORKFLOWJOBS);
                        var workflow = Radio.channel('rodan-client_gui').request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                        return [{ channel: 'rodan', label: 'Group', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOBGROUP, options: { workflowjobs: workflowJobs, workflow: workflow } }];
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Constructor.
                     */
                }]);

                function WorkflowJobItem(options) {
                    _classCallCheck(this, WorkflowJobItem);

                    _get(Object.getPrototypeOf(WorkflowJobItem.prototype), 'constructor', this).call(this, options);
                    var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                    this.menuItems = [{ label: 'Edit', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_VIEW, options: { workflowjob: this.getModel(), workflow: workflow } }, { label: 'Settings', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_SETTINGS_VIEW, options: { workflowjob: this.getModel(), workflow: workflow } }, { label: 'Ports', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_PORTS_VIEW, options: { workflowjob: this.getModel(), workflow: workflow } }, { label: 'Delete', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB, options: { workflowjob: this.getModel(), workflow: workflow } }];
                    this.coordinateSetInfo = [];
                    this.coordinateSetInfo['class'] = WorkflowJobCoordinateSet;
                    this.coordinateSetInfo['url'] = 'workflow_job';
                    this.loadCoordinates();
                }

                /**
                 * Destroy cleanup.
                 */

                _createClass(WorkflowJobItem, [{
                    key: 'destroy',
                    value: function destroy() {
                        var inputPortItems = this._paperGroupInputPorts.removeChildren();
                        var outputPortItems = this._paperGroupOutputPorts.removeChildren();
                        for (var index in inputPortItems) {
                            var port = inputPortItems[index];
                            port.destroy();
                        }
                        for (index in outputPortItems) {
                            port = outputPortItems[index];
                            port.destroy();
                        }
                        _get(Object.getPrototypeOf(WorkflowJobItem.prototype), 'destroy', this).call(this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick(mouseEvent) {
                        var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_VIEW, { workflowjob: this.getModel(), workflow: workflow });
                    }
                }]);

                return WorkflowJobItem;
            })(BaseWorkflowJobItem);

            _export('default', WorkflowJobItem);
        }
    };
});

$__System.register('25', ['10', '11', '12', '13', '16', '17', '18', '20', '24', 'd', 'f', 'e', '1a', '1b', '1e'], function (_export) {
    var Configuration, RODAN_EVENTS, GUI_EVENTS, paper, _createClass, _classCallCheck, InputPortItem, Radio, WorkflowJobItem, _Object$keys, BaseItem, ConnectionItem, LineItem, OutputPortItem, WorkflowJobGroupItem, ItemController;

    return {
        setters: [function (_5) {
            Configuration = _5['default'];
        }, function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_7) {
            GUI_EVENTS = _7['default'];
        }, function (_4) {
            paper = _4['default'];
        }, function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_8) {
            InputPortItem = _8['default'];
        }, function (_3) {
            Radio = _3['default'];
        }, function (_9) {
            WorkflowJobItem = _9['default'];
        }, function (_d) {
            _Object$keys = _d['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }, function (_e) {
            ConnectionItem = _e['default'];
        }, function (_a) {
            LineItem = _a['default'];
        }, function (_b) {
            OutputPortItem = _b['default'];
        }, function (_e2) {
            WorkflowJobGroupItem = _e2['default'];
        }],
        execute: function () {

            /**
             * Controls management of items.
             */
            'use strict';

            ItemController = (function () {
                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Basic constructor
                 */

                function ItemController() {
                    _classCallCheck(this, ItemController);

                    this._selectedItems = {};
                    this._selectingMultiple = false;
                    this._overItem = null;
                    this._outputPortItem = null;
                    this._candidateInputPortItems = {};

                    this._initializeRadio();
                    this._createSegments();
                }

                /**
                 * Handles MouseEvent on item.
                 */

                _createClass(ItemController, [{
                    key: 'handleMouseEvent',
                    value: function handleMouseEvent(mouseEvent) {
                        var item = mouseEvent.target;
                        this._overItem = mouseEvent.type === 'mouseenter' ? item : mouseEvent.type === 'mouseleave' ? null : item;
                        if (mouseEvent.type === 'mousedown') {
                            this._handleEventMouseDown(mouseEvent);
                        } else if (mouseEvent.type === 'mouseup') {}
                    }

                    /**
                     * Returns current item mouse is over (or null).
                     */
                }, {
                    key: 'getMouseOverItem',
                    value: function getMouseOverItem() {
                        return this._overItem;
                    }

                    /**
                     * Saves item positions.
                     */
                }, {
                    key: 'saveSelectedItemPositions',
                    value: function saveSelectedItemPositions() {
                        for (var itemIndex in this._selectedItems) {
                            var item = this._selectedItems[itemIndex];
                            item.updatePositionToServer();
                        }
                    }

                    /**
                     * Move item positions.
                     */
                }, {
                    key: 'moveSelectedItems',
                    value: function moveSelectedItems(delta) {
                        for (var itemIndex in this._selectedItems) {
                            var item = this._selectedItems[itemIndex];
                            if (item.isMoveable()) {
                                item.move(delta);
                            }
                        }
                    }

                    /**
                     * Selects the given item.
                     */
                }, {
                    key: 'selectItem',
                    value: function selectItem(item) {
                        this._selectedItems[item.id] = item;
                        item.setHighlight(true);
                    }

                    /**
                     * Unselects the given item.
                     */
                }, {
                    key: 'unselectItem',
                    value: function unselectItem(item) {
                        delete this._selectedItems[item.id];
                        item.setHighlight(false);
                    }

                    /**
                     * Clears selection.
                     */
                }, {
                    key: 'clearSelected',
                    value: function clearSelected() {
                        for (var itemIndex in this._selectedItems) {
                            var item = this._selectedItems[itemIndex];
                            this.unselectItem(item);
                        }
                        this._selectedItems = {}; // TODO memory leak?
                        this._outputPortItem = null;
                    }

                    /**
                     * Return true iff item is selected.
                     */
                }, {
                    key: 'isSelected',
                    value: function isSelected(item) {
                        return this._selectedItems.hasOwnProperty(item.id);
                    }

                    /**
                     * Returns number of selected items.
                     */
                }, {
                    key: 'getSelectedCount',
                    value: function getSelectedCount() {
                        return _Object$keys(this._selectedItems).length;
                    }

                    /**
                     * Returns array of keys of selected items.
                     */
                }, {
                    key: 'getSelectedItemKeys',
                    value: function getSelectedItemKeys() {
                        return _Object$keys(this._selectedItems);
                    }

                    /**
                     * Returns selected item at key
                     */
                }, {
                    key: 'getSelectedItem',
                    value: function getSelectedItem(key) {
                        return this._selectedItems[key];
                    }

                    /**
                     * Returns true iff we can group the selected items.
                     */
                }, {
                    key: 'canGroupSelectedItems',
                    value: function canGroupSelectedItems() {
                        if (_Object$keys(this._selectedItems).length > 1) {
                            for (var itemIndex in this._selectedItems) {
                                var item = this._selectedItems[itemIndex];
                                if (!(item instanceof WorkflowJobItem)) {
                                    return false;
                                }
                            }
                            return true;
                        }
                        return false;
                    }

                    /**
                     * Return OutputPortItem flagged for Connection creation (null if none).
                     */
                }, {
                    key: 'getOutputPortItemForConnection',
                    value: function getOutputPortItemForConnection() {
                        return this._outputPortItem;
                    }

                    /**
                     * Returns a line item.
                     */
                }, {
                    key: 'createLineItem',
                    value: function createLineItem(startPoint) {
                        return new LineItem({ segments: this._segments.connection, startPoint: startPoint });
                    }

                    /**
                     * Set selecting multiple.
                     */
                }, {
                    key: 'setSelectingMultiple',
                    value: function setSelectingMultiple(selectingMultiple) {
                        this._selectingMultiple = selectingMultiple;
                    }

                    /**
                     * Return true iff selecting multiple.
                     */
                }, {
                    key: 'selectingMultiple',
                    value: function selectingMultiple() {
                        return this._selectingMultiple;
                    }

                    /**
                     * Attempts to create a connection.
                     */
                }, {
                    key: 'createConnection',
                    value: function createConnection(outputPortItem, inputPortItem, workflow) {
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_CONNECTION, { inputport: inputPortItem.getModel(),
                            outputport: outputPortItem.getModel(),
                            workflow: workflow });
                    }

                    /**
                     * Given InputPort URLs, sets them as candidates for satisfying OutputPort.
                     */
                }, {
                    key: 'setInputPortCandidates',
                    value: function setInputPortCandidates(inputPortUrls) {
                        this.clearInputPortCandidates();
                        if (inputPortUrls) {
                            for (var i = 0; i < inputPortUrls.length; i++) {
                                var item = BaseItem.getAssociatedItem(inputPortUrls[i]);
                                item.setTemporaryColor(Configuration.WORKFLOWBUILDERGUI.INPUTPORT_COLOR_CANDIDATE);
                                this._candidateInputPortItems[inputPortUrls[i]] = item;
                            }
                        }
                    }

                    /**
                     * Returns true iff provided InputPortItem represents a candidate InputPort.
                     */
                }, {
                    key: 'isInputPortCandidate',
                    value: function isInputPortCandidate(item) {
                        var url = item.getModel().get('url');
                        return this._candidateInputPortItems.hasOwnProperty(url);
                    }

                    /**
                     * Clears candidate InputPortItems.
                     */
                }, {
                    key: 'clearInputPortCandidates',
                    value: function clearInputPortCandidates() {
                        var keys = _Object$keys(this._candidateInputPortItems);
                        for (var i = 0; i < keys.length; i++) {
                            var item = this._candidateInputPortItems[keys[i]];
                            item.clearTemporaryColor();
                        }
                        this._candidateInputPortItems = {};
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Initializers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        this.guiChannel = Radio.channel('rodan-client_gui');
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_SELECTED_WORKFLOWJOBS, function () {
                            return _this._handleRequestGetSelectedWorkflowJobs();
                        });
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ADD_RESOURCEDISTRIBUTOR, function () {
                            return _this._handleRequestAddResourceDistributor();
                        });

                        this.rodanChannel = Radio.channel('rodan');
                        this.rodanChannel.on(RODAN_EVENTS.EVENT__COLLECTION_ADD, function (options) {
                            return _this._handleEventModelSync(options);
                        });
                        this.rodanChannel.on(RODAN_EVENTS.EVENT__MODEL_SYNC, function (options) {
                            return _this._handleEventModelSync(options);
                        });
                    }

                    /**
                     * Create segment definitions.
                     */
                }, {
                    key: '_createSegments',
                    value: function _createSegments() {
                        var canvasWidth = paper.view.viewSize.width;
                        var canvasHeight = paper.view.viewSize.height;
                        var workflowJobItemWidth = Configuration.WORKFLOWBUILDERGUI.WORKFLOWJOB_WIDTH;
                        var workflowJobItemHeight = Configuration.WORKFLOWBUILDERGUI.WORKFLOWJOB_HEIGHT;
                        var portItemWidth = Configuration.WORKFLOWBUILDERGUI.PORT_WIDTH;
                        var portItemHeight = Configuration.WORKFLOWBUILDERGUI.PORT_HEIGHT;
                        this._segments = {
                            workflowJobItem: [new paper.Point(0, 0), new paper.Point(workflowJobItemWidth, 0), new paper.Point(workflowJobItemWidth, workflowJobItemHeight), new paper.Point(0, workflowJobItemHeight), new paper.Point(0, 0)],
                            portItem: [new paper.Point(0, 0), new paper.Point(portItemWidth, 0), new paper.Point(portItemWidth, portItemHeight), new paper.Point(0, portItemHeight), new paper.Point(0, 0)],
                            listInputportItem: [new paper.Point(0, 0), new paper.Point(portItemWidth, 0), new paper.Point(portItemWidth / 2, portItemHeight), new paper.Point(0, 0)],
                            listOutputPortItem: [new paper.Point(portItemWidth / 2, 0), new paper.Point(portItemWidth, portItemHeight), new paper.Point(0, portItemHeight), new paper.Point(portItemWidth / 2, 0)],
                            connection: [new paper.Point(0, 0), new paper.Point(1, 0)]
                        };
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - REST handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event model sync.
                     *
                     * We check if an item exists for this model. If it does, don't do anything - the
                     * model will take care of itself. If it doesn't, we create a new model.
                     */
                }, {
                    key: '_handleEventModelSync',
                    value: function _handleEventModelSync(options) {
                        if (options.model) {
                            var item = BaseItem.getAssociatedItem(options.model.get('url'));
                            if (!item) {
                                switch (options.model.constructor.name) {
                                    case 'WorkflowJob':
                                        {
                                            var item = new WorkflowJobItem({ segments: this._segments.workflowJobItem, model: options.model, text: true });
                                            var position = new paper.Point(paper.view.size.width * paper.view.zoom / 2, paper.view.size.height * paper.view.zoom / 2);
                                            item.setPosition(position);
                                            break;
                                        }

                                    case 'InputPort':
                                        {
                                            var item = new InputPortItem({ segments: this._segments.portItem, model: options.model, workflowjoburl: options.model.get('workflow_job') });
                                            break;
                                        }

                                    case 'OutputPort':
                                        {
                                            var item = new OutputPortItem({ segments: this._segments.portItem, model: options.model, workflowjoburl: options.model.get('workflow_job') });
                                            break;
                                        }

                                    case 'Connection':
                                        {
                                            var item = new ConnectionItem({ segments: this._segments.connection,
                                                model: options.model,
                                                inputporturl: options.model.get('input_port'),
                                                outputporturl: options.model.get('output_port') });
                                            break;
                                        }

                                    case 'WorkflowJobGroup':
                                        {
                                            var item = new WorkflowJobGroupItem({ segments: this._segments.workflowJobItem, model: options.model, text: true });
                                            var position = new paper.Point(paper.view.size.width * paper.view.zoom / 2, paper.view.size.height * paper.view.zoom / 2);
                                            item.setPosition(position);
                                            break;
                                        }

                                    default:
                                        {
                                            break;
                                        }
                                }
                            } else if (options.options.task === 'destroy') {
                                this.unselectItem(item);
                            }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - MouseEvent handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event mousedown.
                     */
                }, {
                    key: '_handleEventMouseDown',
                    value: function _handleEventMouseDown(mouseEvent) {
                        // Handle selection first.
                        var item = mouseEvent.target;
                        if (!this._selectingMultiple) {
                            if (!this.isSelected(item)) {
                                this.clearSelected();
                                this.selectItem(item);
                            }
                        } else {
                            if (!this.isSelected(item)) {
                                this.selectItem(item);
                            } else {
                                this.unselectItem(item);
                            }
                        }

                        // Next, what kind of button was it.
                        switch (mouseEvent.event.button) {
                            case 0:
                                {
                                    this._handleEventMouseDownMain(mouseEvent);
                                    break;
                                }

                            default:
                                {
                                    this._handleEventMouseDownSecondary(mouseEvent);
                                    break;
                                }
                        }
                    }

                    /**
                     * Handle main button mousedown.
                     */
                }, {
                    key: '_handleEventMouseDownMain',
                    value: function _handleEventMouseDownMain(mouseEvent) {
                        // Check if we can start making a connection.
                        var item = mouseEvent.target;
                        if (this.getSelectedCount() === 1 && item instanceof OutputPortItem) {
                            this._outputPortItem = item;
                        }
                    }

                    /**
                     * Handle secondary button mousedown.
                     */
                }, {
                    key: '_handleEventMouseDownSecondary',
                    value: function _handleEventMouseDownSecondary(mouseEvent) {
                        var itemClass = this._getSelectionItemType();
                        var contextMenuData = [];
                        if (this.getSelectedCount() === 1) {
                            var item = mouseEvent.target;
                            contextMenuData = item.getContextMenuDataSingle();
                        } else {
                            contextMenuData = itemClass.getContextMenuDataMultiple();
                        }

                        if (contextMenuData.length > 0) {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__CONTEXTMENU_SHOW, { items: contextMenuData,
                                top: mouseEvent.event.y,
                                left: mouseEvent.event.x });
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle request for all selected WorkflowJobs.
                     */
                }, {
                    key: '_handleRequestGetSelectedWorkflowJobs',
                    value: function _handleRequestGetSelectedWorkflowJobs() {
                        var workflowJobs = [];
                        for (var itemIndex in this._selectedItems) {
                            workflowJobs.push(this._selectedItems[itemIndex].getModel());
                        }
                        return workflowJobs;
                    }

                    /**
                     * Handle add resource distributor for selected InputPorts.
                     */
                }, {
                    key: '_handleRequestAddResourceDistributor',
                    value: function _handleRequestAddResourceDistributor(options) {
                        var keys = this.getSelectedItemKeys();
                        var inputPorts = [];
                        for (var index in keys) {
                            var item = this.getSelectedItem(keys[index]);
                            inputPorts.push(item.getModel());
                        }
                        var workflow = this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW);
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_DISTRIBUTOR, { inputports: inputPorts, workflow: workflow });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns item type (class constructor) of multiple selection.
                     * If mixed, returns BaseItem. Returns null if none.
                     */
                }, {
                    key: '_getSelectionItemType',
                    value: function _getSelectionItemType() {
                        var keys = this.getSelectedItemKeys();
                        var itemType = null;
                        var urls = [];
                        for (var index in keys) {
                            var item = this.getSelectedItem(keys[index]);
                            if (itemType === null) {
                                itemType = item.constructor;
                            }
                        }
                        return itemType;
                    }
                }]);

                return ItemController;
            })();

            _export('default', ItemController);
        }
    };
});

$__System.register('12', [], function (_export) {
    /**
     * Backbone.Radio events use in this GUI.
     */
    'use strict';

    var GUI_EVENTS;
    return {
        setters: [],
        execute: function () {
            GUI_EVENTS = {
                REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW: 'REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW',
                EVENT__WORKFLOWBUILDER_GUI_DESTROY: 'EVENT__WORKFLOWBUILDER_GUI_DESTROY', // Called when WorkflowBuilder has been destroyed.
                REQUEST__WORKFLOWBUILDER_GUI_ZOOM_IN: 'REQUEST__WORKFLOWBUILDER_GUI_ZOOM_IN', // Called when request workspace zoom in.
                REQUEST__WORKFLOWBUILDER_GUI_ZOOM_OUT: 'REQUEST__WORKFLOWBUILDER_GUI_ZOOM_OUT', // Called when request workspace zoom out.
                REQUEST__WORKFLOWBUILDER_GUI_ZOOM_RESET: 'REQUEST__WORKFLOWBUILDER_GUI_ZOOM_RESET', // Called when request workspace zoom reset.
                REQUEST__WORKFLOWBUILDER_GUI_ADD_RESOURCEDISTRIBUTOR: 'REQUEST__WORKFLOWBUILDER_GUI_ADD_RESOURCEDISTRIBUTOR',
                REQUEST__WORKFLOWBUILDER_GUI_GET_SELECTED_WORKFLOWJOBS: 'REQUEST__WORKFLOWBUILDER_GUI_GET_SELECTED_WORKFLOWJOBS' // Called when request list of all selected WorkflowJob IDs.
            };

            _export('default', GUI_EVENTS);
        }
    };
});

$__System.register('26', ['11', '12', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, GUI_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, LayoutViewWorkflowBuilder;

    return {
        setters: [function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_8) {
            GUI_EVENTS = _8['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }],
        execute: function () {

            /**
             * This class represents the controller for editing a Workflow.
             */
            'use strict';

            LayoutViewWorkflowBuilder = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewWorkflowBuilder, _Marionette$LayoutView);

                function LayoutViewWorkflowBuilder() {
                    _classCallCheck(this, LayoutViewWorkflowBuilder);

                    _get(Object.getPrototypeOf(LayoutViewWorkflowBuilder.prototype), 'constructor', this).apply(this, arguments);
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PROTOTYPE
                ///////////////////////////////////////////////////////////////////////////////////////

                _createClass(LayoutViewWorkflowBuilder, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this._initializeRadio();
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__UPDATER_CLEAR);
                        this._lastErrorCode = '';
                        this._lastErrorDetails = '';
                    }

                    /**
                     * After render.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        this._handleClickCheckboxAddPorts();
                    }

                    /**
                     * Unbind from events.
                     */
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        this.guiChannel.trigger(GUI_EVENTS.EVENT__WORKFLOWBUILDER_GUI_DESTROY);

                        this.rodanChannel.off(null, null, this);
                        this.rodanChannel.stopReplying(null, null, this);
                        this.guiChannel.off(null, null, this);
                        this.guiChannel.stopReplying(null, null, this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        this.rodanChannel = Radio.channel('rodan');
                        this.guiChannel = Radio.channel('rodan-client_gui');
                        this.rodanChannel.on(RODAN_EVENTS.EVENT__SERVER_ERROR, function (options) {
                            return _this._handleEventRodanError(options);
                        }, this);
                    }

                    /**
                     * Handle button zoom in.
                     */
                }, {
                    key: '_handleButtonZoomIn',
                    value: function _handleButtonZoomIn() {
                        this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_IN);
                    }

                    /**
                     * Handle button zoom out.
                     */
                }, {
                    key: '_handleButtonZoomOut',
                    value: function _handleButtonZoomOut() {
                        this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_OUT);
                    }

                    /**
                     * Handle button zoom reset.
                     */
                }, {
                    key: '_handleButtonZoomReset',
                    value: function _handleButtonZoomReset() {
                        this.guiChannel.request(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_RESET);
                    }

                    /**
                     * Handle button edit.
                     */
                }, {
                    key: '_handleButtonEdit',
                    value: function _handleButtonEdit() {
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOW_VIEW, { workflow: this.model });
                    }

                    /**
                     * Handle button add job.
                     */
                }, {
                    key: '_handleButtonAddJob',
                    value: function _handleButtonAddJob() {
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_JOBCOLLECTION_VIEW, { workflow: this.model });
                    }

                    /**
                     * Handle button import workflow.
                     */
                }, {
                    key: '_handleButtonImportWorkflow',
                    value: function _handleButtonImportWorkflow() {
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWCOLLECTION_VIEW, { workflow: this.model });
                    }

                    /**
                     * Handle button run.
                     */
                }, {
                    key: '_handleButtonRun',
                    value: function _handleButtonRun() {
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_CREATE_WORKFLOWRUN, { workflow: this.model });
                    }

                    /**
                     * Handle event Workflow updated.
                     */
                }, {
                    key: '_handleEventRodanError',
                    value: function _handleEventRodanError(options) {
                        this._lastErrorCode = options.json.error_code;
                        this._lastErrorDetails = options.json.details[0];
                    }

                    /**
                     * Handle click data status.
                     */
                }, {
                    key: '_handleClickDataStatus',
                    value: function _handleClickDataStatus() {
                        if (this._lastErrorCode !== '' || this._lastErrorDetails !== '') {
                            this.rodanChannel.request(RODAN_EVENTS.REQUEST__MODAL_SHOW_SIMPLE, { title: 'Error code: ' + this._lastErrorCode, text: this._lastErrorDetails });
                        }
                    }

                    /**
                     * Handle click on checkbox.
                     */
                }, {
                    key: '_handleClickCheckboxAddPorts',
                    value: function _handleClickCheckboxAddPorts() {
                        var checked = this.ui.checkboxAddPorts.is(':checked');
                        this.rodanChannel.request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SET_ADDPORTS, { addports: checked });
                    }

                    /**
                     * Updates info of Workflow in view.
                     */
                }, {
                    key: '_updateView',
                    value: function _updateView(event, model) {
                        if (this.model.get('valid')) {
                            this._lastErrorCode = '';
                            this._lastErrorDetails = '';
                            this.ui.dataStatus.text('Workflow "' + this.model.get('name') + '" is valid');
                        } else {
                            this.ui.dataStatus.text('Workflow "' + this.model.get('name') + '" is INVALID (click here for details)');
                        }
                    }
                }]);

                return LayoutViewWorkflowBuilder;
            })(Marionette.LayoutView);

            LayoutViewWorkflowBuilder.prototype.template = '#template-main_workflowbuilder';
            LayoutViewWorkflowBuilder.prototype.ui = {
                buttonZoomIn: '#button-zoom_in',
                buttonZoomOut: '#button-zoom_out',
                buttonZoomReset: '#button-zoom_reset',
                checkboxAddPorts: '#checkbox-add_ports',
                dataStatus: '#data-workflow_status',
                buttonEdit: '#button-edit',
                buttonAddJob: '#button-add_job',
                buttonImportWorkflow: '#button-import_workflow',
                buttonRun: '#button-run'
            };
            LayoutViewWorkflowBuilder.prototype.events = {
                'click @ui.buttonZoomIn': '_handleButtonZoomIn',
                'click @ui.buttonZoomOut': '_handleButtonZoomOut',
                'click @ui.buttonZoomReset': '_handleButtonZoomReset',
                'click @ui.dataStatus': '_handleClickDataStatus',
                'change @ui.checkboxAddPorts': '_handleClickCheckboxAddPorts',
                'click @ui.buttonEdit': '_handleButtonEdit',
                'click @ui.buttonAddJob': '_handleButtonAddJob',
                'click @ui.buttonImportWorkflow': '_handleButtonImportWorkflow',
                'click @ui.buttonRun': '_handleButtonRun'
            };
            LayoutViewWorkflowBuilder.prototype.modelEvents = {
                'all': '_updateView'
            };

            _export('default', LayoutViewWorkflowBuilder);
        }
    };
});

$__System.register('28', ['6', '10', '11', '12', '13', '16', '17', '18', '20', '25', '26', '29', 'f'], function (_export) {
    var drawGrid, Configuration, RODAN_EVENTS, GUI_EVENTS, paper, _createClass, _classCallCheck, InputPortItem, Radio, ItemController, LayoutViewWorkflowBuilder, Environment, BaseItem, WorkflowBuilderGUI, workspace;

    return {
        setters: [function (_5) {
            drawGrid = _5.drawGrid;
        }, function (_6) {
            Configuration = _6['default'];
        }, function (_8) {
            RODAN_EVENTS = _8['default'];
        }, function (_9) {
            GUI_EVENTS = _9['default'];
        }, function (_4) {
            paper = _4['default'];
        }, function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_10) {
            InputPortItem = _10['default'];
        }, function (_3) {
            Radio = _3['default'];
        }, function (_11) {
            ItemController = _11['default'];
        }, function (_12) {
            LayoutViewWorkflowBuilder = _12['default'];
        }, function (_7) {
            Environment = _7['default'];
        }, function (_f) {
            BaseItem = _f['default'];
        }],
        execute: function () {

            /**
             * Main WorkflowBuilderGUI class.
             */
            'use strict';

            WorkflowBuilderGUI = (function () {
                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function WorkflowBuilderGUI(options) {
                    var _this = this;

                    _classCallCheck(this, WorkflowBuilderGUI);

                    this._oldMouseEvent = window.MouseEvent; // FIX: paper.js stupidly redefines
                    this._workflow = null;
                    Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_SELECTED, function (options) {
                        return _this.initialize(options);
                    });
                }

                /**
                 * Initialize the workspace.
                 * The element associated with the canvas ID MUST be available at this time.
                 */

                _createClass(WorkflowBuilderGUI, [{
                    key: 'initialize',
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                        this._initializeView();
                        this._initializeStateMachine();
                        this._initializePaper('canvas-workspace');
                        this._initializeRadio();
                        this._initializeInterface();
                        this._initializeGlobalTool();
                        this._initializeGui();
                    }

                    /**
                     * Return workflow.
                     */
                }, {
                    key: 'getWorkflow',
                    value: function getWorkflow() {
                        return this._workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Initializers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize view.
                     */
                }, {
                    key: '_initializeView',
                    value: function _initializeView() {
                        var view = new LayoutViewWorkflowBuilder({ model: this.getWorkflow() });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: view });
                        this._menuItems = [{ label: 'Edit Name/Description', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOW_VIEW, options: { workflow: this.getWorkflow() } }, { label: 'Add Job', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_JOBCOLLECTION_VIEW, options: { workflow: this.getWorkflow() } }, { label: 'Import Workflow', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWCOLLECTION_VIEW, options: { workflow: this.getWorkflow() } }, { label: 'Run', radiorequest: RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_CREATE_WORKFLOWRUN, options: { workflow: this.getWorkflow() } }];
                    }

                    /**
                     * Initialize GUI.
                     */
                }, {
                    key: '_initializeGui',
                    value: function _initializeGui() {
                        var _this2 = this;

                        BaseItem.clearMap();
                        this._multipleSelectionKey = Environment.getMultipleSelectionKey();
                        this._line = null;
                        this._zoomRate = Configuration.WORKFLOWBUILDERGUI.ZOOM_RATE;
                        this._itemController = new ItemController();
                        paper.handleMouseEvent = function (event) {
                            return _this2._itemController.handleMouseEvent(event);
                        };
                    }

                    /**
                     * Initialize radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this3 = this;

                        this.rodanChannel = Radio.channel('rodan');
                        this.rodanChannel.on(RODAN_EVENTS.EVENT__MODEL_SYNC, function (options) {
                            return _this3._handleEventModelSync(options);
                        });

                        this.guiChannel = Radio.channel('rodan-client_gui');
                        this.guiChannel.on(GUI_EVENTS.EVENT__WORKFLOWBUILDER_GUI_DESTROY, function () {
                            return _this3._handleGuiDestroy();
                        });
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_GET_WORKFLOW, function () {
                            return _this3.getWorkflow();
                        });
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_IN, function () {
                            return _this3._handleRequestZoomIn();
                        });
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_OUT, function () {
                            return _this3._handleRequestZoomOut();
                        });
                        this.guiChannel.reply(GUI_EVENTS.REQUEST__WORKFLOWBUILDER_GUI_ZOOM_RESET, function () {
                            return _this3._handleRequestZoomReset();
                        });
                    }

                    /**
                     * Initialize state machine.
                     */
                }, {
                    key: '_initializeStateMachine',
                    value: function _initializeStateMachine() {
                        this._STATES = {
                            IDLE: 0,
                            MOUSE_DOWN: 1,
                            MOUSE_UP: 2,
                            DRAWING_LINE: 3
                        };
                        this._firstEntry = false;
                        this._setState(this._STATES.IDLE);
                    }

                    /**
                     * Initialize global tool.
                     */
                }, {
                    key: '_initializeGlobalTool',
                    value: function _initializeGlobalTool() {
                        var _this4 = this;

                        paper.tool = new Tool();
                        paper.tool.onMouseMove = function (event) {
                            return _this4._handleEvent(event);
                        };
                        paper.tool.onMouseUp = function (event) {
                            return _this4._handleEvent(event);
                        };
                        paper.tool.onMouseDown = function (event) {
                            return _this4._handleEvent(event);
                        };
                        paper.tool.onKeyDown = function (event) {
                            return _this4._handleEventKeyDown(event);
                        };
                        paper.tool.onKeyUp = function (event) {
                            return _this4._handleEventKeyUp(event);
                        };
                    }

                    /**
                     * Initialize global interface for GUI.
                     */
                }, {
                    key: '_initializeInterface',
                    value: function _initializeInterface() {
                        var canvas = paper.view.element;
                        canvas.oncontextmenu = function () {
                            return false;
                        };
                    }

                    /**
                     * Initialize paper.
                     */
                }, {
                    key: '_initializePaper',
                    value: function _initializePaper(canvasElementId) {
                        var _this5 = this;

                        paper.install(window);
                        paper.setup(canvasElementId);
                        paper.view.onFrame = function (event) {
                            return _this5._handleFrame(event);
                        };
                        this.drawGrid = drawGrid;
                        this.drawGrid(Configuration.WORKFLOWBUILDERGUI.GRID, paper);
                        this._handleRequestZoomReset();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Events and state machine
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle state. This is frame driven.
                     */
                }, {
                    key: '_handleFrame',
                    value: function _handleFrame(event) {
                        BaseItem.updateItems();
                    }

                    /**
                     * Sets state.
                     */
                }, {
                    key: '_setState',
                    value: function _setState(state) {
                        this._state = state;
                        this._firstEntry = true;
                    }

                    /**
                     * Handle ToolEvent.
                     */
                }, {
                    key: '_handleEvent',
                    value: function _handleEvent(toolEvent) {
                        switch (this._state) {
                            case this._STATES.IDLE:
                                {
                                    this._handleStateIdle(toolEvent);
                                    break;
                                }

                            case this._STATES.MOUSE_DOWN:
                                {
                                    this._handleStateMouseDown(toolEvent);
                                    break;
                                }

                            case this._STATES.MOUSE_UP:
                                {
                                    this._handleStateMouseUp(toolEvent);
                                    break;
                                }

                            case this._STATES.DRAWING_LINE:
                                {
                                    this._handleStateDrawingLine(toolEvent);
                                    break;
                                }

                            default:
                                {
                                    console.log('unknown state');
                                    break;
                                }
                        }
                    }

                    /**
                     * Handle state idle.
                     */
                }, {
                    key: '_handleStateIdle',
                    value: function _handleStateIdle(event) {
                        if (this._firstEntry) {
                            this._firstEntry = false;
                        }

                        if (event.type === 'mousedown') {
                            this._setState(this._STATES.MOUSE_DOWN);
                        }
                    }

                    /**
                     * Handle state mouse down.
                     */
                }, {
                    key: '_handleStateMouseDown',
                    value: function _handleStateMouseDown(event) {
                        if (this._firstEntry) {
                            this._firstEntry = false;
                            if (!this._itemController.getMouseOverItem()) {
                                this._itemController.clearSelected();

                                // If right-click, open context menu.
                                if (event.event.button === 2) {
                                    Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__CONTEXTMENU_SHOW, { items: this._menuItems, top: event.event.y, left: event.event.x });
                                }
                            }
                        }

                        if (event.type === 'mousemove') {
                            if (this._itemController.getOutputPortItemForConnection() !== null) {
                                this._setState(this._STATES.DRAWING_LINE);
                            } else if (this._itemController.getSelectedCount() > 0) {
                                this._itemController.moveSelectedItems(event.delta);
                            } else {
                                // TODO translate canvas
                                // BUG HERE WHEN I TRY TO TRANSLATE CANVAS
                                //this._itemController.moveSelectedItems(event.delta);
                            }
                        } else if (event.type === 'mouseup') {
                                this._setState(this._STATES.MOUSE_UP);
                                this._itemController.saveSelectedItemPositions();
                            }
                    }

                    /**
                     * Handle state mouse up.
                     */
                }, {
                    key: '_handleStateMouseUp',
                    value: function _handleStateMouseUp(event) {
                        if (this._firstEntry) {
                            this._firstEntry = false;
                            this._itemController.saveSelectedItemPositions();
                        }
                        this._setState(this._STATES.IDLE);
                    }

                    /**
                     * Handle state drawing line.
                     */
                }, {
                    key: '_handleStateDrawingLine',
                    value: function _handleStateDrawingLine(event) {
                        if (this._firstEntry) {
                            this._firstEntry = false;

                            // Create line.
                            if (this._line === null) {
                                var item = this._itemController.getOutputPortItemForConnection();
                                var startPoint = new Point(item.position.x, item.bounds.bottom);
                                this._line = this._itemController.createLineItem(startPoint);
                            }

                            // Get satisfiable InputPorts.
                            var outputPortItem = this._itemController.getOutputPortItemForConnection();
                            var candidateInputPortUrls = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_GET_SATISFYING_INPUTPORTS, { workflow: this._workflow, outputport: outputPortItem.getModel() });
                            this._itemController.setInputPortCandidates(candidateInputPortUrls);
                        }

                        if (event.type === 'mousemove') {
                            // Update end point to one pixel ABOVE the mouse pointer. This ensures that the next click event does NOT register
                            // the line as the target.
                            var adjustedPoint = new Point(event.point.x, event.point.y - 1);
                            this._line.setEndPoint(adjustedPoint);
                        } else if (event.type === 'mouseup') {
                            var overItem = this._itemController.getMouseOverItem();
                            if (overItem instanceof InputPortItem && !overItem.isSatisfied() && this._itemController.isInputPortCandidate(overItem)) {
                                var outputPortItem = this._itemController.getOutputPortItemForConnection();
                                this._itemController.createConnection(outputPortItem, overItem, this.getWorkflow());
                            }

                            // Reset.
                            this._state = this._STATES.IDLE;
                            if (this._line) {
                                this._line.remove();
                                this._line.destroy();
                                this._line = null;
                            }
                            this._itemController.clearSelected();
                            this._itemController.clearInputPortCandidates();
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Input event handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event key down.
                     */
                }, {
                    key: '_handleEventKeyDown',
                    value: function _handleEventKeyDown(event) {
                        if (event.event[this._multipleSelectionKey]) {
                            this._itemController.setSelectingMultiple(true);
                        }
                    }

                    /**
                     * Handle event key up.
                     */
                }, {
                    key: '_handleEventKeyUp',
                    value: function _handleEventKeyUp(event) {
                        if (!event.event[this._multipleSelectionKey]) {
                            this._itemController.setSelectingMultiple(false);
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle GUI destroy.
                     */
                }, {
                    key: '_handleGuiDestroy',
                    value: function _handleGuiDestroy() {
                        BaseItem.clearMap();
                        window.MouseEvent = this._oldMouseEvent;
                    }

                    /**
                     * Handle event model sync.
                     *
                     * This guarantees that the WorkflowBuilder always has the latest version of the Workflow.
                     */
                }, {
                    key: '_handleEventModelSync',
                    value: function _handleEventModelSync(options) {
                        if (options.model && options.model.constructor.name === 'Workflow') {
                            this._workflow = options.model;
                        }
                    }

                    /**
                     * Handle zoom in.
                     */
                }, {
                    key: '_handleRequestZoomIn',
                    value: function _handleRequestZoomIn() {
                        var zoom = paper.view.zoom + Configuration.WORKFLOWBUILDERGUI.ZOOM_RATE;
                        paper.view.zoom = zoom < Configuration.WORKFLOWBUILDERGUI.ZOOM_MAX ? zoom : Configuration.WORKFLOWBUILDERGUI.ZOOM_MAX;
                    }

                    /**
                     * Handle zoom out.
                     */
                }, {
                    key: '_handleRequestZoomOut',
                    value: function _handleRequestZoomOut() {
                        var zoom = paper.view.zoom - Configuration.WORKFLOWBUILDERGUI.ZOOM_RATE;
                        paper.view.zoom = zoom > Configuration.WORKFLOWBUILDERGUI.ZOOM_MIN ? zoom : Configuration.WORKFLOWBUILDERGUI.ZOOM_MIN;
                    }

                    /**
                     * Handle zoom reset.
                     */
                }, {
                    key: '_handleRequestZoomReset',
                    value: function _handleRequestZoomReset() {
                        paper.view.zoom = Configuration.WORKFLOWBUILDERGUI.ZOOM_INITIAL;
                    }
                }]);

                return WorkflowBuilderGUI;
            })();

            workspace = new WorkflowBuilderGUI();
        }
    };
});

$__System.register('2a', ['28'], function (_export) {
  'use strict';

  var WorkflowBuilderGUI;
  return {
    setters: [function (_) {
      WorkflowBuilderGUI = _['default'];
    }],
    execute: function () {}
  };
});

$__System.registerDynamic("2b", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    "format global";
    ;
    (function(global, factory) {
      typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory();
    }(this, function() {
      'use strict';
      var hookCallback;
      function utils_hooks__hooks() {
        return hookCallback.apply(null, arguments);
      }
      function setHookCallback(callback) {
        hookCallback = callback;
      }
      function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
      }
      function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
      }
      function map(arr, fn) {
        var res = [],
            i;
        for (i = 0; i < arr.length; ++i) {
          res.push(fn(arr[i], i));
        }
        return res;
      }
      function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
      }
      function extend(a, b) {
        for (var i in b) {
          if (hasOwnProp(b, i)) {
            a[i] = b[i];
          }
        }
        if (hasOwnProp(b, 'toString')) {
          a.toString = b.toString;
        }
        if (hasOwnProp(b, 'valueOf')) {
          a.valueOf = b.valueOf;
        }
        return a;
      }
      function create_utc__createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
      }
      function defaultParsingFlags() {
        return {
          empty: false,
          unusedTokens: [],
          unusedInput: [],
          overflow: -2,
          charsLeftOver: 0,
          nullInput: false,
          invalidMonth: null,
          invalidFormat: false,
          userInvalidated: false,
          iso: false,
          parsedDateParts: [],
          meridiem: null
        };
      }
      function getParsingFlags(m) {
        if (m._pf == null) {
          m._pf = defaultParsingFlags();
        }
        return m._pf;
      }
      var some;
      if (Array.prototype.some) {
        some = Array.prototype.some;
      } else {
        some = function(fun) {
          var t = Object(this);
          var len = t.length >>> 0;
          for (var i = 0; i < len; i++) {
            if (i in t && fun.call(this, t[i], i, t)) {
              return true;
            }
          }
          return false;
        };
      }
      function valid__isValid(m) {
        if (m._isValid == null) {
          var flags = getParsingFlags(m);
          var parsedParts = some.call(flags.parsedDateParts, function(i) {
            return i != null;
          });
          m._isValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));
          if (m._strict) {
            m._isValid = m._isValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
          }
        }
        return m._isValid;
      }
      function valid__createInvalid(flags) {
        var m = create_utc__createUTC(NaN);
        if (flags != null) {
          extend(getParsingFlags(m), flags);
        } else {
          getParsingFlags(m).userInvalidated = true;
        }
        return m;
      }
      function isUndefined(input) {
        return input === void 0;
      }
      var momentProperties = utils_hooks__hooks.momentProperties = [];
      function copyConfig(to, from) {
        var i,
            prop,
            val;
        if (!isUndefined(from._isAMomentObject)) {
          to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
          to._i = from._i;
        }
        if (!isUndefined(from._f)) {
          to._f = from._f;
        }
        if (!isUndefined(from._l)) {
          to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
          to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
          to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
          to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
          to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
          to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
          to._locale = from._locale;
        }
        if (momentProperties.length > 0) {
          for (i in momentProperties) {
            prop = momentProperties[i];
            val = from[prop];
            if (!isUndefined(val)) {
              to[prop] = val;
            }
          }
        }
        return to;
      }
      var updateInProgress = false;
      function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (updateInProgress === false) {
          updateInProgress = true;
          utils_hooks__hooks.updateOffset(this);
          updateInProgress = false;
        }
      }
      function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
      }
      function absFloor(number) {
        if (number < 0) {
          return Math.ceil(number);
        } else {
          return Math.floor(number);
        }
      }
      function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion,
            value = 0;
        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
          value = absFloor(coercedNumber);
        }
        return value;
      }
      function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length),
            lengthDiff = Math.abs(array1.length - array2.length),
            diffs = 0,
            i;
        for (i = 0; i < len; i++) {
          if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
            diffs++;
          }
        }
        return diffs + lengthDiff;
      }
      function warn(msg) {
        if (utils_hooks__hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
          console.warn('Deprecation warning: ' + msg);
        }
      }
      function deprecate(msg, fn) {
        var firstTime = true;
        return extend(function() {
          if (utils_hooks__hooks.deprecationHandler != null) {
            utils_hooks__hooks.deprecationHandler(null, msg);
          }
          if (firstTime) {
            warn(msg + '\nArguments: ' + Array.prototype.slice.call(arguments).join(', ') + '\n' + (new Error()).stack);
            firstTime = false;
          }
          return fn.apply(this, arguments);
        }, fn);
      }
      var deprecations = {};
      function deprecateSimple(name, msg) {
        if (utils_hooks__hooks.deprecationHandler != null) {
          utils_hooks__hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
          warn(msg);
          deprecations[name] = true;
        }
      }
      utils_hooks__hooks.suppressDeprecationWarnings = false;
      utils_hooks__hooks.deprecationHandler = null;
      function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
      }
      function isObject(input) {
        return Object.prototype.toString.call(input) === '[object Object]';
      }
      function locale_set__set(config) {
        var prop,
            i;
        for (i in config) {
          prop = config[i];
          if (isFunction(prop)) {
            this[i] = prop;
          } else {
            this['_' + i] = prop;
          }
        }
        this._config = config;
        this._ordinalParseLenient = new RegExp(this._ordinalParse.source + '|' + (/\d{1,2}/).source);
      }
      function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig),
            prop;
        for (prop in childConfig) {
          if (hasOwnProp(childConfig, prop)) {
            if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
              res[prop] = {};
              extend(res[prop], parentConfig[prop]);
              extend(res[prop], childConfig[prop]);
            } else if (childConfig[prop] != null) {
              res[prop] = childConfig[prop];
            } else {
              delete res[prop];
            }
          }
        }
        return res;
      }
      function Locale(config) {
        if (config != null) {
          this.set(config);
        }
      }
      var keys;
      if (Object.keys) {
        keys = Object.keys;
      } else {
        keys = function(obj) {
          var i,
              res = [];
          for (i in obj) {
            if (hasOwnProp(obj, i)) {
              res.push(i);
            }
          }
          return res;
        };
      }
      var locales = {};
      var globalLocale;
      function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
      }
      function chooseLocale(names) {
        var i = 0,
            j,
            next,
            locale,
            split;
        while (i < names.length) {
          split = normalizeLocale(names[i]).split('-');
          j = split.length;
          next = normalizeLocale(names[i + 1]);
          next = next ? next.split('-') : null;
          while (j > 0) {
            locale = loadLocale(split.slice(0, j).join('-'));
            if (locale) {
              return locale;
            }
            if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
              break;
            }
            j--;
          }
          i++;
        }
        return null;
      }
      function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
          try {
            oldLocale = globalLocale._abbr;
            require('./locale/' + name);
            locale_locales__getSetGlobalLocale(oldLocale);
          } catch (e) {}
        }
        return locales[name];
      }
      function locale_locales__getSetGlobalLocale(key, values) {
        var data;
        if (key) {
          if (isUndefined(values)) {
            data = locale_locales__getLocale(key);
          } else {
            data = defineLocale(key, values);
          }
          if (data) {
            globalLocale = data;
          }
        }
        return globalLocale._abbr;
      }
      function defineLocale(name, config) {
        if (config !== null) {
          config.abbr = name;
          if (locales[name] != null) {
            deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale');
            config = mergeConfigs(locales[name]._config, config);
          } else if (config.parentLocale != null) {
            if (locales[config.parentLocale] != null) {
              config = mergeConfigs(locales[config.parentLocale]._config, config);
            } else {
              deprecateSimple('parentLocaleUndefined', 'specified parentLocale is not defined yet');
            }
          }
          locales[name] = new Locale(config);
          locale_locales__getSetGlobalLocale(name);
          return locales[name];
        } else {
          delete locales[name];
          return null;
        }
      }
      function updateLocale(name, config) {
        if (config != null) {
          var locale;
          if (locales[name] != null) {
            config = mergeConfigs(locales[name]._config, config);
          }
          locale = new Locale(config);
          locale.parentLocale = locales[name];
          locales[name] = locale;
          locale_locales__getSetGlobalLocale(name);
        } else {
          if (locales[name] != null) {
            if (locales[name].parentLocale != null) {
              locales[name] = locales[name].parentLocale;
            } else if (locales[name] != null) {
              delete locales[name];
            }
          }
        }
        return locales[name];
      }
      function locale_locales__getLocale(key) {
        var locale;
        if (key && key._locale && key._locale._abbr) {
          key = key._locale._abbr;
        }
        if (!key) {
          return globalLocale;
        }
        if (!isArray(key)) {
          locale = loadLocale(key);
          if (locale) {
            return locale;
          }
          key = [key];
        }
        return chooseLocale(key);
      }
      function locale_locales__listLocales() {
        return keys(locales);
      }
      var aliases = {};
      function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
      }
      function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
      }
      function normalizeObjectUnits(inputObject) {
        var normalizedInput = {},
            normalizedProp,
            prop;
        for (prop in inputObject) {
          if (hasOwnProp(inputObject, prop)) {
            normalizedProp = normalizeUnits(prop);
            if (normalizedProp) {
              normalizedInput[normalizedProp] = inputObject[prop];
            }
          }
        }
        return normalizedInput;
      }
      function makeGetSet(unit, keepTime) {
        return function(value) {
          if (value != null) {
            get_set__set(this, unit, value);
            utils_hooks__hooks.updateOffset(this, keepTime);
            return this;
          } else {
            return get_set__get(this, unit);
          }
        };
      }
      function get_set__get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
      }
      function get_set__set(mom, unit, value) {
        if (mom.isValid()) {
          mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
        }
      }
      function getSet(units, value) {
        var unit;
        if (typeof units === 'object') {
          for (unit in units) {
            this.set(unit, units[unit]);
          }
        } else {
          units = normalizeUnits(units);
          if (isFunction(this[units])) {
            return this[units](value);
          }
        }
        return this;
      }
      function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number),
            zerosToFill = targetLength - absNumber.length,
            sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
      }
      var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;
      var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;
      var formatFunctions = {};
      var formatTokenFunctions = {};
      function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
          func = function() {
            return this[callback]();
          };
        }
        if (token) {
          formatTokenFunctions[token] = func;
        }
        if (padded) {
          formatTokenFunctions[padded[0]] = function() {
            return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
          };
        }
        if (ordinal) {
          formatTokenFunctions[ordinal] = function() {
            return this.localeData().ordinal(func.apply(this, arguments), token);
          };
        }
      }
      function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
          return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
      }
      function makeFormatFunction(format) {
        var array = format.match(formattingTokens),
            i,
            length;
        for (i = 0, length = array.length; i < length; i++) {
          if (formatTokenFunctions[array[i]]) {
            array[i] = formatTokenFunctions[array[i]];
          } else {
            array[i] = removeFormattingTokens(array[i]);
          }
        }
        return function(mom) {
          var output = '',
              i;
          for (i = 0; i < length; i++) {
            output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
          }
          return output;
        };
      }
      function formatMoment(m, format) {
        if (!m.isValid()) {
          return m.localeData().invalidDate();
        }
        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);
        return formatFunctions[format](m);
      }
      function expandFormat(format, locale) {
        var i = 5;
        function replaceLongDateFormatTokens(input) {
          return locale.longDateFormat(input) || input;
        }
        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
          format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
          localFormattingTokens.lastIndex = 0;
          i -= 1;
        }
        return format;
      }
      var match1 = /\d/;
      var match2 = /\d\d/;
      var match3 = /\d{3}/;
      var match4 = /\d{4}/;
      var match6 = /[+-]?\d{6}/;
      var match1to2 = /\d\d?/;
      var match3to4 = /\d\d\d\d?/;
      var match5to6 = /\d\d\d\d\d\d?/;
      var match1to3 = /\d{1,3}/;
      var match1to4 = /\d{1,4}/;
      var match1to6 = /[+-]?\d{1,6}/;
      var matchUnsigned = /\d+/;
      var matchSigned = /[+-]?\d+/;
      var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
      var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
      var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
      var matchWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i;
      var regexes = {};
      function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
          return (isStrict && strictRegex) ? strictRegex : regex;
        };
      }
      function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
          return new RegExp(unescapeFormat(token));
        }
        return regexes[token](config._strict, config._locale);
      }
      function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
          return p1 || p2 || p3 || p4;
        }));
      }
      function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
      }
      var tokens = {};
      function addParseToken(token, callback) {
        var i,
            func = callback;
        if (typeof token === 'string') {
          token = [token];
        }
        if (typeof callback === 'number') {
          func = function(input, array) {
            array[callback] = toInt(input);
          };
        }
        for (i = 0; i < token.length; i++) {
          tokens[token[i]] = func;
        }
      }
      function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
          config._w = config._w || {};
          callback(input, config._w, config, token);
        });
      }
      function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
          tokens[token](input, config._a, config, token);
        }
      }
      var YEAR = 0;
      var MONTH = 1;
      var DATE = 2;
      var HOUR = 3;
      var MINUTE = 4;
      var SECOND = 5;
      var MILLISECOND = 6;
      var WEEK = 7;
      var WEEKDAY = 8;
      var indexOf;
      if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
      } else {
        indexOf = function(o) {
          var i;
          for (i = 0; i < this.length; ++i) {
            if (this[i] === o) {
              return i;
            }
          }
          return -1;
        };
      }
      function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate();
      }
      addFormatToken('M', ['MM', 2], 'Mo', function() {
        return this.month() + 1;
      });
      addFormatToken('MMM', 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
      });
      addFormatToken('MMMM', 0, 0, function(format) {
        return this.localeData().months(this, format);
      });
      addUnitAlias('month', 'M');
      addRegexToken('M', match1to2);
      addRegexToken('MM', match1to2, match2);
      addRegexToken('MMM', function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
      });
      addRegexToken('MMMM', function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
      });
      addParseToken(['M', 'MM'], function(input, array) {
        array[MONTH] = toInt(input) - 1;
      });
      addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        if (month != null) {
          array[MONTH] = month;
        } else {
          getParsingFlags(config).invalidMonth = input;
        }
      });
      var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s+)+MMMM?/;
      var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
      function localeMonths(m, format) {
        return isArray(this._months) ? this._months[m.month()] : this._months[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }
      var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
      function localeMonthsShort(m, format) {
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
      }
      function units_month__handleStrictParse(monthName, format, strict) {
        var i,
            ii,
            mom,
            llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
          for (i = 0; i < 12; ++i) {
            mom = create_utc__createUTC([2000, i]);
            this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
            this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'MMM') {
            ii = indexOf.call(this._shortMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._longMonthsParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._longMonthsParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortMonthsParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeMonthsParse(monthName, format, strict) {
        var i,
            mom,
            regex;
        if (this._monthsParseExact) {
          return units_month__handleStrictParse.call(this, monthName, format, strict);
        }
        if (!this._monthsParse) {
          this._monthsParse = [];
          this._longMonthsParse = [];
          this._shortMonthsParse = [];
        }
        for (i = 0; i < 12; i++) {
          mom = create_utc__createUTC([2000, i]);
          if (strict && !this._longMonthsParse[i]) {
            this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$', 'i');
            this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$', 'i');
          }
          if (!strict && !this._monthsParse[i]) {
            regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
            this._monthsParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
            return i;
          } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
            return i;
          } else if (!strict && this._monthsParse[i].test(monthName)) {
            return i;
          }
        }
      }
      function setMonth(mom, value) {
        var dayOfMonth;
        if (!mom.isValid()) {
          return mom;
        }
        if (typeof value === 'string') {
          if (/^\d+$/.test(value)) {
            value = toInt(value);
          } else {
            value = mom.localeData().monthsParse(value);
            if (typeof value !== 'number') {
              return mom;
            }
          }
        }
        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
      }
      function getSetMonth(value) {
        if (value != null) {
          setMonth(this, value);
          utils_hooks__hooks.updateOffset(this, true);
          return this;
        } else {
          return get_set__get(this, 'Month');
        }
      }
      function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
      }
      var defaultMonthsShortRegex = matchWord;
      function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsShortStrictRegex;
          } else {
            return this._monthsShortRegex;
          }
        } else {
          return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
      }
      var defaultMonthsRegex = matchWord;
      function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
          if (!hasOwnProp(this, '_monthsRegex')) {
            computeMonthsParse.call(this);
          }
          if (isStrict) {
            return this._monthsStrictRegex;
          } else {
            return this._monthsRegex;
          }
        } else {
          return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
      }
      function computeMonthsParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom;
        for (i = 0; i < 12; i++) {
          mom = create_utc__createUTC([2000, i]);
          shortPieces.push(this.monthsShort(mom, ''));
          longPieces.push(this.months(mom, ''));
          mixedPieces.push(this.months(mom, ''));
          mixedPieces.push(this.monthsShort(mom, ''));
        }
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
      }
      function checkOverflow(m) {
        var overflow;
        var a = m._a;
        if (a && getParsingFlags(m).overflow === -2) {
          overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;
          if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
            overflow = DATE;
          }
          if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
            overflow = WEEK;
          }
          if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
            overflow = WEEKDAY;
          }
          getParsingFlags(m).overflow = overflow;
        }
        return m;
      }
      var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?/;
      var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;
      var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];
      var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];
      var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;
      function configFromISO(config) {
        var i,
            l,
            string = config._i,
            match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string),
            allowTime,
            dateFormat,
            timeFormat,
            tzFormat;
        if (match) {
          getParsingFlags(config).iso = true;
          for (i = 0, l = isoDates.length; i < l; i++) {
            if (isoDates[i][1].exec(match[1])) {
              dateFormat = isoDates[i][0];
              allowTime = isoDates[i][2] !== false;
              break;
            }
          }
          if (dateFormat == null) {
            config._isValid = false;
            return;
          }
          if (match[3]) {
            for (i = 0, l = isoTimes.length; i < l; i++) {
              if (isoTimes[i][1].exec(match[3])) {
                timeFormat = (match[2] || ' ') + isoTimes[i][0];
                break;
              }
            }
            if (timeFormat == null) {
              config._isValid = false;
              return;
            }
          }
          if (!allowTime && timeFormat != null) {
            config._isValid = false;
            return;
          }
          if (match[4]) {
            if (tzRegex.exec(match[4])) {
              tzFormat = 'Z';
            } else {
              config._isValid = false;
              return;
            }
          }
          config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
          configFromStringAndFormat(config);
        } else {
          config._isValid = false;
        }
      }
      function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);
        if (matched !== null) {
          config._d = new Date(+matched[1]);
          return;
        }
        configFromISO(config);
        if (config._isValid === false) {
          delete config._isValid;
          utils_hooks__hooks.createFromInputFallback(config);
        }
      }
      utils_hooks__hooks.createFromInputFallback = deprecate('moment construction falls back to js Date. This is ' + 'discouraged and will be removed in upcoming major ' + 'release. Please refer to ' + 'https://github.com/moment/moment/issues/1407 for more info.', function(config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
      });
      function createDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
          date.setFullYear(y);
        }
        return date;
      }
      function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
          date.setUTCFullYear(y);
        }
        return date;
      }
      addFormatToken('Y', 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
      });
      addFormatToken(0, ['YY', 2], 0, function() {
        return this.year() % 100;
      });
      addFormatToken(0, ['YYYY', 4], 0, 'year');
      addFormatToken(0, ['YYYYY', 5], 0, 'year');
      addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');
      addUnitAlias('year', 'y');
      addRegexToken('Y', matchSigned);
      addRegexToken('YY', match1to2, match2);
      addRegexToken('YYYY', match1to4, match4);
      addRegexToken('YYYYY', match1to6, match6);
      addRegexToken('YYYYYY', match1to6, match6);
      addParseToken(['YYYYY', 'YYYYYY'], YEAR);
      addParseToken('YYYY', function(input, array) {
        array[YEAR] = input.length === 2 ? utils_hooks__hooks.parseTwoDigitYear(input) : toInt(input);
      });
      addParseToken('YY', function(input, array) {
        array[YEAR] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      addParseToken('Y', function(input, array) {
        array[YEAR] = parseInt(input, 10);
      });
      function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
      }
      function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
      }
      utils_hooks__hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
      };
      var getSetYear = makeGetSet('FullYear', true);
      function getIsLeapYear() {
        return isLeapYear(this.year());
      }
      function firstWeekOffset(year, dow, doy) {
        var fwd = 7 + dow - doy,
            fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;
        return -fwdlw + fwd - 1;
      }
      function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7,
            weekOffset = firstWeekOffset(year, dow, doy),
            dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset,
            resYear,
            resDayOfYear;
        if (dayOfYear <= 0) {
          resYear = year - 1;
          resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
          resYear = year + 1;
          resDayOfYear = dayOfYear - daysInYear(year);
        } else {
          resYear = year;
          resDayOfYear = dayOfYear;
        }
        return {
          year: resYear,
          dayOfYear: resDayOfYear
        };
      }
      function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy),
            week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1,
            resWeek,
            resYear;
        if (week < 1) {
          resYear = mom.year() - 1;
          resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
          resWeek = week - weeksInYear(mom.year(), dow, doy);
          resYear = mom.year() + 1;
        } else {
          resYear = mom.year();
          resWeek = week;
        }
        return {
          week: resWeek,
          year: resYear
        };
      }
      function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy),
            weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
      }
      function defaults(a, b, c) {
        if (a != null) {
          return a;
        }
        if (b != null) {
          return b;
        }
        return c;
      }
      function currentDateArray(config) {
        var nowValue = new Date(utils_hooks__hooks.now());
        if (config._useUTC) {
          return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
      }
      function configFromArray(config) {
        var i,
            date,
            input = [],
            currentDate,
            yearToUse;
        if (config._d) {
          return;
        }
        currentDate = currentDateArray(config);
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
          dayOfYearFromWeekInfo(config);
        }
        if (config._dayOfYear) {
          yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);
          if (config._dayOfYear > daysInYear(yearToUse)) {
            getParsingFlags(config)._overflowDayOfYear = true;
          }
          date = createUTCDate(yearToUse, 0, config._dayOfYear);
          config._a[MONTH] = date.getUTCMonth();
          config._a[DATE] = date.getUTCDate();
        }
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
          config._a[i] = input[i] = currentDate[i];
        }
        for (; i < 7; i++) {
          config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
          config._nextDay = true;
          config._a[HOUR] = 0;
        }
        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        if (config._tzm != null) {
          config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }
        if (config._nextDay) {
          config._a[HOUR] = 24;
        }
      }
      function dayOfYearFromWeekInfo(config) {
        var w,
            weekYear,
            week,
            weekday,
            dow,
            doy,
            temp,
            weekdayOverflow;
        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
          dow = 1;
          doy = 4;
          weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(local__createLocal(), 1, 4).year);
          week = defaults(w.W, 1);
          weekday = defaults(w.E, 1);
          if (weekday < 1 || weekday > 7) {
            weekdayOverflow = true;
          }
        } else {
          dow = config._locale._week.dow;
          doy = config._locale._week.doy;
          weekYear = defaults(w.gg, config._a[YEAR], weekOfYear(local__createLocal(), dow, doy).year);
          week = defaults(w.w, 1);
          if (w.d != null) {
            weekday = w.d;
            if (weekday < 0 || weekday > 6) {
              weekdayOverflow = true;
            }
          } else if (w.e != null) {
            weekday = w.e + dow;
            if (w.e < 0 || w.e > 6) {
              weekdayOverflow = true;
            }
          } else {
            weekday = dow;
          }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
          getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
          getParsingFlags(config)._overflowWeekday = true;
        } else {
          temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
          config._a[YEAR] = temp.year;
          config._dayOfYear = temp.dayOfYear;
        }
      }
      utils_hooks__hooks.ISO_8601 = function() {};
      function configFromStringAndFormat(config) {
        if (config._f === utils_hooks__hooks.ISO_8601) {
          configFromISO(config);
          return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;
        var string = '' + config._i,
            i,
            parsedInput,
            tokens,
            token,
            skipped,
            stringLength = string.length,
            totalParsedInputLength = 0;
        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];
        for (i = 0; i < tokens.length; i++) {
          token = tokens[i];
          parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
          if (parsedInput) {
            skipped = string.substr(0, string.indexOf(parsedInput));
            if (skipped.length > 0) {
              getParsingFlags(config).unusedInput.push(skipped);
            }
            string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
            totalParsedInputLength += parsedInput.length;
          }
          if (formatTokenFunctions[token]) {
            if (parsedInput) {
              getParsingFlags(config).empty = false;
            } else {
              getParsingFlags(config).unusedTokens.push(token);
            }
            addTimeToArrayFromToken(token, parsedInput, config);
          } else if (config._strict && !parsedInput) {
            getParsingFlags(config).unusedTokens.push(token);
          }
        }
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
          getParsingFlags(config).unusedInput.push(string);
        }
        if (getParsingFlags(config).bigHour === true && config._a[HOUR] <= 12 && config._a[HOUR] > 0) {
          getParsingFlags(config).bigHour = undefined;
        }
        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);
        configFromArray(config);
        checkOverflow(config);
      }
      function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        if (meridiem == null) {
          return hour;
        }
        if (locale.meridiemHour != null) {
          return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
          isPm = locale.isPM(meridiem);
          if (isPm && hour < 12) {
            hour += 12;
          }
          if (!isPm && hour === 12) {
            hour = 0;
          }
          return hour;
        } else {
          return hour;
        }
      }
      function configFromStringAndArray(config) {
        var tempConfig,
            bestMoment,
            scoreToBeat,
            i,
            currentScore;
        if (config._f.length === 0) {
          getParsingFlags(config).invalidFormat = true;
          config._d = new Date(NaN);
          return;
        }
        for (i = 0; i < config._f.length; i++) {
          currentScore = 0;
          tempConfig = copyConfig({}, config);
          if (config._useUTC != null) {
            tempConfig._useUTC = config._useUTC;
          }
          tempConfig._f = config._f[i];
          configFromStringAndFormat(tempConfig);
          if (!valid__isValid(tempConfig)) {
            continue;
          }
          currentScore += getParsingFlags(tempConfig).charsLeftOver;
          currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;
          getParsingFlags(tempConfig).score = currentScore;
          if (scoreToBeat == null || currentScore < scoreToBeat) {
            scoreToBeat = currentScore;
            bestMoment = tempConfig;
          }
        }
        extend(config, bestMoment || tempConfig);
      }
      function configFromObject(config) {
        if (config._d) {
          return;
        }
        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
          return obj && parseInt(obj, 10);
        });
        configFromArray(config);
      }
      function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
          res.add(1, 'd');
          res._nextDay = undefined;
        }
        return res;
      }
      function prepareConfig(config) {
        var input = config._i,
            format = config._f;
        config._locale = config._locale || locale_locales__getLocale(config._l);
        if (input === null || (format === undefined && input === '')) {
          return valid__createInvalid({nullInput: true});
        }
        if (typeof input === 'string') {
          config._i = input = config._locale.preparse(input);
        }
        if (isMoment(input)) {
          return new Moment(checkOverflow(input));
        } else if (isArray(format)) {
          configFromStringAndArray(config);
        } else if (format) {
          configFromStringAndFormat(config);
        } else if (isDate(input)) {
          config._d = input;
        } else {
          configFromInput(config);
        }
        if (!valid__isValid(config)) {
          config._d = null;
        }
        return config;
      }
      function configFromInput(config) {
        var input = config._i;
        if (input === undefined) {
          config._d = new Date(utils_hooks__hooks.now());
        } else if (isDate(input)) {
          config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
          configFromString(config);
        } else if (isArray(input)) {
          config._a = map(input.slice(0), function(obj) {
            return parseInt(obj, 10);
          });
          configFromArray(config);
        } else if (typeof(input) === 'object') {
          configFromObject(config);
        } else if (typeof(input) === 'number') {
          config._d = new Date(input);
        } else {
          utils_hooks__hooks.createFromInputFallback(config);
        }
      }
      function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};
        if (typeof(locale) === 'boolean') {
          strict = locale;
          locale = undefined;
        }
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;
        return createFromConfig(c);
      }
      function local__createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
      }
      var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548', function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other < this ? this : other;
        } else {
          return valid__createInvalid();
        }
      });
      var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548', function() {
        var other = local__createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
          return other > this ? this : other;
        } else {
          return valid__createInvalid();
        }
      });
      function pickBy(fn, moments) {
        var res,
            i;
        if (moments.length === 1 && isArray(moments[0])) {
          moments = moments[0];
        }
        if (!moments.length) {
          return local__createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
          if (!moments[i].isValid() || moments[i][fn](res)) {
            res = moments[i];
          }
        }
        return res;
      }
      function min() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isBefore', args);
      }
      function max() {
        var args = [].slice.call(arguments, 0);
        return pickBy('isAfter', args);
      }
      var now = function() {
        return Date.now ? Date.now() : +(new Date());
      };
      function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration),
            years = normalizedInput.year || 0,
            quarters = normalizedInput.quarter || 0,
            months = normalizedInput.month || 0,
            weeks = normalizedInput.week || 0,
            days = normalizedInput.day || 0,
            hours = normalizedInput.hour || 0,
            minutes = normalizedInput.minute || 0,
            seconds = normalizedInput.second || 0,
            milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + seconds * 1e3 + minutes * 6e4 + hours * 1000 * 60 * 60;
        this._days = +days + weeks * 7;
        this._months = +months + quarters * 3 + years * 12;
        this._data = {};
        this._locale = locale_locales__getLocale();
        this._bubble();
      }
      function isDuration(obj) {
        return obj instanceof Duration;
      }
      function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
          var offset = this.utcOffset();
          var sign = '+';
          if (offset < 0) {
            offset = -offset;
            sign = '-';
          }
          return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
      }
      offset('Z', ':');
      offset('ZZ', '');
      addRegexToken('Z', matchShortOffset);
      addRegexToken('ZZ', matchShortOffset);
      addParseToken(['Z', 'ZZ'], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
      });
      var chunkOffset = /([\+\-]|\d\d)/gi;
      function offsetFromString(matcher, string) {
        var matches = ((string || '').match(matcher) || []);
        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);
        return parts[0] === '+' ? minutes : -minutes;
      }
      function cloneWithOffset(input, model) {
        var res,
            diff;
        if (model._isUTC) {
          res = model.clone();
          diff = (isMoment(input) || isDate(input) ? input.valueOf() : local__createLocal(input).valueOf()) - res.valueOf();
          res._d.setTime(res._d.valueOf() + diff);
          utils_hooks__hooks.updateOffset(res, false);
          return res;
        } else {
          return local__createLocal(input).local();
        }
      }
      function getDateOffset(m) {
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
      }
      utils_hooks__hooks.updateOffset = function() {};
      function getSetOffset(input, keepLocalTime) {
        var offset = this._offset || 0,
            localAdjust;
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        if (input != null) {
          if (typeof input === 'string') {
            input = offsetFromString(matchShortOffset, input);
          } else if (Math.abs(input) < 16) {
            input = input * 60;
          }
          if (!this._isUTC && keepLocalTime) {
            localAdjust = getDateOffset(this);
          }
          this._offset = input;
          this._isUTC = true;
          if (localAdjust != null) {
            this.add(localAdjust, 'm');
          }
          if (offset !== input) {
            if (!keepLocalTime || this._changeInProgress) {
              add_subtract__addSubtract(this, create__createDuration(input - offset, 'm'), 1, false);
            } else if (!this._changeInProgress) {
              this._changeInProgress = true;
              utils_hooks__hooks.updateOffset(this, true);
              this._changeInProgress = null;
            }
          }
          return this;
        } else {
          return this._isUTC ? offset : getDateOffset(this);
        }
      }
      function getSetZone(input, keepLocalTime) {
        if (input != null) {
          if (typeof input !== 'string') {
            input = -input;
          }
          this.utcOffset(input, keepLocalTime);
          return this;
        } else {
          return -this.utcOffset();
        }
      }
      function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
      }
      function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
          this.utcOffset(0, keepLocalTime);
          this._isUTC = false;
          if (keepLocalTime) {
            this.subtract(getDateOffset(this), 'm');
          }
        }
        return this;
      }
      function setOffsetToParsedOffset() {
        if (this._tzm) {
          this.utcOffset(this._tzm);
        } else if (typeof this._i === 'string') {
          this.utcOffset(offsetFromString(matchOffset, this._i));
        }
        return this;
      }
      function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
          return false;
        }
        input = input ? local__createLocal(input).utcOffset() : 0;
        return (this.utcOffset() - input) % 60 === 0;
      }
      function isDaylightSavingTime() {
        return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
      }
      function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
          return this._isDSTShifted;
        }
        var c = {};
        copyConfig(c, this);
        c = prepareConfig(c);
        if (c._a) {
          var other = c._isUTC ? create_utc__createUTC(c._a) : local__createLocal(c._a);
          this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
          this._isDSTShifted = false;
        }
        return this._isDSTShifted;
      }
      function isLocal() {
        return this.isValid() ? !this._isUTC : false;
      }
      function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
      }
      function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
      }
      var aspNetRegex = /^(\-)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?\d*)?$/;
      var isoRegex = /^(-)?P(?:(-?[0-9,.]*)Y)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)W)?(?:(-?[0-9,.]*)D)?(?:T(?:(-?[0-9,.]*)H)?(?:(-?[0-9,.]*)M)?(?:(-?[0-9,.]*)S)?)?$/;
      function create__createDuration(input, key) {
        var duration = input,
            match = null,
            sign,
            ret,
            diffRes;
        if (isDuration(input)) {
          duration = {
            ms: input._milliseconds,
            d: input._days,
            M: input._months
          };
        } else if (typeof input === 'number') {
          duration = {};
          if (key) {
            duration[key] = input;
          } else {
            duration.milliseconds = input;
          }
        } else if (!!(match = aspNetRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
            y: 0,
            d: toInt(match[DATE]) * sign,
            h: toInt(match[HOUR]) * sign,
            m: toInt(match[MINUTE]) * sign,
            s: toInt(match[SECOND]) * sign,
            ms: toInt(match[MILLISECOND]) * sign
          };
        } else if (!!(match = isoRegex.exec(input))) {
          sign = (match[1] === '-') ? -1 : 1;
          duration = {
            y: parseIso(match[2], sign),
            M: parseIso(match[3], sign),
            w: parseIso(match[4], sign),
            d: parseIso(match[5], sign),
            h: parseIso(match[6], sign),
            m: parseIso(match[7], sign),
            s: parseIso(match[8], sign)
          };
        } else if (duration == null) {
          duration = {};
        } else if (typeof duration === 'object' && ('from' in duration || 'to' in duration)) {
          diffRes = momentsDifference(local__createLocal(duration.from), local__createLocal(duration.to));
          duration = {};
          duration.ms = diffRes.milliseconds;
          duration.M = diffRes.months;
        }
        ret = new Duration(duration);
        if (isDuration(input) && hasOwnProp(input, '_locale')) {
          ret._locale = input._locale;
        }
        return ret;
      }
      create__createDuration.fn = Duration.prototype;
      function parseIso(inp, sign) {
        var res = inp && parseFloat(inp.replace(',', '.'));
        return (isNaN(res) ? 0 : res) * sign;
      }
      function positiveMomentsDifference(base, other) {
        var res = {
          milliseconds: 0,
          months: 0
        };
        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
          --res.months;
        }
        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));
        return res;
      }
      function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
          return {
            milliseconds: 0,
            months: 0
          };
        }
        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
          res = positiveMomentsDifference(base, other);
        } else {
          res = positiveMomentsDifference(other, base);
          res.milliseconds = -res.milliseconds;
          res.months = -res.months;
        }
        return res;
      }
      function absRound(number) {
        if (number < 0) {
          return Math.round(-1 * number) * -1;
        } else {
          return Math.round(number);
        }
      }
      function createAdder(direction, name) {
        return function(val, period) {
          var dur,
              tmp;
          if (period !== null && !isNaN(+period)) {
            deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period).');
            tmp = val;
            val = period;
            period = tmp;
          }
          val = typeof val === 'string' ? +val : val;
          dur = create__createDuration(val, period);
          add_subtract__addSubtract(this, dur, direction);
          return this;
        };
      }
      function add_subtract__addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds,
            days = absRound(duration._days),
            months = absRound(duration._months);
        if (!mom.isValid()) {
          return;
        }
        updateOffset = updateOffset == null ? true : updateOffset;
        if (milliseconds) {
          mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (days) {
          get_set__set(mom, 'Date', get_set__get(mom, 'Date') + days * isAdding);
        }
        if (months) {
          setMonth(mom, get_set__get(mom, 'Month') + months * isAdding);
        }
        if (updateOffset) {
          utils_hooks__hooks.updateOffset(mom, days || months);
        }
      }
      var add_subtract__add = createAdder(1, 'add');
      var add_subtract__subtract = createAdder(-1, 'subtract');
      function moment_calendar__calendar(time, formats) {
        var now = time || local__createLocal(),
            sod = cloneWithOffset(now, this).startOf('day'),
            diff = this.diff(sod, 'days', true),
            format = diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
        var output = formats && (isFunction(formats[format]) ? formats[format]() : formats[format]);
        return this.format(output || this.localeData().calendar(format, this, local__createLocal(now)));
      }
      function clone() {
        return new Moment(this);
      }
      function isAfter(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
          return this.valueOf() > localInput.valueOf();
        } else {
          return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
      }
      function isBefore(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
          return this.valueOf() < localInput.valueOf();
        } else {
          return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
      }
      function isBetween(from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
      }
      function isSame(input, units) {
        var localInput = isMoment(input) ? input : local__createLocal(input),
            inputMs;
        if (!(this.isValid() && localInput.isValid())) {
          return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
          return this.valueOf() === localInput.valueOf();
        } else {
          inputMs = localInput.valueOf();
          return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
      }
      function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
      }
      function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
      }
      function diff(input, units, asFloat) {
        var that,
            zoneDelta,
            delta,
            output;
        if (!this.isValid()) {
          return NaN;
        }
        that = cloneWithOffset(input, this);
        if (!that.isValid()) {
          return NaN;
        }
        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;
        units = normalizeUnits(units);
        if (units === 'year' || units === 'month' || units === 'quarter') {
          output = monthDiff(this, that);
          if (units === 'quarter') {
            output = output / 3;
          } else if (units === 'year') {
            output = output / 12;
          }
        } else {
          delta = this - that;
          output = units === 'second' ? delta / 1e3 : units === 'minute' ? delta / 6e4 : units === 'hour' ? delta / 36e5 : units === 'day' ? (delta - zoneDelta) / 864e5 : units === 'week' ? (delta - zoneDelta) / 6048e5 : delta;
        }
        return asFloat ? output : absFloor(output);
      }
      function monthDiff(a, b) {
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()),
            anchor = a.clone().add(wholeMonthDiff, 'months'),
            anchor2,
            adjust;
        if (b - anchor < 0) {
          anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
          adjust = (b - anchor) / (anchor - anchor2);
        } else {
          anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
          adjust = (b - anchor) / (anchor2 - anchor);
        }
        return -(wholeMonthDiff + adjust) || 0;
      }
      utils_hooks__hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
      utils_hooks__hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';
      function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
      }
      function moment_format__toISOString() {
        var m = this.clone().utc();
        if (0 < m.year() && m.year() <= 9999) {
          if (isFunction(Date.prototype.toISOString)) {
            return this.toDate().toISOString();
          } else {
            return formatMoment(m, 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
          }
        } else {
          return formatMoment(m, 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]');
        }
      }
      function format(inputString) {
        if (!inputString) {
          inputString = this.isUtc() ? utils_hooks__hooks.defaultFormatUtc : utils_hooks__hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
      }
      function from(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
          return create__createDuration({
            to: this,
            from: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function fromNow(withoutSuffix) {
        return this.from(local__createLocal(), withoutSuffix);
      }
      function to(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || local__createLocal(time).isValid())) {
          return create__createDuration({
            from: this,
            to: time
          }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
          return this.localeData().invalidDate();
        }
      }
      function toNow(withoutSuffix) {
        return this.to(local__createLocal(), withoutSuffix);
      }
      function locale(key) {
        var newLocaleData;
        if (key === undefined) {
          return this._locale._abbr;
        } else {
          newLocaleData = locale_locales__getLocale(key);
          if (newLocaleData != null) {
            this._locale = newLocaleData;
          }
          return this;
        }
      }
      var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
        if (key === undefined) {
          return this.localeData();
        } else {
          return this.locale(key);
        }
      });
      function localeData() {
        return this._locale;
      }
      function startOf(units) {
        units = normalizeUnits(units);
        switch (units) {
          case 'year':
            this.month(0);
          case 'quarter':
          case 'month':
            this.date(1);
          case 'week':
          case 'isoWeek':
          case 'day':
          case 'date':
            this.hours(0);
          case 'hour':
            this.minutes(0);
          case 'minute':
            this.seconds(0);
          case 'second':
            this.milliseconds(0);
        }
        if (units === 'week') {
          this.weekday(0);
        }
        if (units === 'isoWeek') {
          this.isoWeekday(1);
        }
        if (units === 'quarter') {
          this.month(Math.floor(this.month() / 3) * 3);
        }
        return this;
      }
      function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
          return this;
        }
        if (units === 'date') {
          units = 'day';
        }
        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
      }
      function to_type__valueOf() {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
      }
      function unix() {
        return Math.floor(this.valueOf() / 1000);
      }
      function toDate() {
        return this._offset ? new Date(this.valueOf()) : this._d;
      }
      function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
      }
      function toObject() {
        var m = this;
        return {
          years: m.year(),
          months: m.month(),
          date: m.date(),
          hours: m.hours(),
          minutes: m.minutes(),
          seconds: m.seconds(),
          milliseconds: m.milliseconds()
        };
      }
      function toJSON() {
        return this.isValid() ? this.toISOString() : null;
      }
      function moment_valid__isValid() {
        return valid__isValid(this);
      }
      function parsingFlags() {
        return extend({}, getParsingFlags(this));
      }
      function invalidAt() {
        return getParsingFlags(this).overflow;
      }
      function creationData() {
        return {
          input: this._i,
          format: this._f,
          locale: this._locale,
          isUTC: this._isUTC,
          strict: this._strict
        };
      }
      addFormatToken(0, ['gg', 2], 0, function() {
        return this.weekYear() % 100;
      });
      addFormatToken(0, ['GG', 2], 0, function() {
        return this.isoWeekYear() % 100;
      });
      function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
      }
      addWeekYearFormatToken('gggg', 'weekYear');
      addWeekYearFormatToken('ggggg', 'weekYear');
      addWeekYearFormatToken('GGGG', 'isoWeekYear');
      addWeekYearFormatToken('GGGGG', 'isoWeekYear');
      addUnitAlias('weekYear', 'gg');
      addUnitAlias('isoWeekYear', 'GG');
      addRegexToken('G', matchSigned);
      addRegexToken('g', matchSigned);
      addRegexToken('GG', match1to2, match2);
      addRegexToken('gg', match1to2, match2);
      addRegexToken('GGGG', match1to4, match4);
      addRegexToken('gggg', match1to4, match4);
      addRegexToken('GGGGG', match1to6, match6);
      addRegexToken('ggggg', match1to6, match6);
      addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
      });
      addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
        week[token] = utils_hooks__hooks.parseTwoDigitYear(input);
      });
      function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
      }
      function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
      }
      function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
      }
      function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
      }
      function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
          return weekOfYear(this, dow, doy).year;
        } else {
          weeksTarget = weeksInYear(input, dow, doy);
          if (week > weeksTarget) {
            week = weeksTarget;
          }
          return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
      }
      function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
            date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
      }
      addFormatToken('Q', 0, 'Qo', 'quarter');
      addUnitAlias('quarter', 'Q');
      addRegexToken('Q', match1);
      addParseToken('Q', function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
      });
      function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
      }
      addFormatToken('w', ['ww', 2], 'wo', 'week');
      addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');
      addUnitAlias('week', 'w');
      addUnitAlias('isoWeek', 'W');
      addRegexToken('w', match1to2);
      addRegexToken('ww', match1to2, match2);
      addRegexToken('W', match1to2);
      addRegexToken('WW', match1to2, match2);
      addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
      });
      function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
      }
      var defaultLocaleWeek = {
        dow: 0,
        doy: 6
      };
      function localeFirstDayOfWeek() {
        return this._week.dow;
      }
      function localeFirstDayOfYear() {
        return this._week.doy;
      }
      function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
      }
      function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
      }
      addFormatToken('D', ['DD', 2], 'Do', 'date');
      addUnitAlias('date', 'D');
      addRegexToken('D', match1to2);
      addRegexToken('DD', match1to2, match2);
      addRegexToken('Do', function(isStrict, locale) {
        return isStrict ? locale._ordinalParse : locale._ordinalParseLenient;
      });
      addParseToken(['D', 'DD'], DATE);
      addParseToken('Do', function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0], 10);
      });
      var getSetDayOfMonth = makeGetSet('Date', true);
      addFormatToken('d', 0, 'do', 'day');
      addFormatToken('dd', 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
      });
      addFormatToken('ddd', 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
      });
      addFormatToken('dddd', 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
      });
      addFormatToken('e', 0, 0, 'weekday');
      addFormatToken('E', 0, 0, 'isoWeekday');
      addUnitAlias('day', 'd');
      addUnitAlias('weekday', 'e');
      addUnitAlias('isoWeekday', 'E');
      addRegexToken('d', match1to2);
      addRegexToken('e', match1to2);
      addRegexToken('E', match1to2);
      addRegexToken('dd', function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
      });
      addRegexToken('ddd', function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
      });
      addRegexToken('dddd', function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
      });
      addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        if (weekday != null) {
          week.d = weekday;
        } else {
          getParsingFlags(config).invalidWeekday = input;
        }
      });
      addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
        week[token] = toInt(input);
      });
      function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
          return input;
        }
        if (!isNaN(input)) {
          return parseInt(input, 10);
        }
        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
          return input;
        }
        return null;
      }
      var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
      function localeWeekdays(m, format) {
        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
      }
      var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
      function localeWeekdaysShort(m) {
        return this._weekdaysShort[m.day()];
      }
      var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
      function localeWeekdaysMin(m) {
        return this._weekdaysMin[m.day()];
      }
      function day_of_week__handleStrictParse(weekdayName, format, strict) {
        var i,
            ii,
            mom,
            llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._minWeekdaysParse = [];
          for (i = 0; i < 7; ++i) {
            mom = create_utc__createUTC([2000, 1]).day(i);
            this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
            this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
            this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
          }
        }
        if (strict) {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        } else {
          if (format === 'dddd') {
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else if (format === 'ddd') {
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._minWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          } else {
            ii = indexOf.call(this._minWeekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._weekdaysParse, llc);
            if (ii !== -1) {
              return ii;
            }
            ii = indexOf.call(this._shortWeekdaysParse, llc);
            return ii !== -1 ? ii : null;
          }
        }
      }
      function localeWeekdaysParse(weekdayName, format, strict) {
        var i,
            mom,
            regex;
        if (this._weekdaysParseExact) {
          return day_of_week__handleStrictParse.call(this, weekdayName, format, strict);
        }
        if (!this._weekdaysParse) {
          this._weekdaysParse = [];
          this._minWeekdaysParse = [];
          this._shortWeekdaysParse = [];
          this._fullWeekdaysParse = [];
        }
        for (i = 0; i < 7; i++) {
          mom = create_utc__createUTC([2000, 1]).day(i);
          if (strict && !this._fullWeekdaysParse[i]) {
            this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$', 'i');
            this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$', 'i');
            this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$', 'i');
          }
          if (!this._weekdaysParse[i]) {
            regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
            this._weekdaysParse[i] = new RegExp(regex.replace('.', ''), 'i');
          }
          if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
            return i;
          } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
            return i;
          }
        }
      }
      function getSetDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
          input = parseWeekday(input, this.localeData());
          return this.add(input - day, 'd');
        } else {
          return day;
        }
      }
      function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
      }
      function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
          return input != null ? this : NaN;
        }
        return input == null ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7);
      }
      var defaultWeekdaysRegex = matchWord;
      function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysStrictRegex;
          } else {
            return this._weekdaysRegex;
          }
        } else {
          return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
      }
      var defaultWeekdaysShortRegex = matchWord;
      function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysShortStrictRegex;
          } else {
            return this._weekdaysShortRegex;
          }
        } else {
          return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
      }
      var defaultWeekdaysMinRegex = matchWord;
      function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
          if (!hasOwnProp(this, '_weekdaysRegex')) {
            computeWeekdaysParse.call(this);
          }
          if (isStrict) {
            return this._weekdaysMinStrictRegex;
          } else {
            return this._weekdaysMinRegex;
          }
        } else {
          return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
      }
      function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
          return b.length - a.length;
        }
        var minPieces = [],
            shortPieces = [],
            longPieces = [],
            mixedPieces = [],
            i,
            mom,
            minp,
            shortp,
            longp;
        for (i = 0; i < 7; i++) {
          mom = create_utc__createUTC([2000, 1]).day(i);
          minp = this.weekdaysMin(mom, '');
          shortp = this.weekdaysShort(mom, '');
          longp = this.weekdays(mom, '');
          minPieces.push(minp);
          shortPieces.push(shortp);
          longPieces.push(longp);
          mixedPieces.push(minp);
          mixedPieces.push(shortp);
          mixedPieces.push(longp);
        }
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
          shortPieces[i] = regexEscape(shortPieces[i]);
          longPieces[i] = regexEscape(longPieces[i]);
          mixedPieces[i] = regexEscape(mixedPieces[i]);
        }
        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')', 'i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;
        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')', 'i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')', 'i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')', 'i');
      }
      addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');
      addUnitAlias('dayOfYear', 'DDD');
      addRegexToken('DDD', match1to3);
      addRegexToken('DDDD', match3);
      addParseToken(['DDD', 'DDDD'], function(input, array, config) {
        config._dayOfYear = toInt(input);
      });
      function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
      }
      function hFormat() {
        return this.hours() % 12 || 12;
      }
      function kFormat() {
        return this.hours() || 24;
      }
      addFormatToken('H', ['HH', 2], 0, 'hour');
      addFormatToken('h', ['hh', 2], 0, hFormat);
      addFormatToken('k', ['kk', 2], 0, kFormat);
      addFormatToken('hmm', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
      });
      addFormatToken('hmmss', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      addFormatToken('Hmm', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
      });
      addFormatToken('Hmmss', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
      });
      function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
          return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
      }
      meridiem('a', true);
      meridiem('A', false);
      addUnitAlias('hour', 'h');
      function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
      }
      addRegexToken('a', matchMeridiem);
      addRegexToken('A', matchMeridiem);
      addRegexToken('H', match1to2);
      addRegexToken('h', match1to2);
      addRegexToken('HH', match1to2, match2);
      addRegexToken('hh', match1to2, match2);
      addRegexToken('hmm', match3to4);
      addRegexToken('hmmss', match5to6);
      addRegexToken('Hmm', match3to4);
      addRegexToken('Hmmss', match5to6);
      addParseToken(['H', 'HH'], HOUR);
      addParseToken(['a', 'A'], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
      });
      addParseToken(['h', 'hh'], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
      });
      addParseToken('Hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
      });
      addParseToken('Hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
      });
      function localeIsPM(input) {
        return ((input + '').toLowerCase().charAt(0) === 'p');
      }
      var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
      function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
          return isLower ? 'pm' : 'PM';
        } else {
          return isLower ? 'am' : 'AM';
        }
      }
      var getSetHour = makeGetSet('Hours', true);
      addFormatToken('m', ['mm', 2], 0, 'minute');
      addUnitAlias('minute', 'm');
      addRegexToken('m', match1to2);
      addRegexToken('mm', match1to2, match2);
      addParseToken(['m', 'mm'], MINUTE);
      var getSetMinute = makeGetSet('Minutes', false);
      addFormatToken('s', ['ss', 2], 0, 'second');
      addUnitAlias('second', 's');
      addRegexToken('s', match1to2);
      addRegexToken('ss', match1to2, match2);
      addParseToken(['s', 'ss'], SECOND);
      var getSetSecond = makeGetSet('Seconds', false);
      addFormatToken('S', 0, 0, function() {
        return ~~(this.millisecond() / 100);
      });
      addFormatToken(0, ['SS', 2], 0, function() {
        return ~~(this.millisecond() / 10);
      });
      addFormatToken(0, ['SSS', 3], 0, 'millisecond');
      addFormatToken(0, ['SSSS', 4], 0, function() {
        return this.millisecond() * 10;
      });
      addFormatToken(0, ['SSSSS', 5], 0, function() {
        return this.millisecond() * 100;
      });
      addFormatToken(0, ['SSSSSS', 6], 0, function() {
        return this.millisecond() * 1000;
      });
      addFormatToken(0, ['SSSSSSS', 7], 0, function() {
        return this.millisecond() * 10000;
      });
      addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
        return this.millisecond() * 100000;
      });
      addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
        return this.millisecond() * 1000000;
      });
      addUnitAlias('millisecond', 'ms');
      addRegexToken('S', match1to3, match1);
      addRegexToken('SS', match1to3, match2);
      addRegexToken('SSS', match1to3, match3);
      var token;
      for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
      }
      function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
      }
      for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
      }
      var getSetMillisecond = makeGetSet('Milliseconds', false);
      addFormatToken('z', 0, 0, 'zoneAbbr');
      addFormatToken('zz', 0, 0, 'zoneName');
      function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
      }
      function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
      }
      var momentPrototype__proto = Moment.prototype;
      momentPrototype__proto.add = add_subtract__add;
      momentPrototype__proto.calendar = moment_calendar__calendar;
      momentPrototype__proto.clone = clone;
      momentPrototype__proto.diff = diff;
      momentPrototype__proto.endOf = endOf;
      momentPrototype__proto.format = format;
      momentPrototype__proto.from = from;
      momentPrototype__proto.fromNow = fromNow;
      momentPrototype__proto.to = to;
      momentPrototype__proto.toNow = toNow;
      momentPrototype__proto.get = getSet;
      momentPrototype__proto.invalidAt = invalidAt;
      momentPrototype__proto.isAfter = isAfter;
      momentPrototype__proto.isBefore = isBefore;
      momentPrototype__proto.isBetween = isBetween;
      momentPrototype__proto.isSame = isSame;
      momentPrototype__proto.isSameOrAfter = isSameOrAfter;
      momentPrototype__proto.isSameOrBefore = isSameOrBefore;
      momentPrototype__proto.isValid = moment_valid__isValid;
      momentPrototype__proto.lang = lang;
      momentPrototype__proto.locale = locale;
      momentPrototype__proto.localeData = localeData;
      momentPrototype__proto.max = prototypeMax;
      momentPrototype__proto.min = prototypeMin;
      momentPrototype__proto.parsingFlags = parsingFlags;
      momentPrototype__proto.set = getSet;
      momentPrototype__proto.startOf = startOf;
      momentPrototype__proto.subtract = add_subtract__subtract;
      momentPrototype__proto.toArray = toArray;
      momentPrototype__proto.toObject = toObject;
      momentPrototype__proto.toDate = toDate;
      momentPrototype__proto.toISOString = moment_format__toISOString;
      momentPrototype__proto.toJSON = toJSON;
      momentPrototype__proto.toString = toString;
      momentPrototype__proto.unix = unix;
      momentPrototype__proto.valueOf = to_type__valueOf;
      momentPrototype__proto.creationData = creationData;
      momentPrototype__proto.year = getSetYear;
      momentPrototype__proto.isLeapYear = getIsLeapYear;
      momentPrototype__proto.weekYear = getSetWeekYear;
      momentPrototype__proto.isoWeekYear = getSetISOWeekYear;
      momentPrototype__proto.quarter = momentPrototype__proto.quarters = getSetQuarter;
      momentPrototype__proto.month = getSetMonth;
      momentPrototype__proto.daysInMonth = getDaysInMonth;
      momentPrototype__proto.week = momentPrototype__proto.weeks = getSetWeek;
      momentPrototype__proto.isoWeek = momentPrototype__proto.isoWeeks = getSetISOWeek;
      momentPrototype__proto.weeksInYear = getWeeksInYear;
      momentPrototype__proto.isoWeeksInYear = getISOWeeksInYear;
      momentPrototype__proto.date = getSetDayOfMonth;
      momentPrototype__proto.day = momentPrototype__proto.days = getSetDayOfWeek;
      momentPrototype__proto.weekday = getSetLocaleDayOfWeek;
      momentPrototype__proto.isoWeekday = getSetISODayOfWeek;
      momentPrototype__proto.dayOfYear = getSetDayOfYear;
      momentPrototype__proto.hour = momentPrototype__proto.hours = getSetHour;
      momentPrototype__proto.minute = momentPrototype__proto.minutes = getSetMinute;
      momentPrototype__proto.second = momentPrototype__proto.seconds = getSetSecond;
      momentPrototype__proto.millisecond = momentPrototype__proto.milliseconds = getSetMillisecond;
      momentPrototype__proto.utcOffset = getSetOffset;
      momentPrototype__proto.utc = setOffsetToUTC;
      momentPrototype__proto.local = setOffsetToLocal;
      momentPrototype__proto.parseZone = setOffsetToParsedOffset;
      momentPrototype__proto.hasAlignedHourOffset = hasAlignedHourOffset;
      momentPrototype__proto.isDST = isDaylightSavingTime;
      momentPrototype__proto.isDSTShifted = isDaylightSavingTimeShifted;
      momentPrototype__proto.isLocal = isLocal;
      momentPrototype__proto.isUtcOffset = isUtcOffset;
      momentPrototype__proto.isUtc = isUtc;
      momentPrototype__proto.isUTC = isUtc;
      momentPrototype__proto.zoneAbbr = getZoneAbbr;
      momentPrototype__proto.zoneName = getZoneName;
      momentPrototype__proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
      momentPrototype__proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
      momentPrototype__proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
      momentPrototype__proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779', getSetZone);
      var momentPrototype = momentPrototype__proto;
      function moment__createUnix(input) {
        return local__createLocal(input * 1000);
      }
      function moment__createInZone() {
        return local__createLocal.apply(null, arguments).parseZone();
      }
      var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
      };
      function locale_calendar__calendar(key, mom, now) {
        var output = this._calendar[key];
        return isFunction(output) ? output.call(mom, now) : output;
      }
      var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
      };
      function longDateFormat(key) {
        var format = this._longDateFormat[key],
            formatUpper = this._longDateFormat[key.toUpperCase()];
        if (format || !formatUpper) {
          return format;
        }
        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
          return val.slice(1);
        });
        return this._longDateFormat[key];
      }
      var defaultInvalidDate = 'Invalid date';
      function invalidDate() {
        return this._invalidDate;
      }
      var defaultOrdinal = '%d';
      var defaultOrdinalParse = /\d{1,2}/;
      function ordinal(number) {
        return this._ordinal.replace('%d', number);
      }
      function preParsePostFormat(string) {
        return string;
      }
      var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
      };
      function relative__relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
      }
      function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
      }
      var prototype__proto = Locale.prototype;
      prototype__proto._calendar = defaultCalendar;
      prototype__proto.calendar = locale_calendar__calendar;
      prototype__proto._longDateFormat = defaultLongDateFormat;
      prototype__proto.longDateFormat = longDateFormat;
      prototype__proto._invalidDate = defaultInvalidDate;
      prototype__proto.invalidDate = invalidDate;
      prototype__proto._ordinal = defaultOrdinal;
      prototype__proto.ordinal = ordinal;
      prototype__proto._ordinalParse = defaultOrdinalParse;
      prototype__proto.preparse = preParsePostFormat;
      prototype__proto.postformat = preParsePostFormat;
      prototype__proto._relativeTime = defaultRelativeTime;
      prototype__proto.relativeTime = relative__relativeTime;
      prototype__proto.pastFuture = pastFuture;
      prototype__proto.set = locale_set__set;
      prototype__proto.months = localeMonths;
      prototype__proto._months = defaultLocaleMonths;
      prototype__proto.monthsShort = localeMonthsShort;
      prototype__proto._monthsShort = defaultLocaleMonthsShort;
      prototype__proto.monthsParse = localeMonthsParse;
      prototype__proto._monthsRegex = defaultMonthsRegex;
      prototype__proto.monthsRegex = monthsRegex;
      prototype__proto._monthsShortRegex = defaultMonthsShortRegex;
      prototype__proto.monthsShortRegex = monthsShortRegex;
      prototype__proto.week = localeWeek;
      prototype__proto._week = defaultLocaleWeek;
      prototype__proto.firstDayOfYear = localeFirstDayOfYear;
      prototype__proto.firstDayOfWeek = localeFirstDayOfWeek;
      prototype__proto.weekdays = localeWeekdays;
      prototype__proto._weekdays = defaultLocaleWeekdays;
      prototype__proto.weekdaysMin = localeWeekdaysMin;
      prototype__proto._weekdaysMin = defaultLocaleWeekdaysMin;
      prototype__proto.weekdaysShort = localeWeekdaysShort;
      prototype__proto._weekdaysShort = defaultLocaleWeekdaysShort;
      prototype__proto.weekdaysParse = localeWeekdaysParse;
      prototype__proto._weekdaysRegex = defaultWeekdaysRegex;
      prototype__proto.weekdaysRegex = weekdaysRegex;
      prototype__proto._weekdaysShortRegex = defaultWeekdaysShortRegex;
      prototype__proto.weekdaysShortRegex = weekdaysShortRegex;
      prototype__proto._weekdaysMinRegex = defaultWeekdaysMinRegex;
      prototype__proto.weekdaysMinRegex = weekdaysMinRegex;
      prototype__proto.isPM = localeIsPM;
      prototype__proto._meridiemParse = defaultLocaleMeridiemParse;
      prototype__proto.meridiem = localeMeridiem;
      function lists__get(format, index, field, setter) {
        var locale = locale_locales__getLocale();
        var utc = create_utc__createUTC().set(setter, index);
        return locale[field](utc, format);
      }
      function listMonthsImpl(format, index, field) {
        if (typeof format === 'number') {
          index = format;
          format = undefined;
        }
        format = format || '';
        if (index != null) {
          return lists__get(format, index, field, 'month');
        }
        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
          out[i] = lists__get(format, i, field, 'month');
        }
        return out;
      }
      function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
          if (typeof format === 'number') {
            index = format;
            format = undefined;
          }
          format = format || '';
        } else {
          format = localeSorted;
          index = format;
          localeSorted = false;
          if (typeof format === 'number') {
            index = format;
            format = undefined;
          }
          format = format || '';
        }
        var locale = locale_locales__getLocale(),
            shift = localeSorted ? locale._week.dow : 0;
        if (index != null) {
          return lists__get(format, (index + shift) % 7, field, 'day');
        }
        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
          out[i] = lists__get(format, (i + shift) % 7, field, 'day');
        }
        return out;
      }
      function lists__listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
      }
      function lists__listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
      }
      function lists__listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
      }
      function lists__listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
      }
      function lists__listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
      }
      locale_locales__getSetGlobalLocale('en', {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
          var b = number % 10,
              output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
          return number + output;
        }
      });
      utils_hooks__hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', locale_locales__getSetGlobalLocale);
      utils_hooks__hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', locale_locales__getLocale);
      var mathAbs = Math.abs;
      function duration_abs__abs() {
        var data = this._data;
        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);
        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);
        return this;
      }
      function duration_add_subtract__addSubtract(duration, input, value, direction) {
        var other = create__createDuration(input, value);
        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;
        return duration._bubble();
      }
      function duration_add_subtract__add(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, 1);
      }
      function duration_add_subtract__subtract(input, value) {
        return duration_add_subtract__addSubtract(this, input, value, -1);
      }
      function absCeil(number) {
        if (number < 0) {
          return Math.floor(number);
        } else {
          return Math.ceil(number);
        }
      }
      function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds,
            minutes,
            hours,
            years,
            monthsFromDays;
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
          milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
          days = 0;
          months = 0;
        }
        data.milliseconds = milliseconds % 1000;
        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;
        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;
        hours = absFloor(minutes / 60);
        data.hours = hours % 24;
        days += absFloor(hours / 24);
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));
        years = absFloor(months / 12);
        months %= 12;
        data.days = days;
        data.months = months;
        data.years = years;
        return this;
      }
      function daysToMonths(days) {
        return days * 4800 / 146097;
      }
      function monthsToDays(months) {
        return months * 146097 / 4800;
      }
      function as(units) {
        var days;
        var months;
        var milliseconds = this._milliseconds;
        units = normalizeUnits(units);
        if (units === 'month' || units === 'year') {
          days = this._days + milliseconds / 864e5;
          months = this._months + daysToMonths(days);
          return units === 'month' ? months : months / 12;
        } else {
          days = this._days + Math.round(monthsToDays(this._months));
          switch (units) {
            case 'week':
              return days / 7 + milliseconds / 6048e5;
            case 'day':
              return days + milliseconds / 864e5;
            case 'hour':
              return days * 24 + milliseconds / 36e5;
            case 'minute':
              return days * 1440 + milliseconds / 6e4;
            case 'second':
              return days * 86400 + milliseconds / 1000;
            case 'millisecond':
              return Math.floor(days * 864e5) + milliseconds;
            default:
              throw new Error('Unknown unit ' + units);
          }
        }
      }
      function duration_as__valueOf() {
        return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
      }
      function makeAs(alias) {
        return function() {
          return this.as(alias);
        };
      }
      var asMilliseconds = makeAs('ms');
      var asSeconds = makeAs('s');
      var asMinutes = makeAs('m');
      var asHours = makeAs('h');
      var asDays = makeAs('d');
      var asWeeks = makeAs('w');
      var asMonths = makeAs('M');
      var asYears = makeAs('y');
      function duration_get__get(units) {
        units = normalizeUnits(units);
        return this[units + 's']();
      }
      function makeGetter(name) {
        return function() {
          return this._data[name];
        };
      }
      var milliseconds = makeGetter('milliseconds');
      var seconds = makeGetter('seconds');
      var minutes = makeGetter('minutes');
      var hours = makeGetter('hours');
      var days = makeGetter('days');
      var months = makeGetter('months');
      var years = makeGetter('years');
      function weeks() {
        return absFloor(this.days() / 7);
      }
      var round = Math.round;
      var thresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
      };
      function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
      }
      function duration_humanize__relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = create__createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));
        var a = seconds < thresholds.s && ['s', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];
        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
      }
      function duration_humanize__getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
          return false;
        }
        if (limit === undefined) {
          return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        return true;
      }
      function humanize(withSuffix) {
        var locale = this.localeData();
        var output = duration_humanize__relativeTime(this, !withSuffix, locale);
        if (withSuffix) {
          output = locale.pastFuture(+this, output);
        }
        return locale.postformat(output);
      }
      var iso_string__abs = Math.abs;
      function iso_string__toISOString() {
        var seconds = iso_string__abs(this._milliseconds) / 1000;
        var days = iso_string__abs(this._days);
        var months = iso_string__abs(this._months);
        var minutes,
            hours,
            years;
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;
        years = absFloor(months / 12);
        months %= 12;
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds;
        var total = this.asSeconds();
        if (!total) {
          return 'P0D';
        }
        return (total < 0 ? '-' : '') + 'P' + (Y ? Y + 'Y' : '') + (M ? M + 'M' : '') + (D ? D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? h + 'H' : '') + (m ? m + 'M' : '') + (s ? s + 'S' : '');
      }
      var duration_prototype__proto = Duration.prototype;
      duration_prototype__proto.abs = duration_abs__abs;
      duration_prototype__proto.add = duration_add_subtract__add;
      duration_prototype__proto.subtract = duration_add_subtract__subtract;
      duration_prototype__proto.as = as;
      duration_prototype__proto.asMilliseconds = asMilliseconds;
      duration_prototype__proto.asSeconds = asSeconds;
      duration_prototype__proto.asMinutes = asMinutes;
      duration_prototype__proto.asHours = asHours;
      duration_prototype__proto.asDays = asDays;
      duration_prototype__proto.asWeeks = asWeeks;
      duration_prototype__proto.asMonths = asMonths;
      duration_prototype__proto.asYears = asYears;
      duration_prototype__proto.valueOf = duration_as__valueOf;
      duration_prototype__proto._bubble = bubble;
      duration_prototype__proto.get = duration_get__get;
      duration_prototype__proto.milliseconds = milliseconds;
      duration_prototype__proto.seconds = seconds;
      duration_prototype__proto.minutes = minutes;
      duration_prototype__proto.hours = hours;
      duration_prototype__proto.days = days;
      duration_prototype__proto.weeks = weeks;
      duration_prototype__proto.months = months;
      duration_prototype__proto.years = years;
      duration_prototype__proto.humanize = humanize;
      duration_prototype__proto.toISOString = iso_string__toISOString;
      duration_prototype__proto.toString = iso_string__toISOString;
      duration_prototype__proto.toJSON = iso_string__toISOString;
      duration_prototype__proto.locale = locale;
      duration_prototype__proto.localeData = localeData;
      duration_prototype__proto.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', iso_string__toISOString);
      duration_prototype__proto.lang = lang;
      addFormatToken('X', 0, 0, 'unix');
      addFormatToken('x', 0, 0, 'valueOf');
      addRegexToken('x', matchSigned);
      addRegexToken('X', matchTimestamp);
      addParseToken('X', function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
      });
      addParseToken('x', function(input, array, config) {
        config._d = new Date(toInt(input));
      });
      utils_hooks__hooks.version = '2.13.0';
      setHookCallback(local__createLocal);
      utils_hooks__hooks.fn = momentPrototype;
      utils_hooks__hooks.min = min;
      utils_hooks__hooks.max = max;
      utils_hooks__hooks.now = now;
      utils_hooks__hooks.utc = create_utc__createUTC;
      utils_hooks__hooks.unix = moment__createUnix;
      utils_hooks__hooks.months = lists__listMonths;
      utils_hooks__hooks.isDate = isDate;
      utils_hooks__hooks.locale = locale_locales__getSetGlobalLocale;
      utils_hooks__hooks.invalid = valid__createInvalid;
      utils_hooks__hooks.duration = create__createDuration;
      utils_hooks__hooks.isMoment = isMoment;
      utils_hooks__hooks.weekdays = lists__listWeekdays;
      utils_hooks__hooks.parseZone = moment__createInZone;
      utils_hooks__hooks.localeData = locale_locales__getLocale;
      utils_hooks__hooks.isDuration = isDuration;
      utils_hooks__hooks.monthsShort = lists__listMonthsShort;
      utils_hooks__hooks.weekdaysMin = lists__listWeekdaysMin;
      utils_hooks__hooks.defineLocale = defineLocale;
      utils_hooks__hooks.updateLocale = updateLocale;
      utils_hooks__hooks.locales = locale_locales__listLocales;
      utils_hooks__hooks.weekdaysShort = lists__listWeekdaysShort;
      utils_hooks__hooks.normalizeUnits = normalizeUnits;
      utils_hooks__hooks.relativeTimeThreshold = duration_humanize__getSetRelativeTimeThreshold;
      utils_hooks__hooks.prototype = momentPrototype;
      var _moment = utils_hooks__hooks;
      return _moment;
    }));
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("2c", ["2b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('2b');
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
(function(factory) {
  'use strict';
  if (typeof define === 'function' && define.amd) {
    define("2d", ["3", "2c"], factory);
  } else if (typeof exports === 'object') {
    factory(require('jquery'), require('moment'));
  } else {
    if (typeof jQuery === 'undefined') {
      throw 'bootstrap-datetimepicker requires jQuery to be loaded first';
    }
    if (typeof moment === 'undefined') {
      throw 'bootstrap-datetimepicker requires Moment.js to be loaded first';
    }
    factory(jQuery, moment);
  }
}(function($, moment) {
  'use strict';
  if (!moment) {
    throw new Error('bootstrap-datetimepicker requires Moment.js to be loaded first');
  }
  var dateTimePicker = function(element, options) {
    var picker = {},
        date,
        viewDate,
        unset = true,
        input,
        component = false,
        widget = false,
        use24Hours,
        minViewModeNumber = 0,
        actualFormat,
        parseFormats,
        currentViewMode,
        datePickerModes = [{
          clsName: 'days',
          navFnc: 'M',
          navStep: 1
        }, {
          clsName: 'months',
          navFnc: 'y',
          navStep: 1
        }, {
          clsName: 'years',
          navFnc: 'y',
          navStep: 10
        }, {
          clsName: 'decades',
          navFnc: 'y',
          navStep: 100
        }],
        viewModes = ['days', 'months', 'years', 'decades'],
        verticalModes = ['top', 'bottom', 'auto'],
        horizontalModes = ['left', 'right', 'auto'],
        toolbarPlacements = ['default', 'top', 'bottom'],
        keyMap = {
          'up': 38,
          38: 'up',
          'down': 40,
          40: 'down',
          'left': 37,
          37: 'left',
          'right': 39,
          39: 'right',
          'tab': 9,
          9: 'tab',
          'escape': 27,
          27: 'escape',
          'enter': 13,
          13: 'enter',
          'pageUp': 33,
          33: 'pageUp',
          'pageDown': 34,
          34: 'pageDown',
          'shift': 16,
          16: 'shift',
          'control': 17,
          17: 'control',
          'space': 32,
          32: 'space',
          't': 84,
          84: 't',
          'delete': 46,
          46: 'delete'
        },
        keyState = {},
        getMoment = function(d) {
          var tzEnabled = false,
              returnMoment,
              currentZoneOffset,
              incomingZoneOffset,
              timeZoneIndicator,
              dateWithTimeZoneInfo;
          if (moment.tz !== undefined && options.timeZone !== undefined && options.timeZone !== null && options.timeZone !== '') {
            tzEnabled = true;
          }
          if (d === undefined || d === null) {
            if (tzEnabled) {
              returnMoment = moment().tz(options.timeZone).startOf('d');
            } else {
              returnMoment = moment().startOf('d');
            }
          } else {
            if (tzEnabled) {
              currentZoneOffset = moment().tz(options.timeZone).utcOffset();
              incomingZoneOffset = moment(d, parseFormats, options.useStrict).utcOffset();
              if (incomingZoneOffset !== currentZoneOffset) {
                timeZoneIndicator = moment().tz(options.timeZone).format('Z');
                dateWithTimeZoneInfo = moment(d, parseFormats, options.useStrict).format('YYYY-MM-DD[T]HH:mm:ss') + timeZoneIndicator;
                returnMoment = moment(dateWithTimeZoneInfo, parseFormats, options.useStrict).tz(options.timeZone);
              } else {
                returnMoment = moment(d, parseFormats, options.useStrict).tz(options.timeZone);
              }
            } else {
              returnMoment = moment(d, parseFormats, options.useStrict);
            }
          }
          return returnMoment;
        },
        isEnabled = function(granularity) {
          if (typeof granularity !== 'string' || granularity.length > 1) {
            throw new TypeError('isEnabled expects a single character string parameter');
          }
          switch (granularity) {
            case 'y':
              return actualFormat.indexOf('Y') !== -1;
            case 'M':
              return actualFormat.indexOf('M') !== -1;
            case 'd':
              return actualFormat.toLowerCase().indexOf('d') !== -1;
            case 'h':
            case 'H':
              return actualFormat.toLowerCase().indexOf('h') !== -1;
            case 'm':
              return actualFormat.indexOf('m') !== -1;
            case 's':
              return actualFormat.indexOf('s') !== -1;
            default:
              return false;
          }
        },
        hasTime = function() {
          return (isEnabled('h') || isEnabled('m') || isEnabled('s'));
        },
        hasDate = function() {
          return (isEnabled('y') || isEnabled('M') || isEnabled('d'));
        },
        getDatePickerTemplate = function() {
          var headTemplate = $('<thead>').append($('<tr>').append($('<th>').addClass('prev').attr('data-action', 'previous').append($('<span>').addClass(options.icons.previous))).append($('<th>').addClass('picker-switch').attr('data-action', 'pickerSwitch').attr('colspan', (options.calendarWeeks ? '6' : '5'))).append($('<th>').addClass('next').attr('data-action', 'next').append($('<span>').addClass(options.icons.next)))),
              contTemplate = $('<tbody>').append($('<tr>').append($('<td>').attr('colspan', (options.calendarWeeks ? '8' : '7'))));
          return [$('<div>').addClass('datepicker-days').append($('<table>').addClass('table-condensed').append(headTemplate).append($('<tbody>'))), $('<div>').addClass('datepicker-months').append($('<table>').addClass('table-condensed').append(headTemplate.clone()).append(contTemplate.clone())), $('<div>').addClass('datepicker-years').append($('<table>').addClass('table-condensed').append(headTemplate.clone()).append(contTemplate.clone())), $('<div>').addClass('datepicker-decades').append($('<table>').addClass('table-condensed').append(headTemplate.clone()).append(contTemplate.clone()))];
        },
        getTimePickerMainTemplate = function() {
          var topRow = $('<tr>'),
              middleRow = $('<tr>'),
              bottomRow = $('<tr>');
          if (isEnabled('h')) {
            topRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.incrementHour
            }).addClass('btn').attr('data-action', 'incrementHours').append($('<span>').addClass(options.icons.up))));
            middleRow.append($('<td>').append($('<span>').addClass('timepicker-hour').attr({
              'data-time-component': 'hours',
              'title': options.tooltips.pickHour
            }).attr('data-action', 'showHours')));
            bottomRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.decrementHour
            }).addClass('btn').attr('data-action', 'decrementHours').append($('<span>').addClass(options.icons.down))));
          }
          if (isEnabled('m')) {
            if (isEnabled('h')) {
              topRow.append($('<td>').addClass('separator'));
              middleRow.append($('<td>').addClass('separator').html(':'));
              bottomRow.append($('<td>').addClass('separator'));
            }
            topRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.incrementMinute
            }).addClass('btn').attr('data-action', 'incrementMinutes').append($('<span>').addClass(options.icons.up))));
            middleRow.append($('<td>').append($('<span>').addClass('timepicker-minute').attr({
              'data-time-component': 'minutes',
              'title': options.tooltips.pickMinute
            }).attr('data-action', 'showMinutes')));
            bottomRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.decrementMinute
            }).addClass('btn').attr('data-action', 'decrementMinutes').append($('<span>').addClass(options.icons.down))));
          }
          if (isEnabled('s')) {
            if (isEnabled('m')) {
              topRow.append($('<td>').addClass('separator'));
              middleRow.append($('<td>').addClass('separator').html(':'));
              bottomRow.append($('<td>').addClass('separator'));
            }
            topRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.incrementSecond
            }).addClass('btn').attr('data-action', 'incrementSeconds').append($('<span>').addClass(options.icons.up))));
            middleRow.append($('<td>').append($('<span>').addClass('timepicker-second').attr({
              'data-time-component': 'seconds',
              'title': options.tooltips.pickSecond
            }).attr('data-action', 'showSeconds')));
            bottomRow.append($('<td>').append($('<a>').attr({
              href: '#',
              tabindex: '-1',
              'title': options.tooltips.decrementSecond
            }).addClass('btn').attr('data-action', 'decrementSeconds').append($('<span>').addClass(options.icons.down))));
          }
          if (!use24Hours) {
            topRow.append($('<td>').addClass('separator'));
            middleRow.append($('<td>').append($('<button>').addClass('btn btn-primary').attr({
              'data-action': 'togglePeriod',
              tabindex: '-1',
              'title': options.tooltips.togglePeriod
            })));
            bottomRow.append($('<td>').addClass('separator'));
          }
          return $('<div>').addClass('timepicker-picker').append($('<table>').addClass('table-condensed').append([topRow, middleRow, bottomRow]));
        },
        getTimePickerTemplate = function() {
          var hoursView = $('<div>').addClass('timepicker-hours').append($('<table>').addClass('table-condensed')),
              minutesView = $('<div>').addClass('timepicker-minutes').append($('<table>').addClass('table-condensed')),
              secondsView = $('<div>').addClass('timepicker-seconds').append($('<table>').addClass('table-condensed')),
              ret = [getTimePickerMainTemplate()];
          if (isEnabled('h')) {
            ret.push(hoursView);
          }
          if (isEnabled('m')) {
            ret.push(minutesView);
          }
          if (isEnabled('s')) {
            ret.push(secondsView);
          }
          return ret;
        },
        getToolbar = function() {
          var row = [];
          if (options.showTodayButton) {
            row.push($('<td>').append($('<a>').attr({
              'data-action': 'today',
              'title': options.tooltips.today
            }).append($('<span>').addClass(options.icons.today))));
          }
          if (!options.sideBySide && hasDate() && hasTime()) {
            row.push($('<td>').append($('<a>').attr({
              'data-action': 'togglePicker',
              'title': options.tooltips.selectTime
            }).append($('<span>').addClass(options.icons.time))));
          }
          if (options.showClear) {
            row.push($('<td>').append($('<a>').attr({
              'data-action': 'clear',
              'title': options.tooltips.clear
            }).append($('<span>').addClass(options.icons.clear))));
          }
          if (options.showClose) {
            row.push($('<td>').append($('<a>').attr({
              'data-action': 'close',
              'title': options.tooltips.close
            }).append($('<span>').addClass(options.icons.close))));
          }
          return $('<table>').addClass('table-condensed').append($('<tbody>').append($('<tr>').append(row)));
        },
        getTemplate = function() {
          var template = $('<div>').addClass('bootstrap-datetimepicker-widget dropdown-menu'),
              dateView = $('<div>').addClass('datepicker').append(getDatePickerTemplate()),
              timeView = $('<div>').addClass('timepicker').append(getTimePickerTemplate()),
              content = $('<ul>').addClass('list-unstyled'),
              toolbar = $('<li>').addClass('picker-switch' + (options.collapse ? ' accordion-toggle' : '')).append(getToolbar());
          if (options.inline) {
            template.removeClass('dropdown-menu');
          }
          if (use24Hours) {
            template.addClass('usetwentyfour');
          }
          if (isEnabled('s') && !use24Hours) {
            template.addClass('wider');
          }
          if (options.sideBySide && hasDate() && hasTime()) {
            template.addClass('timepicker-sbs');
            if (options.toolbarPlacement === 'top') {
              template.append(toolbar);
            }
            template.append($('<div>').addClass('row').append(dateView.addClass('col-md-6')).append(timeView.addClass('col-md-6')));
            if (options.toolbarPlacement === 'bottom') {
              template.append(toolbar);
            }
            return template;
          }
          if (options.toolbarPlacement === 'top') {
            content.append(toolbar);
          }
          if (hasDate()) {
            content.append($('<li>').addClass((options.collapse && hasTime() ? 'collapse in' : '')).append(dateView));
          }
          if (options.toolbarPlacement === 'default') {
            content.append(toolbar);
          }
          if (hasTime()) {
            content.append($('<li>').addClass((options.collapse && hasDate() ? 'collapse' : '')).append(timeView));
          }
          if (options.toolbarPlacement === 'bottom') {
            content.append(toolbar);
          }
          return template.append(content);
        },
        dataToOptions = function() {
          var eData,
              dataOptions = {};
          if (element.is('input') || options.inline) {
            eData = element.data();
          } else {
            eData = element.find('input').data();
          }
          if (eData.dateOptions && eData.dateOptions instanceof Object) {
            dataOptions = $.extend(true, dataOptions, eData.dateOptions);
          }
          $.each(options, function(key) {
            var attributeName = 'date' + key.charAt(0).toUpperCase() + key.slice(1);
            if (eData[attributeName] !== undefined) {
              dataOptions[key] = eData[attributeName];
            }
          });
          return dataOptions;
        },
        place = function() {
          var position = (component || element).position(),
              offset = (component || element).offset(),
              vertical = options.widgetPositioning.vertical,
              horizontal = options.widgetPositioning.horizontal,
              parent;
          if (options.widgetParent) {
            parent = options.widgetParent.append(widget);
          } else if (element.is('input')) {
            parent = element.after(widget).parent();
          } else if (options.inline) {
            parent = element.append(widget);
            return;
          } else {
            parent = element;
            element.children().first().after(widget);
          }
          if (vertical === 'auto') {
            if (offset.top + widget.height() * 1.5 >= $(window).height() + $(window).scrollTop() && widget.height() + element.outerHeight() < offset.top) {
              vertical = 'top';
            } else {
              vertical = 'bottom';
            }
          }
          if (horizontal === 'auto') {
            if (parent.width() < offset.left + widget.outerWidth() / 2 && offset.left + widget.outerWidth() > $(window).width()) {
              horizontal = 'right';
            } else {
              horizontal = 'left';
            }
          }
          if (vertical === 'top') {
            widget.addClass('top').removeClass('bottom');
          } else {
            widget.addClass('bottom').removeClass('top');
          }
          if (horizontal === 'right') {
            widget.addClass('pull-right');
          } else {
            widget.removeClass('pull-right');
          }
          if (parent.css('position') !== 'relative') {
            parent = parent.parents().filter(function() {
              return $(this).css('position') === 'relative';
            }).first();
          }
          if (parent.length === 0) {
            throw new Error('datetimepicker component should be placed within a relative positioned container');
          }
          widget.css({
            top: vertical === 'top' ? 'auto' : position.top + element.outerHeight(),
            bottom: vertical === 'top' ? position.top + element.outerHeight() : 'auto',
            left: horizontal === 'left' ? (parent === element ? 0 : position.left) : 'auto',
            right: horizontal === 'left' ? 'auto' : parent.outerWidth() - element.outerWidth() - (parent === element ? 0 : position.left)
          });
        },
        notifyEvent = function(e) {
          if (e.type === 'dp.change' && ((e.date && e.date.isSame(e.oldDate)) || (!e.date && !e.oldDate))) {
            return;
          }
          element.trigger(e);
        },
        viewUpdate = function(e) {
          if (e === 'y') {
            e = 'YYYY';
          }
          notifyEvent({
            type: 'dp.update',
            change: e,
            viewDate: viewDate.clone()
          });
        },
        showMode = function(dir) {
          if (!widget) {
            return;
          }
          if (dir) {
            currentViewMode = Math.max(minViewModeNumber, Math.min(3, currentViewMode + dir));
          }
          widget.find('.datepicker > div').hide().filter('.datepicker-' + datePickerModes[currentViewMode].clsName).show();
        },
        fillDow = function() {
          var row = $('<tr>'),
              currentDate = viewDate.clone().startOf('w').startOf('d');
          if (options.calendarWeeks === true) {
            row.append($('<th>').addClass('cw').text('#'));
          }
          while (currentDate.isBefore(viewDate.clone().endOf('w'))) {
            row.append($('<th>').addClass('dow').text(currentDate.format('dd')));
            currentDate.add(1, 'd');
          }
          widget.find('.datepicker-days thead').append(row);
        },
        isInDisabledDates = function(testDate) {
          return options.disabledDates[testDate.format('YYYY-MM-DD')] === true;
        },
        isInEnabledDates = function(testDate) {
          return options.enabledDates[testDate.format('YYYY-MM-DD')] === true;
        },
        isInDisabledHours = function(testDate) {
          return options.disabledHours[testDate.format('H')] === true;
        },
        isInEnabledHours = function(testDate) {
          return options.enabledHours[testDate.format('H')] === true;
        },
        isValid = function(targetMoment, granularity) {
          if (!targetMoment.isValid()) {
            return false;
          }
          if (options.disabledDates && granularity === 'd' && isInDisabledDates(targetMoment)) {
            return false;
          }
          if (options.enabledDates && granularity === 'd' && !isInEnabledDates(targetMoment)) {
            return false;
          }
          if (options.minDate && targetMoment.isBefore(options.minDate, granularity)) {
            return false;
          }
          if (options.maxDate && targetMoment.isAfter(options.maxDate, granularity)) {
            return false;
          }
          if (options.daysOfWeekDisabled && granularity === 'd' && options.daysOfWeekDisabled.indexOf(targetMoment.day()) !== -1) {
            return false;
          }
          if (options.disabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && isInDisabledHours(targetMoment)) {
            return false;
          }
          if (options.enabledHours && (granularity === 'h' || granularity === 'm' || granularity === 's') && !isInEnabledHours(targetMoment)) {
            return false;
          }
          if (options.disabledTimeIntervals && (granularity === 'h' || granularity === 'm' || granularity === 's')) {
            var found = false;
            $.each(options.disabledTimeIntervals, function() {
              if (targetMoment.isBetween(this[0], this[1])) {
                found = true;
                return false;
              }
            });
            if (found) {
              return false;
            }
          }
          return true;
        },
        fillMonths = function() {
          var spans = [],
              monthsShort = viewDate.clone().startOf('y').startOf('d');
          while (monthsShort.isSame(viewDate, 'y')) {
            spans.push($('<span>').attr('data-action', 'selectMonth').addClass('month').text(monthsShort.format('MMM')));
            monthsShort.add(1, 'M');
          }
          widget.find('.datepicker-months td').empty().append(spans);
        },
        updateMonths = function() {
          var monthsView = widget.find('.datepicker-months'),
              monthsViewHeader = monthsView.find('th'),
              months = monthsView.find('tbody').find('span');
          monthsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevYear);
          monthsViewHeader.eq(1).attr('title', options.tooltips.selectYear);
          monthsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextYear);
          monthsView.find('.disabled').removeClass('disabled');
          if (!isValid(viewDate.clone().subtract(1, 'y'), 'y')) {
            monthsViewHeader.eq(0).addClass('disabled');
          }
          monthsViewHeader.eq(1).text(viewDate.year());
          if (!isValid(viewDate.clone().add(1, 'y'), 'y')) {
            monthsViewHeader.eq(2).addClass('disabled');
          }
          months.removeClass('active');
          if (date.isSame(viewDate, 'y') && !unset) {
            months.eq(date.month()).addClass('active');
          }
          months.each(function(index) {
            if (!isValid(viewDate.clone().month(index), 'M')) {
              $(this).addClass('disabled');
            }
          });
        },
        updateYears = function() {
          var yearsView = widget.find('.datepicker-years'),
              yearsViewHeader = yearsView.find('th'),
              startYear = viewDate.clone().subtract(5, 'y'),
              endYear = viewDate.clone().add(6, 'y'),
              html = '';
          yearsViewHeader.eq(0).find('span').attr('title', options.tooltips.prevDecade);
          yearsViewHeader.eq(1).attr('title', options.tooltips.selectDecade);
          yearsViewHeader.eq(2).find('span').attr('title', options.tooltips.nextDecade);
          yearsView.find('.disabled').removeClass('disabled');
          if (options.minDate && options.minDate.isAfter(startYear, 'y')) {
            yearsViewHeader.eq(0).addClass('disabled');
          }
          yearsViewHeader.eq(1).text(startYear.year() + '-' + endYear.year());
          if (options.maxDate && options.maxDate.isBefore(endYear, 'y')) {
            yearsViewHeader.eq(2).addClass('disabled');
          }
          while (!startYear.isAfter(endYear, 'y')) {
            html += '<span data-action="selectYear" class="year' + (startYear.isSame(date, 'y') && !unset ? ' active' : '') + (!isValid(startYear, 'y') ? ' disabled' : '') + '">' + startYear.year() + '</span>';
            startYear.add(1, 'y');
          }
          yearsView.find('td').html(html);
        },
        updateDecades = function() {
          var decadesView = widget.find('.datepicker-decades'),
              decadesViewHeader = decadesView.find('th'),
              startDecade = moment({y: viewDate.year() - (viewDate.year() % 100) - 1}),
              endDecade = startDecade.clone().add(100, 'y'),
              startedAt = startDecade.clone(),
              html = '';
          decadesViewHeader.eq(0).find('span').attr('title', options.tooltips.prevCentury);
          decadesViewHeader.eq(2).find('span').attr('title', options.tooltips.nextCentury);
          decadesView.find('.disabled').removeClass('disabled');
          if (startDecade.isSame(moment({y: 1900})) || (options.minDate && options.minDate.isAfter(startDecade, 'y'))) {
            decadesViewHeader.eq(0).addClass('disabled');
          }
          decadesViewHeader.eq(1).text(startDecade.year() + '-' + endDecade.year());
          if (startDecade.isSame(moment({y: 2000})) || (options.maxDate && options.maxDate.isBefore(endDecade, 'y'))) {
            decadesViewHeader.eq(2).addClass('disabled');
          }
          while (!startDecade.isAfter(endDecade, 'y')) {
            html += '<span data-action="selectDecade" class="decade' + (startDecade.isSame(date, 'y') ? ' active' : '') + (!isValid(startDecade, 'y') ? ' disabled' : '') + '" data-selection="' + (startDecade.year() + 6) + '">' + (startDecade.year() + 1) + ' - ' + (startDecade.year() + 12) + '</span>';
            startDecade.add(12, 'y');
          }
          html += '<span></span><span></span><span></span>';
          decadesView.find('td').html(html);
          decadesViewHeader.eq(1).text((startedAt.year() + 1) + '-' + (startDecade.year()));
        },
        fillDate = function() {
          var daysView = widget.find('.datepicker-days'),
              daysViewHeader = daysView.find('th'),
              currentDate,
              html = [],
              row,
              clsName,
              i;
          if (!hasDate()) {
            return;
          }
          daysViewHeader.eq(0).find('span').attr('title', options.tooltips.prevMonth);
          daysViewHeader.eq(1).attr('title', options.tooltips.selectMonth);
          daysViewHeader.eq(2).find('span').attr('title', options.tooltips.nextMonth);
          daysView.find('.disabled').removeClass('disabled');
          daysViewHeader.eq(1).text(viewDate.format(options.dayViewHeaderFormat));
          if (!isValid(viewDate.clone().subtract(1, 'M'), 'M')) {
            daysViewHeader.eq(0).addClass('disabled');
          }
          if (!isValid(viewDate.clone().add(1, 'M'), 'M')) {
            daysViewHeader.eq(2).addClass('disabled');
          }
          currentDate = viewDate.clone().startOf('M').startOf('w').startOf('d');
          for (i = 0; i < 42; i++) {
            if (currentDate.weekday() === 0) {
              row = $('<tr>');
              if (options.calendarWeeks) {
                row.append('<td class="cw">' + currentDate.week() + '</td>');
              }
              html.push(row);
            }
            clsName = '';
            if (currentDate.isBefore(viewDate, 'M')) {
              clsName += ' old';
            }
            if (currentDate.isAfter(viewDate, 'M')) {
              clsName += ' new';
            }
            if (currentDate.isSame(date, 'd') && !unset) {
              clsName += ' active';
            }
            if (!isValid(currentDate, 'd')) {
              clsName += ' disabled';
            }
            if (currentDate.isSame(getMoment(), 'd')) {
              clsName += ' today';
            }
            if (currentDate.day() === 0 || currentDate.day() === 6) {
              clsName += ' weekend';
            }
            row.append('<td data-action="selectDay" data-day="' + currentDate.format('L') + '" class="day' + clsName + '">' + currentDate.date() + '</td>');
            currentDate.add(1, 'd');
          }
          daysView.find('tbody').empty().append(html);
          updateMonths();
          updateYears();
          updateDecades();
        },
        fillHours = function() {
          var table = widget.find('.timepicker-hours table'),
              currentHour = viewDate.clone().startOf('d'),
              html = [],
              row = $('<tr>');
          if (viewDate.hour() > 11 && !use24Hours) {
            currentHour.hour(12);
          }
          while (currentHour.isSame(viewDate, 'd') && (use24Hours || (viewDate.hour() < 12 && currentHour.hour() < 12) || viewDate.hour() > 11)) {
            if (currentHour.hour() % 4 === 0) {
              row = $('<tr>');
              html.push(row);
            }
            row.append('<td data-action="selectHour" class="hour' + (!isValid(currentHour, 'h') ? ' disabled' : '') + '">' + currentHour.format(use24Hours ? 'HH' : 'hh') + '</td>');
            currentHour.add(1, 'h');
          }
          table.empty().append(html);
        },
        fillMinutes = function() {
          var table = widget.find('.timepicker-minutes table'),
              currentMinute = viewDate.clone().startOf('h'),
              html = [],
              row = $('<tr>'),
              step = options.stepping === 1 ? 5 : options.stepping;
          while (viewDate.isSame(currentMinute, 'h')) {
            if (currentMinute.minute() % (step * 4) === 0) {
              row = $('<tr>');
              html.push(row);
            }
            row.append('<td data-action="selectMinute" class="minute' + (!isValid(currentMinute, 'm') ? ' disabled' : '') + '">' + currentMinute.format('mm') + '</td>');
            currentMinute.add(step, 'm');
          }
          table.empty().append(html);
        },
        fillSeconds = function() {
          var table = widget.find('.timepicker-seconds table'),
              currentSecond = viewDate.clone().startOf('m'),
              html = [],
              row = $('<tr>');
          while (viewDate.isSame(currentSecond, 'm')) {
            if (currentSecond.second() % 20 === 0) {
              row = $('<tr>');
              html.push(row);
            }
            row.append('<td data-action="selectSecond" class="second' + (!isValid(currentSecond, 's') ? ' disabled' : '') + '">' + currentSecond.format('ss') + '</td>');
            currentSecond.add(5, 's');
          }
          table.empty().append(html);
        },
        fillTime = function() {
          var toggle,
              newDate,
              timeComponents = widget.find('.timepicker span[data-time-component]');
          if (!use24Hours) {
            toggle = widget.find('.timepicker [data-action=togglePeriod]');
            newDate = date.clone().add((date.hours() >= 12) ? -12 : 12, 'h');
            toggle.text(date.format('A'));
            if (isValid(newDate, 'h')) {
              toggle.removeClass('disabled');
            } else {
              toggle.addClass('disabled');
            }
          }
          timeComponents.filter('[data-time-component=hours]').text(date.format(use24Hours ? 'HH' : 'hh'));
          timeComponents.filter('[data-time-component=minutes]').text(date.format('mm'));
          timeComponents.filter('[data-time-component=seconds]').text(date.format('ss'));
          fillHours();
          fillMinutes();
          fillSeconds();
        },
        update = function() {
          if (!widget) {
            return;
          }
          fillDate();
          fillTime();
        },
        setValue = function(targetMoment) {
          var oldDate = unset ? null : date;
          if (!targetMoment) {
            unset = true;
            input.val('');
            element.data('date', '');
            notifyEvent({
              type: 'dp.change',
              date: false,
              oldDate: oldDate
            });
            update();
            return;
          }
          targetMoment = targetMoment.clone().locale(options.locale);
          if (options.stepping !== 1) {
            targetMoment.minutes((Math.round(targetMoment.minutes() / options.stepping) * options.stepping) % 60).seconds(0);
          }
          if (isValid(targetMoment)) {
            date = targetMoment;
            viewDate = date.clone();
            input.val(date.format(actualFormat));
            element.data('date', date.format(actualFormat));
            unset = false;
            update();
            notifyEvent({
              type: 'dp.change',
              date: date.clone(),
              oldDate: oldDate
            });
          } else {
            if (!options.keepInvalid) {
              input.val(unset ? '' : date.format(actualFormat));
            }
            notifyEvent({
              type: 'dp.error',
              date: targetMoment
            });
          }
        },
        hide = function() {
          var transitioning = false;
          if (!widget) {
            return picker;
          }
          widget.find('.collapse').each(function() {
            var collapseData = $(this).data('collapse');
            if (collapseData && collapseData.transitioning) {
              transitioning = true;
              return false;
            }
            return true;
          });
          if (transitioning) {
            return picker;
          }
          if (component && component.hasClass('btn')) {
            component.toggleClass('active');
          }
          widget.hide();
          $(window).off('resize', place);
          widget.off('click', '[data-action]');
          widget.off('mousedown', false);
          widget.remove();
          widget = false;
          notifyEvent({
            type: 'dp.hide',
            date: date.clone()
          });
          input.blur();
          return picker;
        },
        clear = function() {
          setValue(null);
        },
        actions = {
          next: function() {
            var navFnc = datePickerModes[currentViewMode].navFnc;
            viewDate.add(datePickerModes[currentViewMode].navStep, navFnc);
            fillDate();
            viewUpdate(navFnc);
          },
          previous: function() {
            var navFnc = datePickerModes[currentViewMode].navFnc;
            viewDate.subtract(datePickerModes[currentViewMode].navStep, navFnc);
            fillDate();
            viewUpdate(navFnc);
          },
          pickerSwitch: function() {
            showMode(1);
          },
          selectMonth: function(e) {
            var month = $(e.target).closest('tbody').find('span').index($(e.target));
            viewDate.month(month);
            if (currentViewMode === minViewModeNumber) {
              setValue(date.clone().year(viewDate.year()).month(viewDate.month()));
              if (!options.inline) {
                hide();
              }
            } else {
              showMode(-1);
              fillDate();
            }
            viewUpdate('M');
          },
          selectYear: function(e) {
            var year = parseInt($(e.target).text(), 10) || 0;
            viewDate.year(year);
            if (currentViewMode === minViewModeNumber) {
              setValue(date.clone().year(viewDate.year()));
              if (!options.inline) {
                hide();
              }
            } else {
              showMode(-1);
              fillDate();
            }
            viewUpdate('YYYY');
          },
          selectDecade: function(e) {
            var year = parseInt($(e.target).data('selection'), 10) || 0;
            viewDate.year(year);
            if (currentViewMode === minViewModeNumber) {
              setValue(date.clone().year(viewDate.year()));
              if (!options.inline) {
                hide();
              }
            } else {
              showMode(-1);
              fillDate();
            }
            viewUpdate('YYYY');
          },
          selectDay: function(e) {
            var day = viewDate.clone();
            if ($(e.target).is('.old')) {
              day.subtract(1, 'M');
            }
            if ($(e.target).is('.new')) {
              day.add(1, 'M');
            }
            setValue(day.date(parseInt($(e.target).text(), 10)));
            if (!hasTime() && !options.keepOpen && !options.inline) {
              hide();
            }
          },
          incrementHours: function() {
            var newDate = date.clone().add(1, 'h');
            if (isValid(newDate, 'h')) {
              setValue(newDate);
            }
          },
          incrementMinutes: function() {
            var newDate = date.clone().add(options.stepping, 'm');
            if (isValid(newDate, 'm')) {
              setValue(newDate);
            }
          },
          incrementSeconds: function() {
            var newDate = date.clone().add(1, 's');
            if (isValid(newDate, 's')) {
              setValue(newDate);
            }
          },
          decrementHours: function() {
            var newDate = date.clone().subtract(1, 'h');
            if (isValid(newDate, 'h')) {
              setValue(newDate);
            }
          },
          decrementMinutes: function() {
            var newDate = date.clone().subtract(options.stepping, 'm');
            if (isValid(newDate, 'm')) {
              setValue(newDate);
            }
          },
          decrementSeconds: function() {
            var newDate = date.clone().subtract(1, 's');
            if (isValid(newDate, 's')) {
              setValue(newDate);
            }
          },
          togglePeriod: function() {
            setValue(date.clone().add((date.hours() >= 12) ? -12 : 12, 'h'));
          },
          togglePicker: function(e) {
            var $this = $(e.target),
                $parent = $this.closest('ul'),
                expanded = $parent.find('.in'),
                closed = $parent.find('.collapse:not(.in)'),
                collapseData;
            if (expanded && expanded.length) {
              collapseData = expanded.data('collapse');
              if (collapseData && collapseData.transitioning) {
                return;
              }
              if (expanded.collapse) {
                expanded.collapse('hide');
                closed.collapse('show');
              } else {
                expanded.removeClass('in');
                closed.addClass('in');
              }
              if ($this.is('span')) {
                $this.toggleClass(options.icons.time + ' ' + options.icons.date);
              } else {
                $this.find('span').toggleClass(options.icons.time + ' ' + options.icons.date);
              }
            }
          },
          showPicker: function() {
            widget.find('.timepicker > div:not(.timepicker-picker)').hide();
            widget.find('.timepicker .timepicker-picker').show();
          },
          showHours: function() {
            widget.find('.timepicker .timepicker-picker').hide();
            widget.find('.timepicker .timepicker-hours').show();
          },
          showMinutes: function() {
            widget.find('.timepicker .timepicker-picker').hide();
            widget.find('.timepicker .timepicker-minutes').show();
          },
          showSeconds: function() {
            widget.find('.timepicker .timepicker-picker').hide();
            widget.find('.timepicker .timepicker-seconds').show();
          },
          selectHour: function(e) {
            var hour = parseInt($(e.target).text(), 10);
            if (!use24Hours) {
              if (date.hours() >= 12) {
                if (hour !== 12) {
                  hour += 12;
                }
              } else {
                if (hour === 12) {
                  hour = 0;
                }
              }
            }
            setValue(date.clone().hours(hour));
            actions.showPicker.call(picker);
          },
          selectMinute: function(e) {
            setValue(date.clone().minutes(parseInt($(e.target).text(), 10)));
            actions.showPicker.call(picker);
          },
          selectSecond: function(e) {
            setValue(date.clone().seconds(parseInt($(e.target).text(), 10)));
            actions.showPicker.call(picker);
          },
          clear: clear,
          today: function() {
            var todaysDate = getMoment();
            if (isValid(todaysDate, 'd')) {
              setValue(todaysDate);
            }
          },
          close: hide
        },
        doAction = function(e) {
          if ($(e.currentTarget).is('.disabled')) {
            return false;
          }
          actions[$(e.currentTarget).data('action')].apply(picker, arguments);
          return false;
        },
        show = function() {
          var currentMoment,
              useCurrentGranularity = {
                'year': function(m) {
                  return m.month(0).date(1).hours(0).seconds(0).minutes(0);
                },
                'month': function(m) {
                  return m.date(1).hours(0).seconds(0).minutes(0);
                },
                'day': function(m) {
                  return m.hours(0).seconds(0).minutes(0);
                },
                'hour': function(m) {
                  return m.seconds(0).minutes(0);
                },
                'minute': function(m) {
                  return m.seconds(0);
                }
              };
          if (input.prop('disabled') || (!options.ignoreReadonly && input.prop('readonly')) || widget) {
            return picker;
          }
          if (input.val() !== undefined && input.val().trim().length !== 0) {
            setValue(parseInputDate(input.val().trim()));
          } else if (options.useCurrent && unset && ((input.is('input') && input.val().trim().length === 0) || options.inline)) {
            currentMoment = getMoment();
            if (typeof options.useCurrent === 'string') {
              currentMoment = useCurrentGranularity[options.useCurrent](currentMoment);
            }
            setValue(currentMoment);
          }
          widget = getTemplate();
          fillDow();
          fillMonths();
          widget.find('.timepicker-hours').hide();
          widget.find('.timepicker-minutes').hide();
          widget.find('.timepicker-seconds').hide();
          update();
          showMode();
          $(window).on('resize', place);
          widget.on('click', '[data-action]', doAction);
          widget.on('mousedown', false);
          if (component && component.hasClass('btn')) {
            component.toggleClass('active');
          }
          widget.show();
          place();
          if (options.focusOnShow && !input.is(':focus')) {
            input.focus();
          }
          notifyEvent({type: 'dp.show'});
          return picker;
        },
        toggle = function() {
          return (widget ? hide() : show());
        },
        parseInputDate = function(inputDate) {
          if (options.parseInputDate === undefined) {
            if (moment.isMoment(inputDate) || inputDate instanceof Date) {
              inputDate = moment(inputDate);
            } else {
              inputDate = getMoment(inputDate);
            }
          } else {
            inputDate = options.parseInputDate(inputDate);
          }
          inputDate.locale(options.locale);
          return inputDate;
        },
        keydown = function(e) {
          var handler = null,
              index,
              index2,
              pressedKeys = [],
              pressedModifiers = {},
              currentKey = e.which,
              keyBindKeys,
              allModifiersPressed,
              pressed = 'p';
          keyState[currentKey] = pressed;
          for (index in keyState) {
            if (keyState.hasOwnProperty(index) && keyState[index] === pressed) {
              pressedKeys.push(index);
              if (parseInt(index, 10) !== currentKey) {
                pressedModifiers[index] = true;
              }
            }
          }
          for (index in options.keyBinds) {
            if (options.keyBinds.hasOwnProperty(index) && typeof(options.keyBinds[index]) === 'function') {
              keyBindKeys = index.split(' ');
              if (keyBindKeys.length === pressedKeys.length && keyMap[currentKey] === keyBindKeys[keyBindKeys.length - 1]) {
                allModifiersPressed = true;
                for (index2 = keyBindKeys.length - 2; index2 >= 0; index2--) {
                  if (!(keyMap[keyBindKeys[index2]] in pressedModifiers)) {
                    allModifiersPressed = false;
                    break;
                  }
                }
                if (allModifiersPressed) {
                  handler = options.keyBinds[index];
                  break;
                }
              }
            }
          }
          if (handler) {
            handler.call(picker, widget);
            e.stopPropagation();
            e.preventDefault();
          }
        },
        keyup = function(e) {
          keyState[e.which] = 'r';
          e.stopPropagation();
          e.preventDefault();
        },
        change = function(e) {
          var val = $(e.target).val().trim(),
              parsedDate = val ? parseInputDate(val) : null;
          setValue(parsedDate);
          e.stopImmediatePropagation();
          return false;
        },
        attachDatePickerElementEvents = function() {
          input.on({
            'change': change,
            'blur': options.debug ? '' : hide,
            'keydown': keydown,
            'keyup': keyup,
            'focus': options.allowInputToggle ? show : ''
          });
          if (element.is('input')) {
            input.on({'focus': show});
          } else if (component) {
            component.on('click', toggle);
            component.on('mousedown', false);
          }
        },
        detachDatePickerElementEvents = function() {
          input.off({
            'change': change,
            'blur': blur,
            'keydown': keydown,
            'keyup': keyup,
            'focus': options.allowInputToggle ? hide : ''
          });
          if (element.is('input')) {
            input.off({'focus': show});
          } else if (component) {
            component.off('click', toggle);
            component.off('mousedown', false);
          }
        },
        indexGivenDates = function(givenDatesArray) {
          var givenDatesIndexed = {};
          $.each(givenDatesArray, function() {
            var dDate = parseInputDate(this);
            if (dDate.isValid()) {
              givenDatesIndexed[dDate.format('YYYY-MM-DD')] = true;
            }
          });
          return (Object.keys(givenDatesIndexed).length) ? givenDatesIndexed : false;
        },
        indexGivenHours = function(givenHoursArray) {
          var givenHoursIndexed = {};
          $.each(givenHoursArray, function() {
            givenHoursIndexed[this] = true;
          });
          return (Object.keys(givenHoursIndexed).length) ? givenHoursIndexed : false;
        },
        initFormatting = function() {
          var format = options.format || 'L LT';
          actualFormat = format.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput) {
            var newinput = date.localeData().longDateFormat(formatInput) || formatInput;
            return newinput.replace(/(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, function(formatInput2) {
              return date.localeData().longDateFormat(formatInput2) || formatInput2;
            });
          });
          parseFormats = options.extraFormats ? options.extraFormats.slice() : [];
          if (parseFormats.indexOf(format) < 0 && parseFormats.indexOf(actualFormat) < 0) {
            parseFormats.push(actualFormat);
          }
          use24Hours = (actualFormat.toLowerCase().indexOf('a') < 1 && actualFormat.replace(/\[.*?\]/g, '').indexOf('h') < 1);
          if (isEnabled('y')) {
            minViewModeNumber = 2;
          }
          if (isEnabled('M')) {
            minViewModeNumber = 1;
          }
          if (isEnabled('d')) {
            minViewModeNumber = 0;
          }
          currentViewMode = Math.max(minViewModeNumber, currentViewMode);
          if (!unset) {
            setValue(date);
          }
        };
    picker.destroy = function() {
      hide();
      detachDatePickerElementEvents();
      element.removeData('DateTimePicker');
      element.removeData('date');
    };
    picker.toggle = toggle;
    picker.show = show;
    picker.hide = hide;
    picker.disable = function() {
      hide();
      if (component && component.hasClass('btn')) {
        component.addClass('disabled');
      }
      input.prop('disabled', true);
      return picker;
    };
    picker.enable = function() {
      if (component && component.hasClass('btn')) {
        component.removeClass('disabled');
      }
      input.prop('disabled', false);
      return picker;
    };
    picker.ignoreReadonly = function(ignoreReadonly) {
      if (arguments.length === 0) {
        return options.ignoreReadonly;
      }
      if (typeof ignoreReadonly !== 'boolean') {
        throw new TypeError('ignoreReadonly () expects a boolean parameter');
      }
      options.ignoreReadonly = ignoreReadonly;
      return picker;
    };
    picker.options = function(newOptions) {
      if (arguments.length === 0) {
        return $.extend(true, {}, options);
      }
      if (!(newOptions instanceof Object)) {
        throw new TypeError('options() options parameter should be an object');
      }
      $.extend(true, options, newOptions);
      $.each(options, function(key, value) {
        if (picker[key] !== undefined) {
          picker[key](value);
        } else {
          throw new TypeError('option ' + key + ' is not recognized!');
        }
      });
      return picker;
    };
    picker.date = function(newDate) {
      if (arguments.length === 0) {
        if (unset) {
          return null;
        }
        return date.clone();
      }
      if (newDate !== null && typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
        throw new TypeError('date() parameter must be one of [null, string, moment or Date]');
      }
      setValue(newDate === null ? null : parseInputDate(newDate));
      return picker;
    };
    picker.format = function(newFormat) {
      if (arguments.length === 0) {
        return options.format;
      }
      if ((typeof newFormat !== 'string') && ((typeof newFormat !== 'boolean') || (newFormat !== false))) {
        throw new TypeError('format() expects a sting or boolean:false parameter ' + newFormat);
      }
      options.format = newFormat;
      if (actualFormat) {
        initFormatting();
      }
      return picker;
    };
    picker.timeZone = function(newZone) {
      if (arguments.length === 0) {
        return options.timeZone;
      }
      options.timeZone = newZone;
      return picker;
    };
    picker.dayViewHeaderFormat = function(newFormat) {
      if (arguments.length === 0) {
        return options.dayViewHeaderFormat;
      }
      if (typeof newFormat !== 'string') {
        throw new TypeError('dayViewHeaderFormat() expects a string parameter');
      }
      options.dayViewHeaderFormat = newFormat;
      return picker;
    };
    picker.extraFormats = function(formats) {
      if (arguments.length === 0) {
        return options.extraFormats;
      }
      if (formats !== false && !(formats instanceof Array)) {
        throw new TypeError('extraFormats() expects an array or false parameter');
      }
      options.extraFormats = formats;
      if (parseFormats) {
        initFormatting();
      }
      return picker;
    };
    picker.disabledDates = function(dates) {
      if (arguments.length === 0) {
        return (options.disabledDates ? $.extend({}, options.disabledDates) : options.disabledDates);
      }
      if (!dates) {
        options.disabledDates = false;
        update();
        return picker;
      }
      if (!(dates instanceof Array)) {
        throw new TypeError('disabledDates() expects an array parameter');
      }
      options.disabledDates = indexGivenDates(dates);
      options.enabledDates = false;
      update();
      return picker;
    };
    picker.enabledDates = function(dates) {
      if (arguments.length === 0) {
        return (options.enabledDates ? $.extend({}, options.enabledDates) : options.enabledDates);
      }
      if (!dates) {
        options.enabledDates = false;
        update();
        return picker;
      }
      if (!(dates instanceof Array)) {
        throw new TypeError('enabledDates() expects an array parameter');
      }
      options.enabledDates = indexGivenDates(dates);
      options.disabledDates = false;
      update();
      return picker;
    };
    picker.daysOfWeekDisabled = function(daysOfWeekDisabled) {
      if (arguments.length === 0) {
        return options.daysOfWeekDisabled.splice(0);
      }
      if ((typeof daysOfWeekDisabled === 'boolean') && !daysOfWeekDisabled) {
        options.daysOfWeekDisabled = false;
        update();
        return picker;
      }
      if (!(daysOfWeekDisabled instanceof Array)) {
        throw new TypeError('daysOfWeekDisabled() expects an array parameter');
      }
      options.daysOfWeekDisabled = daysOfWeekDisabled.reduce(function(previousValue, currentValue) {
        currentValue = parseInt(currentValue, 10);
        if (currentValue > 6 || currentValue < 0 || isNaN(currentValue)) {
          return previousValue;
        }
        if (previousValue.indexOf(currentValue) === -1) {
          previousValue.push(currentValue);
        }
        return previousValue;
      }, []).sort();
      if (options.useCurrent && !options.keepInvalid) {
        var tries = 0;
        while (!isValid(date, 'd')) {
          date.add(1, 'd');
          if (tries === 7) {
            throw 'Tried 7 times to find a valid date';
          }
          tries++;
        }
        setValue(date);
      }
      update();
      return picker;
    };
    picker.maxDate = function(maxDate) {
      if (arguments.length === 0) {
        return options.maxDate ? options.maxDate.clone() : options.maxDate;
      }
      if ((typeof maxDate === 'boolean') && maxDate === false) {
        options.maxDate = false;
        update();
        return picker;
      }
      if (typeof maxDate === 'string') {
        if (maxDate === 'now' || maxDate === 'moment') {
          maxDate = getMoment();
        }
      }
      var parsedDate = parseInputDate(maxDate);
      if (!parsedDate.isValid()) {
        throw new TypeError('maxDate() Could not parse date parameter: ' + maxDate);
      }
      if (options.minDate && parsedDate.isBefore(options.minDate)) {
        throw new TypeError('maxDate() date parameter is before options.minDate: ' + parsedDate.format(actualFormat));
      }
      options.maxDate = parsedDate;
      if (options.useCurrent && !options.keepInvalid && date.isAfter(maxDate)) {
        setValue(options.maxDate);
      }
      if (viewDate.isAfter(parsedDate)) {
        viewDate = parsedDate.clone().subtract(options.stepping, 'm');
      }
      update();
      return picker;
    };
    picker.minDate = function(minDate) {
      if (arguments.length === 0) {
        return options.minDate ? options.minDate.clone() : options.minDate;
      }
      if ((typeof minDate === 'boolean') && minDate === false) {
        options.minDate = false;
        update();
        return picker;
      }
      if (typeof minDate === 'string') {
        if (minDate === 'now' || minDate === 'moment') {
          minDate = getMoment();
        }
      }
      var parsedDate = parseInputDate(minDate);
      if (!parsedDate.isValid()) {
        throw new TypeError('minDate() Could not parse date parameter: ' + minDate);
      }
      if (options.maxDate && parsedDate.isAfter(options.maxDate)) {
        throw new TypeError('minDate() date parameter is after options.maxDate: ' + parsedDate.format(actualFormat));
      }
      options.minDate = parsedDate;
      if (options.useCurrent && !options.keepInvalid && date.isBefore(minDate)) {
        setValue(options.minDate);
      }
      if (viewDate.isBefore(parsedDate)) {
        viewDate = parsedDate.clone().add(options.stepping, 'm');
      }
      update();
      return picker;
    };
    picker.defaultDate = function(defaultDate) {
      if (arguments.length === 0) {
        return options.defaultDate ? options.defaultDate.clone() : options.defaultDate;
      }
      if (!defaultDate) {
        options.defaultDate = false;
        return picker;
      }
      if (typeof defaultDate === 'string') {
        if (defaultDate === 'now' || defaultDate === 'moment') {
          defaultDate = getMoment();
        }
      }
      var parsedDate = parseInputDate(defaultDate);
      if (!parsedDate.isValid()) {
        throw new TypeError('defaultDate() Could not parse date parameter: ' + defaultDate);
      }
      if (!isValid(parsedDate)) {
        throw new TypeError('defaultDate() date passed is invalid according to component setup validations');
      }
      options.defaultDate = parsedDate;
      if ((options.defaultDate && options.inline) || input.val().trim() === '') {
        setValue(options.defaultDate);
      }
      return picker;
    };
    picker.locale = function(locale) {
      if (arguments.length === 0) {
        return options.locale;
      }
      if (!moment.localeData(locale)) {
        throw new TypeError('locale() locale ' + locale + ' is not loaded from moment locales!');
      }
      options.locale = locale;
      date.locale(options.locale);
      viewDate.locale(options.locale);
      if (actualFormat) {
        initFormatting();
      }
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.stepping = function(stepping) {
      if (arguments.length === 0) {
        return options.stepping;
      }
      stepping = parseInt(stepping, 10);
      if (isNaN(stepping) || stepping < 1) {
        stepping = 1;
      }
      options.stepping = stepping;
      return picker;
    };
    picker.useCurrent = function(useCurrent) {
      var useCurrentOptions = ['year', 'month', 'day', 'hour', 'minute'];
      if (arguments.length === 0) {
        return options.useCurrent;
      }
      if ((typeof useCurrent !== 'boolean') && (typeof useCurrent !== 'string')) {
        throw new TypeError('useCurrent() expects a boolean or string parameter');
      }
      if (typeof useCurrent === 'string' && useCurrentOptions.indexOf(useCurrent.toLowerCase()) === -1) {
        throw new TypeError('useCurrent() expects a string parameter of ' + useCurrentOptions.join(', '));
      }
      options.useCurrent = useCurrent;
      return picker;
    };
    picker.collapse = function(collapse) {
      if (arguments.length === 0) {
        return options.collapse;
      }
      if (typeof collapse !== 'boolean') {
        throw new TypeError('collapse() expects a boolean parameter');
      }
      if (options.collapse === collapse) {
        return picker;
      }
      options.collapse = collapse;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.icons = function(icons) {
      if (arguments.length === 0) {
        return $.extend({}, options.icons);
      }
      if (!(icons instanceof Object)) {
        throw new TypeError('icons() expects parameter to be an Object');
      }
      $.extend(options.icons, icons);
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.tooltips = function(tooltips) {
      if (arguments.length === 0) {
        return $.extend({}, options.tooltips);
      }
      if (!(tooltips instanceof Object)) {
        throw new TypeError('tooltips() expects parameter to be an Object');
      }
      $.extend(options.tooltips, tooltips);
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.useStrict = function(useStrict) {
      if (arguments.length === 0) {
        return options.useStrict;
      }
      if (typeof useStrict !== 'boolean') {
        throw new TypeError('useStrict() expects a boolean parameter');
      }
      options.useStrict = useStrict;
      return picker;
    };
    picker.sideBySide = function(sideBySide) {
      if (arguments.length === 0) {
        return options.sideBySide;
      }
      if (typeof sideBySide !== 'boolean') {
        throw new TypeError('sideBySide() expects a boolean parameter');
      }
      options.sideBySide = sideBySide;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.viewMode = function(viewMode) {
      if (arguments.length === 0) {
        return options.viewMode;
      }
      if (typeof viewMode !== 'string') {
        throw new TypeError('viewMode() expects a string parameter');
      }
      if (viewModes.indexOf(viewMode) === -1) {
        throw new TypeError('viewMode() parameter must be one of (' + viewModes.join(', ') + ') value');
      }
      options.viewMode = viewMode;
      currentViewMode = Math.max(viewModes.indexOf(viewMode), minViewModeNumber);
      showMode();
      return picker;
    };
    picker.toolbarPlacement = function(toolbarPlacement) {
      if (arguments.length === 0) {
        return options.toolbarPlacement;
      }
      if (typeof toolbarPlacement !== 'string') {
        throw new TypeError('toolbarPlacement() expects a string parameter');
      }
      if (toolbarPlacements.indexOf(toolbarPlacement) === -1) {
        throw new TypeError('toolbarPlacement() parameter must be one of (' + toolbarPlacements.join(', ') + ') value');
      }
      options.toolbarPlacement = toolbarPlacement;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.widgetPositioning = function(widgetPositioning) {
      if (arguments.length === 0) {
        return $.extend({}, options.widgetPositioning);
      }
      if (({}).toString.call(widgetPositioning) !== '[object Object]') {
        throw new TypeError('widgetPositioning() expects an object variable');
      }
      if (widgetPositioning.horizontal) {
        if (typeof widgetPositioning.horizontal !== 'string') {
          throw new TypeError('widgetPositioning() horizontal variable must be a string');
        }
        widgetPositioning.horizontal = widgetPositioning.horizontal.toLowerCase();
        if (horizontalModes.indexOf(widgetPositioning.horizontal) === -1) {
          throw new TypeError('widgetPositioning() expects horizontal parameter to be one of (' + horizontalModes.join(', ') + ')');
        }
        options.widgetPositioning.horizontal = widgetPositioning.horizontal;
      }
      if (widgetPositioning.vertical) {
        if (typeof widgetPositioning.vertical !== 'string') {
          throw new TypeError('widgetPositioning() vertical variable must be a string');
        }
        widgetPositioning.vertical = widgetPositioning.vertical.toLowerCase();
        if (verticalModes.indexOf(widgetPositioning.vertical) === -1) {
          throw new TypeError('widgetPositioning() expects vertical parameter to be one of (' + verticalModes.join(', ') + ')');
        }
        options.widgetPositioning.vertical = widgetPositioning.vertical;
      }
      update();
      return picker;
    };
    picker.calendarWeeks = function(calendarWeeks) {
      if (arguments.length === 0) {
        return options.calendarWeeks;
      }
      if (typeof calendarWeeks !== 'boolean') {
        throw new TypeError('calendarWeeks() expects parameter to be a boolean value');
      }
      options.calendarWeeks = calendarWeeks;
      update();
      return picker;
    };
    picker.showTodayButton = function(showTodayButton) {
      if (arguments.length === 0) {
        return options.showTodayButton;
      }
      if (typeof showTodayButton !== 'boolean') {
        throw new TypeError('showTodayButton() expects a boolean parameter');
      }
      options.showTodayButton = showTodayButton;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.showClear = function(showClear) {
      if (arguments.length === 0) {
        return options.showClear;
      }
      if (typeof showClear !== 'boolean') {
        throw new TypeError('showClear() expects a boolean parameter');
      }
      options.showClear = showClear;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.widgetParent = function(widgetParent) {
      if (arguments.length === 0) {
        return options.widgetParent;
      }
      if (typeof widgetParent === 'string') {
        widgetParent = $(widgetParent);
      }
      if (widgetParent !== null && (typeof widgetParent !== 'string' && !(widgetParent instanceof $))) {
        throw new TypeError('widgetParent() expects a string or a jQuery object parameter');
      }
      options.widgetParent = widgetParent;
      if (widget) {
        hide();
        show();
      }
      return picker;
    };
    picker.keepOpen = function(keepOpen) {
      if (arguments.length === 0) {
        return options.keepOpen;
      }
      if (typeof keepOpen !== 'boolean') {
        throw new TypeError('keepOpen() expects a boolean parameter');
      }
      options.keepOpen = keepOpen;
      return picker;
    };
    picker.focusOnShow = function(focusOnShow) {
      if (arguments.length === 0) {
        return options.focusOnShow;
      }
      if (typeof focusOnShow !== 'boolean') {
        throw new TypeError('focusOnShow() expects a boolean parameter');
      }
      options.focusOnShow = focusOnShow;
      return picker;
    };
    picker.inline = function(inline) {
      if (arguments.length === 0) {
        return options.inline;
      }
      if (typeof inline !== 'boolean') {
        throw new TypeError('inline() expects a boolean parameter');
      }
      options.inline = inline;
      return picker;
    };
    picker.clear = function() {
      clear();
      return picker;
    };
    picker.keyBinds = function(keyBinds) {
      options.keyBinds = keyBinds;
      return picker;
    };
    picker.getMoment = function(d) {
      return getMoment(d);
    };
    picker.debug = function(debug) {
      if (typeof debug !== 'boolean') {
        throw new TypeError('debug() expects a boolean parameter');
      }
      options.debug = debug;
      return picker;
    };
    picker.allowInputToggle = function(allowInputToggle) {
      if (arguments.length === 0) {
        return options.allowInputToggle;
      }
      if (typeof allowInputToggle !== 'boolean') {
        throw new TypeError('allowInputToggle() expects a boolean parameter');
      }
      options.allowInputToggle = allowInputToggle;
      return picker;
    };
    picker.showClose = function(showClose) {
      if (arguments.length === 0) {
        return options.showClose;
      }
      if (typeof showClose !== 'boolean') {
        throw new TypeError('showClose() expects a boolean parameter');
      }
      options.showClose = showClose;
      return picker;
    };
    picker.keepInvalid = function(keepInvalid) {
      if (arguments.length === 0) {
        return options.keepInvalid;
      }
      if (typeof keepInvalid !== 'boolean') {
        throw new TypeError('keepInvalid() expects a boolean parameter');
      }
      options.keepInvalid = keepInvalid;
      return picker;
    };
    picker.datepickerInput = function(datepickerInput) {
      if (arguments.length === 0) {
        return options.datepickerInput;
      }
      if (typeof datepickerInput !== 'string') {
        throw new TypeError('datepickerInput() expects a string parameter');
      }
      options.datepickerInput = datepickerInput;
      return picker;
    };
    picker.parseInputDate = function(parseInputDate) {
      if (arguments.length === 0) {
        return options.parseInputDate;
      }
      if (typeof parseInputDate !== 'function') {
        throw new TypeError('parseInputDate() sholud be as function');
      }
      options.parseInputDate = parseInputDate;
      return picker;
    };
    picker.disabledTimeIntervals = function(disabledTimeIntervals) {
      if (arguments.length === 0) {
        return (options.disabledTimeIntervals ? $.extend({}, options.disabledTimeIntervals) : options.disabledTimeIntervals);
      }
      if (!disabledTimeIntervals) {
        options.disabledTimeIntervals = false;
        update();
        return picker;
      }
      if (!(disabledTimeIntervals instanceof Array)) {
        throw new TypeError('disabledTimeIntervals() expects an array parameter');
      }
      options.disabledTimeIntervals = disabledTimeIntervals;
      update();
      return picker;
    };
    picker.disabledHours = function(hours) {
      if (arguments.length === 0) {
        return (options.disabledHours ? $.extend({}, options.disabledHours) : options.disabledHours);
      }
      if (!hours) {
        options.disabledHours = false;
        update();
        return picker;
      }
      if (!(hours instanceof Array)) {
        throw new TypeError('disabledHours() expects an array parameter');
      }
      options.disabledHours = indexGivenHours(hours);
      options.enabledHours = false;
      if (options.useCurrent && !options.keepInvalid) {
        var tries = 0;
        while (!isValid(date, 'h')) {
          date.add(1, 'h');
          if (tries === 24) {
            throw 'Tried 24 times to find a valid date';
          }
          tries++;
        }
        setValue(date);
      }
      update();
      return picker;
    };
    picker.enabledHours = function(hours) {
      if (arguments.length === 0) {
        return (options.enabledHours ? $.extend({}, options.enabledHours) : options.enabledHours);
      }
      if (!hours) {
        options.enabledHours = false;
        update();
        return picker;
      }
      if (!(hours instanceof Array)) {
        throw new TypeError('enabledHours() expects an array parameter');
      }
      options.enabledHours = indexGivenHours(hours);
      options.disabledHours = false;
      if (options.useCurrent && !options.keepInvalid) {
        var tries = 0;
        while (!isValid(date, 'h')) {
          date.add(1, 'h');
          if (tries === 24) {
            throw 'Tried 24 times to find a valid date';
          }
          tries++;
        }
        setValue(date);
      }
      update();
      return picker;
    };
    picker.viewDate = function(newDate) {
      if (arguments.length === 0) {
        return viewDate.clone();
      }
      if (!newDate) {
        viewDate = date.clone();
        return picker;
      }
      if (typeof newDate !== 'string' && !moment.isMoment(newDate) && !(newDate instanceof Date)) {
        throw new TypeError('viewDate() parameter must be one of [string, moment or Date]');
      }
      viewDate = parseInputDate(newDate);
      viewUpdate();
      return picker;
    };
    if (element.is('input')) {
      input = element;
    } else {
      input = element.find(options.datepickerInput);
      if (input.size() === 0) {
        input = element.find('input');
      } else if (!input.is('input')) {
        throw new Error('CSS class "' + options.datepickerInput + '" cannot be applied to non input element');
      }
    }
    if (element.hasClass('input-group')) {
      if (element.find('.datepickerbutton').size() === 0) {
        component = element.find('.input-group-addon');
      } else {
        component = element.find('.datepickerbutton');
      }
    }
    if (!options.inline && !input.is('input')) {
      throw new Error('Could not initialize DateTimePicker without an input element');
    }
    date = getMoment();
    viewDate = date.clone();
    $.extend(true, options, dataToOptions());
    picker.options(options);
    initFormatting();
    attachDatePickerElementEvents();
    if (input.prop('disabled')) {
      picker.disable();
    }
    if (input.is('input') && input.val().trim().length !== 0) {
      setValue(parseInputDate(input.val().trim()));
    } else if (options.defaultDate && input.attr('placeholder') === undefined) {
      setValue(options.defaultDate);
    }
    if (options.inline) {
      show();
    }
    return picker;
  };
  $.fn.datetimepicker = function(options) {
    return this.each(function() {
      var $this = $(this);
      if (!$this.data('DateTimePicker')) {
        options = $.extend(true, {}, $.fn.datetimepicker.defaults, options);
        $this.data('DateTimePicker', dateTimePicker($this, options));
      }
    });
  };
  $.fn.datetimepicker.defaults = {
    timeZone: 'Etc/UTC',
    format: false,
    dayViewHeaderFormat: 'MMMM YYYY',
    extraFormats: false,
    stepping: 1,
    minDate: false,
    maxDate: false,
    useCurrent: true,
    collapse: true,
    locale: moment.locale(),
    defaultDate: false,
    disabledDates: false,
    enabledDates: false,
    icons: {
      time: 'glyphicon glyphicon-time',
      date: 'glyphicon glyphicon-calendar',
      up: 'glyphicon glyphicon-chevron-up',
      down: 'glyphicon glyphicon-chevron-down',
      previous: 'glyphicon glyphicon-chevron-left',
      next: 'glyphicon glyphicon-chevron-right',
      today: 'glyphicon glyphicon-screenshot',
      clear: 'glyphicon glyphicon-trash',
      close: 'glyphicon glyphicon-remove'
    },
    tooltips: {
      today: 'Go to today',
      clear: 'Clear selection',
      close: 'Close the picker',
      selectMonth: 'Select Month',
      prevMonth: 'Previous Month',
      nextMonth: 'Next Month',
      selectYear: 'Select Year',
      prevYear: 'Previous Year',
      nextYear: 'Next Year',
      selectDecade: 'Select Decade',
      prevDecade: 'Previous Decade',
      nextDecade: 'Next Decade',
      prevCentury: 'Previous Century',
      nextCentury: 'Next Century',
      pickHour: 'Pick Hour',
      incrementHour: 'Increment Hour',
      decrementHour: 'Decrement Hour',
      pickMinute: 'Pick Minute',
      incrementMinute: 'Increment Minute',
      decrementMinute: 'Decrement Minute',
      pickSecond: 'Pick Second',
      incrementSecond: 'Increment Second',
      decrementSecond: 'Decrement Second',
      togglePeriod: 'Toggle Period',
      selectTime: 'Select Time'
    },
    useStrict: false,
    sideBySide: false,
    daysOfWeekDisabled: false,
    calendarWeeks: false,
    viewMode: 'days',
    toolbarPlacement: 'default',
    showTodayButton: false,
    showClear: false,
    showClose: false,
    widgetPositioning: {
      horizontal: 'auto',
      vertical: 'auto'
    },
    widgetParent: null,
    ignoreReadonly: false,
    keepOpen: false,
    focusOnShow: true,
    inline: false,
    keepInvalid: false,
    datepickerInput: '.datepickerinput',
    keyBinds: {
      up: function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().subtract(7, 'd'));
        } else {
          this.date(d.clone().add(this.stepping(), 'm'));
        }
      },
      down: function(widget) {
        if (!widget) {
          this.show();
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().add(7, 'd'));
        } else {
          this.date(d.clone().subtract(this.stepping(), 'm'));
        }
      },
      'control up': function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().subtract(1, 'y'));
        } else {
          this.date(d.clone().add(1, 'h'));
        }
      },
      'control down': function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().add(1, 'y'));
        } else {
          this.date(d.clone().subtract(1, 'h'));
        }
      },
      left: function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().subtract(1, 'd'));
        }
      },
      right: function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().add(1, 'd'));
        }
      },
      pageUp: function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().subtract(1, 'M'));
        }
      },
      pageDown: function(widget) {
        if (!widget) {
          return;
        }
        var d = this.date() || this.getMoment();
        if (widget.find('.datepicker').is(':visible')) {
          this.date(d.clone().add(1, 'M'));
        }
      },
      enter: function() {
        this.hide();
      },
      escape: function() {
        this.hide();
      },
      'control space': function(widget) {
        if (widget.find('.timepicker').is(':visible')) {
          widget.find('.btn[data-action="togglePeriod"]').click();
        }
      },
      t: function() {
        this.date(this.getMoment());
      },
      'delete': function() {
        this.clear();
      }
    },
    debug: false,
    allowInputToggle: false,
    disabledTimeIntervals: false,
    disabledHours: false,
    enabledHours: false,
    viewDate: false
  };
}));

})();
(function() {
var define = $__System.amdDefine;
define("2e", ["2d"], function(main) {
  return main;
});

})();
$__System.registerDynamic("2f", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(factory) {
    if (typeof define === "function" && define.amd) {
      define(["jquery"], factory);
    } else {
      factory(jQuery);
    }
  }(function($) {
    $.ui = $.ui || {};
    $.extend($.ui, {
      version: "1.11.1",
      keyCode: {
        BACKSPACE: 8,
        COMMA: 188,
        DELETE: 46,
        DOWN: 40,
        END: 35,
        ENTER: 13,
        ESCAPE: 27,
        HOME: 36,
        LEFT: 37,
        PAGE_DOWN: 34,
        PAGE_UP: 33,
        PERIOD: 190,
        RIGHT: 39,
        SPACE: 32,
        TAB: 9,
        UP: 38
      }
    });
    $.fn.extend({
      scrollParent: function(includeHidden) {
        var position = this.css("position"),
            excludeStaticParent = position === "absolute",
            overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
            scrollParent = this.parents().filter(function() {
              var parent = $(this);
              if (excludeStaticParent && parent.css("position") === "static") {
                return false;
              }
              return overflowRegex.test(parent.css("overflow") + parent.css("overflow-y") + parent.css("overflow-x"));
            }).eq(0);
        return position === "fixed" || !scrollParent.length ? $(this[0].ownerDocument || document) : scrollParent;
      },
      uniqueId: (function() {
        var uuid = 0;
        return function() {
          return this.each(function() {
            if (!this.id) {
              this.id = "ui-id-" + (++uuid);
            }
          });
        };
      })(),
      removeUniqueId: function() {
        return this.each(function() {
          if (/^ui-id-\d+$/.test(this.id)) {
            $(this).removeAttr("id");
          }
        });
      }
    });
    function focusable(element, isTabIndexNotNaN) {
      var map,
          mapName,
          img,
          nodeName = element.nodeName.toLowerCase();
      if ("area" === nodeName) {
        map = element.parentNode;
        mapName = map.name;
        if (!element.href || !mapName || map.nodeName.toLowerCase() !== "map") {
          return false;
        }
        img = $("img[usemap='#" + mapName + "']")[0];
        return !!img && visible(img);
      }
      return (/input|select|textarea|button|object/.test(nodeName) ? !element.disabled : "a" === nodeName ? element.href || isTabIndexNotNaN : isTabIndexNotNaN) && visible(element);
    }
    function visible(element) {
      return $.expr.filters.visible(element) && !$(element).parents().addBack().filter(function() {
        return $.css(this, "visibility") === "hidden";
      }).length;
    }
    $.extend($.expr[":"], {
      data: $.expr.createPseudo ? $.expr.createPseudo(function(dataName) {
        return function(elem) {
          return !!$.data(elem, dataName);
        };
      }) : function(elem, i, match) {
        return !!$.data(elem, match[3]);
      },
      focusable: function(element) {
        return focusable(element, !isNaN($.attr(element, "tabindex")));
      },
      tabbable: function(element) {
        var tabIndex = $.attr(element, "tabindex"),
            isTabIndexNaN = isNaN(tabIndex);
        return (isTabIndexNaN || tabIndex >= 0) && focusable(element, !isTabIndexNaN);
      }
    });
    if (!$("<a>").outerWidth(1).jquery) {
      $.each(["Width", "Height"], function(i, name) {
        var side = name === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
            type = name.toLowerCase(),
            orig = {
              innerWidth: $.fn.innerWidth,
              innerHeight: $.fn.innerHeight,
              outerWidth: $.fn.outerWidth,
              outerHeight: $.fn.outerHeight
            };
        function reduce(elem, size, border, margin) {
          $.each(side, function() {
            size -= parseFloat($.css(elem, "padding" + this)) || 0;
            if (border) {
              size -= parseFloat($.css(elem, "border" + this + "Width")) || 0;
            }
            if (margin) {
              size -= parseFloat($.css(elem, "margin" + this)) || 0;
            }
          });
          return size;
        }
        $.fn["inner" + name] = function(size) {
          if (size === undefined) {
            return orig["inner" + name].call(this);
          }
          return this.each(function() {
            $(this).css(type, reduce(this, size) + "px");
          });
        };
        $.fn["outer" + name] = function(size, margin) {
          if (typeof size !== "number") {
            return orig["outer" + name].call(this, size);
          }
          return this.each(function() {
            $(this).css(type, reduce(this, size, true, margin) + "px");
          });
        };
      });
    }
    if (!$.fn.addBack) {
      $.fn.addBack = function(selector) {
        return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
      };
    }
    if ($("<a>").data("a-b", "a").removeData("a-b").data("a-b")) {
      $.fn.removeData = (function(removeData) {
        return function(key) {
          if (arguments.length) {
            return removeData.call(this, $.camelCase(key));
          } else {
            return removeData.call(this);
          }
        };
      })($.fn.removeData);
    }
    $.ui.ie = !!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());
    $.fn.extend({
      focus: (function(orig) {
        return function(delay, fn) {
          return typeof delay === "number" ? this.each(function() {
            var elem = this;
            setTimeout(function() {
              $(elem).focus();
              if (fn) {
                fn.call(elem);
              }
            }, delay);
          }) : orig.apply(this, arguments);
        };
      })($.fn.focus),
      disableSelection: (function() {
        var eventType = "onselectstart" in document.createElement("div") ? "selectstart" : "mousedown";
        return function() {
          return this.bind(eventType + ".ui-disableSelection", function(event) {
            event.preventDefault();
          });
        };
      })(),
      enableSelection: function() {
        return this.unbind(".ui-disableSelection");
      },
      zIndex: function(zIndex) {
        if (zIndex !== undefined) {
          return this.css("zIndex", zIndex);
        }
        if (this.length) {
          var elem = $(this[0]),
              position,
              value;
          while (elem.length && elem[0] !== document) {
            position = elem.css("position");
            if (position === "absolute" || position === "relative" || position === "fixed") {
              value = parseInt(elem.css("zIndex"), 10);
              if (!isNaN(value) && value !== 0) {
                return value;
              }
            }
            elem = elem.parent();
          }
        }
        return 0;
      }
    });
    $.ui.plugin = {
      add: function(module, option, set) {
        var i,
            proto = $.ui[module].prototype;
        for (i in set) {
          proto.plugins[i] = proto.plugins[i] || [];
          proto.plugins[i].push([option, set[i]]);
        }
      },
      call: function(instance, name, args, allowDisconnected) {
        var i,
            set = instance.plugins[name];
        if (!set) {
          return;
        }
        if (!allowDisconnected && (!instance.element[0].parentNode || instance.element[0].parentNode.nodeType === 11)) {
          return;
        }
        for (i = 0; i < set.length; i++) {
          if (instance.options[set[i][0]]) {
            set[i][1].apply(instance.element, args);
          }
        }
      }
    };
    var widget_uuid = 0,
        widget_slice = Array.prototype.slice;
    $.cleanData = (function(orig) {
      return function(elems) {
        var events,
            elem,
            i;
        for (i = 0; (elem = elems[i]) != null; i++) {
          try {
            events = $._data(elem, "events");
            if (events && events.remove) {
              $(elem).triggerHandler("remove");
            }
          } catch (e) {}
        }
        orig(elems);
      };
    })($.cleanData);
    $.widget = function(name, base, prototype) {
      var fullName,
          existingConstructor,
          constructor,
          basePrototype,
          proxiedPrototype = {},
          namespace = name.split(".")[0];
      name = name.split(".")[1];
      fullName = namespace + "-" + name;
      if (!prototype) {
        prototype = base;
        base = $.Widget;
      }
      $.expr[":"][fullName.toLowerCase()] = function(elem) {
        return !!$.data(elem, fullName);
      };
      $[namespace] = $[namespace] || {};
      existingConstructor = $[namespace][name];
      constructor = $[namespace][name] = function(options, element) {
        if (!this._createWidget) {
          return new constructor(options, element);
        }
        if (arguments.length) {
          this._createWidget(options, element);
        }
      };
      $.extend(constructor, existingConstructor, {
        version: prototype.version,
        _proto: $.extend({}, prototype),
        _childConstructors: []
      });
      basePrototype = new base();
      basePrototype.options = $.widget.extend({}, basePrototype.options);
      $.each(prototype, function(prop, value) {
        if (!$.isFunction(value)) {
          proxiedPrototype[prop] = value;
          return;
        }
        proxiedPrototype[prop] = (function() {
          var _super = function() {
            return base.prototype[prop].apply(this, arguments);
          },
              _superApply = function(args) {
                return base.prototype[prop].apply(this, args);
              };
          return function() {
            var __super = this._super,
                __superApply = this._superApply,
                returnValue;
            this._super = _super;
            this._superApply = _superApply;
            returnValue = value.apply(this, arguments);
            this._super = __super;
            this._superApply = __superApply;
            return returnValue;
          };
        })();
      });
      constructor.prototype = $.widget.extend(basePrototype, {widgetEventPrefix: existingConstructor ? (basePrototype.widgetEventPrefix || name) : name}, proxiedPrototype, {
        constructor: constructor,
        namespace: namespace,
        widgetName: name,
        widgetFullName: fullName
      });
      if (existingConstructor) {
        $.each(existingConstructor._childConstructors, function(i, child) {
          var childPrototype = child.prototype;
          $.widget(childPrototype.namespace + "." + childPrototype.widgetName, constructor, child._proto);
        });
        delete existingConstructor._childConstructors;
      } else {
        base._childConstructors.push(constructor);
      }
      $.widget.bridge(name, constructor);
      return constructor;
    };
    $.widget.extend = function(target) {
      var input = widget_slice.call(arguments, 1),
          inputIndex = 0,
          inputLength = input.length,
          key,
          value;
      for (; inputIndex < inputLength; inputIndex++) {
        for (key in input[inputIndex]) {
          value = input[inputIndex][key];
          if (input[inputIndex].hasOwnProperty(key) && value !== undefined) {
            if ($.isPlainObject(value)) {
              target[key] = $.isPlainObject(target[key]) ? $.widget.extend({}, target[key], value) : $.widget.extend({}, value);
            } else {
              target[key] = value;
            }
          }
        }
      }
      return target;
    };
    $.widget.bridge = function(name, object) {
      var fullName = object.prototype.widgetFullName || name;
      $.fn[name] = function(options) {
        var isMethodCall = typeof options === "string",
            args = widget_slice.call(arguments, 1),
            returnValue = this;
        options = !isMethodCall && args.length ? $.widget.extend.apply(null, [options].concat(args)) : options;
        if (isMethodCall) {
          this.each(function() {
            var methodValue,
                instance = $.data(this, fullName);
            if (options === "instance") {
              returnValue = instance;
              return false;
            }
            if (!instance) {
              return $.error("cannot call methods on " + name + " prior to initialization; " + "attempted to call method '" + options + "'");
            }
            if (!$.isFunction(instance[options]) || options.charAt(0) === "_") {
              return $.error("no such method '" + options + "' for " + name + " widget instance");
            }
            methodValue = instance[options].apply(instance, args);
            if (methodValue !== instance && methodValue !== undefined) {
              returnValue = methodValue && methodValue.jquery ? returnValue.pushStack(methodValue.get()) : methodValue;
              return false;
            }
          });
        } else {
          this.each(function() {
            var instance = $.data(this, fullName);
            if (instance) {
              instance.option(options || {});
              if (instance._init) {
                instance._init();
              }
            } else {
              $.data(this, fullName, new object(options, this));
            }
          });
        }
        return returnValue;
      };
    };
    $.Widget = function() {};
    $.Widget._childConstructors = [];
    $.Widget.prototype = {
      widgetName: "widget",
      widgetEventPrefix: "",
      defaultElement: "<div>",
      options: {
        disabled: false,
        create: null
      },
      _createWidget: function(options, element) {
        element = $(element || this.defaultElement || this)[0];
        this.element = $(element);
        this.uuid = widget_uuid++;
        this.eventNamespace = "." + this.widgetName + this.uuid;
        this.options = $.widget.extend({}, this.options, this._getCreateOptions(), options);
        this.bindings = $();
        this.hoverable = $();
        this.focusable = $();
        if (element !== this) {
          $.data(element, this.widgetFullName, this);
          this._on(true, this.element, {remove: function(event) {
              if (event.target === element) {
                this.destroy();
              }
            }});
          this.document = $(element.style ? element.ownerDocument : element.document || element);
          this.window = $(this.document[0].defaultView || this.document[0].parentWindow);
        }
        this._create();
        this._trigger("create", null, this._getCreateEventData());
        this._init();
      },
      _getCreateOptions: $.noop,
      _getCreateEventData: $.noop,
      _create: $.noop,
      _init: $.noop,
      destroy: function() {
        this._destroy();
        this.element.unbind(this.eventNamespace).removeData(this.widgetFullName).removeData($.camelCase(this.widgetFullName));
        this.widget().unbind(this.eventNamespace).removeAttr("aria-disabled").removeClass(this.widgetFullName + "-disabled " + "ui-state-disabled");
        this.bindings.unbind(this.eventNamespace);
        this.hoverable.removeClass("ui-state-hover");
        this.focusable.removeClass("ui-state-focus");
      },
      _destroy: $.noop,
      widget: function() {
        return this.element;
      },
      option: function(key, value) {
        var options = key,
            parts,
            curOption,
            i;
        if (arguments.length === 0) {
          return $.widget.extend({}, this.options);
        }
        if (typeof key === "string") {
          options = {};
          parts = key.split(".");
          key = parts.shift();
          if (parts.length) {
            curOption = options[key] = $.widget.extend({}, this.options[key]);
            for (i = 0; i < parts.length - 1; i++) {
              curOption[parts[i]] = curOption[parts[i]] || {};
              curOption = curOption[parts[i]];
            }
            key = parts.pop();
            if (arguments.length === 1) {
              return curOption[key] === undefined ? null : curOption[key];
            }
            curOption[key] = value;
          } else {
            if (arguments.length === 1) {
              return this.options[key] === undefined ? null : this.options[key];
            }
            options[key] = value;
          }
        }
        this._setOptions(options);
        return this;
      },
      _setOptions: function(options) {
        var key;
        for (key in options) {
          this._setOption(key, options[key]);
        }
        return this;
      },
      _setOption: function(key, value) {
        this.options[key] = value;
        if (key === "disabled") {
          this.widget().toggleClass(this.widgetFullName + "-disabled", !!value);
          if (value) {
            this.hoverable.removeClass("ui-state-hover");
            this.focusable.removeClass("ui-state-focus");
          }
        }
        return this;
      },
      enable: function() {
        return this._setOptions({disabled: false});
      },
      disable: function() {
        return this._setOptions({disabled: true});
      },
      _on: function(suppressDisabledCheck, element, handlers) {
        var delegateElement,
            instance = this;
        if (typeof suppressDisabledCheck !== "boolean") {
          handlers = element;
          element = suppressDisabledCheck;
          suppressDisabledCheck = false;
        }
        if (!handlers) {
          handlers = element;
          element = this.element;
          delegateElement = this.widget();
        } else {
          element = delegateElement = $(element);
          this.bindings = this.bindings.add(element);
        }
        $.each(handlers, function(event, handler) {
          function handlerProxy() {
            if (!suppressDisabledCheck && (instance.options.disabled === true || $(this).hasClass("ui-state-disabled"))) {
              return;
            }
            return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
          }
          if (typeof handler !== "string") {
            handlerProxy.guid = handler.guid = handler.guid || handlerProxy.guid || $.guid++;
          }
          var match = event.match(/^([\w:-]*)\s*(.*)$/),
              eventName = match[1] + instance.eventNamespace,
              selector = match[2];
          if (selector) {
            delegateElement.delegate(selector, eventName, handlerProxy);
          } else {
            element.bind(eventName, handlerProxy);
          }
        });
      },
      _off: function(element, eventName) {
        eventName = (eventName || "").split(" ").join(this.eventNamespace + " ") + this.eventNamespace;
        element.unbind(eventName).undelegate(eventName);
      },
      _delay: function(handler, delay) {
        function handlerProxy() {
          return (typeof handler === "string" ? instance[handler] : handler).apply(instance, arguments);
        }
        var instance = this;
        return setTimeout(handlerProxy, delay || 0);
      },
      _hoverable: function(element) {
        this.hoverable = this.hoverable.add(element);
        this._on(element, {
          mouseenter: function(event) {
            $(event.currentTarget).addClass("ui-state-hover");
          },
          mouseleave: function(event) {
            $(event.currentTarget).removeClass("ui-state-hover");
          }
        });
      },
      _focusable: function(element) {
        this.focusable = this.focusable.add(element);
        this._on(element, {
          focusin: function(event) {
            $(event.currentTarget).addClass("ui-state-focus");
          },
          focusout: function(event) {
            $(event.currentTarget).removeClass("ui-state-focus");
          }
        });
      },
      _trigger: function(type, event, data) {
        var prop,
            orig,
            callback = this.options[type];
        data = data || {};
        event = $.Event(event);
        event.type = (type === this.widgetEventPrefix ? type : this.widgetEventPrefix + type).toLowerCase();
        event.target = this.element[0];
        orig = event.originalEvent;
        if (orig) {
          for (prop in orig) {
            if (!(prop in event)) {
              event[prop] = orig[prop];
            }
          }
        }
        this.element.trigger(event, data);
        return !($.isFunction(callback) && callback.apply(this.element[0], [event].concat(data)) === false || event.isDefaultPrevented());
      }
    };
    $.each({
      show: "fadeIn",
      hide: "fadeOut"
    }, function(method, defaultEffect) {
      $.Widget.prototype["_" + method] = function(element, options, callback) {
        if (typeof options === "string") {
          options = {effect: options};
        }
        var hasOptions,
            effectName = !options ? method : options === true || typeof options === "number" ? defaultEffect : options.effect || defaultEffect;
        options = options || {};
        if (typeof options === "number") {
          options = {duration: options};
        }
        hasOptions = !$.isEmptyObject(options);
        options.complete = callback;
        if (options.delay) {
          element.delay(options.delay);
        }
        if (hasOptions && $.effects && $.effects.effect[effectName]) {
          element[method](options);
        } else if (effectName !== method && element[effectName]) {
          element[effectName](options.duration, options.easing, callback);
        } else {
          element.queue(function(next) {
            $(this)[method]();
            if (callback) {
              callback.call(element[0]);
            }
            next();
          });
        }
      };
    });
    var widget = $.widget;
    var mouseHandled = false;
    $(document).mouseup(function() {
      mouseHandled = false;
    });
    var mouse = $.widget("ui.mouse", {
      version: "1.11.1",
      options: {
        cancel: "input,textarea,button,select,option",
        distance: 1,
        delay: 0
      },
      _mouseInit: function() {
        var that = this;
        this.element.bind("mousedown." + this.widgetName, function(event) {
          return that._mouseDown(event);
        }).bind("click." + this.widgetName, function(event) {
          if (true === $.data(event.target, that.widgetName + ".preventClickEvent")) {
            $.removeData(event.target, that.widgetName + ".preventClickEvent");
            event.stopImmediatePropagation();
            return false;
          }
        });
        this.started = false;
      },
      _mouseDestroy: function() {
        this.element.unbind("." + this.widgetName);
        if (this._mouseMoveDelegate) {
          this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        }
      },
      _mouseDown: function(event) {
        if (mouseHandled) {
          return;
        }
        (this._mouseStarted && this._mouseUp(event));
        this._mouseDownEvent = event;
        var that = this,
            btnIsLeft = (event.which === 1),
            elIsCancel = (typeof this.options.cancel === "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
        if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
          return true;
        }
        this.mouseDelayMet = !this.options.delay;
        if (!this.mouseDelayMet) {
          this._mouseDelayTimer = setTimeout(function() {
            that.mouseDelayMet = true;
          }, this.options.delay);
        }
        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = (this._mouseStart(event) !== false);
          if (!this._mouseStarted) {
            event.preventDefault();
            return true;
          }
        }
        if (true === $.data(event.target, this.widgetName + ".preventClickEvent")) {
          $.removeData(event.target, this.widgetName + ".preventClickEvent");
        }
        this._mouseMoveDelegate = function(event) {
          return that._mouseMove(event);
        };
        this._mouseUpDelegate = function(event) {
          return that._mouseUp(event);
        };
        this.document.bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate);
        event.preventDefault();
        mouseHandled = true;
        return true;
      },
      _mouseMove: function(event) {
        if ($.ui.ie && (!document.documentMode || document.documentMode < 9) && !event.button) {
          return this._mouseUp(event);
        } else if (!event.which) {
          return this._mouseUp(event);
        }
        if (this._mouseStarted) {
          this._mouseDrag(event);
          return event.preventDefault();
        }
        if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
          this._mouseStarted = (this._mouseStart(this._mouseDownEvent, event) !== false);
          (this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
        }
        return !this._mouseStarted;
      },
      _mouseUp: function(event) {
        this.document.unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate);
        if (this._mouseStarted) {
          this._mouseStarted = false;
          if (event.target === this._mouseDownEvent.target) {
            $.data(event.target, this.widgetName + ".preventClickEvent", true);
          }
          this._mouseStop(event);
        }
        mouseHandled = false;
        return false;
      },
      _mouseDistanceMet: function(event) {
        return (Math.max(Math.abs(this._mouseDownEvent.pageX - event.pageX), Math.abs(this._mouseDownEvent.pageY - event.pageY)) >= this.options.distance);
      },
      _mouseDelayMet: function() {
        return this.mouseDelayMet;
      },
      _mouseStart: function() {},
      _mouseDrag: function() {},
      _mouseStop: function() {},
      _mouseCapture: function() {
        return true;
      }
    });
    (function() {
      $.ui = $.ui || {};
      var cachedScrollbarWidth,
          supportsOffsetFractions,
          max = Math.max,
          abs = Math.abs,
          round = Math.round,
          rhorizontal = /left|center|right/,
          rvertical = /top|center|bottom/,
          roffset = /[\+\-]\d+(\.[\d]+)?%?/,
          rposition = /^\w+/,
          rpercent = /%$/,
          _position = $.fn.position;
      function getOffsets(offsets, width, height) {
        return [parseFloat(offsets[0]) * (rpercent.test(offsets[0]) ? width / 100 : 1), parseFloat(offsets[1]) * (rpercent.test(offsets[1]) ? height / 100 : 1)];
      }
      function parseCss(element, property) {
        return parseInt($.css(element, property), 10) || 0;
      }
      function getDimensions(elem) {
        var raw = elem[0];
        if (raw.nodeType === 9) {
          return {
            width: elem.width(),
            height: elem.height(),
            offset: {
              top: 0,
              left: 0
            }
          };
        }
        if ($.isWindow(raw)) {
          return {
            width: elem.width(),
            height: elem.height(),
            offset: {
              top: elem.scrollTop(),
              left: elem.scrollLeft()
            }
          };
        }
        if (raw.preventDefault) {
          return {
            width: 0,
            height: 0,
            offset: {
              top: raw.pageY,
              left: raw.pageX
            }
          };
        }
        return {
          width: elem.outerWidth(),
          height: elem.outerHeight(),
          offset: elem.offset()
        };
      }
      $.position = {
        scrollbarWidth: function() {
          if (cachedScrollbarWidth !== undefined) {
            return cachedScrollbarWidth;
          }
          var w1,
              w2,
              div = $("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),
              innerDiv = div.children()[0];
          $("body").append(div);
          w1 = innerDiv.offsetWidth;
          div.css("overflow", "scroll");
          w2 = innerDiv.offsetWidth;
          if (w1 === w2) {
            w2 = div[0].clientWidth;
          }
          div.remove();
          return (cachedScrollbarWidth = w1 - w2);
        },
        getScrollInfo: function(within) {
          var overflowX = within.isWindow || within.isDocument ? "" : within.element.css("overflow-x"),
              overflowY = within.isWindow || within.isDocument ? "" : within.element.css("overflow-y"),
              hasOverflowX = overflowX === "scroll" || (overflowX === "auto" && within.width < within.element[0].scrollWidth),
              hasOverflowY = overflowY === "scroll" || (overflowY === "auto" && within.height < within.element[0].scrollHeight);
          return {
            width: hasOverflowY ? $.position.scrollbarWidth() : 0,
            height: hasOverflowX ? $.position.scrollbarWidth() : 0
          };
        },
        getWithinInfo: function(element) {
          var withinElement = $(element || window),
              isWindow = $.isWindow(withinElement[0]),
              isDocument = !!withinElement[0] && withinElement[0].nodeType === 9;
          return {
            element: withinElement,
            isWindow: isWindow,
            isDocument: isDocument,
            offset: withinElement.offset() || {
              left: 0,
              top: 0
            },
            scrollLeft: withinElement.scrollLeft(),
            scrollTop: withinElement.scrollTop(),
            width: isWindow || isDocument ? withinElement.width() : withinElement.outerWidth(),
            height: isWindow || isDocument ? withinElement.height() : withinElement.outerHeight()
          };
        }
      };
      $.fn.position = function(options) {
        if (!options || !options.of) {
          return _position.apply(this, arguments);
        }
        options = $.extend({}, options);
        var atOffset,
            targetWidth,
            targetHeight,
            targetOffset,
            basePosition,
            dimensions,
            target = $(options.of),
            within = $.position.getWithinInfo(options.within),
            scrollInfo = $.position.getScrollInfo(within),
            collision = (options.collision || "flip").split(" "),
            offsets = {};
        dimensions = getDimensions(target);
        if (target[0].preventDefault) {
          options.at = "left top";
        }
        targetWidth = dimensions.width;
        targetHeight = dimensions.height;
        targetOffset = dimensions.offset;
        basePosition = $.extend({}, targetOffset);
        $.each(["my", "at"], function() {
          var pos = (options[this] || "").split(" "),
              horizontalOffset,
              verticalOffset;
          if (pos.length === 1) {
            pos = rhorizontal.test(pos[0]) ? pos.concat(["center"]) : rvertical.test(pos[0]) ? ["center"].concat(pos) : ["center", "center"];
          }
          pos[0] = rhorizontal.test(pos[0]) ? pos[0] : "center";
          pos[1] = rvertical.test(pos[1]) ? pos[1] : "center";
          horizontalOffset = roffset.exec(pos[0]);
          verticalOffset = roffset.exec(pos[1]);
          offsets[this] = [horizontalOffset ? horizontalOffset[0] : 0, verticalOffset ? verticalOffset[0] : 0];
          options[this] = [rposition.exec(pos[0])[0], rposition.exec(pos[1])[0]];
        });
        if (collision.length === 1) {
          collision[1] = collision[0];
        }
        if (options.at[0] === "right") {
          basePosition.left += targetWidth;
        } else if (options.at[0] === "center") {
          basePosition.left += targetWidth / 2;
        }
        if (options.at[1] === "bottom") {
          basePosition.top += targetHeight;
        } else if (options.at[1] === "center") {
          basePosition.top += targetHeight / 2;
        }
        atOffset = getOffsets(offsets.at, targetWidth, targetHeight);
        basePosition.left += atOffset[0];
        basePosition.top += atOffset[1];
        return this.each(function() {
          var collisionPosition,
              using,
              elem = $(this),
              elemWidth = elem.outerWidth(),
              elemHeight = elem.outerHeight(),
              marginLeft = parseCss(this, "marginLeft"),
              marginTop = parseCss(this, "marginTop"),
              collisionWidth = elemWidth + marginLeft + parseCss(this, "marginRight") + scrollInfo.width,
              collisionHeight = elemHeight + marginTop + parseCss(this, "marginBottom") + scrollInfo.height,
              position = $.extend({}, basePosition),
              myOffset = getOffsets(offsets.my, elem.outerWidth(), elem.outerHeight());
          if (options.my[0] === "right") {
            position.left -= elemWidth;
          } else if (options.my[0] === "center") {
            position.left -= elemWidth / 2;
          }
          if (options.my[1] === "bottom") {
            position.top -= elemHeight;
          } else if (options.my[1] === "center") {
            position.top -= elemHeight / 2;
          }
          position.left += myOffset[0];
          position.top += myOffset[1];
          if (!supportsOffsetFractions) {
            position.left = round(position.left);
            position.top = round(position.top);
          }
          collisionPosition = {
            marginLeft: marginLeft,
            marginTop: marginTop
          };
          $.each(["left", "top"], function(i, dir) {
            if ($.ui.position[collision[i]]) {
              $.ui.position[collision[i]][dir](position, {
                targetWidth: targetWidth,
                targetHeight: targetHeight,
                elemWidth: elemWidth,
                elemHeight: elemHeight,
                collisionPosition: collisionPosition,
                collisionWidth: collisionWidth,
                collisionHeight: collisionHeight,
                offset: [atOffset[0] + myOffset[0], atOffset[1] + myOffset[1]],
                my: options.my,
                at: options.at,
                within: within,
                elem: elem
              });
            }
          });
          if (options.using) {
            using = function(props) {
              var left = targetOffset.left - position.left,
                  right = left + targetWidth - elemWidth,
                  top = targetOffset.top - position.top,
                  bottom = top + targetHeight - elemHeight,
                  feedback = {
                    target: {
                      element: target,
                      left: targetOffset.left,
                      top: targetOffset.top,
                      width: targetWidth,
                      height: targetHeight
                    },
                    element: {
                      element: elem,
                      left: position.left,
                      top: position.top,
                      width: elemWidth,
                      height: elemHeight
                    },
                    horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
                    vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
                  };
              if (targetWidth < elemWidth && abs(left + right) < targetWidth) {
                feedback.horizontal = "center";
              }
              if (targetHeight < elemHeight && abs(top + bottom) < targetHeight) {
                feedback.vertical = "middle";
              }
              if (max(abs(left), abs(right)) > max(abs(top), abs(bottom))) {
                feedback.important = "horizontal";
              } else {
                feedback.important = "vertical";
              }
              options.using.call(this, props, feedback);
            };
          }
          elem.offset($.extend(position, {using: using}));
        });
      };
      $.ui.position = {
        fit: {
          left: function(position, data) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
                outerWidth = within.width,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = withinOffset - collisionPosLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
                newOverRight;
            if (data.collisionWidth > outerWidth) {
              if (overLeft > 0 && overRight <= 0) {
                newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
                position.left += overLeft - newOverRight;
              } else if (overRight > 0 && overLeft <= 0) {
                position.left = withinOffset;
              } else {
                if (overLeft > overRight) {
                  position.left = withinOffset + outerWidth - data.collisionWidth;
                } else {
                  position.left = withinOffset;
                }
              }
            } else if (overLeft > 0) {
              position.left += overLeft;
            } else if (overRight > 0) {
              position.left -= overRight;
            } else {
              position.left = max(position.left - collisionPosLeft, position.left);
            }
          },
          top: function(position, data) {
            var within = data.within,
                withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
                outerHeight = data.within.height,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = withinOffset - collisionPosTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
                newOverBottom;
            if (data.collisionHeight > outerHeight) {
              if (overTop > 0 && overBottom <= 0) {
                newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
                position.top += overTop - newOverBottom;
              } else if (overBottom > 0 && overTop <= 0) {
                position.top = withinOffset;
              } else {
                if (overTop > overBottom) {
                  position.top = withinOffset + outerHeight - data.collisionHeight;
                } else {
                  position.top = withinOffset;
                }
              }
            } else if (overTop > 0) {
              position.top += overTop;
            } else if (overBottom > 0) {
              position.top -= overBottom;
            } else {
              position.top = max(position.top - collisionPosTop, position.top);
            }
          }
        },
        flip: {
          left: function(position, data) {
            var within = data.within,
                withinOffset = within.offset.left + within.scrollLeft,
                outerWidth = within.width,
                offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
                collisionPosLeft = position.left - data.collisionPosition.marginLeft,
                overLeft = collisionPosLeft - offsetLeft,
                overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
                myOffset = data.my[0] === "left" ? -data.elemWidth : data.my[0] === "right" ? data.elemWidth : 0,
                atOffset = data.at[0] === "left" ? data.targetWidth : data.at[0] === "right" ? -data.targetWidth : 0,
                offset = -2 * data.offset[0],
                newOverRight,
                newOverLeft;
            if (overLeft < 0) {
              newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
              if (newOverRight < 0 || newOverRight < abs(overLeft)) {
                position.left += myOffset + atOffset + offset;
              }
            } else if (overRight > 0) {
              newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
              if (newOverLeft > 0 || abs(newOverLeft) < overRight) {
                position.left += myOffset + atOffset + offset;
              }
            }
          },
          top: function(position, data) {
            var within = data.within,
                withinOffset = within.offset.top + within.scrollTop,
                outerHeight = within.height,
                offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
                collisionPosTop = position.top - data.collisionPosition.marginTop,
                overTop = collisionPosTop - offsetTop,
                overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
                top = data.my[1] === "top",
                myOffset = top ? -data.elemHeight : data.my[1] === "bottom" ? data.elemHeight : 0,
                atOffset = data.at[1] === "top" ? data.targetHeight : data.at[1] === "bottom" ? -data.targetHeight : 0,
                offset = -2 * data.offset[1],
                newOverTop,
                newOverBottom;
            if (overTop < 0) {
              newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
              if ((position.top + myOffset + atOffset + offset) > overTop && (newOverBottom < 0 || newOverBottom < abs(overTop))) {
                position.top += myOffset + atOffset + offset;
              }
            } else if (overBottom > 0) {
              newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
              if ((position.top + myOffset + atOffset + offset) > overBottom && (newOverTop > 0 || abs(newOverTop) < overBottom)) {
                position.top += myOffset + atOffset + offset;
              }
            }
          }
        },
        flipfit: {
          left: function() {
            $.ui.position.flip.left.apply(this, arguments);
            $.ui.position.fit.left.apply(this, arguments);
          },
          top: function() {
            $.ui.position.flip.top.apply(this, arguments);
            $.ui.position.fit.top.apply(this, arguments);
          }
        }
      };
      (function() {
        var testElement,
            testElementParent,
            testElementStyle,
            offsetLeft,
            i,
            body = document.getElementsByTagName("body")[0],
            div = document.createElement("div");
        testElement = document.createElement(body ? "div" : "body");
        testElementStyle = {
          visibility: "hidden",
          width: 0,
          height: 0,
          border: 0,
          margin: 0,
          background: "none"
        };
        if (body) {
          $.extend(testElementStyle, {
            position: "absolute",
            left: "-1000px",
            top: "-1000px"
          });
        }
        for (i in testElementStyle) {
          testElement.style[i] = testElementStyle[i];
        }
        testElement.appendChild(div);
        testElementParent = body || document.documentElement;
        testElementParent.insertBefore(testElement, testElementParent.firstChild);
        div.style.cssText = "position: absolute; left: 10.7432222px;";
        offsetLeft = $(div).offset().left;
        supportsOffsetFractions = offsetLeft > 10 && offsetLeft < 11;
        testElement.innerHTML = "";
        testElementParent.removeChild(testElement);
      })();
    })();
    var position = $.ui.position;
    var accordion = $.widget("ui.accordion", {
      version: "1.11.1",
      options: {
        active: 0,
        animate: {},
        collapsible: false,
        event: "click",
        header: "> li > :first-child,> :not(li):even",
        heightStyle: "auto",
        icons: {
          activeHeader: "ui-icon-triangle-1-s",
          header: "ui-icon-triangle-1-e"
        },
        activate: null,
        beforeActivate: null
      },
      hideProps: {
        borderTopWidth: "hide",
        borderBottomWidth: "hide",
        paddingTop: "hide",
        paddingBottom: "hide",
        height: "hide"
      },
      showProps: {
        borderTopWidth: "show",
        borderBottomWidth: "show",
        paddingTop: "show",
        paddingBottom: "show",
        height: "show"
      },
      _create: function() {
        var options = this.options;
        this.prevShow = this.prevHide = $();
        this.element.addClass("ui-accordion ui-widget ui-helper-reset").attr("role", "tablist");
        if (!options.collapsible && (options.active === false || options.active == null)) {
          options.active = 0;
        }
        this._processPanels();
        if (options.active < 0) {
          options.active += this.headers.length;
        }
        this._refresh();
      },
      _getCreateEventData: function() {
        return {
          header: this.active,
          panel: !this.active.length ? $() : this.active.next()
        };
      },
      _createIcons: function() {
        var icons = this.options.icons;
        if (icons) {
          $("<span>").addClass("ui-accordion-header-icon ui-icon " + icons.header).prependTo(this.headers);
          this.active.children(".ui-accordion-header-icon").removeClass(icons.header).addClass(icons.activeHeader);
          this.headers.addClass("ui-accordion-icons");
        }
      },
      _destroyIcons: function() {
        this.headers.removeClass("ui-accordion-icons").children(".ui-accordion-header-icon").remove();
      },
      _destroy: function() {
        var contents;
        this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role");
        this.headers.removeClass("ui-accordion-header ui-accordion-header-active ui-state-default " + "ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("aria-controls").removeAttr("tabIndex").removeUniqueId();
        this._destroyIcons();
        contents = this.headers.next().removeClass("ui-helper-reset ui-widget-content ui-corner-bottom " + "ui-accordion-content ui-accordion-content-active ui-state-disabled").css("display", "").removeAttr("role").removeAttr("aria-hidden").removeAttr("aria-labelledby").removeUniqueId();
        if (this.options.heightStyle !== "content") {
          contents.css("height", "");
        }
      },
      _setOption: function(key, value) {
        if (key === "active") {
          this._activate(value);
          return;
        }
        if (key === "event") {
          if (this.options.event) {
            this._off(this.headers, this.options.event);
          }
          this._setupEvents(value);
        }
        this._super(key, value);
        if (key === "collapsible" && !value && this.options.active === false) {
          this._activate(0);
        }
        if (key === "icons") {
          this._destroyIcons();
          if (value) {
            this._createIcons();
          }
        }
        if (key === "disabled") {
          this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
          this.headers.add(this.headers.next()).toggleClass("ui-state-disabled", !!value);
        }
      },
      _keydown: function(event) {
        if (event.altKey || event.ctrlKey) {
          return;
        }
        var keyCode = $.ui.keyCode,
            length = this.headers.length,
            currentIndex = this.headers.index(event.target),
            toFocus = false;
        switch (event.keyCode) {
          case keyCode.RIGHT:
          case keyCode.DOWN:
            toFocus = this.headers[(currentIndex + 1) % length];
            break;
          case keyCode.LEFT:
          case keyCode.UP:
            toFocus = this.headers[(currentIndex - 1 + length) % length];
            break;
          case keyCode.SPACE:
          case keyCode.ENTER:
            this._eventHandler(event);
            break;
          case keyCode.HOME:
            toFocus = this.headers[0];
            break;
          case keyCode.END:
            toFocus = this.headers[length - 1];
            break;
        }
        if (toFocus) {
          $(event.target).attr("tabIndex", -1);
          $(toFocus).attr("tabIndex", 0);
          toFocus.focus();
          event.preventDefault();
        }
      },
      _panelKeyDown: function(event) {
        if (event.keyCode === $.ui.keyCode.UP && event.ctrlKey) {
          $(event.currentTarget).prev().focus();
        }
      },
      refresh: function() {
        var options = this.options;
        this._processPanels();
        if ((options.active === false && options.collapsible === true) || !this.headers.length) {
          options.active = false;
          this.active = $();
        } else if (options.active === false) {
          this._activate(0);
        } else if (this.active.length && !$.contains(this.element[0], this.active[0])) {
          if (this.headers.length === this.headers.find(".ui-state-disabled").length) {
            options.active = false;
            this.active = $();
          } else {
            this._activate(Math.max(0, options.active - 1));
          }
        } else {
          options.active = this.headers.index(this.active);
        }
        this._destroyIcons();
        this._refresh();
      },
      _processPanels: function() {
        this.headers = this.element.find(this.options.header).addClass("ui-accordion-header ui-state-default ui-corner-all");
        this.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom").filter(":not(.ui-accordion-content-active)").hide();
      },
      _refresh: function() {
        var maxHeight,
            options = this.options,
            heightStyle = options.heightStyle,
            parent = this.element.parent();
        this.active = this._findActive(options.active).addClass("ui-accordion-header-active ui-state-active ui-corner-top").removeClass("ui-corner-all");
        this.active.next().addClass("ui-accordion-content-active").show();
        this.headers.attr("role", "tab").each(function() {
          var header = $(this),
              headerId = header.uniqueId().attr("id"),
              panel = header.next(),
              panelId = panel.uniqueId().attr("id");
          header.attr("aria-controls", panelId);
          panel.attr("aria-labelledby", headerId);
        }).next().attr("role", "tabpanel");
        this.headers.not(this.active).attr({
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        }).next().attr({"aria-hidden": "true"}).hide();
        if (!this.active.length) {
          this.headers.eq(0).attr("tabIndex", 0);
        } else {
          this.active.attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          }).next().attr({"aria-hidden": "false"});
        }
        this._createIcons();
        this._setupEvents(options.event);
        if (heightStyle === "fill") {
          maxHeight = parent.height();
          this.element.siblings(":visible").each(function() {
            var elem = $(this),
                position = elem.css("position");
            if (position === "absolute" || position === "fixed") {
              return;
            }
            maxHeight -= elem.outerHeight(true);
          });
          this.headers.each(function() {
            maxHeight -= $(this).outerHeight(true);
          });
          this.headers.next().each(function() {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          }).css("overflow", "auto");
        } else if (heightStyle === "auto") {
          maxHeight = 0;
          this.headers.next().each(function() {
            maxHeight = Math.max(maxHeight, $(this).css("height", "").height());
          }).height(maxHeight);
        }
      },
      _activate: function(index) {
        var active = this._findActive(index)[0];
        if (active === this.active[0]) {
          return;
        }
        active = active || this.active[0];
        this._eventHandler({
          target: active,
          currentTarget: active,
          preventDefault: $.noop
        });
      },
      _findActive: function(selector) {
        return typeof selector === "number" ? this.headers.eq(selector) : $();
      },
      _setupEvents: function(event) {
        var events = {keydown: "_keydown"};
        if (event) {
          $.each(event.split(" "), function(index, eventName) {
            events[eventName] = "_eventHandler";
          });
        }
        this._off(this.headers.add(this.headers.next()));
        this._on(this.headers, events);
        this._on(this.headers.next(), {keydown: "_panelKeyDown"});
        this._hoverable(this.headers);
        this._focusable(this.headers);
      },
      _eventHandler: function(event) {
        var options = this.options,
            active = this.active,
            clicked = $(event.currentTarget),
            clickedIsActive = clicked[0] === active[0],
            collapsing = clickedIsActive && options.collapsible,
            toShow = collapsing ? $() : clicked.next(),
            toHide = active.next(),
            eventData = {
              oldHeader: active,
              oldPanel: toHide,
              newHeader: collapsing ? $() : clicked,
              newPanel: toShow
            };
        event.preventDefault();
        if ((clickedIsActive && !options.collapsible) || (this._trigger("beforeActivate", event, eventData) === false)) {
          return;
        }
        options.active = collapsing ? false : this.headers.index(clicked);
        this.active = clickedIsActive ? $() : clicked;
        this._toggle(eventData);
        active.removeClass("ui-accordion-header-active ui-state-active");
        if (options.icons) {
          active.children(".ui-accordion-header-icon").removeClass(options.icons.activeHeader).addClass(options.icons.header);
        }
        if (!clickedIsActive) {
          clicked.removeClass("ui-corner-all").addClass("ui-accordion-header-active ui-state-active ui-corner-top");
          if (options.icons) {
            clicked.children(".ui-accordion-header-icon").removeClass(options.icons.header).addClass(options.icons.activeHeader);
          }
          clicked.next().addClass("ui-accordion-content-active");
        }
      },
      _toggle: function(data) {
        var toShow = data.newPanel,
            toHide = this.prevShow.length ? this.prevShow : data.oldPanel;
        this.prevShow.add(this.prevHide).stop(true, true);
        this.prevShow = toShow;
        this.prevHide = toHide;
        if (this.options.animate) {
          this._animate(toShow, toHide, data);
        } else {
          toHide.hide();
          toShow.show();
          this._toggleComplete(data);
        }
        toHide.attr({"aria-hidden": "true"});
        toHide.prev().attr("aria-selected", "false");
        if (toShow.length && toHide.length) {
          toHide.prev().attr({
            "tabIndex": -1,
            "aria-expanded": "false"
          });
        } else if (toShow.length) {
          this.headers.filter(function() {
            return $(this).attr("tabIndex") === 0;
          }).attr("tabIndex", -1);
        }
        toShow.attr("aria-hidden", "false").prev().attr({
          "aria-selected": "true",
          tabIndex: 0,
          "aria-expanded": "true"
        });
      },
      _animate: function(toShow, toHide, data) {
        var total,
            easing,
            duration,
            that = this,
            adjust = 0,
            down = toShow.length && (!toHide.length || (toShow.index() < toHide.index())),
            animate = this.options.animate || {},
            options = down && animate.down || animate,
            complete = function() {
              that._toggleComplete(data);
            };
        if (typeof options === "number") {
          duration = options;
        }
        if (typeof options === "string") {
          easing = options;
        }
        easing = easing || options.easing || animate.easing;
        duration = duration || options.duration || animate.duration;
        if (!toHide.length) {
          return toShow.animate(this.showProps, duration, easing, complete);
        }
        if (!toShow.length) {
          return toHide.animate(this.hideProps, duration, easing, complete);
        }
        total = toShow.show().outerHeight();
        toHide.animate(this.hideProps, {
          duration: duration,
          easing: easing,
          step: function(now, fx) {
            fx.now = Math.round(now);
          }
        });
        toShow.hide().animate(this.showProps, {
          duration: duration,
          easing: easing,
          complete: complete,
          step: function(now, fx) {
            fx.now = Math.round(now);
            if (fx.prop !== "height") {
              adjust += fx.now;
            } else if (that.options.heightStyle !== "content") {
              fx.now = Math.round(total - toHide.outerHeight() - adjust);
              adjust = 0;
            }
          }
        });
      },
      _toggleComplete: function(data) {
        var toHide = data.oldPanel;
        toHide.removeClass("ui-accordion-content-active").prev().removeClass("ui-corner-top").addClass("ui-corner-all");
        if (toHide.length) {
          toHide.parent()[0].className = toHide.parent()[0].className;
        }
        this._trigger("activate", null, data);
      }
    });
    var menu = $.widget("ui.menu", {
      version: "1.11.1",
      defaultElement: "<ul>",
      delay: 300,
      options: {
        icons: {submenu: "ui-icon-carat-1-e"},
        items: "> *",
        menus: "ul",
        position: {
          my: "left-1 top",
          at: "right top"
        },
        role: "menu",
        blur: null,
        focus: null,
        select: null
      },
      _create: function() {
        this.activeMenu = this.element;
        this.mouseHandled = false;
        this.element.uniqueId().addClass("ui-menu ui-widget ui-widget-content").toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length).attr({
          role: this.options.role,
          tabIndex: 0
        });
        if (this.options.disabled) {
          this.element.addClass("ui-state-disabled").attr("aria-disabled", "true");
        }
        this._on({
          "mousedown .ui-menu-item": function(event) {
            event.preventDefault();
          },
          "click .ui-menu-item": function(event) {
            var target = $(event.target);
            if (!this.mouseHandled && target.not(".ui-state-disabled").length) {
              this.select(event);
              if (!event.isPropagationStopped()) {
                this.mouseHandled = true;
              }
              if (target.has(".ui-menu").length) {
                this.expand(event);
              } else if (!this.element.is(":focus") && $(this.document[0].activeElement).closest(".ui-menu").length) {
                this.element.trigger("focus", [true]);
                if (this.active && this.active.parents(".ui-menu").length === 1) {
                  clearTimeout(this.timer);
                }
              }
            }
          },
          "mouseenter .ui-menu-item": function(event) {
            var target = $(event.currentTarget);
            target.siblings(".ui-state-active").removeClass("ui-state-active");
            this.focus(event, target);
          },
          mouseleave: "collapseAll",
          "mouseleave .ui-menu": "collapseAll",
          focus: function(event, keepActiveItem) {
            var item = this.active || this.element.find(this.options.items).eq(0);
            if (!keepActiveItem) {
              this.focus(event, item);
            }
          },
          blur: function(event) {
            this._delay(function() {
              if (!$.contains(this.element[0], this.document[0].activeElement)) {
                this.collapseAll(event);
              }
            });
          },
          keydown: "_keydown"
        });
        this.refresh();
        this._on(this.document, {click: function(event) {
            if (this._closeOnDocumentClick(event)) {
              this.collapseAll(event);
            }
            this.mouseHandled = false;
          }});
      },
      _destroy: function() {
        this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeClass("ui-menu ui-widget ui-widget-content ui-menu-icons ui-front").removeAttr("role").removeAttr("tabIndex").removeAttr("aria-labelledby").removeAttr("aria-expanded").removeAttr("aria-hidden").removeAttr("aria-disabled").removeUniqueId().show();
        this.element.find(".ui-menu-item").removeClass("ui-menu-item").removeAttr("role").removeAttr("aria-disabled").removeUniqueId().removeClass("ui-state-hover").removeAttr("tabIndex").removeAttr("role").removeAttr("aria-haspopup").children().each(function() {
          var elem = $(this);
          if (elem.data("ui-menu-submenu-carat")) {
            elem.remove();
          }
        });
        this.element.find(".ui-menu-divider").removeClass("ui-menu-divider ui-widget-content");
      },
      _keydown: function(event) {
        var match,
            prev,
            character,
            skip,
            regex,
            preventDefault = true;
        function escape(value) {
          return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
        }
        switch (event.keyCode) {
          case $.ui.keyCode.PAGE_UP:
            this.previousPage(event);
            break;
          case $.ui.keyCode.PAGE_DOWN:
            this.nextPage(event);
            break;
          case $.ui.keyCode.HOME:
            this._move("first", "first", event);
            break;
          case $.ui.keyCode.END:
            this._move("last", "last", event);
            break;
          case $.ui.keyCode.UP:
            this.previous(event);
            break;
          case $.ui.keyCode.DOWN:
            this.next(event);
            break;
          case $.ui.keyCode.LEFT:
            this.collapse(event);
            break;
          case $.ui.keyCode.RIGHT:
            if (this.active && !this.active.is(".ui-state-disabled")) {
              this.expand(event);
            }
            break;
          case $.ui.keyCode.ENTER:
          case $.ui.keyCode.SPACE:
            this._activate(event);
            break;
          case $.ui.keyCode.ESCAPE:
            this.collapse(event);
            break;
          default:
            preventDefault = false;
            prev = this.previousFilter || "";
            character = String.fromCharCode(event.keyCode);
            skip = false;
            clearTimeout(this.filterTimer);
            if (character === prev) {
              skip = true;
            } else {
              character = prev + character;
            }
            regex = new RegExp("^" + escape(character), "i");
            match = this.activeMenu.find(this.options.items).filter(function() {
              return regex.test($(this).text());
            });
            match = skip && match.index(this.active.next()) !== -1 ? this.active.nextAll(".ui-menu-item") : match;
            if (!match.length) {
              character = String.fromCharCode(event.keyCode);
              regex = new RegExp("^" + escape(character), "i");
              match = this.activeMenu.find(this.options.items).filter(function() {
                return regex.test($(this).text());
              });
            }
            if (match.length) {
              this.focus(event, match);
              if (match.length > 1) {
                this.previousFilter = character;
                this.filterTimer = this._delay(function() {
                  delete this.previousFilter;
                }, 1000);
              } else {
                delete this.previousFilter;
              }
            } else {
              delete this.previousFilter;
            }
        }
        if (preventDefault) {
          event.preventDefault();
        }
      },
      _activate: function(event) {
        if (!this.active.is(".ui-state-disabled")) {
          if (this.active.is("[aria-haspopup='true']")) {
            this.expand(event);
          } else {
            this.select(event);
          }
        }
      },
      refresh: function() {
        var menus,
            items,
            that = this,
            icon = this.options.icons.submenu,
            submenus = this.element.find(this.options.menus);
        this.element.toggleClass("ui-menu-icons", !!this.element.find(".ui-icon").length);
        submenus.filter(":not(.ui-menu)").addClass("ui-menu ui-widget ui-widget-content ui-front").hide().attr({
          role: this.options.role,
          "aria-hidden": "true",
          "aria-expanded": "false"
        }).each(function() {
          var menu = $(this),
              item = menu.parent(),
              submenuCarat = $("<span>").addClass("ui-menu-icon ui-icon " + icon).data("ui-menu-submenu-carat", true);
          item.attr("aria-haspopup", "true").prepend(submenuCarat);
          menu.attr("aria-labelledby", item.attr("id"));
        });
        menus = submenus.add(this.element);
        items = menus.find(this.options.items);
        items.not(".ui-menu-item").each(function() {
          var item = $(this);
          if (that._isDivider(item)) {
            item.addClass("ui-widget-content ui-menu-divider");
          }
        });
        items.not(".ui-menu-item, .ui-menu-divider").addClass("ui-menu-item").uniqueId().attr({
          tabIndex: -1,
          role: this._itemRole()
        });
        items.filter(".ui-state-disabled").attr("aria-disabled", "true");
        if (this.active && !$.contains(this.element[0], this.active[0])) {
          this.blur();
        }
      },
      _itemRole: function() {
        return {
          menu: "menuitem",
          listbox: "option"
        }[this.options.role];
      },
      _setOption: function(key, value) {
        if (key === "icons") {
          this.element.find(".ui-menu-icon").removeClass(this.options.icons.submenu).addClass(value.submenu);
        }
        if (key === "disabled") {
          this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
        }
        this._super(key, value);
      },
      focus: function(event, item) {
        var nested,
            focused;
        this.blur(event, event && event.type === "focus");
        this._scrollIntoView(item);
        this.active = item.first();
        focused = this.active.addClass("ui-state-focus").removeClass("ui-state-active");
        if (this.options.role) {
          this.element.attr("aria-activedescendant", focused.attr("id"));
        }
        this.active.parent().closest(".ui-menu-item").addClass("ui-state-active");
        if (event && event.type === "keydown") {
          this._close();
        } else {
          this.timer = this._delay(function() {
            this._close();
          }, this.delay);
        }
        nested = item.children(".ui-menu");
        if (nested.length && event && (/^mouse/.test(event.type))) {
          this._startOpening(nested);
        }
        this.activeMenu = item.parent();
        this._trigger("focus", event, {item: item});
      },
      _scrollIntoView: function(item) {
        var borderTop,
            paddingTop,
            offset,
            scroll,
            elementHeight,
            itemHeight;
        if (this._hasScroll()) {
          borderTop = parseFloat($.css(this.activeMenu[0], "borderTopWidth")) || 0;
          paddingTop = parseFloat($.css(this.activeMenu[0], "paddingTop")) || 0;
          offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
          scroll = this.activeMenu.scrollTop();
          elementHeight = this.activeMenu.height();
          itemHeight = item.outerHeight();
          if (offset < 0) {
            this.activeMenu.scrollTop(scroll + offset);
          } else if (offset + itemHeight > elementHeight) {
            this.activeMenu.scrollTop(scroll + offset - elementHeight + itemHeight);
          }
        }
      },
      blur: function(event, fromFocus) {
        if (!fromFocus) {
          clearTimeout(this.timer);
        }
        if (!this.active) {
          return;
        }
        this.active.removeClass("ui-state-focus");
        this.active = null;
        this._trigger("blur", event, {item: this.active});
      },
      _startOpening: function(submenu) {
        clearTimeout(this.timer);
        if (submenu.attr("aria-hidden") !== "true") {
          return;
        }
        this.timer = this._delay(function() {
          this._close();
          this._open(submenu);
        }, this.delay);
      },
      _open: function(submenu) {
        var position = $.extend({of: this.active}, this.options.position);
        clearTimeout(this.timer);
        this.element.find(".ui-menu").not(submenu.parents(".ui-menu")).hide().attr("aria-hidden", "true");
        submenu.show().removeAttr("aria-hidden").attr("aria-expanded", "true").position(position);
      },
      collapseAll: function(event, all) {
        clearTimeout(this.timer);
        this.timer = this._delay(function() {
          var currentMenu = all ? this.element : $(event && event.target).closest(this.element.find(".ui-menu"));
          if (!currentMenu.length) {
            currentMenu = this.element;
          }
          this._close(currentMenu);
          this.blur(event);
          this.activeMenu = currentMenu;
        }, this.delay);
      },
      _close: function(startMenu) {
        if (!startMenu) {
          startMenu = this.active ? this.active.parent() : this.element;
        }
        startMenu.find(".ui-menu").hide().attr("aria-hidden", "true").attr("aria-expanded", "false").end().find(".ui-state-active").not(".ui-state-focus").removeClass("ui-state-active");
      },
      _closeOnDocumentClick: function(event) {
        return !$(event.target).closest(".ui-menu").length;
      },
      _isDivider: function(item) {
        return !/[^\-\u2014\u2013\s]/.test(item.text());
      },
      collapse: function(event) {
        var newItem = this.active && this.active.parent().closest(".ui-menu-item", this.element);
        if (newItem && newItem.length) {
          this._close();
          this.focus(event, newItem);
        }
      },
      expand: function(event) {
        var newItem = this.active && this.active.children(".ui-menu ").find(this.options.items).first();
        if (newItem && newItem.length) {
          this._open(newItem.parent());
          this._delay(function() {
            this.focus(event, newItem);
          });
        }
      },
      next: function(event) {
        this._move("next", "first", event);
      },
      previous: function(event) {
        this._move("prev", "last", event);
      },
      isFirstItem: function() {
        return this.active && !this.active.prevAll(".ui-menu-item").length;
      },
      isLastItem: function() {
        return this.active && !this.active.nextAll(".ui-menu-item").length;
      },
      _move: function(direction, filter, event) {
        var next;
        if (this.active) {
          if (direction === "first" || direction === "last") {
            next = this.active[direction === "first" ? "prevAll" : "nextAll"](".ui-menu-item").eq(-1);
          } else {
            next = this.active[direction + "All"](".ui-menu-item").eq(0);
          }
        }
        if (!next || !next.length || !this.active) {
          next = this.activeMenu.find(this.options.items)[filter]();
        }
        this.focus(event, next);
      },
      nextPage: function(event) {
        var item,
            base,
            height;
        if (!this.active) {
          this.next(event);
          return;
        }
        if (this.isLastItem()) {
          return;
        }
        if (this._hasScroll()) {
          base = this.active.offset().top;
          height = this.element.height();
          this.active.nextAll(".ui-menu-item").each(function() {
            item = $(this);
            return item.offset().top - base - height < 0;
          });
          this.focus(event, item);
        } else {
          this.focus(event, this.activeMenu.find(this.options.items)[!this.active ? "first" : "last"]());
        }
      },
      previousPage: function(event) {
        var item,
            base,
            height;
        if (!this.active) {
          this.next(event);
          return;
        }
        if (this.isFirstItem()) {
          return;
        }
        if (this._hasScroll()) {
          base = this.active.offset().top;
          height = this.element.height();
          this.active.prevAll(".ui-menu-item").each(function() {
            item = $(this);
            return item.offset().top - base + height > 0;
          });
          this.focus(event, item);
        } else {
          this.focus(event, this.activeMenu.find(this.options.items).first());
        }
      },
      _hasScroll: function() {
        return this.element.outerHeight() < this.element.prop("scrollHeight");
      },
      select: function(event) {
        this.active = this.active || $(event.target).closest(".ui-menu-item");
        var ui = {item: this.active};
        if (!this.active.has(".ui-menu").length) {
          this.collapseAll(event, true);
        }
        this._trigger("select", event, ui);
      }
    });
    $.widget("ui.autocomplete", {
      version: "1.11.1",
      defaultElement: "<input>",
      options: {
        appendTo: null,
        autoFocus: false,
        delay: 300,
        minLength: 1,
        position: {
          my: "left top",
          at: "left bottom",
          collision: "none"
        },
        source: null,
        change: null,
        close: null,
        focus: null,
        open: null,
        response: null,
        search: null,
        select: null
      },
      requestIndex: 0,
      pending: 0,
      _create: function() {
        var suppressKeyPress,
            suppressKeyPressRepeat,
            suppressInput,
            nodeName = this.element[0].nodeName.toLowerCase(),
            isTextarea = nodeName === "textarea",
            isInput = nodeName === "input";
        this.isMultiLine = isTextarea ? true : isInput ? false : this.element.prop("isContentEditable");
        this.valueMethod = this.element[isTextarea || isInput ? "val" : "text"];
        this.isNewMenu = true;
        this.element.addClass("ui-autocomplete-input").attr("autocomplete", "off");
        this._on(this.element, {
          keydown: function(event) {
            if (this.element.prop("readOnly")) {
              suppressKeyPress = true;
              suppressInput = true;
              suppressKeyPressRepeat = true;
              return;
            }
            suppressKeyPress = false;
            suppressInput = false;
            suppressKeyPressRepeat = false;
            var keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.PAGE_UP:
                suppressKeyPress = true;
                this._move("previousPage", event);
                break;
              case keyCode.PAGE_DOWN:
                suppressKeyPress = true;
                this._move("nextPage", event);
                break;
              case keyCode.UP:
                suppressKeyPress = true;
                this._keyEvent("previous", event);
                break;
              case keyCode.DOWN:
                suppressKeyPress = true;
                this._keyEvent("next", event);
                break;
              case keyCode.ENTER:
                if (this.menu.active) {
                  suppressKeyPress = true;
                  event.preventDefault();
                  this.menu.select(event);
                }
                break;
              case keyCode.TAB:
                if (this.menu.active) {
                  this.menu.select(event);
                }
                break;
              case keyCode.ESCAPE:
                if (this.menu.element.is(":visible")) {
                  if (!this.isMultiLine) {
                    this._value(this.term);
                  }
                  this.close(event);
                  event.preventDefault();
                }
                break;
              default:
                suppressKeyPressRepeat = true;
                this._searchTimeout(event);
                break;
            }
          },
          keypress: function(event) {
            if (suppressKeyPress) {
              suppressKeyPress = false;
              if (!this.isMultiLine || this.menu.element.is(":visible")) {
                event.preventDefault();
              }
              return;
            }
            if (suppressKeyPressRepeat) {
              return;
            }
            var keyCode = $.ui.keyCode;
            switch (event.keyCode) {
              case keyCode.PAGE_UP:
                this._move("previousPage", event);
                break;
              case keyCode.PAGE_DOWN:
                this._move("nextPage", event);
                break;
              case keyCode.UP:
                this._keyEvent("previous", event);
                break;
              case keyCode.DOWN:
                this._keyEvent("next", event);
                break;
            }
          },
          input: function(event) {
            if (suppressInput) {
              suppressInput = false;
              event.preventDefault();
              return;
            }
            this._searchTimeout(event);
          },
          focus: function() {
            this.selectedItem = null;
            this.previous = this._value();
          },
          blur: function(event) {
            if (this.cancelBlur) {
              delete this.cancelBlur;
              return;
            }
            clearTimeout(this.searching);
            this.close(event);
            this._change(event);
          }
        });
        this._initSource();
        this.menu = $("<ul>").addClass("ui-autocomplete ui-front").appendTo(this._appendTo()).menu({role: null}).hide().menu("instance");
        this._on(this.menu.element, {
          mousedown: function(event) {
            event.preventDefault();
            this.cancelBlur = true;
            this._delay(function() {
              delete this.cancelBlur;
            });
            var menuElement = this.menu.element[0];
            if (!$(event.target).closest(".ui-menu-item").length) {
              this._delay(function() {
                var that = this;
                this.document.one("mousedown", function(event) {
                  if (event.target !== that.element[0] && event.target !== menuElement && !$.contains(menuElement, event.target)) {
                    that.close();
                  }
                });
              });
            }
          },
          menufocus: function(event, ui) {
            var label,
                item;
            if (this.isNewMenu) {
              this.isNewMenu = false;
              if (event.originalEvent && /^mouse/.test(event.originalEvent.type)) {
                this.menu.blur();
                this.document.one("mousemove", function() {
                  $(event.target).trigger(event.originalEvent);
                });
                return;
              }
            }
            item = ui.item.data("ui-autocomplete-item");
            if (false !== this._trigger("focus", event, {item: item})) {
              if (event.originalEvent && /^key/.test(event.originalEvent.type)) {
                this._value(item.value);
              }
            }
            label = ui.item.attr("aria-label") || item.value;
            if (label && $.trim(label).length) {
              this.liveRegion.children().hide();
              $("<div>").text(label).appendTo(this.liveRegion);
            }
          },
          menuselect: function(event, ui) {
            var item = ui.item.data("ui-autocomplete-item"),
                previous = this.previous;
            if (this.element[0] !== this.document[0].activeElement) {
              this.element.focus();
              this.previous = previous;
              this._delay(function() {
                this.previous = previous;
                this.selectedItem = item;
              });
            }
            if (false !== this._trigger("select", event, {item: item})) {
              this._value(item.value);
            }
            this.term = this._value();
            this.close(event);
            this.selectedItem = item;
          }
        });
        this.liveRegion = $("<span>", {
          role: "status",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
        this._on(this.window, {beforeunload: function() {
            this.element.removeAttr("autocomplete");
          }});
      },
      _destroy: function() {
        clearTimeout(this.searching);
        this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete");
        this.menu.element.remove();
        this.liveRegion.remove();
      },
      _setOption: function(key, value) {
        this._super(key, value);
        if (key === "source") {
          this._initSource();
        }
        if (key === "appendTo") {
          this.menu.element.appendTo(this._appendTo());
        }
        if (key === "disabled" && value && this.xhr) {
          this.xhr.abort();
        }
      },
      _appendTo: function() {
        var element = this.options.appendTo;
        if (element) {
          element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
        }
        if (!element || !element[0]) {
          element = this.element.closest(".ui-front");
        }
        if (!element.length) {
          element = this.document[0].body;
        }
        return element;
      },
      _initSource: function() {
        var array,
            url,
            that = this;
        if ($.isArray(this.options.source)) {
          array = this.options.source;
          this.source = function(request, response) {
            response($.ui.autocomplete.filter(array, request.term));
          };
        } else if (typeof this.options.source === "string") {
          url = this.options.source;
          this.source = function(request, response) {
            if (that.xhr) {
              that.xhr.abort();
            }
            that.xhr = $.ajax({
              url: url,
              data: request,
              dataType: "json",
              success: function(data) {
                response(data);
              },
              error: function() {
                response([]);
              }
            });
          };
        } else {
          this.source = this.options.source;
        }
      },
      _searchTimeout: function(event) {
        clearTimeout(this.searching);
        this.searching = this._delay(function() {
          var equalValues = this.term === this._value(),
              menuVisible = this.menu.element.is(":visible"),
              modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;
          if (!equalValues || (equalValues && !menuVisible && !modifierKey)) {
            this.selectedItem = null;
            this.search(null, event);
          }
        }, this.options.delay);
      },
      search: function(value, event) {
        value = value != null ? value : this._value();
        this.term = this._value();
        if (value.length < this.options.minLength) {
          return this.close(event);
        }
        if (this._trigger("search", event) === false) {
          return;
        }
        return this._search(value);
      },
      _search: function(value) {
        this.pending++;
        this.element.addClass("ui-autocomplete-loading");
        this.cancelSearch = false;
        this.source({term: value}, this._response());
      },
      _response: function() {
        var index = ++this.requestIndex;
        return $.proxy(function(content) {
          if (index === this.requestIndex) {
            this.__response(content);
          }
          this.pending--;
          if (!this.pending) {
            this.element.removeClass("ui-autocomplete-loading");
          }
        }, this);
      },
      __response: function(content) {
        if (content) {
          content = this._normalize(content);
        }
        this._trigger("response", null, {content: content});
        if (!this.options.disabled && content && content.length && !this.cancelSearch) {
          this._suggest(content);
          this._trigger("open");
        } else {
          this._close();
        }
      },
      close: function(event) {
        this.cancelSearch = true;
        this._close(event);
      },
      _close: function(event) {
        if (this.menu.element.is(":visible")) {
          this.menu.element.hide();
          this.menu.blur();
          this.isNewMenu = true;
          this._trigger("close", event);
        }
      },
      _change: function(event) {
        if (this.previous !== this._value()) {
          this._trigger("change", event, {item: this.selectedItem});
        }
      },
      _normalize: function(items) {
        if (items.length && items[0].label && items[0].value) {
          return items;
        }
        return $.map(items, function(item) {
          if (typeof item === "string") {
            return {
              label: item,
              value: item
            };
          }
          return $.extend({}, item, {
            label: item.label || item.value,
            value: item.value || item.label
          });
        });
      },
      _suggest: function(items) {
        var ul = this.menu.element.empty();
        this._renderMenu(ul, items);
        this.isNewMenu = true;
        this.menu.refresh();
        ul.show();
        this._resizeMenu();
        ul.position($.extend({of: this.element}, this.options.position));
        if (this.options.autoFocus) {
          this.menu.next();
        }
      },
      _resizeMenu: function() {
        var ul = this.menu.element;
        ul.outerWidth(Math.max(ul.width("").outerWidth() + 1, this.element.outerWidth()));
      },
      _renderMenu: function(ul, items) {
        var that = this;
        $.each(items, function(index, item) {
          that._renderItemData(ul, item);
        });
      },
      _renderItemData: function(ul, item) {
        return this._renderItem(ul, item).data("ui-autocomplete-item", item);
      },
      _renderItem: function(ul, item) {
        return $("<li>").text(item.label).appendTo(ul);
      },
      _move: function(direction, event) {
        if (!this.menu.element.is(":visible")) {
          this.search(null, event);
          return;
        }
        if (this.menu.isFirstItem() && /^previous/.test(direction) || this.menu.isLastItem() && /^next/.test(direction)) {
          if (!this.isMultiLine) {
            this._value(this.term);
          }
          this.menu.blur();
          return;
        }
        this.menu[direction](event);
      },
      widget: function() {
        return this.menu.element;
      },
      _value: function() {
        return this.valueMethod.apply(this.element, arguments);
      },
      _keyEvent: function(keyEvent, event) {
        if (!this.isMultiLine || this.menu.element.is(":visible")) {
          this._move(keyEvent, event);
          event.preventDefault();
        }
      }
    });
    $.extend($.ui.autocomplete, {
      escapeRegex: function(value) {
        return value.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&");
      },
      filter: function(array, term) {
        var matcher = new RegExp($.ui.autocomplete.escapeRegex(term), "i");
        return $.grep(array, function(value) {
          return matcher.test(value.label || value.value || value);
        });
      }
    });
    $.widget("ui.autocomplete", $.ui.autocomplete, {
      options: {messages: {
          noResults: "No search results.",
          results: function(amount) {
            return amount + (amount > 1 ? " results are" : " result is") + " available, use up and down arrow keys to navigate.";
          }
        }},
      __response: function(content) {
        var message;
        this._superApply(arguments);
        if (this.options.disabled || this.cancelSearch) {
          return;
        }
        if (content && content.length) {
          message = this.options.messages.results(content.length);
        } else {
          message = this.options.messages.noResults;
        }
        this.liveRegion.children().hide();
        $("<div>").text(message).appendTo(this.liveRegion);
      }
    });
    var autocomplete = $.ui.autocomplete;
    var lastActive,
        baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
        typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
        formResetHandler = function() {
          var form = $(this);
          setTimeout(function() {
            form.find(":ui-button").button("refresh");
          }, 1);
        },
        radioGroup = function(radio) {
          var name = radio.name,
              form = radio.form,
              radios = $([]);
          if (name) {
            name = name.replace(/'/g, "\\'");
            if (form) {
              radios = $(form).find("[name='" + name + "'][type=radio]");
            } else {
              radios = $("[name='" + name + "'][type=radio]", radio.ownerDocument).filter(function() {
                return !this.form;
              });
            }
          }
          return radios;
        };
    $.widget("ui.button", {
      version: "1.11.1",
      defaultElement: "<button>",
      options: {
        disabled: null,
        text: true,
        label: null,
        icons: {
          primary: null,
          secondary: null
        }
      },
      _create: function() {
        this.element.closest("form").unbind("reset" + this.eventNamespace).bind("reset" + this.eventNamespace, formResetHandler);
        if (typeof this.options.disabled !== "boolean") {
          this.options.disabled = !!this.element.prop("disabled");
        } else {
          this.element.prop("disabled", this.options.disabled);
        }
        this._determineButtonType();
        this.hasTitle = !!this.buttonElement.attr("title");
        var that = this,
            options = this.options,
            toggleButton = this.type === "checkbox" || this.type === "radio",
            activeClass = !toggleButton ? "ui-state-active" : "";
        if (options.label === null) {
          options.label = (this.type === "input" ? this.buttonElement.val() : this.buttonElement.html());
        }
        this._hoverable(this.buttonElement);
        this.buttonElement.addClass(baseClasses).attr("role", "button").bind("mouseenter" + this.eventNamespace, function() {
          if (options.disabled) {
            return;
          }
          if (this === lastActive) {
            $(this).addClass("ui-state-active");
          }
        }).bind("mouseleave" + this.eventNamespace, function() {
          if (options.disabled) {
            return;
          }
          $(this).removeClass(activeClass);
        }).bind("click" + this.eventNamespace, function(event) {
          if (options.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
          }
        });
        this._on({
          focus: function() {
            this.buttonElement.addClass("ui-state-focus");
          },
          blur: function() {
            this.buttonElement.removeClass("ui-state-focus");
          }
        });
        if (toggleButton) {
          this.element.bind("change" + this.eventNamespace, function() {
            that.refresh();
          });
        }
        if (this.type === "checkbox") {
          this.buttonElement.bind("click" + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
          });
        } else if (this.type === "radio") {
          this.buttonElement.bind("click" + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
            $(this).addClass("ui-state-active");
            that.buttonElement.attr("aria-pressed", "true");
            var radio = that.element[0];
            radioGroup(radio).not(radio).map(function() {
              return $(this).button("widget")[0];
            }).removeClass("ui-state-active").attr("aria-pressed", "false");
          });
        } else {
          this.buttonElement.bind("mousedown" + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
            $(this).addClass("ui-state-active");
            lastActive = this;
            that.document.one("mouseup", function() {
              lastActive = null;
            });
          }).bind("mouseup" + this.eventNamespace, function() {
            if (options.disabled) {
              return false;
            }
            $(this).removeClass("ui-state-active");
          }).bind("keydown" + this.eventNamespace, function(event) {
            if (options.disabled) {
              return false;
            }
            if (event.keyCode === $.ui.keyCode.SPACE || event.keyCode === $.ui.keyCode.ENTER) {
              $(this).addClass("ui-state-active");
            }
          }).bind("keyup" + this.eventNamespace + " blur" + this.eventNamespace, function() {
            $(this).removeClass("ui-state-active");
          });
          if (this.buttonElement.is("a")) {
            this.buttonElement.keyup(function(event) {
              if (event.keyCode === $.ui.keyCode.SPACE) {
                $(this).click();
              }
            });
          }
        }
        this._setOption("disabled", options.disabled);
        this._resetButton();
      },
      _determineButtonType: function() {
        var ancestor,
            labelSelector,
            checked;
        if (this.element.is("[type=checkbox]")) {
          this.type = "checkbox";
        } else if (this.element.is("[type=radio]")) {
          this.type = "radio";
        } else if (this.element.is("input")) {
          this.type = "input";
        } else {
          this.type = "button";
        }
        if (this.type === "checkbox" || this.type === "radio") {
          ancestor = this.element.parents().last();
          labelSelector = "label[for='" + this.element.attr("id") + "']";
          this.buttonElement = ancestor.find(labelSelector);
          if (!this.buttonElement.length) {
            ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
            this.buttonElement = ancestor.filter(labelSelector);
            if (!this.buttonElement.length) {
              this.buttonElement = ancestor.find(labelSelector);
            }
          }
          this.element.addClass("ui-helper-hidden-accessible");
          checked = this.element.is(":checked");
          if (checked) {
            this.buttonElement.addClass("ui-state-active");
          }
          this.buttonElement.prop("aria-pressed", checked);
        } else {
          this.buttonElement = this.element;
        }
      },
      widget: function() {
        return this.buttonElement;
      },
      _destroy: function() {
        this.element.removeClass("ui-helper-hidden-accessible");
        this.buttonElement.removeClass(baseClasses + " ui-state-active " + typeClasses).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html());
        if (!this.hasTitle) {
          this.buttonElement.removeAttr("title");
        }
      },
      _setOption: function(key, value) {
        this._super(key, value);
        if (key === "disabled") {
          this.widget().toggleClass("ui-state-disabled", !!value);
          this.element.prop("disabled", !!value);
          if (value) {
            if (this.type === "checkbox" || this.type === "radio") {
              this.buttonElement.removeClass("ui-state-focus");
            } else {
              this.buttonElement.removeClass("ui-state-focus ui-state-active");
            }
          }
          return;
        }
        this._resetButton();
      },
      refresh: function() {
        var isDisabled = this.element.is("input, button") ? this.element.is(":disabled") : this.element.hasClass("ui-button-disabled");
        if (isDisabled !== this.options.disabled) {
          this._setOption("disabled", isDisabled);
        }
        if (this.type === "radio") {
          radioGroup(this.element[0]).each(function() {
            if ($(this).is(":checked")) {
              $(this).button("widget").addClass("ui-state-active").attr("aria-pressed", "true");
            } else {
              $(this).button("widget").removeClass("ui-state-active").attr("aria-pressed", "false");
            }
          });
        } else if (this.type === "checkbox") {
          if (this.element.is(":checked")) {
            this.buttonElement.addClass("ui-state-active").attr("aria-pressed", "true");
          } else {
            this.buttonElement.removeClass("ui-state-active").attr("aria-pressed", "false");
          }
        }
      },
      _resetButton: function() {
        if (this.type === "input") {
          if (this.options.label) {
            this.element.val(this.options.label);
          }
          return;
        }
        var buttonElement = this.buttonElement.removeClass(typeClasses),
            buttonText = $("<span></span>", this.document[0]).addClass("ui-button-text").html(this.options.label).appendTo(buttonElement.empty()).text(),
            icons = this.options.icons,
            multipleIcons = icons.primary && icons.secondary,
            buttonClasses = [];
        if (icons.primary || icons.secondary) {
          if (this.options.text) {
            buttonClasses.push("ui-button-text-icon" + (multipleIcons ? "s" : (icons.primary ? "-primary" : "-secondary")));
          }
          if (icons.primary) {
            buttonElement.prepend("<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>");
          }
          if (icons.secondary) {
            buttonElement.append("<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>");
          }
          if (!this.options.text) {
            buttonClasses.push(multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only");
            if (!this.hasTitle) {
              buttonElement.attr("title", $.trim(buttonText));
            }
          }
        } else {
          buttonClasses.push("ui-button-text-only");
        }
        buttonElement.addClass(buttonClasses.join(" "));
      }
    });
    $.widget("ui.buttonset", {
      version: "1.11.1",
      options: {items: "button, input[type=button], input[type=submit], input[type=reset], input[type=checkbox], input[type=radio], a, :data(ui-button)"},
      _create: function() {
        this.element.addClass("ui-buttonset");
      },
      _init: function() {
        this.refresh();
      },
      _setOption: function(key, value) {
        if (key === "disabled") {
          this.buttons.button("option", key, value);
        }
        this._super(key, value);
      },
      refresh: function() {
        var rtl = this.element.css("direction") === "rtl",
            allButtons = this.element.find(this.options.items),
            existingButtons = allButtons.filter(":ui-button");
        allButtons.not(":ui-button").button();
        existingButtons.button("refresh");
        this.buttons = allButtons.map(function() {
          return $(this).button("widget")[0];
        }).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(rtl ? "ui-corner-right" : "ui-corner-left").end().filter(":last").addClass(rtl ? "ui-corner-left" : "ui-corner-right").end().end();
      },
      _destroy: function() {
        this.element.removeClass("ui-buttonset");
        this.buttons.map(function() {
          return $(this).button("widget")[0];
        }).removeClass("ui-corner-left ui-corner-right").end().button("destroy");
      }
    });
    var button = $.ui.button;
    $.extend($.ui, {datepicker: {version: "1.11.1"}});
    var datepicker_instActive;
    function datepicker_getZindex(elem) {
      var position,
          value;
      while (elem.length && elem[0] !== document) {
        position = elem.css("position");
        if (position === "absolute" || position === "relative" || position === "fixed") {
          value = parseInt(elem.css("zIndex"), 10);
          if (!isNaN(value) && value !== 0) {
            return value;
          }
        }
        elem = elem.parent();
      }
      return 0;
    }
    function Datepicker() {
      this._curInst = null;
      this._keyEvent = false;
      this._disabledInputs = [];
      this._datepickerShowing = false;
      this._inDialog = false;
      this._mainDivId = "ui-datepicker-div";
      this._inlineClass = "ui-datepicker-inline";
      this._appendClass = "ui-datepicker-append";
      this._triggerClass = "ui-datepicker-trigger";
      this._dialogClass = "ui-datepicker-dialog";
      this._disableClass = "ui-datepicker-disabled";
      this._unselectableClass = "ui-datepicker-unselectable";
      this._currentClass = "ui-datepicker-current-day";
      this._dayOverClass = "ui-datepicker-days-cell-over";
      this.regional = [];
      this.regional[""] = {
        closeText: "Done",
        prevText: "Prev",
        nextText: "Next",
        currentText: "Today",
        monthNames: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
        monthNamesShort: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
        dayNames: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
        dayNamesShort: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        dayNamesMin: ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"],
        weekHeader: "Wk",
        dateFormat: "mm/dd/yy",
        firstDay: 0,
        isRTL: false,
        showMonthAfterYear: false,
        yearSuffix: ""
      };
      this._defaults = {
        showOn: "focus",
        showAnim: "fadeIn",
        showOptions: {},
        defaultDate: null,
        appendText: "",
        buttonText: "...",
        buttonImage: "",
        buttonImageOnly: false,
        hideIfNoPrevNext: false,
        navigationAsDateFormat: false,
        gotoCurrent: false,
        changeMonth: false,
        changeYear: false,
        yearRange: "c-10:c+10",
        showOtherMonths: false,
        selectOtherMonths: false,
        showWeek: false,
        calculateWeek: this.iso8601Week,
        shortYearCutoff: "+10",
        minDate: null,
        maxDate: null,
        duration: "fast",
        beforeShowDay: null,
        beforeShow: null,
        onSelect: null,
        onChangeMonthYear: null,
        onClose: null,
        numberOfMonths: 1,
        showCurrentAtPos: 0,
        stepMonths: 1,
        stepBigMonths: 12,
        altField: "",
        altFormat: "",
        constrainInput: true,
        showButtonPanel: false,
        autoSize: false,
        disabled: false
      };
      $.extend(this._defaults, this.regional[""]);
      this.regional.en = $.extend(true, {}, this.regional[""]);
      this.regional["en-US"] = $.extend(true, {}, this.regional.en);
      this.dpDiv = datepicker_bindHover($("<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"));
    }
    $.extend(Datepicker.prototype, {
      markerClassName: "hasDatepicker",
      maxRows: 4,
      _widgetDatepicker: function() {
        return this.dpDiv;
      },
      setDefaults: function(settings) {
        datepicker_extendRemove(this._defaults, settings || {});
        return this;
      },
      _attachDatepicker: function(target, settings) {
        var nodeName,
            inline,
            inst;
        nodeName = target.nodeName.toLowerCase();
        inline = (nodeName === "div" || nodeName === "span");
        if (!target.id) {
          this.uuid += 1;
          target.id = "dp" + this.uuid;
        }
        inst = this._newInst($(target), inline);
        inst.settings = $.extend({}, settings || {});
        if (nodeName === "input") {
          this._connectDatepicker(target, inst);
        } else if (inline) {
          this._inlineDatepicker(target, inst);
        }
      },
      _newInst: function(target, inline) {
        var id = target[0].id.replace(/([^A-Za-z0-9_\-])/g, "\\\\$1");
        return {
          id: id,
          input: target,
          selectedDay: 0,
          selectedMonth: 0,
          selectedYear: 0,
          drawMonth: 0,
          drawYear: 0,
          inline: inline,
          dpDiv: (!inline ? this.dpDiv : datepicker_bindHover($("<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")))
        };
      },
      _connectDatepicker: function(target, inst) {
        var input = $(target);
        inst.append = $([]);
        inst.trigger = $([]);
        if (input.hasClass(this.markerClassName)) {
          return;
        }
        this._attachments(input, inst);
        input.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp);
        this._autoSize(inst);
        $.data(target, "datepicker", inst);
        if (inst.settings.disabled) {
          this._disableDatepicker(target);
        }
      },
      _attachments: function(input, inst) {
        var showOn,
            buttonText,
            buttonImage,
            appendText = this._get(inst, "appendText"),
            isRTL = this._get(inst, "isRTL");
        if (inst.append) {
          inst.append.remove();
        }
        if (appendText) {
          inst.append = $("<span class='" + this._appendClass + "'>" + appendText + "</span>");
          input[isRTL ? "before" : "after"](inst.append);
        }
        input.unbind("focus", this._showDatepicker);
        if (inst.trigger) {
          inst.trigger.remove();
        }
        showOn = this._get(inst, "showOn");
        if (showOn === "focus" || showOn === "both") {
          input.focus(this._showDatepicker);
        }
        if (showOn === "button" || showOn === "both") {
          buttonText = this._get(inst, "buttonText");
          buttonImage = this._get(inst, "buttonImage");
          inst.trigger = $(this._get(inst, "buttonImageOnly") ? $("<img/>").addClass(this._triggerClass).attr({
            src: buttonImage,
            alt: buttonText,
            title: buttonText
          }) : $("<button type='button'></button>").addClass(this._triggerClass).html(!buttonImage ? buttonText : $("<img/>").attr({
            src: buttonImage,
            alt: buttonText,
            title: buttonText
          })));
          input[isRTL ? "before" : "after"](inst.trigger);
          inst.trigger.click(function() {
            if ($.datepicker._datepickerShowing && $.datepicker._lastInput === input[0]) {
              $.datepicker._hideDatepicker();
            } else if ($.datepicker._datepickerShowing && $.datepicker._lastInput !== input[0]) {
              $.datepicker._hideDatepicker();
              $.datepicker._showDatepicker(input[0]);
            } else {
              $.datepicker._showDatepicker(input[0]);
            }
            return false;
          });
        }
      },
      _autoSize: function(inst) {
        if (this._get(inst, "autoSize") && !inst.inline) {
          var findMax,
              max,
              maxI,
              i,
              date = new Date(2009, 12 - 1, 20),
              dateFormat = this._get(inst, "dateFormat");
          if (dateFormat.match(/[DM]/)) {
            findMax = function(names) {
              max = 0;
              maxI = 0;
              for (i = 0; i < names.length; i++) {
                if (names[i].length > max) {
                  max = names[i].length;
                  maxI = i;
                }
              }
              return maxI;
            };
            date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ? "monthNames" : "monthNamesShort"))));
            date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ? "dayNames" : "dayNamesShort"))) + 20 - date.getDay());
          }
          inst.input.attr("size", this._formatDate(inst, date).length);
        }
      },
      _inlineDatepicker: function(target, inst) {
        var divSpan = $(target);
        if (divSpan.hasClass(this.markerClassName)) {
          return;
        }
        divSpan.addClass(this.markerClassName).append(inst.dpDiv);
        $.data(target, "datepicker", inst);
        this._setDate(inst, this._getDefaultDate(inst), true);
        this._updateDatepicker(inst);
        this._updateAlternate(inst);
        if (inst.settings.disabled) {
          this._disableDatepicker(target);
        }
        inst.dpDiv.css("display", "block");
      },
      _dialogDatepicker: function(input, date, onSelect, settings, pos) {
        var id,
            browserWidth,
            browserHeight,
            scrollX,
            scrollY,
            inst = this._dialogInst;
        if (!inst) {
          this.uuid += 1;
          id = "dp" + this.uuid;
          this._dialogInput = $("<input type='text' id='" + id + "' style='position: absolute; top: -100px; width: 0px;'/>");
          this._dialogInput.keydown(this._doKeyDown);
          $("body").append(this._dialogInput);
          inst = this._dialogInst = this._newInst(this._dialogInput, false);
          inst.settings = {};
          $.data(this._dialogInput[0], "datepicker", inst);
        }
        datepicker_extendRemove(inst.settings, settings || {});
        date = (date && date.constructor === Date ? this._formatDate(inst, date) : date);
        this._dialogInput.val(date);
        this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
        if (!this._pos) {
          browserWidth = document.documentElement.clientWidth;
          browserHeight = document.documentElement.clientHeight;
          scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
          scrollY = document.documentElement.scrollTop || document.body.scrollTop;
          this._pos = [(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
        }
        this._dialogInput.css("left", (this._pos[0] + 20) + "px").css("top", this._pos[1] + "px");
        inst.settings.onSelect = onSelect;
        this._inDialog = true;
        this.dpDiv.addClass(this._dialogClass);
        this._showDatepicker(this._dialogInput[0]);
        if ($.blockUI) {
          $.blockUI(this.dpDiv);
        }
        $.data(this._dialogInput[0], "datepicker", inst);
        return this;
      },
      _destroyDatepicker: function(target) {
        var nodeName,
            $target = $(target),
            inst = $.data(target, "datepicker");
        if (!$target.hasClass(this.markerClassName)) {
          return;
        }
        nodeName = target.nodeName.toLowerCase();
        $.removeData(target, "datepicker");
        if (nodeName === "input") {
          inst.append.remove();
          inst.trigger.remove();
          $target.removeClass(this.markerClassName).unbind("focus", this._showDatepicker).unbind("keydown", this._doKeyDown).unbind("keypress", this._doKeyPress).unbind("keyup", this._doKeyUp);
        } else if (nodeName === "div" || nodeName === "span") {
          $target.removeClass(this.markerClassName).empty();
        }
      },
      _enableDatepicker: function(target) {
        var nodeName,
            inline,
            $target = $(target),
            inst = $.data(target, "datepicker");
        if (!$target.hasClass(this.markerClassName)) {
          return;
        }
        nodeName = target.nodeName.toLowerCase();
        if (nodeName === "input") {
          target.disabled = false;
          inst.trigger.filter("button").each(function() {
            this.disabled = false;
          }).end().filter("img").css({
            opacity: "1.0",
            cursor: ""
          });
        } else if (nodeName === "div" || nodeName === "span") {
          inline = $target.children("." + this._inlineClass);
          inline.children().removeClass("ui-state-disabled");
          inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", false);
        }
        this._disabledInputs = $.map(this._disabledInputs, function(value) {
          return (value === target ? null : value);
        });
      },
      _disableDatepicker: function(target) {
        var nodeName,
            inline,
            $target = $(target),
            inst = $.data(target, "datepicker");
        if (!$target.hasClass(this.markerClassName)) {
          return;
        }
        nodeName = target.nodeName.toLowerCase();
        if (nodeName === "input") {
          target.disabled = true;
          inst.trigger.filter("button").each(function() {
            this.disabled = true;
          }).end().filter("img").css({
            opacity: "0.5",
            cursor: "default"
          });
        } else if (nodeName === "div" || nodeName === "span") {
          inline = $target.children("." + this._inlineClass);
          inline.children().addClass("ui-state-disabled");
          inline.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled", true);
        }
        this._disabledInputs = $.map(this._disabledInputs, function(value) {
          return (value === target ? null : value);
        });
        this._disabledInputs[this._disabledInputs.length] = target;
      },
      _isDisabledDatepicker: function(target) {
        if (!target) {
          return false;
        }
        for (var i = 0; i < this._disabledInputs.length; i++) {
          if (this._disabledInputs[i] === target) {
            return true;
          }
        }
        return false;
      },
      _getInst: function(target) {
        try {
          return $.data(target, "datepicker");
        } catch (err) {
          throw "Missing instance data for this datepicker";
        }
      },
      _optionDatepicker: function(target, name, value) {
        var settings,
            date,
            minDate,
            maxDate,
            inst = this._getInst(target);
        if (arguments.length === 2 && typeof name === "string") {
          return (name === "defaults" ? $.extend({}, $.datepicker._defaults) : (inst ? (name === "all" ? $.extend({}, inst.settings) : this._get(inst, name)) : null));
        }
        settings = name || {};
        if (typeof name === "string") {
          settings = {};
          settings[name] = value;
        }
        if (inst) {
          if (this._curInst === inst) {
            this._hideDatepicker();
          }
          date = this._getDateDatepicker(target, true);
          minDate = this._getMinMaxDate(inst, "min");
          maxDate = this._getMinMaxDate(inst, "max");
          datepicker_extendRemove(inst.settings, settings);
          if (minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined) {
            inst.settings.minDate = this._formatDate(inst, minDate);
          }
          if (maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined) {
            inst.settings.maxDate = this._formatDate(inst, maxDate);
          }
          if ("disabled" in settings) {
            if (settings.disabled) {
              this._disableDatepicker(target);
            } else {
              this._enableDatepicker(target);
            }
          }
          this._attachments($(target), inst);
          this._autoSize(inst);
          this._setDate(inst, date);
          this._updateAlternate(inst);
          this._updateDatepicker(inst);
        }
      },
      _changeDatepicker: function(target, name, value) {
        this._optionDatepicker(target, name, value);
      },
      _refreshDatepicker: function(target) {
        var inst = this._getInst(target);
        if (inst) {
          this._updateDatepicker(inst);
        }
      },
      _setDateDatepicker: function(target, date) {
        var inst = this._getInst(target);
        if (inst) {
          this._setDate(inst, date);
          this._updateDatepicker(inst);
          this._updateAlternate(inst);
        }
      },
      _getDateDatepicker: function(target, noDefault) {
        var inst = this._getInst(target);
        if (inst && !inst.inline) {
          this._setDateFromField(inst, noDefault);
        }
        return (inst ? this._getDate(inst) : null);
      },
      _doKeyDown: function(event) {
        var onSelect,
            dateStr,
            sel,
            inst = $.datepicker._getInst(event.target),
            handled = true,
            isRTL = inst.dpDiv.is(".ui-datepicker-rtl");
        inst._keyEvent = true;
        if ($.datepicker._datepickerShowing) {
          switch (event.keyCode) {
            case 9:
              $.datepicker._hideDatepicker();
              handled = false;
              break;
            case 13:
              sel = $("td." + $.datepicker._dayOverClass + ":not(." + $.datepicker._currentClass + ")", inst.dpDiv);
              if (sel[0]) {
                $.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
              }
              onSelect = $.datepicker._get(inst, "onSelect");
              if (onSelect) {
                dateStr = $.datepicker._formatDate(inst);
                onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
              } else {
                $.datepicker._hideDatepicker();
              }
              return false;
            case 27:
              $.datepicker._hideDatepicker();
              break;
            case 33:
              $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths")), "M");
              break;
            case 34:
              $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths")), "M");
              break;
            case 35:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._clearDate(event.target);
              }
              handled = event.ctrlKey || event.metaKey;
              break;
            case 36:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._gotoToday(event.target);
              }
              handled = event.ctrlKey || event.metaKey;
              break;
            case 37:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), "D");
              }
              handled = event.ctrlKey || event.metaKey;
              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, (event.ctrlKey ? -$.datepicker._get(inst, "stepBigMonths") : -$.datepicker._get(inst, "stepMonths")), "M");
              }
              break;
            case 38:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, -7, "D");
              }
              handled = event.ctrlKey || event.metaKey;
              break;
            case 39:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), "D");
              }
              handled = event.ctrlKey || event.metaKey;
              if (event.originalEvent.altKey) {
                $.datepicker._adjustDate(event.target, (event.ctrlKey ? +$.datepicker._get(inst, "stepBigMonths") : +$.datepicker._get(inst, "stepMonths")), "M");
              }
              break;
            case 40:
              if (event.ctrlKey || event.metaKey) {
                $.datepicker._adjustDate(event.target, +7, "D");
              }
              handled = event.ctrlKey || event.metaKey;
              break;
            default:
              handled = false;
          }
        } else if (event.keyCode === 36 && event.ctrlKey) {
          $.datepicker._showDatepicker(this);
        } else {
          handled = false;
        }
        if (handled) {
          event.preventDefault();
          event.stopPropagation();
        }
      },
      _doKeyPress: function(event) {
        var chars,
            chr,
            inst = $.datepicker._getInst(event.target);
        if ($.datepicker._get(inst, "constrainInput")) {
          chars = $.datepicker._possibleChars($.datepicker._get(inst, "dateFormat"));
          chr = String.fromCharCode(event.charCode == null ? event.keyCode : event.charCode);
          return event.ctrlKey || event.metaKey || (chr < " " || !chars || chars.indexOf(chr) > -1);
        }
      },
      _doKeyUp: function(event) {
        var date,
            inst = $.datepicker._getInst(event.target);
        if (inst.input.val() !== inst.lastVal) {
          try {
            date = $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), (inst.input ? inst.input.val() : null), $.datepicker._getFormatConfig(inst));
            if (date) {
              $.datepicker._setDateFromField(inst);
              $.datepicker._updateAlternate(inst);
              $.datepicker._updateDatepicker(inst);
            }
          } catch (err) {}
        }
        return true;
      },
      _showDatepicker: function(input) {
        input = input.target || input;
        if (input.nodeName.toLowerCase() !== "input") {
          input = $("input", input.parentNode)[0];
        }
        if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput === input) {
          return;
        }
        var inst,
            beforeShow,
            beforeShowSettings,
            isFixed,
            offset,
            showAnim,
            duration;
        inst = $.datepicker._getInst(input);
        if ($.datepicker._curInst && $.datepicker._curInst !== inst) {
          $.datepicker._curInst.dpDiv.stop(true, true);
          if (inst && $.datepicker._datepickerShowing) {
            $.datepicker._hideDatepicker($.datepicker._curInst.input[0]);
          }
        }
        beforeShow = $.datepicker._get(inst, "beforeShow");
        beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
        if (beforeShowSettings === false) {
          return;
        }
        datepicker_extendRemove(inst.settings, beforeShowSettings);
        inst.lastVal = null;
        $.datepicker._lastInput = input;
        $.datepicker._setDateFromField(inst);
        if ($.datepicker._inDialog) {
          input.value = "";
        }
        if (!$.datepicker._pos) {
          $.datepicker._pos = $.datepicker._findPos(input);
          $.datepicker._pos[1] += input.offsetHeight;
        }
        isFixed = false;
        $(input).parents().each(function() {
          isFixed |= $(this).css("position") === "fixed";
          return !isFixed;
        });
        offset = {
          left: $.datepicker._pos[0],
          top: $.datepicker._pos[1]
        };
        $.datepicker._pos = null;
        inst.dpDiv.empty();
        inst.dpDiv.css({
          position: "absolute",
          display: "block",
          top: "-1000px"
        });
        $.datepicker._updateDatepicker(inst);
        offset = $.datepicker._checkOffset(inst, offset, isFixed);
        inst.dpDiv.css({
          position: ($.datepicker._inDialog && $.blockUI ? "static" : (isFixed ? "fixed" : "absolute")),
          display: "none",
          left: offset.left + "px",
          top: offset.top + "px"
        });
        if (!inst.inline) {
          showAnim = $.datepicker._get(inst, "showAnim");
          duration = $.datepicker._get(inst, "duration");
          inst.dpDiv.css("z-index", datepicker_getZindex($(input)) + 1);
          $.datepicker._datepickerShowing = true;
          if ($.effects && $.effects.effect[showAnim]) {
            inst.dpDiv.show(showAnim, $.datepicker._get(inst, "showOptions"), duration);
          } else {
            inst.dpDiv[showAnim || "show"](showAnim ? duration : null);
          }
          if ($.datepicker._shouldFocusInput(inst)) {
            inst.input.focus();
          }
          $.datepicker._curInst = inst;
        }
      },
      _updateDatepicker: function(inst) {
        this.maxRows = 4;
        datepicker_instActive = inst;
        inst.dpDiv.empty().append(this._generateHTML(inst));
        this._attachHandlers(inst);
        var origyearshtml,
            numMonths = this._getNumberOfMonths(inst),
            cols = numMonths[1],
            width = 17,
            activeCell = inst.dpDiv.find("." + this._dayOverClass + " a");
        if (activeCell.length > 0) {
          datepicker_handleMouseover.apply(activeCell.get(0));
        }
        inst.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width("");
        if (cols > 1) {
          inst.dpDiv.addClass("ui-datepicker-multi-" + cols).css("width", (width * cols) + "em");
        }
        inst.dpDiv[(numMonths[0] !== 1 || numMonths[1] !== 1 ? "add" : "remove") + "Class"]("ui-datepicker-multi");
        inst.dpDiv[(this._get(inst, "isRTL") ? "add" : "remove") + "Class"]("ui-datepicker-rtl");
        if (inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput(inst)) {
          inst.input.focus();
        }
        if (inst.yearshtml) {
          origyearshtml = inst.yearshtml;
          setTimeout(function() {
            if (origyearshtml === inst.yearshtml && inst.yearshtml) {
              inst.dpDiv.find("select.ui-datepicker-year:first").replaceWith(inst.yearshtml);
            }
            origyearshtml = inst.yearshtml = null;
          }, 0);
        }
      },
      _shouldFocusInput: function(inst) {
        return inst.input && inst.input.is(":visible") && !inst.input.is(":disabled") && !inst.input.is(":focus");
      },
      _checkOffset: function(inst, offset, isFixed) {
        var dpWidth = inst.dpDiv.outerWidth(),
            dpHeight = inst.dpDiv.outerHeight(),
            inputWidth = inst.input ? inst.input.outerWidth() : 0,
            inputHeight = inst.input ? inst.input.outerHeight() : 0,
            viewWidth = document.documentElement.clientWidth + (isFixed ? 0 : $(document).scrollLeft()),
            viewHeight = document.documentElement.clientHeight + (isFixed ? 0 : $(document).scrollTop());
        offset.left -= (this._get(inst, "isRTL") ? (dpWidth - inputWidth) : 0);
        offset.left -= (isFixed && offset.left === inst.input.offset().left) ? $(document).scrollLeft() : 0;
        offset.top -= (isFixed && offset.top === (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;
        offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ? Math.abs(offset.left + dpWidth - viewWidth) : 0);
        offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ? Math.abs(dpHeight + inputHeight) : 0);
        return offset;
      },
      _findPos: function(obj) {
        var position,
            inst = this._getInst(obj),
            isRTL = this._get(inst, "isRTL");
        while (obj && (obj.type === "hidden" || obj.nodeType !== 1 || $.expr.filters.hidden(obj))) {
          obj = obj[isRTL ? "previousSibling" : "nextSibling"];
        }
        position = $(obj).offset();
        return [position.left, position.top];
      },
      _hideDatepicker: function(input) {
        var showAnim,
            duration,
            postProcess,
            onClose,
            inst = this._curInst;
        if (!inst || (input && inst !== $.data(input, "datepicker"))) {
          return;
        }
        if (this._datepickerShowing) {
          showAnim = this._get(inst, "showAnim");
          duration = this._get(inst, "duration");
          postProcess = function() {
            $.datepicker._tidyDialog(inst);
          };
          if ($.effects && ($.effects.effect[showAnim] || $.effects[showAnim])) {
            inst.dpDiv.hide(showAnim, $.datepicker._get(inst, "showOptions"), duration, postProcess);
          } else {
            inst.dpDiv[(showAnim === "slideDown" ? "slideUp" : (showAnim === "fadeIn" ? "fadeOut" : "hide"))]((showAnim ? duration : null), postProcess);
          }
          if (!showAnim) {
            postProcess();
          }
          this._datepickerShowing = false;
          onClose = this._get(inst, "onClose");
          if (onClose) {
            onClose.apply((inst.input ? inst.input[0] : null), [(inst.input ? inst.input.val() : ""), inst]);
          }
          this._lastInput = null;
          if (this._inDialog) {
            this._dialogInput.css({
              position: "absolute",
              left: "0",
              top: "-100px"
            });
            if ($.blockUI) {
              $.unblockUI();
              $("body").append(this.dpDiv);
            }
          }
          this._inDialog = false;
        }
      },
      _tidyDialog: function(inst) {
        inst.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar");
      },
      _checkExternalClick: function(event) {
        if (!$.datepicker._curInst) {
          return;
        }
        var $target = $(event.target),
            inst = $.datepicker._getInst($target[0]);
        if ((($target[0].id !== $.datepicker._mainDivId && $target.parents("#" + $.datepicker._mainDivId).length === 0 && !$target.hasClass($.datepicker.markerClassName) && !$target.closest("." + $.datepicker._triggerClass).length && $.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI))) || ($target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst !== inst)) {
          $.datepicker._hideDatepicker();
        }
      },
      _adjustDate: function(id, offset, period) {
        var target = $(id),
            inst = this._getInst(target[0]);
        if (this._isDisabledDatepicker(target[0])) {
          return;
        }
        this._adjustInstDate(inst, offset + (period === "M" ? this._get(inst, "showCurrentAtPos") : 0), period);
        this._updateDatepicker(inst);
      },
      _gotoToday: function(id) {
        var date,
            target = $(id),
            inst = this._getInst(target[0]);
        if (this._get(inst, "gotoCurrent") && inst.currentDay) {
          inst.selectedDay = inst.currentDay;
          inst.drawMonth = inst.selectedMonth = inst.currentMonth;
          inst.drawYear = inst.selectedYear = inst.currentYear;
        } else {
          date = new Date();
          inst.selectedDay = date.getDate();
          inst.drawMonth = inst.selectedMonth = date.getMonth();
          inst.drawYear = inst.selectedYear = date.getFullYear();
        }
        this._notifyChange(inst);
        this._adjustDate(target);
      },
      _selectMonthYear: function(id, select, period) {
        var target = $(id),
            inst = this._getInst(target[0]);
        inst["selected" + (period === "M" ? "Month" : "Year")] = inst["draw" + (period === "M" ? "Month" : "Year")] = parseInt(select.options[select.selectedIndex].value, 10);
        this._notifyChange(inst);
        this._adjustDate(target);
      },
      _selectDay: function(id, month, year, td) {
        var inst,
            target = $(id);
        if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
          return;
        }
        inst = this._getInst(target[0]);
        inst.selectedDay = inst.currentDay = $("a", td).html();
        inst.selectedMonth = inst.currentMonth = month;
        inst.selectedYear = inst.currentYear = year;
        this._selectDate(id, this._formatDate(inst, inst.currentDay, inst.currentMonth, inst.currentYear));
      },
      _clearDate: function(id) {
        var target = $(id);
        this._selectDate(target, "");
      },
      _selectDate: function(id, dateStr) {
        var onSelect,
            target = $(id),
            inst = this._getInst(target[0]);
        dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
        if (inst.input) {
          inst.input.val(dateStr);
        }
        this._updateAlternate(inst);
        onSelect = this._get(inst, "onSelect");
        if (onSelect) {
          onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
        } else if (inst.input) {
          inst.input.trigger("change");
        }
        if (inst.inline) {
          this._updateDatepicker(inst);
        } else {
          this._hideDatepicker();
          this._lastInput = inst.input[0];
          if (typeof(inst.input[0]) !== "object") {
            inst.input.focus();
          }
          this._lastInput = null;
        }
      },
      _updateAlternate: function(inst) {
        var altFormat,
            date,
            dateStr,
            altField = this._get(inst, "altField");
        if (altField) {
          altFormat = this._get(inst, "altFormat") || this._get(inst, "dateFormat");
          date = this._getDate(inst);
          dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
          $(altField).each(function() {
            $(this).val(dateStr);
          });
        }
      },
      noWeekends: function(date) {
        var day = date.getDay();
        return [(day > 0 && day < 6), ""];
      },
      iso8601Week: function(date) {
        var time,
            checkDate = new Date(date.getTime());
        checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
        time = checkDate.getTime();
        checkDate.setMonth(0);
        checkDate.setDate(1);
        return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
      },
      parseDate: function(format, value, settings) {
        if (format == null || value == null) {
          throw "Invalid arguments";
        }
        value = (typeof value === "object" ? value.toString() : value + "");
        if (value === "") {
          return null;
        }
        var iFormat,
            dim,
            extra,
            iValue = 0,
            shortYearCutoffTemp = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff,
            shortYearCutoff = (typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp : new Date().getFullYear() % 100 + parseInt(shortYearCutoffTemp, 10)),
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            year = -1,
            month = -1,
            day = -1,
            doy = -1,
            literal = false,
            date,
            lookAhead = function(match) {
              var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
              if (matches) {
                iFormat++;
              }
              return matches;
            },
            getNumber = function(match) {
              var isDoubled = lookAhead(match),
                  size = (match === "@" ? 14 : (match === "!" ? 20 : (match === "y" && isDoubled ? 4 : (match === "o" ? 3 : 2)))),
                  minSize = (match === "y" ? size : 1),
                  digits = new RegExp("^\\d{" + minSize + "," + size + "}"),
                  num = value.substring(iValue).match(digits);
              if (!num) {
                throw "Missing number at position " + iValue;
              }
              iValue += num[0].length;
              return parseInt(num[0], 10);
            },
            getName = function(match, shortNames, longNames) {
              var index = -1,
                  names = $.map(lookAhead(match) ? longNames : shortNames, function(v, k) {
                    return [[k, v]];
                  }).sort(function(a, b) {
                    return -(a[1].length - b[1].length);
                  });
              $.each(names, function(i, pair) {
                var name = pair[1];
                if (value.substr(iValue, name.length).toLowerCase() === name.toLowerCase()) {
                  index = pair[0];
                  iValue += name.length;
                  return false;
                }
              });
              if (index !== -1) {
                return index + 1;
              } else {
                throw "Unknown name at position " + iValue;
              }
            },
            checkLiteral = function() {
              if (value.charAt(iValue) !== format.charAt(iFormat)) {
                throw "Unexpected literal at position " + iValue;
              }
              iValue++;
            };
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              checkLiteral();
            }
          } else {
            switch (format.charAt(iFormat)) {
              case "d":
                day = getNumber("d");
                break;
              case "D":
                getName("D", dayNamesShort, dayNames);
                break;
              case "o":
                doy = getNumber("o");
                break;
              case "m":
                month = getNumber("m");
                break;
              case "M":
                month = getName("M", monthNamesShort, monthNames);
                break;
              case "y":
                year = getNumber("y");
                break;
              case "@":
                date = new Date(getNumber("@"));
                year = date.getFullYear();
                month = date.getMonth() + 1;
                day = date.getDate();
                break;
              case "!":
                date = new Date((getNumber("!") - this._ticksTo1970) / 10000);
                year = date.getFullYear();
                month = date.getMonth() + 1;
                day = date.getDate();
                break;
              case "'":
                if (lookAhead("'")) {
                  checkLiteral();
                } else {
                  literal = true;
                }
                break;
              default:
                checkLiteral();
            }
          }
        }
        if (iValue < value.length) {
          extra = value.substr(iValue);
          if (!/^\s+/.test(extra)) {
            throw "Extra/unparsed characters found in date: " + extra;
          }
        }
        if (year === -1) {
          year = new Date().getFullYear();
        } else if (year < 100) {
          year += new Date().getFullYear() - new Date().getFullYear() % 100 + (year <= shortYearCutoff ? 0 : -100);
        }
        if (doy > -1) {
          month = 1;
          day = doy;
          do {
            dim = this._getDaysInMonth(year, month - 1);
            if (day <= dim) {
              break;
            }
            month++;
            day -= dim;
          } while (true);
        }
        date = this._daylightSavingAdjust(new Date(year, month - 1, day));
        if (date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day) {
          throw "Invalid date";
        }
        return date;
      },
      ATOM: "yy-mm-dd",
      COOKIE: "D, dd M yy",
      ISO_8601: "yy-mm-dd",
      RFC_822: "D, d M y",
      RFC_850: "DD, dd-M-y",
      RFC_1036: "D, d M y",
      RFC_1123: "D, d M yy",
      RFC_2822: "D, d M yy",
      RSS: "D, d M y",
      TICKS: "!",
      TIMESTAMP: "@",
      W3C: "yy-mm-dd",
      _ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) + Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),
      formatDate: function(format, date, settings) {
        if (!date) {
          return "";
        }
        var iFormat,
            dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort,
            dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames,
            monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort,
            monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames,
            lookAhead = function(match) {
              var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
              if (matches) {
                iFormat++;
              }
              return matches;
            },
            formatNumber = function(match, value, len) {
              var num = "" + value;
              if (lookAhead(match)) {
                while (num.length < len) {
                  num = "0" + num;
                }
              }
              return num;
            },
            formatName = function(match, value, shortNames, longNames) {
              return (lookAhead(match) ? longNames[value] : shortNames[value]);
            },
            output = "",
            literal = false;
        if (date) {
          for (iFormat = 0; iFormat < format.length; iFormat++) {
            if (literal) {
              if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
                literal = false;
              } else {
                output += format.charAt(iFormat);
              }
            } else {
              switch (format.charAt(iFormat)) {
                case "d":
                  output += formatNumber("d", date.getDate(), 2);
                  break;
                case "D":
                  output += formatName("D", date.getDay(), dayNamesShort, dayNames);
                  break;
                case "o":
                  output += formatNumber("o", Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
                  break;
                case "m":
                  output += formatNumber("m", date.getMonth() + 1, 2);
                  break;
                case "M":
                  output += formatName("M", date.getMonth(), monthNamesShort, monthNames);
                  break;
                case "y":
                  output += (lookAhead("y") ? date.getFullYear() : (date.getYear() % 100 < 10 ? "0" : "") + date.getYear() % 100);
                  break;
                case "@":
                  output += date.getTime();
                  break;
                case "!":
                  output += date.getTime() * 10000 + this._ticksTo1970;
                  break;
                case "'":
                  if (lookAhead("'")) {
                    output += "'";
                  } else {
                    literal = true;
                  }
                  break;
                default:
                  output += format.charAt(iFormat);
              }
            }
          }
        }
        return output;
      },
      _possibleChars: function(format) {
        var iFormat,
            chars = "",
            literal = false,
            lookAhead = function(match) {
              var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) === match);
              if (matches) {
                iFormat++;
              }
              return matches;
            };
        for (iFormat = 0; iFormat < format.length; iFormat++) {
          if (literal) {
            if (format.charAt(iFormat) === "'" && !lookAhead("'")) {
              literal = false;
            } else {
              chars += format.charAt(iFormat);
            }
          } else {
            switch (format.charAt(iFormat)) {
              case "d":
              case "m":
              case "y":
              case "@":
                chars += "0123456789";
                break;
              case "D":
              case "M":
                return null;
              case "'":
                if (lookAhead("'")) {
                  chars += "'";
                } else {
                  literal = true;
                }
                break;
              default:
                chars += format.charAt(iFormat);
            }
          }
        }
        return chars;
      },
      _get: function(inst, name) {
        return inst.settings[name] !== undefined ? inst.settings[name] : this._defaults[name];
      },
      _setDateFromField: function(inst, noDefault) {
        if (inst.input.val() === inst.lastVal) {
          return;
        }
        var dateFormat = this._get(inst, "dateFormat"),
            dates = inst.lastVal = inst.input ? inst.input.val() : null,
            defaultDate = this._getDefaultDate(inst),
            date = defaultDate,
            settings = this._getFormatConfig(inst);
        try {
          date = this.parseDate(dateFormat, dates, settings) || defaultDate;
        } catch (event) {
          dates = (noDefault ? "" : dates);
        }
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        inst.currentDay = (dates ? date.getDate() : 0);
        inst.currentMonth = (dates ? date.getMonth() : 0);
        inst.currentYear = (dates ? date.getFullYear() : 0);
        this._adjustInstDate(inst);
      },
      _getDefaultDate: function(inst) {
        return this._restrictMinMax(inst, this._determineDate(inst, this._get(inst, "defaultDate"), new Date()));
      },
      _determineDate: function(inst, date, defaultDate) {
        var offsetNumeric = function(offset) {
          var date = new Date();
          date.setDate(date.getDate() + offset);
          return date;
        },
            offsetString = function(offset) {
              try {
                return $.datepicker.parseDate($.datepicker._get(inst, "dateFormat"), offset, $.datepicker._getFormatConfig(inst));
              } catch (e) {}
              var date = (offset.toLowerCase().match(/^c/) ? $.datepicker._getDate(inst) : null) || new Date(),
                  year = date.getFullYear(),
                  month = date.getMonth(),
                  day = date.getDate(),
                  pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
                  matches = pattern.exec(offset);
              while (matches) {
                switch (matches[2] || "d") {
                  case "d":
                  case "D":
                    day += parseInt(matches[1], 10);
                    break;
                  case "w":
                  case "W":
                    day += parseInt(matches[1], 10) * 7;
                    break;
                  case "m":
                  case "M":
                    month += parseInt(matches[1], 10);
                    day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                    break;
                  case "y":
                  case "Y":
                    year += parseInt(matches[1], 10);
                    day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
                    break;
                }
                matches = pattern.exec(offset);
              }
              return new Date(year, month, day);
            },
            newDate = (date == null || date === "" ? defaultDate : (typeof date === "string" ? offsetString(date) : (typeof date === "number" ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
        newDate = (newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate);
        if (newDate) {
          newDate.setHours(0);
          newDate.setMinutes(0);
          newDate.setSeconds(0);
          newDate.setMilliseconds(0);
        }
        return this._daylightSavingAdjust(newDate);
      },
      _daylightSavingAdjust: function(date) {
        if (!date) {
          return null;
        }
        date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
        return date;
      },
      _setDate: function(inst, date, noChange) {
        var clear = !date,
            origMonth = inst.selectedMonth,
            origYear = inst.selectedYear,
            newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
        inst.selectedDay = inst.currentDay = newDate.getDate();
        inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
        inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
        if ((origMonth !== inst.selectedMonth || origYear !== inst.selectedYear) && !noChange) {
          this._notifyChange(inst);
        }
        this._adjustInstDate(inst);
        if (inst.input) {
          inst.input.val(clear ? "" : this._formatDate(inst));
        }
      },
      _getDate: function(inst) {
        var startDate = (!inst.currentYear || (inst.input && inst.input.val() === "") ? null : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
        return startDate;
      },
      _attachHandlers: function(inst) {
        var stepMonths = this._get(inst, "stepMonths"),
            id = "#" + inst.id.replace(/\\\\/g, "\\");
        inst.dpDiv.find("[data-handler]").map(function() {
          var handler = {
            prev: function() {
              $.datepicker._adjustDate(id, -stepMonths, "M");
            },
            next: function() {
              $.datepicker._adjustDate(id, +stepMonths, "M");
            },
            hide: function() {
              $.datepicker._hideDatepicker();
            },
            today: function() {
              $.datepicker._gotoToday(id);
            },
            selectDay: function() {
              $.datepicker._selectDay(id, +this.getAttribute("data-month"), +this.getAttribute("data-year"), this);
              return false;
            },
            selectMonth: function() {
              $.datepicker._selectMonthYear(id, this, "M");
              return false;
            },
            selectYear: function() {
              $.datepicker._selectMonthYear(id, this, "Y");
              return false;
            }
          };
          $(this).bind(this.getAttribute("data-event"), handler[this.getAttribute("data-handler")]);
        });
      },
      _generateHTML: function(inst) {
        var maxDraw,
            prevText,
            prev,
            nextText,
            next,
            currentText,
            gotoDate,
            controls,
            buttonPanel,
            firstDay,
            showWeek,
            dayNames,
            dayNamesMin,
            monthNames,
            monthNamesShort,
            beforeShowDay,
            showOtherMonths,
            selectOtherMonths,
            defaultDate,
            html,
            dow,
            row,
            group,
            col,
            selectedDate,
            cornerClass,
            calender,
            thead,
            day,
            daysInMonth,
            leadDays,
            curRows,
            numRows,
            printDate,
            dRow,
            tbody,
            daySettings,
            otherMonth,
            unselectable,
            tempDate = new Date(),
            today = this._daylightSavingAdjust(new Date(tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate())),
            isRTL = this._get(inst, "isRTL"),
            showButtonPanel = this._get(inst, "showButtonPanel"),
            hideIfNoPrevNext = this._get(inst, "hideIfNoPrevNext"),
            navigationAsDateFormat = this._get(inst, "navigationAsDateFormat"),
            numMonths = this._getNumberOfMonths(inst),
            showCurrentAtPos = this._get(inst, "showCurrentAtPos"),
            stepMonths = this._get(inst, "stepMonths"),
            isMultiMonth = (numMonths[0] !== 1 || numMonths[1] !== 1),
            currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) : new Date(inst.currentYear, inst.currentMonth, inst.currentDay))),
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            drawMonth = inst.drawMonth - showCurrentAtPos,
            drawYear = inst.drawYear;
        if (drawMonth < 0) {
          drawMonth += 12;
          drawYear--;
        }
        if (maxDate) {
          maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(), maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
          maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
          while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
            drawMonth--;
            if (drawMonth < 0) {
              drawMonth = 11;
              drawYear--;
            }
          }
        }
        inst.drawMonth = drawMonth;
        inst.drawYear = drawYear;
        prevText = this._get(inst, "prevText");
        prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText, this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)), this._getFormatConfig(inst)));
        prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ? "<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" + " title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>" : (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "e" : "w") + "'>" + prevText + "</span></a>"));
        nextText = this._get(inst, "nextText");
        nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText, this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)), this._getFormatConfig(inst)));
        next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ? "<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" + " title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>" : (hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + (isRTL ? "w" : "e") + "'>" + nextText + "</span></a>"));
        currentText = this._get(inst, "currentText");
        gotoDate = (this._get(inst, "gotoCurrent") && inst.currentDay ? currentDate : today);
        currentText = (!navigationAsDateFormat ? currentText : this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
        controls = (!inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" + this._get(inst, "closeText") + "</button>" : "");
        buttonPanel = (showButtonPanel) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + (isRTL ? controls : "") + (this._isInRange(inst, gotoDate) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" + ">" + currentText + "</button>" : "") + (isRTL ? "" : controls) + "</div>" : "";
        firstDay = parseInt(this._get(inst, "firstDay"), 10);
        firstDay = (isNaN(firstDay) ? 0 : firstDay);
        showWeek = this._get(inst, "showWeek");
        dayNames = this._get(inst, "dayNames");
        dayNamesMin = this._get(inst, "dayNamesMin");
        monthNames = this._get(inst, "monthNames");
        monthNamesShort = this._get(inst, "monthNamesShort");
        beforeShowDay = this._get(inst, "beforeShowDay");
        showOtherMonths = this._get(inst, "showOtherMonths");
        selectOtherMonths = this._get(inst, "selectOtherMonths");
        defaultDate = this._getDefaultDate(inst);
        html = "";
        dow;
        for (row = 0; row < numMonths[0]; row++) {
          group = "";
          this.maxRows = 4;
          for (col = 0; col < numMonths[1]; col++) {
            selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
            cornerClass = " ui-corner-all";
            calender = "";
            if (isMultiMonth) {
              calender += "<div class='ui-datepicker-group";
              if (numMonths[1] > 1) {
                switch (col) {
                  case 0:
                    calender += " ui-datepicker-group-first";
                    cornerClass = " ui-corner-" + (isRTL ? "right" : "left");
                    break;
                  case numMonths[1] - 1:
                    calender += " ui-datepicker-group-last";
                    cornerClass = " ui-corner-" + (isRTL ? "left" : "right");
                    break;
                  default:
                    calender += " ui-datepicker-group-middle";
                    cornerClass = "";
                    break;
                }
              }
              calender += "'>";
            }
            calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" + (/all|left/.test(cornerClass) && row === 0 ? (isRTL ? next : prev) : "") + (/all|right/.test(cornerClass) && row === 0 ? (isRTL ? prev : next) : "") + this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate, row > 0 || col > 0, monthNames, monthNamesShort) + "</div><table class='ui-datepicker-calendar'><thead>" + "<tr>";
            thead = (showWeek ? "<th class='ui-datepicker-week-col'>" + this._get(inst, "weekHeader") + "</th>" : "");
            for (dow = 0; dow < 7; dow++) {
              day = (dow + firstDay) % 7;
              thead += "<th scope='col'" + ((dow + firstDay + 6) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "") + ">" + "<span title='" + dayNames[day] + "'>" + dayNamesMin[day] + "</span></th>";
            }
            calender += thead + "</tr></thead><tbody>";
            daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
            if (drawYear === inst.selectedYear && drawMonth === inst.selectedMonth) {
              inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
            }
            leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
            curRows = Math.ceil((leadDays + daysInMonth) / 7);
            numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows);
            this.maxRows = numRows;
            printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
            for (dRow = 0; dRow < numRows; dRow++) {
              calender += "<tr>";
              tbody = (!showWeek ? "" : "<td class='ui-datepicker-week-col'>" + this._get(inst, "calculateWeek")(printDate) + "</td>");
              for (dow = 0; dow < 7; dow++) {
                daySettings = (beforeShowDay ? beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, ""]);
                otherMonth = (printDate.getMonth() !== drawMonth);
                unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] || (minDate && printDate < minDate) || (maxDate && printDate > maxDate);
                tbody += "<td class='" + ((dow + firstDay + 6) % 7 >= 5 ? " ui-datepicker-week-end" : "") + (otherMonth ? " ui-datepicker-other-month" : "") + ((printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent) || (defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime()) ? " " + this._dayOverClass : "") + (unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "") + (otherMonth && !showOtherMonths ? "" : " " + daySettings[1] + (printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "") + (printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "")) + "'" + ((!otherMonth || showOtherMonths) && daySettings[2] ? " title='" + daySettings[2].replace(/'/g, "&#39;") + "'" : "") + (unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'") + ">" + (otherMonth && !showOtherMonths ? "&#xa0;" : (unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" + (printDate.getTime() === today.getTime() ? " ui-state-highlight" : "") + (printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "") + (otherMonth ? " ui-priority-secondary" : "") + "' href='#'>" + printDate.getDate() + "</a>")) + "</td>";
                printDate.setDate(printDate.getDate() + 1);
                printDate = this._daylightSavingAdjust(printDate);
              }
              calender += tbody + "</tr>";
            }
            drawMonth++;
            if (drawMonth > 11) {
              drawMonth = 0;
              drawYear++;
            }
            calender += "</tbody></table>" + (isMultiMonth ? "</div>" + ((numMonths[0] > 0 && col === numMonths[1] - 1) ? "<div class='ui-datepicker-row-break'></div>" : "") : "");
            group += calender;
          }
          html += group;
        }
        html += buttonPanel;
        inst._keyEvent = false;
        return html;
      },
      _generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate, secondary, monthNames, monthNamesShort) {
        var inMinYear,
            inMaxYear,
            month,
            years,
            thisYear,
            determineYear,
            year,
            endYear,
            changeMonth = this._get(inst, "changeMonth"),
            changeYear = this._get(inst, "changeYear"),
            showMonthAfterYear = this._get(inst, "showMonthAfterYear"),
            html = "<div class='ui-datepicker-title'>",
            monthHtml = "";
        if (secondary || !changeMonth) {
          monthHtml += "<span class='ui-datepicker-month'>" + monthNames[drawMonth] + "</span>";
        } else {
          inMinYear = (minDate && minDate.getFullYear() === drawYear);
          inMaxYear = (maxDate && maxDate.getFullYear() === drawYear);
          monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
          for (month = 0; month < 12; month++) {
            if ((!inMinYear || month >= minDate.getMonth()) && (!inMaxYear || month <= maxDate.getMonth())) {
              monthHtml += "<option value='" + month + "'" + (month === drawMonth ? " selected='selected'" : "") + ">" + monthNamesShort[month] + "</option>";
            }
          }
          monthHtml += "</select>";
        }
        if (!showMonthAfterYear) {
          html += monthHtml + (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "");
        }
        if (!inst.yearshtml) {
          inst.yearshtml = "";
          if (secondary || !changeYear) {
            html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
          } else {
            years = this._get(inst, "yearRange").split(":");
            thisYear = new Date().getFullYear();
            determineYear = function(value) {
              var year = (value.match(/c[+\-].*/) ? drawYear + parseInt(value.substring(1), 10) : (value.match(/[+\-].*/) ? thisYear + parseInt(value, 10) : parseInt(value, 10)));
              return (isNaN(year) ? thisYear : year);
            };
            year = determineYear(years[0]);
            endYear = Math.max(year, determineYear(years[1] || ""));
            year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
            endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
            inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
            for (; year <= endYear; year++) {
              inst.yearshtml += "<option value='" + year + "'" + (year === drawYear ? " selected='selected'" : "") + ">" + year + "</option>";
            }
            inst.yearshtml += "</select>";
            html += inst.yearshtml;
            inst.yearshtml = null;
          }
        }
        html += this._get(inst, "yearSuffix");
        if (showMonthAfterYear) {
          html += (secondary || !(changeMonth && changeYear) ? "&#xa0;" : "") + monthHtml;
        }
        html += "</div>";
        return html;
      },
      _adjustInstDate: function(inst, offset, period) {
        var year = inst.drawYear + (period === "Y" ? offset : 0),
            month = inst.drawMonth + (period === "M" ? offset : 0),
            day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) + (period === "D" ? offset : 0),
            date = this._restrictMinMax(inst, this._daylightSavingAdjust(new Date(year, month, day)));
        inst.selectedDay = date.getDate();
        inst.drawMonth = inst.selectedMonth = date.getMonth();
        inst.drawYear = inst.selectedYear = date.getFullYear();
        if (period === "M" || period === "Y") {
          this._notifyChange(inst);
        }
      },
      _restrictMinMax: function(inst, date) {
        var minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            newDate = (minDate && date < minDate ? minDate : date);
        return (maxDate && newDate > maxDate ? maxDate : newDate);
      },
      _notifyChange: function(inst) {
        var onChange = this._get(inst, "onChangeMonthYear");
        if (onChange) {
          onChange.apply((inst.input ? inst.input[0] : null), [inst.selectedYear, inst.selectedMonth + 1, inst]);
        }
      },
      _getNumberOfMonths: function(inst) {
        var numMonths = this._get(inst, "numberOfMonths");
        return (numMonths == null ? [1, 1] : (typeof numMonths === "number" ? [1, numMonths] : numMonths));
      },
      _getMinMaxDate: function(inst, minMax) {
        return this._determineDate(inst, this._get(inst, minMax + "Date"), null);
      },
      _getDaysInMonth: function(year, month) {
        return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
      },
      _getFirstDayOfMonth: function(year, month) {
        return new Date(year, month, 1).getDay();
      },
      _canAdjustMonth: function(inst, offset, curYear, curMonth) {
        var numMonths = this._getNumberOfMonths(inst),
            date = this._daylightSavingAdjust(new Date(curYear, curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
        if (offset < 0) {
          date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
        }
        return this._isInRange(inst, date);
      },
      _isInRange: function(inst, date) {
        var yearSplit,
            currentYear,
            minDate = this._getMinMaxDate(inst, "min"),
            maxDate = this._getMinMaxDate(inst, "max"),
            minYear = null,
            maxYear = null,
            years = this._get(inst, "yearRange");
        if (years) {
          yearSplit = years.split(":");
          currentYear = new Date().getFullYear();
          minYear = parseInt(yearSplit[0], 10);
          maxYear = parseInt(yearSplit[1], 10);
          if (yearSplit[0].match(/[+\-].*/)) {
            minYear += currentYear;
          }
          if (yearSplit[1].match(/[+\-].*/)) {
            maxYear += currentYear;
          }
        }
        return ((!minDate || date.getTime() >= minDate.getTime()) && (!maxDate || date.getTime() <= maxDate.getTime()) && (!minYear || date.getFullYear() >= minYear) && (!maxYear || date.getFullYear() <= maxYear));
      },
      _getFormatConfig: function(inst) {
        var shortYearCutoff = this._get(inst, "shortYearCutoff");
        shortYearCutoff = (typeof shortYearCutoff !== "string" ? shortYearCutoff : new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
        return {
          shortYearCutoff: shortYearCutoff,
          dayNamesShort: this._get(inst, "dayNamesShort"),
          dayNames: this._get(inst, "dayNames"),
          monthNamesShort: this._get(inst, "monthNamesShort"),
          monthNames: this._get(inst, "monthNames")
        };
      },
      _formatDate: function(inst, day, month, year) {
        if (!day) {
          inst.currentDay = inst.selectedDay;
          inst.currentMonth = inst.selectedMonth;
          inst.currentYear = inst.selectedYear;
        }
        var date = (day ? (typeof day === "object" ? day : this._daylightSavingAdjust(new Date(year, month, day))) : this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
        return this.formatDate(this._get(inst, "dateFormat"), date, this._getFormatConfig(inst));
      }
    });
    function datepicker_bindHover(dpDiv) {
      var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
      return dpDiv.delegate(selector, "mouseout", function() {
        $(this).removeClass("ui-state-hover");
        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
          $(this).removeClass("ui-datepicker-prev-hover");
        }
        if (this.className.indexOf("ui-datepicker-next") !== -1) {
          $(this).removeClass("ui-datepicker-next-hover");
        }
      }).delegate(selector, "mouseover", datepicker_handleMouseover);
    }
    function datepicker_handleMouseover() {
      if (!$.datepicker._isDisabledDatepicker(datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[0] : datepicker_instActive.input[0])) {
        $(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover");
        $(this).addClass("ui-state-hover");
        if (this.className.indexOf("ui-datepicker-prev") !== -1) {
          $(this).addClass("ui-datepicker-prev-hover");
        }
        if (this.className.indexOf("ui-datepicker-next") !== -1) {
          $(this).addClass("ui-datepicker-next-hover");
        }
      }
    }
    function datepicker_extendRemove(target, props) {
      $.extend(target, props);
      for (var name in props) {
        if (props[name] == null) {
          target[name] = props[name];
        }
      }
      return target;
    }
    $.fn.datepicker = function(options) {
      if (!this.length) {
        return this;
      }
      if (!$.datepicker.initialized) {
        $(document).mousedown($.datepicker._checkExternalClick);
        $.datepicker.initialized = true;
      }
      if ($("#" + $.datepicker._mainDivId).length === 0) {
        $("body").append($.datepicker.dpDiv);
      }
      var otherArgs = Array.prototype.slice.call(arguments, 1);
      if (typeof options === "string" && (options === "isDisabled" || options === "getDate" || options === "widget")) {
        return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
      }
      if (options === "option" && arguments.length === 2 && typeof arguments[1] === "string") {
        return $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this[0]].concat(otherArgs));
      }
      return this.each(function() {
        typeof options === "string" ? $.datepicker["_" + options + "Datepicker"].apply($.datepicker, [this].concat(otherArgs)) : $.datepicker._attachDatepicker(this, options);
      });
    };
    $.datepicker = new Datepicker();
    $.datepicker.initialized = false;
    $.datepicker.uuid = new Date().getTime();
    $.datepicker.version = "1.11.1";
    var datepicker = $.datepicker;
    $.widget("ui.draggable", $.ui.mouse, {
      version: "1.11.1",
      widgetEventPrefix: "drag",
      options: {
        addClasses: true,
        appendTo: "parent",
        axis: false,
        connectToSortable: false,
        containment: false,
        cursor: "auto",
        cursorAt: false,
        grid: false,
        handle: false,
        helper: "original",
        iframeFix: false,
        opacity: false,
        refreshPositions: false,
        revert: false,
        revertDuration: 500,
        scope: "default",
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        snap: false,
        snapMode: "both",
        snapTolerance: 20,
        stack: false,
        zIndex: false,
        drag: null,
        start: null,
        stop: null
      },
      _create: function() {
        if (this.options.helper === "original" && !(/^(?:r|a|f)/).test(this.element.css("position"))) {
          this.element[0].style.position = "relative";
        }
        if (this.options.addClasses) {
          this.element.addClass("ui-draggable");
        }
        if (this.options.disabled) {
          this.element.addClass("ui-draggable-disabled");
        }
        this._setHandleClassName();
        this._mouseInit();
      },
      _setOption: function(key, value) {
        this._super(key, value);
        if (key === "handle") {
          this._removeHandleClassName();
          this._setHandleClassName();
        }
      },
      _destroy: function() {
        if ((this.helper || this.element).is(".ui-draggable-dragging")) {
          this.destroyOnClear = true;
          return;
        }
        this.element.removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled");
        this._removeHandleClassName();
        this._mouseDestroy();
      },
      _mouseCapture: function(event) {
        var document = this.document[0],
            o = this.options;
        try {
          if (document.activeElement && document.activeElement.nodeName.toLowerCase() !== "body") {
            $(document.activeElement).blur();
          }
        } catch (error) {}
        if (this.helper || o.disabled || $(event.target).closest(".ui-resizable-handle").length > 0) {
          return false;
        }
        this.handle = this._getHandle(event);
        if (!this.handle) {
          return false;
        }
        $(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
          $("<div class='ui-draggable-iframeFix' style='background: #fff;'></div>").css({
            width: this.offsetWidth + "px",
            height: this.offsetHeight + "px",
            position: "absolute",
            opacity: "0.001",
            zIndex: 1000
          }).css($(this).offset()).appendTo("body");
        });
        return true;
      },
      _mouseStart: function(event) {
        var o = this.options;
        this.helper = this._createHelper(event);
        this.helper.addClass("ui-draggable-dragging");
        this._cacheHelperProportions();
        if ($.ui.ddmanager) {
          $.ui.ddmanager.current = this;
        }
        this._cacheMargins();
        this.cssPosition = this.helper.css("position");
        this.scrollParent = this.helper.scrollParent(true);
        this.offsetParent = this.helper.offsetParent();
        this.offsetParentCssPosition = this.offsetParent.css("position");
        this.offset = this.positionAbs = this.element.offset();
        this.offset = {
          top: this.offset.top - this.margins.top,
          left: this.offset.left - this.margins.left
        };
        this.offset.scroll = false;
        $.extend(this.offset, {
          click: {
            left: event.pageX - this.offset.left,
            top: event.pageY - this.offset.top
          },
          parent: this._getParentOffset(),
          relative: this._getRelativeOffset()
        });
        this.originalPosition = this.position = this._generatePosition(event, false);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY;
        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
        this._setContainment();
        if (this._trigger("start", event) === false) {
          this._clear();
          return false;
        }
        this._cacheHelperProportions();
        if ($.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
        this._mouseDrag(event, true);
        if ($.ui.ddmanager) {
          $.ui.ddmanager.dragStart(this, event);
        }
        return true;
      },
      _mouseDrag: function(event, noPropagation) {
        if (this.offsetParentCssPosition === "fixed") {
          this.offset.parent = this._getParentOffset();
        }
        this.position = this._generatePosition(event, true);
        this.positionAbs = this._convertPositionTo("absolute");
        if (!noPropagation) {
          var ui = this._uiHash();
          if (this._trigger("drag", event, ui) === false) {
            this._mouseUp({});
            return false;
          }
          this.position = ui.position;
        }
        this.helper[0].style.left = this.position.left + "px";
        this.helper[0].style.top = this.position.top + "px";
        if ($.ui.ddmanager) {
          $.ui.ddmanager.drag(this, event);
        }
        return false;
      },
      _mouseStop: function(event) {
        var that = this,
            dropped = false;
        if ($.ui.ddmanager && !this.options.dropBehaviour) {
          dropped = $.ui.ddmanager.drop(this, event);
        }
        if (this.dropped) {
          dropped = this.dropped;
          this.dropped = false;
        }
        if ((this.options.revert === "invalid" && !dropped) || (this.options.revert === "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
          $(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
            if (that._trigger("stop", event) !== false) {
              that._clear();
            }
          });
        } else {
          if (this._trigger("stop", event) !== false) {
            this._clear();
          }
        }
        return false;
      },
      _mouseUp: function(event) {
        $("div.ui-draggable-iframeFix").each(function() {
          this.parentNode.removeChild(this);
        });
        if ($.ui.ddmanager) {
          $.ui.ddmanager.dragStop(this, event);
        }
        this.element.focus();
        return $.ui.mouse.prototype._mouseUp.call(this, event);
      },
      cancel: function() {
        if (this.helper.is(".ui-draggable-dragging")) {
          this._mouseUp({});
        } else {
          this._clear();
        }
        return this;
      },
      _getHandle: function(event) {
        return this.options.handle ? !!$(event.target).closest(this.element.find(this.options.handle)).length : true;
      },
      _setHandleClassName: function() {
        this.handleElement = this.options.handle ? this.element.find(this.options.handle) : this.element;
        this.handleElement.addClass("ui-draggable-handle");
      },
      _removeHandleClassName: function() {
        this.handleElement.removeClass("ui-draggable-handle");
      },
      _createHelper: function(event) {
        var o = this.options,
            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper === "clone" ? this.element.clone().removeAttr("id") : this.element);
        if (!helper.parents("body").length) {
          helper.appendTo((o.appendTo === "parent" ? this.element[0].parentNode : o.appendTo));
        }
        if (helper[0] !== this.element[0] && !(/(fixed|absolute)/).test(helper.css("position"))) {
          helper.css("position", "absolute");
        }
        return helper;
      },
      _adjustOffsetFromHelper: function(obj) {
        if (typeof obj === "string") {
          obj = obj.split(" ");
        }
        if ($.isArray(obj)) {
          obj = {
            left: +obj[0],
            top: +obj[1] || 0
          };
        }
        if ("left" in obj) {
          this.offset.click.left = obj.left + this.margins.left;
        }
        if ("right" in obj) {
          this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }
        if ("top" in obj) {
          this.offset.click.top = obj.top + this.margins.top;
        }
        if ("bottom" in obj) {
          this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
      },
      _isRootNode: function(element) {
        return (/(html|body)/i).test(element.tagName) || element === this.document[0];
      },
      _getParentOffset: function() {
        var po = this.offsetParent.offset(),
            document = this.document[0];
        if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
          po.left += this.scrollParent.scrollLeft();
          po.top += this.scrollParent.scrollTop();
        }
        if (this._isRootNode(this.offsetParent[0])) {
          po = {
            top: 0,
            left: 0
          };
        }
        return {
          top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
          left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
        };
      },
      _getRelativeOffset: function() {
        if (this.cssPosition !== "relative") {
          return {
            top: 0,
            left: 0
          };
        }
        var p = this.element.position(),
            scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
        return {
          top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollTop() : 0),
          left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + (!scrollIsRootNode ? this.scrollParent.scrollLeft() : 0)
        };
      },
      _cacheMargins: function() {
        this.margins = {
          left: (parseInt(this.element.css("marginLeft"), 10) || 0),
          top: (parseInt(this.element.css("marginTop"), 10) || 0),
          right: (parseInt(this.element.css("marginRight"), 10) || 0),
          bottom: (parseInt(this.element.css("marginBottom"), 10) || 0)
        };
      },
      _cacheHelperProportions: function() {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        };
      },
      _setContainment: function() {
        var over,
            c,
            ce,
            o = this.options,
            document = this.document[0];
        this.relativeContainer = null;
        if (!o.containment) {
          this.containment = null;
          return;
        }
        if (o.containment === "window") {
          this.containment = [$(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, $(window).scrollLeft() + $(window).width() - this.helperProportions.width - this.margins.left, $(window).scrollTop() + ($(window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
          return;
        }
        if (o.containment === "document") {
          this.containment = [0, 0, $(document).width() - this.helperProportions.width - this.margins.left, ($(document).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
          return;
        }
        if (o.containment.constructor === Array) {
          this.containment = o.containment;
          return;
        }
        if (o.containment === "parent") {
          o.containment = this.helper[0].parentNode;
        }
        c = $(o.containment);
        ce = c[0];
        if (!ce) {
          return;
        }
        over = c.css("overflow") !== "hidden";
        this.containment = [(parseInt(c.css("borderLeftWidth"), 10) || 0) + (parseInt(c.css("paddingLeft"), 10) || 0), (parseInt(c.css("borderTopWidth"), 10) || 0) + (parseInt(c.css("paddingTop"), 10) || 0), (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt(c.css("borderRightWidth"), 10) || 0) - (parseInt(c.css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt(c.css("borderBottomWidth"), 10) || 0) - (parseInt(c.css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom];
        this.relativeContainer = c;
      },
      _convertPositionTo: function(d, pos) {
        if (!pos) {
          pos = this.position;
        }
        var mod = d === "absolute" ? 1 : -1,
            scrollIsRootNode = this._isRootNode(this.scrollParent[0]);
        return {
          top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ((this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top)) * mod)),
          left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ((this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left)) * mod))
        };
      },
      _generatePosition: function(event, constrainPosition) {
        var containment,
            co,
            top,
            left,
            o = this.options,
            scrollIsRootNode = this._isRootNode(this.scrollParent[0]),
            pageX = event.pageX,
            pageY = event.pageY;
        if (!scrollIsRootNode || !this.offset.scroll) {
          this.offset.scroll = {
            top: this.scrollParent.scrollTop(),
            left: this.scrollParent.scrollLeft()
          };
        }
        if (constrainPosition) {
          if (this.containment) {
            if (this.relativeContainer) {
              co = this.relativeContainer.offset();
              containment = [this.containment[0] + co.left, this.containment[1] + co.top, this.containment[2] + co.left, this.containment[3] + co.top];
            } else {
              containment = this.containment;
            }
            if (event.pageX - this.offset.click.left < containment[0]) {
              pageX = containment[0] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top < containment[1]) {
              pageY = containment[1] + this.offset.click.top;
            }
            if (event.pageX - this.offset.click.left > containment[2]) {
              pageX = containment[2] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top > containment[3]) {
              pageY = containment[3] + this.offset.click.top;
            }
          }
          if (o.grid) {
            top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
            pageY = containment ? ((top - this.offset.click.top >= containment[1] || top - this.offset.click.top > containment[3]) ? top : ((top - this.offset.click.top >= containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
            left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
            pageX = containment ? ((left - this.offset.click.left >= containment[0] || left - this.offset.click.left > containment[2]) ? left : ((left - this.offset.click.left >= containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
          }
          if (o.axis === "y") {
            pageX = this.originalPageX;
          }
          if (o.axis === "x") {
            pageY = this.originalPageY;
          }
        }
        return {
          top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (this.cssPosition === "fixed" ? -this.offset.scroll.top : (scrollIsRootNode ? 0 : this.offset.scroll.top))),
          left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (this.cssPosition === "fixed" ? -this.offset.scroll.left : (scrollIsRootNode ? 0 : this.offset.scroll.left)))
        };
      },
      _clear: function() {
        this.helper.removeClass("ui-draggable-dragging");
        if (this.helper[0] !== this.element[0] && !this.cancelHelperRemoval) {
          this.helper.remove();
        }
        this.helper = null;
        this.cancelHelperRemoval = false;
        if (this.destroyOnClear) {
          this.destroy();
        }
      },
      _trigger: function(type, event, ui) {
        ui = ui || this._uiHash();
        $.ui.plugin.call(this, type, [event, ui, this], true);
        if (type === "drag") {
          this.positionAbs = this._convertPositionTo("absolute");
        }
        return $.Widget.prototype._trigger.call(this, type, event, ui);
      },
      plugins: {},
      _uiHash: function() {
        return {
          helper: this.helper,
          position: this.position,
          originalPosition: this.originalPosition,
          offset: this.positionAbs
        };
      }
    });
    $.ui.plugin.add("draggable", "connectToSortable", {
      start: function(event, ui, inst) {
        var o = inst.options,
            uiSortable = $.extend({}, ui, {item: inst.element});
        inst.sortables = [];
        $(o.connectToSortable).each(function() {
          var sortable = $(this).sortable("instance");
          if (sortable && !sortable.options.disabled) {
            inst.sortables.push({
              instance: sortable,
              shouldRevert: sortable.options.revert
            });
            sortable.refreshPositions();
            sortable._trigger("activate", event, uiSortable);
          }
        });
      },
      stop: function(event, ui, inst) {
        var uiSortable = $.extend({}, ui, {item: inst.element});
        $.each(inst.sortables, function() {
          if (this.instance.isOver) {
            this.instance.isOver = 0;
            inst.cancelHelperRemoval = true;
            this.instance.cancelHelperRemoval = false;
            if (this.shouldRevert) {
              this.instance.options.revert = this.shouldRevert;
            }
            this.instance._mouseStop(event);
            this.instance.options.helper = this.instance.options._helper;
            if (inst.options.helper === "original") {
              this.instance.currentItem.css({
                top: "auto",
                left: "auto"
              });
            }
          } else {
            this.instance.cancelHelperRemoval = false;
            this.instance._trigger("deactivate", event, uiSortable);
          }
        });
      },
      drag: function(event, ui, inst) {
        var that = this;
        $.each(inst.sortables, function() {
          var innermostIntersecting = false,
              thisSortable = this;
          this.instance.positionAbs = inst.positionAbs;
          this.instance.helperProportions = inst.helperProportions;
          this.instance.offset.click = inst.offset.click;
          if (this.instance._intersectsWith(this.instance.containerCache)) {
            innermostIntersecting = true;
            $.each(inst.sortables, function() {
              this.instance.positionAbs = inst.positionAbs;
              this.instance.helperProportions = inst.helperProportions;
              this.instance.offset.click = inst.offset.click;
              if (this !== thisSortable && this.instance._intersectsWith(this.instance.containerCache) && $.contains(thisSortable.instance.element[0], this.instance.element[0])) {
                innermostIntersecting = false;
              }
              return innermostIntersecting;
            });
          }
          if (innermostIntersecting) {
            if (!this.instance.isOver) {
              this.instance.isOver = 1;
              this.instance.currentItem = $(that).clone().removeAttr("id").appendTo(this.instance.element).data("ui-sortable-item", true);
              this.instance.options._helper = this.instance.options.helper;
              this.instance.options.helper = function() {
                return ui.helper[0];
              };
              event.target = this.instance.currentItem[0];
              this.instance._mouseCapture(event, true);
              this.instance._mouseStart(event, true, true);
              this.instance.offset.click.top = inst.offset.click.top;
              this.instance.offset.click.left = inst.offset.click.left;
              this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
              this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;
              inst._trigger("toSortable", event);
              inst.dropped = this.instance.element;
              inst.currentItem = inst.element;
              this.instance.fromOutside = inst;
            }
            if (this.instance.currentItem) {
              this.instance._mouseDrag(event);
            }
          } else {
            if (this.instance.isOver) {
              this.instance.isOver = 0;
              this.instance.cancelHelperRemoval = true;
              this.instance.options.revert = false;
              this.instance._trigger("out", event, this.instance._uiHash(this.instance));
              this.instance._mouseStop(event, true);
              this.instance.options.helper = this.instance.options._helper;
              this.instance.currentItem.remove();
              if (this.instance.placeholder) {
                this.instance.placeholder.remove();
              }
              inst._trigger("fromSortable", event);
              inst.dropped = false;
            }
          }
        });
      }
    });
    $.ui.plugin.add("draggable", "cursor", {
      start: function(event, ui, instance) {
        var t = $("body"),
            o = instance.options;
        if (t.css("cursor")) {
          o._cursor = t.css("cursor");
        }
        t.css("cursor", o.cursor);
      },
      stop: function(event, ui, instance) {
        var o = instance.options;
        if (o._cursor) {
          $("body").css("cursor", o._cursor);
        }
      }
    });
    $.ui.plugin.add("draggable", "opacity", {
      start: function(event, ui, instance) {
        var t = $(ui.helper),
            o = instance.options;
        if (t.css("opacity")) {
          o._opacity = t.css("opacity");
        }
        t.css("opacity", o.opacity);
      },
      stop: function(event, ui, instance) {
        var o = instance.options;
        if (o._opacity) {
          $(ui.helper).css("opacity", o._opacity);
        }
      }
    });
    $.ui.plugin.add("draggable", "scroll", {
      start: function(event, ui, i) {
        if (!i.scrollParentNotHidden) {
          i.scrollParentNotHidden = i.helper.scrollParent(false);
        }
        if (i.scrollParentNotHidden[0] !== i.document[0] && i.scrollParentNotHidden[0].tagName !== "HTML") {
          i.overflowOffset = i.scrollParentNotHidden.offset();
        }
      },
      drag: function(event, ui, i) {
        var o = i.options,
            scrolled = false,
            scrollParent = i.scrollParentNotHidden[0],
            document = i.document[0];
        if (scrollParent !== document && scrollParent.tagName !== "HTML") {
          if (!o.axis || o.axis !== "x") {
            if ((i.overflowOffset.top + scrollParent.offsetHeight) - event.pageY < o.scrollSensitivity) {
              scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
            } else if (event.pageY - i.overflowOffset.top < o.scrollSensitivity) {
              scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
            }
          }
          if (!o.axis || o.axis !== "y") {
            if ((i.overflowOffset.left + scrollParent.offsetWidth) - event.pageX < o.scrollSensitivity) {
              scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
            } else if (event.pageX - i.overflowOffset.left < o.scrollSensitivity) {
              scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
            }
          }
        } else {
          if (!o.axis || o.axis !== "x") {
            if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
              scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
            } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
              scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
            }
          }
          if (!o.axis || o.axis !== "y") {
            if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
              scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
            } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
              scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
            }
          }
        }
        if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(i, event);
        }
      }
    });
    $.ui.plugin.add("draggable", "snap", {
      start: function(event, ui, i) {
        var o = i.options;
        i.snapElements = [];
        $(o.snap.constructor !== String ? (o.snap.items || ":data(ui-draggable)") : o.snap).each(function() {
          var $t = $(this),
              $o = $t.offset();
          if (this !== i.element[0]) {
            i.snapElements.push({
              item: this,
              width: $t.outerWidth(),
              height: $t.outerHeight(),
              top: $o.top,
              left: $o.left
            });
          }
        });
      },
      drag: function(event, ui, inst) {
        var ts,
            bs,
            ls,
            rs,
            l,
            r,
            t,
            b,
            i,
            first,
            o = inst.options,
            d = o.snapTolerance,
            x1 = ui.offset.left,
            x2 = x1 + inst.helperProportions.width,
            y1 = ui.offset.top,
            y2 = y1 + inst.helperProportions.height;
        for (i = inst.snapElements.length - 1; i >= 0; i--) {
          l = inst.snapElements[i].left;
          r = l + inst.snapElements[i].width;
          t = inst.snapElements[i].top;
          b = t + inst.snapElements[i].height;
          if (x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d || !$.contains(inst.snapElements[i].item.ownerDocument, inst.snapElements[i].item)) {
            if (inst.snapElements[i].snapping) {
              (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})));
            }
            inst.snapElements[i].snapping = false;
            continue;
          }
          if (o.snapMode !== "inner") {
            ts = Math.abs(t - y2) <= d;
            bs = Math.abs(b - y1) <= d;
            ls = Math.abs(l - x2) <= d;
            rs = Math.abs(r - x1) <= d;
            if (ts) {
              ui.position.top = inst._convertPositionTo("relative", {
                top: t - inst.helperProportions.height,
                left: 0
              }).top - inst.margins.top;
            }
            if (bs) {
              ui.position.top = inst._convertPositionTo("relative", {
                top: b,
                left: 0
              }).top - inst.margins.top;
            }
            if (ls) {
              ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l - inst.helperProportions.width
              }).left - inst.margins.left;
            }
            if (rs) {
              ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r
              }).left - inst.margins.left;
            }
          }
          first = (ts || bs || ls || rs);
          if (o.snapMode !== "outer") {
            ts = Math.abs(t - y1) <= d;
            bs = Math.abs(b - y2) <= d;
            ls = Math.abs(l - x1) <= d;
            rs = Math.abs(r - x2) <= d;
            if (ts) {
              ui.position.top = inst._convertPositionTo("relative", {
                top: t,
                left: 0
              }).top - inst.margins.top;
            }
            if (bs) {
              ui.position.top = inst._convertPositionTo("relative", {
                top: b - inst.helperProportions.height,
                left: 0
              }).top - inst.margins.top;
            }
            if (ls) {
              ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: l
              }).left - inst.margins.left;
            }
            if (rs) {
              ui.position.left = inst._convertPositionTo("relative", {
                top: 0,
                left: r - inst.helperProportions.width
              }).left - inst.margins.left;
            }
          }
          if (!inst.snapElements[i].snapping && (ts || bs || ls || rs || first)) {
            (inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), {snapItem: inst.snapElements[i].item})));
          }
          inst.snapElements[i].snapping = (ts || bs || ls || rs || first);
        }
      }
    });
    $.ui.plugin.add("draggable", "stack", {start: function(event, ui, instance) {
        var min,
            o = instance.options,
            group = $.makeArray($(o.stack)).sort(function(a, b) {
              return (parseInt($(a).css("zIndex"), 10) || 0) - (parseInt($(b).css("zIndex"), 10) || 0);
            });
        if (!group.length) {
          return;
        }
        min = parseInt($(group[0]).css("zIndex"), 10) || 0;
        $(group).each(function(i) {
          $(this).css("zIndex", min + i);
        });
        this.css("zIndex", (min + group.length));
      }});
    $.ui.plugin.add("draggable", "zIndex", {
      start: function(event, ui, instance) {
        var t = $(ui.helper),
            o = instance.options;
        if (t.css("zIndex")) {
          o._zIndex = t.css("zIndex");
        }
        t.css("zIndex", o.zIndex);
      },
      stop: function(event, ui, instance) {
        var o = instance.options;
        if (o._zIndex) {
          $(ui.helper).css("zIndex", o._zIndex);
        }
      }
    });
    var draggable = $.ui.draggable;
    $.widget("ui.resizable", $.ui.mouse, {
      version: "1.11.1",
      widgetEventPrefix: "resize",
      options: {
        alsoResize: false,
        animate: false,
        animateDuration: "slow",
        animateEasing: "swing",
        aspectRatio: false,
        autoHide: false,
        containment: false,
        ghost: false,
        grid: false,
        handles: "e,s,se",
        helper: false,
        maxHeight: null,
        maxWidth: null,
        minHeight: 10,
        minWidth: 10,
        zIndex: 90,
        resize: null,
        start: null,
        stop: null
      },
      _num: function(value) {
        return parseInt(value, 10) || 0;
      },
      _isNumber: function(value) {
        return !isNaN(parseInt(value, 10));
      },
      _hasScroll: function(el, a) {
        if ($(el).css("overflow") === "hidden") {
          return false;
        }
        var scroll = (a && a === "left") ? "scrollLeft" : "scrollTop",
            has = false;
        if (el[scroll] > 0) {
          return true;
        }
        el[scroll] = 1;
        has = (el[scroll] > 0);
        el[scroll] = 0;
        return has;
      },
      _create: function() {
        var n,
            i,
            handle,
            axis,
            hname,
            that = this,
            o = this.options;
        this.element.addClass("ui-resizable");
        $.extend(this, {
          _aspectRatio: !!(o.aspectRatio),
          aspectRatio: o.aspectRatio,
          originalElement: this.element,
          _proportionallyResizeElements: [],
          _helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
        });
        if (this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {
          this.element.wrap($("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({
            position: this.element.css("position"),
            width: this.element.outerWidth(),
            height: this.element.outerHeight(),
            top: this.element.css("top"),
            left: this.element.css("left")
          }));
          this.element = this.element.parent().data("ui-resizable", this.element.resizable("instance"));
          this.elementIsWrapper = true;
          this.element.css({
            marginLeft: this.originalElement.css("marginLeft"),
            marginTop: this.originalElement.css("marginTop"),
            marginRight: this.originalElement.css("marginRight"),
            marginBottom: this.originalElement.css("marginBottom")
          });
          this.originalElement.css({
            marginLeft: 0,
            marginTop: 0,
            marginRight: 0,
            marginBottom: 0
          });
          this.originalResizeStyle = this.originalElement.css("resize");
          this.originalElement.css("resize", "none");
          this._proportionallyResizeElements.push(this.originalElement.css({
            position: "static",
            zoom: 1,
            display: "block"
          }));
          this.originalElement.css({margin: this.originalElement.css("margin")});
          this._proportionallyResize();
        }
        this.handles = o.handles || (!$(".ui-resizable-handle", this.element).length ? "e,s,se" : {
          n: ".ui-resizable-n",
          e: ".ui-resizable-e",
          s: ".ui-resizable-s",
          w: ".ui-resizable-w",
          se: ".ui-resizable-se",
          sw: ".ui-resizable-sw",
          ne: ".ui-resizable-ne",
          nw: ".ui-resizable-nw"
        });
        if (this.handles.constructor === String) {
          if (this.handles === "all") {
            this.handles = "n,e,s,w,se,sw,ne,nw";
          }
          n = this.handles.split(",");
          this.handles = {};
          for (i = 0; i < n.length; i++) {
            handle = $.trim(n[i]);
            hname = "ui-resizable-" + handle;
            axis = $("<div class='ui-resizable-handle " + hname + "'></div>");
            axis.css({zIndex: o.zIndex});
            if ("se" === handle) {
              axis.addClass("ui-icon ui-icon-gripsmall-diagonal-se");
            }
            this.handles[handle] = ".ui-resizable-" + handle;
            this.element.append(axis);
          }
        }
        this._renderAxis = function(target) {
          var i,
              axis,
              padPos,
              padWrapper;
          target = target || this.element;
          for (i in this.handles) {
            if (this.handles[i].constructor === String) {
              this.handles[i] = this.element.children(this.handles[i]).first().show();
            }
            if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {
              axis = $(this.handles[i], this.element);
              padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();
              padPos = ["padding", /ne|nw|n/.test(i) ? "Top" : /se|sw|s/.test(i) ? "Bottom" : /^e$/.test(i) ? "Right" : "Left"].join("");
              target.css(padPos, padWrapper);
              this._proportionallyResize();
            }
            if (!$(this.handles[i]).length) {
              continue;
            }
          }
        };
        this._renderAxis(this.element);
        this._handles = $(".ui-resizable-handle", this.element).disableSelection();
        this._handles.mouseover(function() {
          if (!that.resizing) {
            if (this.className) {
              axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
            }
            that.axis = axis && axis[1] ? axis[1] : "se";
          }
        });
        if (o.autoHide) {
          this._handles.hide();
          $(this.element).addClass("ui-resizable-autohide").mouseenter(function() {
            if (o.disabled) {
              return;
            }
            $(this).removeClass("ui-resizable-autohide");
            that._handles.show();
          }).mouseleave(function() {
            if (o.disabled) {
              return;
            }
            if (!that.resizing) {
              $(this).addClass("ui-resizable-autohide");
              that._handles.hide();
            }
          });
        }
        this._mouseInit();
      },
      _destroy: function() {
        this._mouseDestroy();
        var wrapper,
            _destroy = function(exp) {
              $(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").removeData("ui-resizable").unbind(".resizable").find(".ui-resizable-handle").remove();
            };
        if (this.elementIsWrapper) {
          _destroy(this.element);
          wrapper = this.element;
          this.originalElement.css({
            position: wrapper.css("position"),
            width: wrapper.outerWidth(),
            height: wrapper.outerHeight(),
            top: wrapper.css("top"),
            left: wrapper.css("left")
          }).insertAfter(wrapper);
          wrapper.remove();
        }
        this.originalElement.css("resize", this.originalResizeStyle);
        _destroy(this.originalElement);
        return this;
      },
      _mouseCapture: function(event) {
        var i,
            handle,
            capture = false;
        for (i in this.handles) {
          handle = $(this.handles[i])[0];
          if (handle === event.target || $.contains(handle, event.target)) {
            capture = true;
          }
        }
        return !this.options.disabled && capture;
      },
      _mouseStart: function(event) {
        var curleft,
            curtop,
            cursor,
            o = this.options,
            el = this.element;
        this.resizing = true;
        this._renderProxy();
        curleft = this._num(this.helper.css("left"));
        curtop = this._num(this.helper.css("top"));
        if (o.containment) {
          curleft += $(o.containment).scrollLeft() || 0;
          curtop += $(o.containment).scrollTop() || 0;
        }
        this.offset = this.helper.offset();
        this.position = {
          left: curleft,
          top: curtop
        };
        this.size = this._helper ? {
          width: this.helper.width(),
          height: this.helper.height()
        } : {
          width: el.width(),
          height: el.height()
        };
        this.originalSize = this._helper ? {
          width: el.outerWidth(),
          height: el.outerHeight()
        } : {
          width: el.width(),
          height: el.height()
        };
        this.sizeDiff = {
          width: el.outerWidth() - el.width(),
          height: el.outerHeight() - el.height()
        };
        this.originalPosition = {
          left: curleft,
          top: curtop
        };
        this.originalMousePosition = {
          left: event.pageX,
          top: event.pageY
        };
        this.aspectRatio = (typeof o.aspectRatio === "number") ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);
        cursor = $(".ui-resizable-" + this.axis).css("cursor");
        $("body").css("cursor", cursor === "auto" ? this.axis + "-resize" : cursor);
        el.addClass("ui-resizable-resizing");
        this._propagate("start", event);
        return true;
      },
      _mouseDrag: function(event) {
        var data,
            props,
            smp = this.originalMousePosition,
            a = this.axis,
            dx = (event.pageX - smp.left) || 0,
            dy = (event.pageY - smp.top) || 0,
            trigger = this._change[a];
        this._updatePrevProperties();
        if (!trigger) {
          return false;
        }
        data = trigger.apply(this, [event, dx, dy]);
        this._updateVirtualBoundaries(event.shiftKey);
        if (this._aspectRatio || event.shiftKey) {
          data = this._updateRatio(data, event);
        }
        data = this._respectSize(data, event);
        this._updateCache(data);
        this._propagate("resize", event);
        props = this._applyChanges();
        if (!this._helper && this._proportionallyResizeElements.length) {
          this._proportionallyResize();
        }
        if (!$.isEmptyObject(props)) {
          this._updatePrevProperties();
          this._trigger("resize", event, this.ui());
          this._applyChanges();
        }
        return false;
      },
      _mouseStop: function(event) {
        this.resizing = false;
        var pr,
            ista,
            soffseth,
            soffsetw,
            s,
            left,
            top,
            o = this.options,
            that = this;
        if (this._helper) {
          pr = this._proportionallyResizeElements;
          ista = pr.length && (/textarea/i).test(pr[0].nodeName);
          soffseth = ista && this._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height;
          soffsetw = ista ? 0 : that.sizeDiff.width;
          s = {
            width: (that.helper.width() - soffsetw),
            height: (that.helper.height() - soffseth)
          };
          left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null;
          top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
          if (!o.animate) {
            this.element.css($.extend(s, {
              top: top,
              left: left
            }));
          }
          that.helper.height(that.size.height);
          that.helper.width(that.size.width);
          if (this._helper && !o.animate) {
            this._proportionallyResize();
          }
        }
        $("body").css("cursor", "auto");
        this.element.removeClass("ui-resizable-resizing");
        this._propagate("stop", event);
        if (this._helper) {
          this.helper.remove();
        }
        return false;
      },
      _updatePrevProperties: function() {
        this.prevPosition = {
          top: this.position.top,
          left: this.position.left
        };
        this.prevSize = {
          width: this.size.width,
          height: this.size.height
        };
      },
      _applyChanges: function() {
        var props = {};
        if (this.position.top !== this.prevPosition.top) {
          props.top = this.position.top + "px";
        }
        if (this.position.left !== this.prevPosition.left) {
          props.left = this.position.left + "px";
        }
        if (this.size.width !== this.prevSize.width) {
          props.width = this.size.width + "px";
        }
        if (this.size.height !== this.prevSize.height) {
          props.height = this.size.height + "px";
        }
        this.helper.css(props);
        return props;
      },
      _updateVirtualBoundaries: function(forceAspectRatio) {
        var pMinWidth,
            pMaxWidth,
            pMinHeight,
            pMaxHeight,
            b,
            o = this.options;
        b = {
          minWidth: this._isNumber(o.minWidth) ? o.minWidth : 0,
          maxWidth: this._isNumber(o.maxWidth) ? o.maxWidth : Infinity,
          minHeight: this._isNumber(o.minHeight) ? o.minHeight : 0,
          maxHeight: this._isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };
        if (this._aspectRatio || forceAspectRatio) {
          pMinWidth = b.minHeight * this.aspectRatio;
          pMinHeight = b.minWidth / this.aspectRatio;
          pMaxWidth = b.maxHeight * this.aspectRatio;
          pMaxHeight = b.maxWidth / this.aspectRatio;
          if (pMinWidth > b.minWidth) {
            b.minWidth = pMinWidth;
          }
          if (pMinHeight > b.minHeight) {
            b.minHeight = pMinHeight;
          }
          if (pMaxWidth < b.maxWidth) {
            b.maxWidth = pMaxWidth;
          }
          if (pMaxHeight < b.maxHeight) {
            b.maxHeight = pMaxHeight;
          }
        }
        this._vBoundaries = b;
      },
      _updateCache: function(data) {
        this.offset = this.helper.offset();
        if (this._isNumber(data.left)) {
          this.position.left = data.left;
        }
        if (this._isNumber(data.top)) {
          this.position.top = data.top;
        }
        if (this._isNumber(data.height)) {
          this.size.height = data.height;
        }
        if (this._isNumber(data.width)) {
          this.size.width = data.width;
        }
      },
      _updateRatio: function(data) {
        var cpos = this.position,
            csize = this.size,
            a = this.axis;
        if (this._isNumber(data.height)) {
          data.width = (data.height * this.aspectRatio);
        } else if (this._isNumber(data.width)) {
          data.height = (data.width / this.aspectRatio);
        }
        if (a === "sw") {
          data.left = cpos.left + (csize.width - data.width);
          data.top = null;
        }
        if (a === "nw") {
          data.top = cpos.top + (csize.height - data.height);
          data.left = cpos.left + (csize.width - data.width);
        }
        return data;
      },
      _respectSize: function(data) {
        var o = this._vBoundaries,
            a = this.axis,
            ismaxw = this._isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width),
            ismaxh = this._isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
            isminw = this._isNumber(data.width) && o.minWidth && (o.minWidth > data.width),
            isminh = this._isNumber(data.height) && o.minHeight && (o.minHeight > data.height),
            dw = this.originalPosition.left + this.originalSize.width,
            dh = this.position.top + this.size.height,
            cw = /sw|nw|w/.test(a),
            ch = /nw|ne|n/.test(a);
        if (isminw) {
          data.width = o.minWidth;
        }
        if (isminh) {
          data.height = o.minHeight;
        }
        if (ismaxw) {
          data.width = o.maxWidth;
        }
        if (ismaxh) {
          data.height = o.maxHeight;
        }
        if (isminw && cw) {
          data.left = dw - o.minWidth;
        }
        if (ismaxw && cw) {
          data.left = dw - o.maxWidth;
        }
        if (isminh && ch) {
          data.top = dh - o.minHeight;
        }
        if (ismaxh && ch) {
          data.top = dh - o.maxHeight;
        }
        if (!data.width && !data.height && !data.left && data.top) {
          data.top = null;
        } else if (!data.width && !data.height && !data.top && data.left) {
          data.left = null;
        }
        return data;
      },
      _getPaddingPlusBorderDimensions: function(element) {
        var i = 0,
            widths = [],
            borders = [element.css("borderTopWidth"), element.css("borderRightWidth"), element.css("borderBottomWidth"), element.css("borderLeftWidth")],
            paddings = [element.css("paddingTop"), element.css("paddingRight"), element.css("paddingBottom"), element.css("paddingLeft")];
        for (; i < 4; i++) {
          widths[i] = (parseInt(borders[i], 10) || 0);
          widths[i] += (parseInt(paddings[i], 10) || 0);
        }
        return {
          height: widths[0] + widths[2],
          width: widths[1] + widths[3]
        };
      },
      _proportionallyResize: function() {
        if (!this._proportionallyResizeElements.length) {
          return;
        }
        var prel,
            i = 0,
            element = this.helper || this.element;
        for (; i < this._proportionallyResizeElements.length; i++) {
          prel = this._proportionallyResizeElements[i];
          if (!this.outerDimensions) {
            this.outerDimensions = this._getPaddingPlusBorderDimensions(prel);
          }
          prel.css({
            height: (element.height() - this.outerDimensions.height) || 0,
            width: (element.width() - this.outerDimensions.width) || 0
          });
        }
      },
      _renderProxy: function() {
        var el = this.element,
            o = this.options;
        this.elementOffset = el.offset();
        if (this._helper) {
          this.helper = this.helper || $("<div style='overflow:hidden;'></div>");
          this.helper.addClass(this._helper).css({
            width: this.element.outerWidth() - 1,
            height: this.element.outerHeight() - 1,
            position: "absolute",
            left: this.elementOffset.left + "px",
            top: this.elementOffset.top + "px",
            zIndex: ++o.zIndex
          });
          this.helper.appendTo("body").disableSelection();
        } else {
          this.helper = this.element;
        }
      },
      _change: {
        e: function(event, dx) {
          return {width: this.originalSize.width + dx};
        },
        w: function(event, dx) {
          var cs = this.originalSize,
              sp = this.originalPosition;
          return {
            left: sp.left + dx,
            width: cs.width - dx
          };
        },
        n: function(event, dx, dy) {
          var cs = this.originalSize,
              sp = this.originalPosition;
          return {
            top: sp.top + dy,
            height: cs.height - dy
          };
        },
        s: function(event, dx, dy) {
          return {height: this.originalSize.height + dy};
        },
        se: function(event, dx, dy) {
          return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        sw: function(event, dx, dy) {
          return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        },
        ne: function(event, dx, dy) {
          return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
        },
        nw: function(event, dx, dy) {
          return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
        }
      },
      _propagate: function(n, event) {
        $.ui.plugin.call(this, n, [event, this.ui()]);
        (n !== "resize" && this._trigger(n, event, this.ui()));
      },
      plugins: {},
      ui: function() {
        return {
          originalElement: this.originalElement,
          element: this.element,
          helper: this.helper,
          position: this.position,
          size: this.size,
          originalSize: this.originalSize,
          originalPosition: this.originalPosition
        };
      }
    });
    $.ui.plugin.add("resizable", "animate", {stop: function(event) {
        var that = $(this).resizable("instance"),
            o = that.options,
            pr = that._proportionallyResizeElements,
            ista = pr.length && (/textarea/i).test(pr[0].nodeName),
            soffseth = ista && that._hasScroll(pr[0], "left") ? 0 : that.sizeDiff.height,
            soffsetw = ista ? 0 : that.sizeDiff.width,
            style = {
              width: (that.size.width - soffsetw),
              height: (that.size.height - soffseth)
            },
            left = (parseInt(that.element.css("left"), 10) + (that.position.left - that.originalPosition.left)) || null,
            top = (parseInt(that.element.css("top"), 10) + (that.position.top - that.originalPosition.top)) || null;
        that.element.animate($.extend(style, top && left ? {
          top: top,
          left: left
        } : {}), {
          duration: o.animateDuration,
          easing: o.animateEasing,
          step: function() {
            var data = {
              width: parseInt(that.element.css("width"), 10),
              height: parseInt(that.element.css("height"), 10),
              top: parseInt(that.element.css("top"), 10),
              left: parseInt(that.element.css("left"), 10)
            };
            if (pr && pr.length) {
              $(pr[0]).css({
                width: data.width,
                height: data.height
              });
            }
            that._updateCache(data);
            that._propagate("resize", event);
          }
        });
      }});
    $.ui.plugin.add("resizable", "containment", {
      start: function() {
        var element,
            p,
            co,
            ch,
            cw,
            width,
            height,
            that = $(this).resizable("instance"),
            o = that.options,
            el = that.element,
            oc = o.containment,
            ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
        if (!ce) {
          return;
        }
        that.containerElement = $(ce);
        if (/document/.test(oc) || oc === document) {
          that.containerOffset = {
            left: 0,
            top: 0
          };
          that.containerPosition = {
            left: 0,
            top: 0
          };
          that.parentData = {
            element: $(document),
            left: 0,
            top: 0,
            width: $(document).width(),
            height: $(document).height() || document.body.parentNode.scrollHeight
          };
        } else {
          element = $(ce);
          p = [];
          $(["Top", "Right", "Left", "Bottom"]).each(function(i, name) {
            p[i] = that._num(element.css("padding" + name));
          });
          that.containerOffset = element.offset();
          that.containerPosition = element.position();
          that.containerSize = {
            height: (element.innerHeight() - p[3]),
            width: (element.innerWidth() - p[1])
          };
          co = that.containerOffset;
          ch = that.containerSize.height;
          cw = that.containerSize.width;
          width = (that._hasScroll(ce, "left") ? ce.scrollWidth : cw);
          height = (that._hasScroll(ce) ? ce.scrollHeight : ch);
          that.parentData = {
            element: ce,
            left: co.left,
            top: co.top,
            width: width,
            height: height
          };
        }
      },
      resize: function(event) {
        var woset,
            hoset,
            isParent,
            isOffsetRelative,
            that = $(this).resizable("instance"),
            o = that.options,
            co = that.containerOffset,
            cp = that.position,
            pRatio = that._aspectRatio || event.shiftKey,
            cop = {
              top: 0,
              left: 0
            },
            ce = that.containerElement,
            continueResize = true;
        if (ce[0] !== document && (/static/).test(ce.css("position"))) {
          cop = co;
        }
        if (cp.left < (that._helper ? co.left : 0)) {
          that.size.width = that.size.width + (that._helper ? (that.position.left - co.left) : (that.position.left - cop.left));
          if (pRatio) {
            that.size.height = that.size.width / that.aspectRatio;
            continueResize = false;
          }
          that.position.left = o.helper ? co.left : 0;
        }
        if (cp.top < (that._helper ? co.top : 0)) {
          that.size.height = that.size.height + (that._helper ? (that.position.top - co.top) : that.position.top);
          if (pRatio) {
            that.size.width = that.size.height * that.aspectRatio;
            continueResize = false;
          }
          that.position.top = that._helper ? co.top : 0;
        }
        isParent = that.containerElement.get(0) === that.element.parent().get(0);
        isOffsetRelative = /relative|absolute/.test(that.containerElement.css("position"));
        if (isParent && isOffsetRelative) {
          that.offset.left = that.parentData.left + that.position.left;
          that.offset.top = that.parentData.top + that.position.top;
        } else {
          that.offset.left = that.element.offset().left;
          that.offset.top = that.element.offset().top;
        }
        woset = Math.abs(that.sizeDiff.width + (that._helper ? that.offset.left - cop.left : (that.offset.left - co.left)));
        hoset = Math.abs(that.sizeDiff.height + (that._helper ? that.offset.top - cop.top : (that.offset.top - co.top)));
        if (woset + that.size.width >= that.parentData.width) {
          that.size.width = that.parentData.width - woset;
          if (pRatio) {
            that.size.height = that.size.width / that.aspectRatio;
            continueResize = false;
          }
        }
        if (hoset + that.size.height >= that.parentData.height) {
          that.size.height = that.parentData.height - hoset;
          if (pRatio) {
            that.size.width = that.size.height * that.aspectRatio;
            continueResize = false;
          }
        }
        if (!continueResize) {
          that.position.left = that.prevPosition.left;
          that.position.top = that.prevPosition.top;
          that.size.width = that.prevSize.width;
          that.size.height = that.prevSize.height;
        }
      },
      stop: function() {
        var that = $(this).resizable("instance"),
            o = that.options,
            co = that.containerOffset,
            cop = that.containerPosition,
            ce = that.containerElement,
            helper = $(that.helper),
            ho = helper.offset(),
            w = helper.outerWidth() - that.sizeDiff.width,
            h = helper.outerHeight() - that.sizeDiff.height;
        if (that._helper && !o.animate && (/relative/).test(ce.css("position"))) {
          $(this).css({
            left: ho.left - cop.left - co.left,
            width: w,
            height: h
          });
        }
        if (that._helper && !o.animate && (/static/).test(ce.css("position"))) {
          $(this).css({
            left: ho.left - cop.left - co.left,
            width: w,
            height: h
          });
        }
      }
    });
    $.ui.plugin.add("resizable", "alsoResize", {
      start: function() {
        var that = $(this).resizable("instance"),
            o = that.options,
            _store = function(exp) {
              $(exp).each(function() {
                var el = $(this);
                el.data("ui-resizable-alsoresize", {
                  width: parseInt(el.width(), 10),
                  height: parseInt(el.height(), 10),
                  left: parseInt(el.css("left"), 10),
                  top: parseInt(el.css("top"), 10)
                });
              });
            };
        if (typeof(o.alsoResize) === "object" && !o.alsoResize.parentNode) {
          if (o.alsoResize.length) {
            o.alsoResize = o.alsoResize[0];
            _store(o.alsoResize);
          } else {
            $.each(o.alsoResize, function(exp) {
              _store(exp);
            });
          }
        } else {
          _store(o.alsoResize);
        }
      },
      resize: function(event, ui) {
        var that = $(this).resizable("instance"),
            o = that.options,
            os = that.originalSize,
            op = that.originalPosition,
            delta = {
              height: (that.size.height - os.height) || 0,
              width: (that.size.width - os.width) || 0,
              top: (that.position.top - op.top) || 0,
              left: (that.position.left - op.left) || 0
            },
            _alsoResize = function(exp, c) {
              $(exp).each(function() {
                var el = $(this),
                    start = $(this).data("ui-resizable-alsoresize"),
                    style = {},
                    css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ["width", "height"] : ["width", "height", "top", "left"];
                $.each(css, function(i, prop) {
                  var sum = (start[prop] || 0) + (delta[prop] || 0);
                  if (sum && sum >= 0) {
                    style[prop] = sum || null;
                  }
                });
                el.css(style);
              });
            };
        if (typeof(o.alsoResize) === "object" && !o.alsoResize.nodeType) {
          $.each(o.alsoResize, function(exp, c) {
            _alsoResize(exp, c);
          });
        } else {
          _alsoResize(o.alsoResize);
        }
      },
      stop: function() {
        $(this).removeData("resizable-alsoresize");
      }
    });
    $.ui.plugin.add("resizable", "ghost", {
      start: function() {
        var that = $(this).resizable("instance"),
            o = that.options,
            cs = that.size;
        that.ghost = that.originalElement.clone();
        that.ghost.css({
          opacity: 0.25,
          display: "block",
          position: "relative",
          height: cs.height,
          width: cs.width,
          margin: 0,
          left: 0,
          top: 0
        }).addClass("ui-resizable-ghost").addClass(typeof o.ghost === "string" ? o.ghost : "");
        that.ghost.appendTo(that.helper);
      },
      resize: function() {
        var that = $(this).resizable("instance");
        if (that.ghost) {
          that.ghost.css({
            position: "relative",
            height: that.size.height,
            width: that.size.width
          });
        }
      },
      stop: function() {
        var that = $(this).resizable("instance");
        if (that.ghost && that.helper) {
          that.helper.get(0).removeChild(that.ghost.get(0));
        }
      }
    });
    $.ui.plugin.add("resizable", "grid", {resize: function() {
        var outerDimensions,
            that = $(this).resizable("instance"),
            o = that.options,
            cs = that.size,
            os = that.originalSize,
            op = that.originalPosition,
            a = that.axis,
            grid = typeof o.grid === "number" ? [o.grid, o.grid] : o.grid,
            gridX = (grid[0] || 1),
            gridY = (grid[1] || 1),
            ox = Math.round((cs.width - os.width) / gridX) * gridX,
            oy = Math.round((cs.height - os.height) / gridY) * gridY,
            newWidth = os.width + ox,
            newHeight = os.height + oy,
            isMaxWidth = o.maxWidth && (o.maxWidth < newWidth),
            isMaxHeight = o.maxHeight && (o.maxHeight < newHeight),
            isMinWidth = o.minWidth && (o.minWidth > newWidth),
            isMinHeight = o.minHeight && (o.minHeight > newHeight);
        o.grid = grid;
        if (isMinWidth) {
          newWidth += gridX;
        }
        if (isMinHeight) {
          newHeight += gridY;
        }
        if (isMaxWidth) {
          newWidth -= gridX;
        }
        if (isMaxHeight) {
          newHeight -= gridY;
        }
        if (/^(se|s|e)$/.test(a)) {
          that.size.width = newWidth;
          that.size.height = newHeight;
        } else if (/^(ne)$/.test(a)) {
          that.size.width = newWidth;
          that.size.height = newHeight;
          that.position.top = op.top - oy;
        } else if (/^(sw)$/.test(a)) {
          that.size.width = newWidth;
          that.size.height = newHeight;
          that.position.left = op.left - ox;
        } else {
          if (newHeight - gridY <= 0 || newWidth - gridX <= 0) {
            outerDimensions = that._getPaddingPlusBorderDimensions(this);
          }
          if (newHeight - gridY > 0) {
            that.size.height = newHeight;
            that.position.top = op.top - oy;
          } else {
            newHeight = gridY - outerDimensions.height;
            that.size.height = newHeight;
            that.position.top = op.top + os.height - newHeight;
          }
          if (newWidth - gridX > 0) {
            that.size.width = newWidth;
            that.position.left = op.left - ox;
          } else {
            newWidth = gridY - outerDimensions.height;
            that.size.width = newWidth;
            that.position.left = op.left + os.width - newWidth;
          }
        }
      }});
    var resizable = $.ui.resizable;
    var dialog = $.widget("ui.dialog", {
      version: "1.11.1",
      options: {
        appendTo: "body",
        autoOpen: true,
        buttons: [],
        closeOnEscape: true,
        closeText: "Close",
        dialogClass: "",
        draggable: true,
        hide: null,
        height: "auto",
        maxHeight: null,
        maxWidth: null,
        minHeight: 150,
        minWidth: 150,
        modal: false,
        position: {
          my: "center",
          at: "center",
          of: window,
          collision: "fit",
          using: function(pos) {
            var topOffset = $(this).css(pos).offset().top;
            if (topOffset < 0) {
              $(this).css("top", pos.top - topOffset);
            }
          }
        },
        resizable: true,
        show: null,
        title: null,
        width: 300,
        beforeClose: null,
        close: null,
        drag: null,
        dragStart: null,
        dragStop: null,
        focus: null,
        open: null,
        resize: null,
        resizeStart: null,
        resizeStop: null
      },
      sizeRelatedOptions: {
        buttons: true,
        height: true,
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true,
        width: true
      },
      resizableRelatedOptions: {
        maxHeight: true,
        maxWidth: true,
        minHeight: true,
        minWidth: true
      },
      _create: function() {
        this.originalCss = {
          display: this.element[0].style.display,
          width: this.element[0].style.width,
          minHeight: this.element[0].style.minHeight,
          maxHeight: this.element[0].style.maxHeight,
          height: this.element[0].style.height
        };
        this.originalPosition = {
          parent: this.element.parent(),
          index: this.element.parent().children().index(this.element)
        };
        this.originalTitle = this.element.attr("title");
        this.options.title = this.options.title || this.originalTitle;
        this._createWrapper();
        this.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(this.uiDialog);
        this._createTitlebar();
        this._createButtonPane();
        if (this.options.draggable && $.fn.draggable) {
          this._makeDraggable();
        }
        if (this.options.resizable && $.fn.resizable) {
          this._makeResizable();
        }
        this._isOpen = false;
        this._trackFocus();
      },
      _init: function() {
        if (this.options.autoOpen) {
          this.open();
        }
      },
      _appendTo: function() {
        var element = this.options.appendTo;
        if (element && (element.jquery || element.nodeType)) {
          return $(element);
        }
        return this.document.find(element || "body").eq(0);
      },
      _destroy: function() {
        var next,
            originalPosition = this.originalPosition;
        this._destroyOverlay();
        this.element.removeUniqueId().removeClass("ui-dialog-content ui-widget-content").css(this.originalCss).detach();
        this.uiDialog.stop(true, true).remove();
        if (this.originalTitle) {
          this.element.attr("title", this.originalTitle);
        }
        next = originalPosition.parent.children().eq(originalPosition.index);
        if (next.length && next[0] !== this.element[0]) {
          next.before(this.element);
        } else {
          originalPosition.parent.append(this.element);
        }
      },
      widget: function() {
        return this.uiDialog;
      },
      disable: $.noop,
      enable: $.noop,
      close: function(event) {
        var activeElement,
            that = this;
        if (!this._isOpen || this._trigger("beforeClose", event) === false) {
          return;
        }
        this._isOpen = false;
        this._focusedElement = null;
        this._destroyOverlay();
        this._untrackInstance();
        if (!this.opener.filter(":focusable").focus().length) {
          try {
            activeElement = this.document[0].activeElement;
            if (activeElement && activeElement.nodeName.toLowerCase() !== "body") {
              $(activeElement).blur();
            }
          } catch (error) {}
        }
        this._hide(this.uiDialog, this.options.hide, function() {
          that._trigger("close", event);
        });
      },
      isOpen: function() {
        return this._isOpen;
      },
      moveToTop: function() {
        this._moveToTop();
      },
      _moveToTop: function(event, silent) {
        var moved = false,
            zIndicies = this.uiDialog.siblings(".ui-front:visible").map(function() {
              return +$(this).css("z-index");
            }).get(),
            zIndexMax = Math.max.apply(null, zIndicies);
        if (zIndexMax >= +this.uiDialog.css("z-index")) {
          this.uiDialog.css("z-index", zIndexMax + 1);
          moved = true;
        }
        if (moved && !silent) {
          this._trigger("focus", event);
        }
        return moved;
      },
      open: function() {
        var that = this;
        if (this._isOpen) {
          if (this._moveToTop()) {
            this._focusTabbable();
          }
          return;
        }
        this._isOpen = true;
        this.opener = $(this.document[0].activeElement);
        this._size();
        this._position();
        this._createOverlay();
        this._moveToTop(null, true);
        if (this.overlay) {
          this.overlay.css("z-index", this.uiDialog.css("z-index") - 1);
        }
        this._show(this.uiDialog, this.options.show, function() {
          that._focusTabbable();
          that._trigger("focus");
        });
        this._makeFocusTarget();
        this._trigger("open");
      },
      _focusTabbable: function() {
        var hasFocus = this._focusedElement;
        if (!hasFocus) {
          hasFocus = this.element.find("[autofocus]");
        }
        if (!hasFocus.length) {
          hasFocus = this.element.find(":tabbable");
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialogButtonPane.find(":tabbable");
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialogTitlebarClose.filter(":tabbable");
        }
        if (!hasFocus.length) {
          hasFocus = this.uiDialog;
        }
        hasFocus.eq(0).focus();
      },
      _keepFocus: function(event) {
        function checkFocus() {
          var activeElement = this.document[0].activeElement,
              isActive = this.uiDialog[0] === activeElement || $.contains(this.uiDialog[0], activeElement);
          if (!isActive) {
            this._focusTabbable();
          }
        }
        event.preventDefault();
        checkFocus.call(this);
        this._delay(checkFocus);
      },
      _createWrapper: function() {
        this.uiDialog = $("<div>").addClass("ui-dialog ui-widget ui-widget-content ui-corner-all ui-front " + this.options.dialogClass).hide().attr({
          tabIndex: -1,
          role: "dialog"
        }).appendTo(this._appendTo());
        this._on(this.uiDialog, {
          keydown: function(event) {
            if (this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode && event.keyCode === $.ui.keyCode.ESCAPE) {
              event.preventDefault();
              this.close(event);
              return;
            }
            if (event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented()) {
              return;
            }
            var tabbables = this.uiDialog.find(":tabbable"),
                first = tabbables.filter(":first"),
                last = tabbables.filter(":last");
            if ((event.target === last[0] || event.target === this.uiDialog[0]) && !event.shiftKey) {
              this._delay(function() {
                first.focus();
              });
              event.preventDefault();
            } else if ((event.target === first[0] || event.target === this.uiDialog[0]) && event.shiftKey) {
              this._delay(function() {
                last.focus();
              });
              event.preventDefault();
            }
          },
          mousedown: function(event) {
            if (this._moveToTop(event)) {
              this._focusTabbable();
            }
          }
        });
        if (!this.element.find("[aria-describedby]").length) {
          this.uiDialog.attr({"aria-describedby": this.element.uniqueId().attr("id")});
        }
      },
      _createTitlebar: function() {
        var uiDialogTitle;
        this.uiDialogTitlebar = $("<div>").addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(this.uiDialog);
        this._on(this.uiDialogTitlebar, {mousedown: function(event) {
            if (!$(event.target).closest(".ui-dialog-titlebar-close")) {
              this.uiDialog.focus();
            }
          }});
        this.uiDialogTitlebarClose = $("<button type='button'></button>").button({
          label: this.options.closeText,
          icons: {primary: "ui-icon-closethick"},
          text: false
        }).addClass("ui-dialog-titlebar-close").appendTo(this.uiDialogTitlebar);
        this._on(this.uiDialogTitlebarClose, {click: function(event) {
            event.preventDefault();
            this.close(event);
          }});
        uiDialogTitle = $("<span>").uniqueId().addClass("ui-dialog-title").prependTo(this.uiDialogTitlebar);
        this._title(uiDialogTitle);
        this.uiDialog.attr({"aria-labelledby": uiDialogTitle.attr("id")});
      },
      _title: function(title) {
        if (!this.options.title) {
          title.html("&#160;");
        }
        title.text(this.options.title);
      },
      _createButtonPane: function() {
        this.uiDialogButtonPane = $("<div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix");
        this.uiButtonSet = $("<div>").addClass("ui-dialog-buttonset").appendTo(this.uiDialogButtonPane);
        this._createButtons();
      },
      _createButtons: function() {
        var that = this,
            buttons = this.options.buttons;
        this.uiDialogButtonPane.remove();
        this.uiButtonSet.empty();
        if ($.isEmptyObject(buttons) || ($.isArray(buttons) && !buttons.length)) {
          this.uiDialog.removeClass("ui-dialog-buttons");
          return;
        }
        $.each(buttons, function(name, props) {
          var click,
              buttonOptions;
          props = $.isFunction(props) ? {
            click: props,
            text: name
          } : props;
          props = $.extend({type: "button"}, props);
          click = props.click;
          props.click = function() {
            click.apply(that.element[0], arguments);
          };
          buttonOptions = {
            icons: props.icons,
            text: props.showText
          };
          delete props.icons;
          delete props.showText;
          $("<button></button>", props).button(buttonOptions).appendTo(that.uiButtonSet);
        });
        this.uiDialog.addClass("ui-dialog-buttons");
        this.uiDialogButtonPane.appendTo(this.uiDialog);
      },
      _makeDraggable: function() {
        var that = this,
            options = this.options;
        function filteredUi(ui) {
          return {
            position: ui.position,
            offset: ui.offset
          };
        }
        this.uiDialog.draggable({
          cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
          handle: ".ui-dialog-titlebar",
          containment: "document",
          start: function(event, ui) {
            $(this).addClass("ui-dialog-dragging");
            that._blockFrames();
            that._trigger("dragStart", event, filteredUi(ui));
          },
          drag: function(event, ui) {
            that._trigger("drag", event, filteredUi(ui));
          },
          stop: function(event, ui) {
            var left = ui.offset.left - that.document.scrollLeft(),
                top = ui.offset.top - that.document.scrollTop();
            options.position = {
              my: "left top",
              at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
              of: that.window
            };
            $(this).removeClass("ui-dialog-dragging");
            that._unblockFrames();
            that._trigger("dragStop", event, filteredUi(ui));
          }
        });
      },
      _makeResizable: function() {
        var that = this,
            options = this.options,
            handles = options.resizable,
            position = this.uiDialog.css("position"),
            resizeHandles = typeof handles === "string" ? handles : "n,e,s,w,se,sw,ne,nw";
        function filteredUi(ui) {
          return {
            originalPosition: ui.originalPosition,
            originalSize: ui.originalSize,
            position: ui.position,
            size: ui.size
          };
        }
        this.uiDialog.resizable({
          cancel: ".ui-dialog-content",
          containment: "document",
          alsoResize: this.element,
          maxWidth: options.maxWidth,
          maxHeight: options.maxHeight,
          minWidth: options.minWidth,
          minHeight: this._minHeight(),
          handles: resizeHandles,
          start: function(event, ui) {
            $(this).addClass("ui-dialog-resizing");
            that._blockFrames();
            that._trigger("resizeStart", event, filteredUi(ui));
          },
          resize: function(event, ui) {
            that._trigger("resize", event, filteredUi(ui));
          },
          stop: function(event, ui) {
            var offset = that.uiDialog.offset(),
                left = offset.left - that.document.scrollLeft(),
                top = offset.top - that.document.scrollTop();
            options.height = that.uiDialog.height();
            options.width = that.uiDialog.width();
            options.position = {
              my: "left top",
              at: "left" + (left >= 0 ? "+" : "") + left + " " + "top" + (top >= 0 ? "+" : "") + top,
              of: that.window
            };
            $(this).removeClass("ui-dialog-resizing");
            that._unblockFrames();
            that._trigger("resizeStop", event, filteredUi(ui));
          }
        }).css("position", position);
      },
      _trackFocus: function() {
        this._on(this.widget(), {focusin: function(event) {
            this._makeFocusTarget();
            this._focusedElement = $(event.target);
          }});
      },
      _makeFocusTarget: function() {
        this._untrackInstance();
        this._trackingInstances().unshift(this);
      },
      _untrackInstance: function() {
        var instances = this._trackingInstances(),
            exists = $.inArray(this, instances);
        if (exists !== -1) {
          instances.splice(exists, 1);
        }
      },
      _trackingInstances: function() {
        var instances = this.document.data("ui-dialog-instances");
        if (!instances) {
          instances = [];
          this.document.data("ui-dialog-instances", instances);
        }
        return instances;
      },
      _minHeight: function() {
        var options = this.options;
        return options.height === "auto" ? options.minHeight : Math.min(options.minHeight, options.height);
      },
      _position: function() {
        var isVisible = this.uiDialog.is(":visible");
        if (!isVisible) {
          this.uiDialog.show();
        }
        this.uiDialog.position(this.options.position);
        if (!isVisible) {
          this.uiDialog.hide();
        }
      },
      _setOptions: function(options) {
        var that = this,
            resize = false,
            resizableOptions = {};
        $.each(options, function(key, value) {
          that._setOption(key, value);
          if (key in that.sizeRelatedOptions) {
            resize = true;
          }
          if (key in that.resizableRelatedOptions) {
            resizableOptions[key] = value;
          }
        });
        if (resize) {
          this._size();
          this._position();
        }
        if (this.uiDialog.is(":data(ui-resizable)")) {
          this.uiDialog.resizable("option", resizableOptions);
        }
      },
      _setOption: function(key, value) {
        var isDraggable,
            isResizable,
            uiDialog = this.uiDialog;
        if (key === "dialogClass") {
          uiDialog.removeClass(this.options.dialogClass).addClass(value);
        }
        if (key === "disabled") {
          return;
        }
        this._super(key, value);
        if (key === "appendTo") {
          this.uiDialog.appendTo(this._appendTo());
        }
        if (key === "buttons") {
          this._createButtons();
        }
        if (key === "closeText") {
          this.uiDialogTitlebarClose.button({label: "" + value});
        }
        if (key === "draggable") {
          isDraggable = uiDialog.is(":data(ui-draggable)");
          if (isDraggable && !value) {
            uiDialog.draggable("destroy");
          }
          if (!isDraggable && value) {
            this._makeDraggable();
          }
        }
        if (key === "position") {
          this._position();
        }
        if (key === "resizable") {
          isResizable = uiDialog.is(":data(ui-resizable)");
          if (isResizable && !value) {
            uiDialog.resizable("destroy");
          }
          if (isResizable && typeof value === "string") {
            uiDialog.resizable("option", "handles", value);
          }
          if (!isResizable && value !== false) {
            this._makeResizable();
          }
        }
        if (key === "title") {
          this._title(this.uiDialogTitlebar.find(".ui-dialog-title"));
        }
      },
      _size: function() {
        var nonContentHeight,
            minContentHeight,
            maxContentHeight,
            options = this.options;
        this.element.show().css({
          width: "auto",
          minHeight: 0,
          maxHeight: "none",
          height: 0
        });
        if (options.minWidth > options.width) {
          options.width = options.minWidth;
        }
        nonContentHeight = this.uiDialog.css({
          height: "auto",
          width: options.width
        }).outerHeight();
        minContentHeight = Math.max(0, options.minHeight - nonContentHeight);
        maxContentHeight = typeof options.maxHeight === "number" ? Math.max(0, options.maxHeight - nonContentHeight) : "none";
        if (options.height === "auto") {
          this.element.css({
            minHeight: minContentHeight,
            maxHeight: maxContentHeight,
            height: "auto"
          });
        } else {
          this.element.height(Math.max(0, options.height - nonContentHeight));
        }
        if (this.uiDialog.is(":data(ui-resizable)")) {
          this.uiDialog.resizable("option", "minHeight", this._minHeight());
        }
      },
      _blockFrames: function() {
        this.iframeBlocks = this.document.find("iframe").map(function() {
          var iframe = $(this);
          return $("<div>").css({
            position: "absolute",
            width: iframe.outerWidth(),
            height: iframe.outerHeight()
          }).appendTo(iframe.parent()).offset(iframe.offset())[0];
        });
      },
      _unblockFrames: function() {
        if (this.iframeBlocks) {
          this.iframeBlocks.remove();
          delete this.iframeBlocks;
        }
      },
      _allowInteraction: function(event) {
        if ($(event.target).closest(".ui-dialog").length) {
          return true;
        }
        return !!$(event.target).closest(".ui-datepicker").length;
      },
      _createOverlay: function() {
        if (!this.options.modal) {
          return;
        }
        var isOpening = true;
        this._delay(function() {
          isOpening = false;
        });
        if (!this.document.data("ui-dialog-overlays")) {
          this._on(this.document, {focusin: function(event) {
              if (isOpening) {
                return;
              }
              if (!this._allowInteraction(event)) {
                event.preventDefault();
                this._trackingInstances()[0]._focusTabbable();
              }
            }});
        }
        this.overlay = $("<div>").addClass("ui-widget-overlay ui-front").appendTo(this._appendTo());
        this._on(this.overlay, {mousedown: "_keepFocus"});
        this.document.data("ui-dialog-overlays", (this.document.data("ui-dialog-overlays") || 0) + 1);
      },
      _destroyOverlay: function() {
        if (!this.options.modal) {
          return;
        }
        if (this.overlay) {
          var overlays = this.document.data("ui-dialog-overlays") - 1;
          if (!overlays) {
            this.document.unbind("focusin").removeData("ui-dialog-overlays");
          } else {
            this.document.data("ui-dialog-overlays", overlays);
          }
          this.overlay.remove();
          this.overlay = null;
        }
      }
    });
    $.widget("ui.droppable", {
      version: "1.11.1",
      widgetEventPrefix: "drop",
      options: {
        accept: "*",
        activeClass: false,
        addClasses: true,
        greedy: false,
        hoverClass: false,
        scope: "default",
        tolerance: "intersect",
        activate: null,
        deactivate: null,
        drop: null,
        out: null,
        over: null
      },
      _create: function() {
        var proportions,
            o = this.options,
            accept = o.accept;
        this.isover = false;
        this.isout = true;
        this.accept = $.isFunction(accept) ? accept : function(d) {
          return d.is(accept);
        };
        this.proportions = function() {
          if (arguments.length) {
            proportions = arguments[0];
          } else {
            return proportions ? proportions : proportions = {
              width: this.element[0].offsetWidth,
              height: this.element[0].offsetHeight
            };
          }
        };
        this._addToManager(o.scope);
        o.addClasses && this.element.addClass("ui-droppable");
      },
      _addToManager: function(scope) {
        $.ui.ddmanager.droppables[scope] = $.ui.ddmanager.droppables[scope] || [];
        $.ui.ddmanager.droppables[scope].push(this);
      },
      _splice: function(drop) {
        var i = 0;
        for (; i < drop.length; i++) {
          if (drop[i] === this) {
            drop.splice(i, 1);
          }
        }
      },
      _destroy: function() {
        var drop = $.ui.ddmanager.droppables[this.options.scope];
        this._splice(drop);
        this.element.removeClass("ui-droppable ui-droppable-disabled");
      },
      _setOption: function(key, value) {
        if (key === "accept") {
          this.accept = $.isFunction(value) ? value : function(d) {
            return d.is(value);
          };
        } else if (key === "scope") {
          var drop = $.ui.ddmanager.droppables[this.options.scope];
          this._splice(drop);
          this._addToManager(value);
        }
        this._super(key, value);
      },
      _activate: function(event) {
        var draggable = $.ui.ddmanager.current;
        if (this.options.activeClass) {
          this.element.addClass(this.options.activeClass);
        }
        if (draggable) {
          this._trigger("activate", event, this.ui(draggable));
        }
      },
      _deactivate: function(event) {
        var draggable = $.ui.ddmanager.current;
        if (this.options.activeClass) {
          this.element.removeClass(this.options.activeClass);
        }
        if (draggable) {
          this._trigger("deactivate", event, this.ui(draggable));
        }
      },
      _over: function(event) {
        var draggable = $.ui.ddmanager.current;
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
          return;
        }
        if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
          if (this.options.hoverClass) {
            this.element.addClass(this.options.hoverClass);
          }
          this._trigger("over", event, this.ui(draggable));
        }
      },
      _out: function(event) {
        var draggable = $.ui.ddmanager.current;
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
          return;
        }
        if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
          if (this.options.hoverClass) {
            this.element.removeClass(this.options.hoverClass);
          }
          this._trigger("out", event, this.ui(draggable));
        }
      },
      _drop: function(event, custom) {
        var draggable = custom || $.ui.ddmanager.current,
            childrenIntersection = false;
        if (!draggable || (draggable.currentItem || draggable.element)[0] === this.element[0]) {
          return false;
        }
        this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function() {
          var inst = $(this).droppable("instance");
          if (inst.options.greedy && !inst.options.disabled && inst.options.scope === draggable.options.scope && inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element)) && $.ui.intersect(draggable, $.extend(inst, {offset: inst.element.offset()}), inst.options.tolerance, event)) {
            childrenIntersection = true;
            return false;
          }
        });
        if (childrenIntersection) {
          return false;
        }
        if (this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
          if (this.options.activeClass) {
            this.element.removeClass(this.options.activeClass);
          }
          if (this.options.hoverClass) {
            this.element.removeClass(this.options.hoverClass);
          }
          this._trigger("drop", event, this.ui(draggable));
          return this.element;
        }
        return false;
      },
      ui: function(c) {
        return {
          draggable: (c.currentItem || c.element),
          helper: c.helper,
          position: c.position,
          offset: c.positionAbs
        };
      }
    });
    $.ui.intersect = (function() {
      function isOverAxis(x, reference, size) {
        return (x >= reference) && (x < (reference + size));
      }
      return function(draggable, droppable, toleranceMode, event) {
        if (!droppable.offset) {
          return false;
        }
        var x1 = (draggable.positionAbs || draggable.position.absolute).left,
            y1 = (draggable.positionAbs || draggable.position.absolute).top,
            x2 = x1 + draggable.helperProportions.width,
            y2 = y1 + draggable.helperProportions.height,
            l = droppable.offset.left,
            t = droppable.offset.top,
            r = l + droppable.proportions().width,
            b = t + droppable.proportions().height;
        switch (toleranceMode) {
          case "fit":
            return (l <= x1 && x2 <= r && t <= y1 && y2 <= b);
          case "intersect":
            return (l < x1 + (draggable.helperProportions.width / 2) && x2 - (draggable.helperProportions.width / 2) < r && t < y1 + (draggable.helperProportions.height / 2) && y2 - (draggable.helperProportions.height / 2) < b);
          case "pointer":
            return isOverAxis(event.pageY, t, droppable.proportions().height) && isOverAxis(event.pageX, l, droppable.proportions().width);
          case "touch":
            return ((y1 >= t && y1 <= b) || (y2 >= t && y2 <= b) || (y1 < t && y2 > b)) && ((x1 >= l && x1 <= r) || (x2 >= l && x2 <= r) || (x1 < l && x2 > r));
          default:
            return false;
        }
      };
    })();
    $.ui.ddmanager = {
      current: null,
      droppables: {"default": []},
      prepareOffsets: function(t, event) {
        var i,
            j,
            m = $.ui.ddmanager.droppables[t.options.scope] || [],
            type = event ? event.type : null,
            list = (t.currentItem || t.element).find(":data(ui-droppable)").addBack();
        droppablesLoop: for (i = 0; i < m.length; i++) {
          if (m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0], (t.currentItem || t.element)))) {
            continue;
          }
          for (j = 0; j < list.length; j++) {
            if (list[j] === m[i].element[0]) {
              m[i].proportions().height = 0;
              continue droppablesLoop;
            }
          }
          m[i].visible = m[i].element.css("display") !== "none";
          if (!m[i].visible) {
            continue;
          }
          if (type === "mousedown") {
            m[i]._activate.call(m[i], event);
          }
          m[i].offset = m[i].element.offset();
          m[i].proportions({
            width: m[i].element[0].offsetWidth,
            height: m[i].element[0].offsetHeight
          });
        }
      },
      drop: function(draggable, event) {
        var dropped = false;
        $.each(($.ui.ddmanager.droppables[draggable.options.scope] || []).slice(), function() {
          if (!this.options) {
            return;
          }
          if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance, event)) {
            dropped = this._drop.call(this, event) || dropped;
          }
          if (!this.options.disabled && this.visible && this.accept.call(this.element[0], (draggable.currentItem || draggable.element))) {
            this.isout = true;
            this.isover = false;
            this._deactivate.call(this, event);
          }
        });
        return dropped;
      },
      dragStart: function(draggable, event) {
        draggable.element.parentsUntil("body").bind("scroll.droppable", function() {
          if (!draggable.options.refreshPositions) {
            $.ui.ddmanager.prepareOffsets(draggable, event);
          }
        });
      },
      drag: function(draggable, event) {
        if (draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
        $.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {
          if (this.options.disabled || this.greedyChild || !this.visible) {
            return;
          }
          var parentInstance,
              scope,
              parent,
              intersects = $.ui.intersect(draggable, this, this.options.tolerance, event),
              c = !intersects && this.isover ? "isout" : (intersects && !this.isover ? "isover" : null);
          if (!c) {
            return;
          }
          if (this.options.greedy) {
            scope = this.options.scope;
            parent = this.element.parents(":data(ui-droppable)").filter(function() {
              return $(this).droppable("instance").options.scope === scope;
            });
            if (parent.length) {
              parentInstance = $(parent[0]).droppable("instance");
              parentInstance.greedyChild = (c === "isover");
            }
          }
          if (parentInstance && c === "isover") {
            parentInstance.isover = false;
            parentInstance.isout = true;
            parentInstance._out.call(parentInstance, event);
          }
          this[c] = true;
          this[c === "isout" ? "isover" : "isout"] = false;
          this[c === "isover" ? "_over" : "_out"].call(this, event);
          if (parentInstance && c === "isout") {
            parentInstance.isout = false;
            parentInstance.isover = true;
            parentInstance._over.call(parentInstance, event);
          }
        });
      },
      dragStop: function(draggable, event) {
        draggable.element.parentsUntil("body").unbind("scroll.droppable");
        if (!draggable.options.refreshPositions) {
          $.ui.ddmanager.prepareOffsets(draggable, event);
        }
      }
    };
    var droppable = $.ui.droppable;
    var dataSpace = "ui-effects-",
        jQuery = $;
    $.effects = {effect: {}};
    (function(jQuery, undefined) {
      var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",
          rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,
          stringParsers = [{
            re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
              return [execResult[1], execResult[2], execResult[3], execResult[4]];
            }
          }, {
            re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            parse: function(execResult) {
              return [execResult[1] * 2.55, execResult[2] * 2.55, execResult[3] * 2.55, execResult[4]];
            }
          }, {
            re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
            parse: function(execResult) {
              return [parseInt(execResult[1], 16), parseInt(execResult[2], 16), parseInt(execResult[3], 16)];
            }
          }, {
            re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
            parse: function(execResult) {
              return [parseInt(execResult[1] + execResult[1], 16), parseInt(execResult[2] + execResult[2], 16), parseInt(execResult[3] + execResult[3], 16)];
            }
          }, {
            re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
            space: "hsla",
            parse: function(execResult) {
              return [execResult[1], execResult[2] / 100, execResult[3] / 100, execResult[4]];
            }
          }],
          color = jQuery.Color = function(color, green, blue, alpha) {
            return new jQuery.Color.fn.parse(color, green, blue, alpha);
          },
          spaces = {
            rgba: {props: {
                red: {
                  idx: 0,
                  type: "byte"
                },
                green: {
                  idx: 1,
                  type: "byte"
                },
                blue: {
                  idx: 2,
                  type: "byte"
                }
              }},
            hsla: {props: {
                hue: {
                  idx: 0,
                  type: "degrees"
                },
                saturation: {
                  idx: 1,
                  type: "percent"
                },
                lightness: {
                  idx: 2,
                  type: "percent"
                }
              }}
          },
          propTypes = {
            "byte": {
              floor: true,
              max: 255
            },
            "percent": {max: 1},
            "degrees": {
              mod: 360,
              floor: true
            }
          },
          support = color.support = {},
          supportElem = jQuery("<p>")[0],
          colors,
          each = jQuery.each;
      supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
      support.rgba = supportElem.style.backgroundColor.indexOf("rgba") > -1;
      each(spaces, function(spaceName, space) {
        space.cache = "_" + spaceName;
        space.props.alpha = {
          idx: 3,
          type: "percent",
          def: 1
        };
      });
      function clamp(value, prop, allowEmpty) {
        var type = propTypes[prop.type] || {};
        if (value == null) {
          return (allowEmpty || !prop.def) ? null : prop.def;
        }
        value = type.floor ? ~~value : parseFloat(value);
        if (isNaN(value)) {
          return prop.def;
        }
        if (type.mod) {
          return (value + type.mod) % type.mod;
        }
        return 0 > value ? 0 : type.max < value ? type.max : value;
      }
      function stringParse(string) {
        var inst = color(),
            rgba = inst._rgba = [];
        string = string.toLowerCase();
        each(stringParsers, function(i, parser) {
          var parsed,
              match = parser.re.exec(string),
              values = match && parser.parse(match),
              spaceName = parser.space || "rgba";
          if (values) {
            parsed = inst[spaceName](values);
            inst[spaces[spaceName].cache] = parsed[spaces[spaceName].cache];
            rgba = inst._rgba = parsed._rgba;
            return false;
          }
        });
        if (rgba.length) {
          if (rgba.join() === "0,0,0,0") {
            jQuery.extend(rgba, colors.transparent);
          }
          return inst;
        }
        return colors[string];
      }
      color.fn = jQuery.extend(color.prototype, {
        parse: function(red, green, blue, alpha) {
          if (red === undefined) {
            this._rgba = [null, null, null, null];
            return this;
          }
          if (red.jquery || red.nodeType) {
            red = jQuery(red).css(green);
            green = undefined;
          }
          var inst = this,
              type = jQuery.type(red),
              rgba = this._rgba = [];
          if (green !== undefined) {
            red = [red, green, blue, alpha];
            type = "array";
          }
          if (type === "string") {
            return this.parse(stringParse(red) || colors._default);
          }
          if (type === "array") {
            each(spaces.rgba.props, function(key, prop) {
              rgba[prop.idx] = clamp(red[prop.idx], prop);
            });
            return this;
          }
          if (type === "object") {
            if (red instanceof color) {
              each(spaces, function(spaceName, space) {
                if (red[space.cache]) {
                  inst[space.cache] = red[space.cache].slice();
                }
              });
            } else {
              each(spaces, function(spaceName, space) {
                var cache = space.cache;
                each(space.props, function(key, prop) {
                  if (!inst[cache] && space.to) {
                    if (key === "alpha" || red[key] == null) {
                      return;
                    }
                    inst[cache] = space.to(inst._rgba);
                  }
                  inst[cache][prop.idx] = clamp(red[key], prop, true);
                });
                if (inst[cache] && jQuery.inArray(null, inst[cache].slice(0, 3)) < 0) {
                  inst[cache][3] = 1;
                  if (space.from) {
                    inst._rgba = space.from(inst[cache]);
                  }
                }
              });
            }
            return this;
          }
        },
        is: function(compare) {
          var is = color(compare),
              same = true,
              inst = this;
          each(spaces, function(_, space) {
            var localCache,
                isCache = is[space.cache];
            if (isCache) {
              localCache = inst[space.cache] || space.to && space.to(inst._rgba) || [];
              each(space.props, function(_, prop) {
                if (isCache[prop.idx] != null) {
                  same = (isCache[prop.idx] === localCache[prop.idx]);
                  return same;
                }
              });
            }
            return same;
          });
          return same;
        },
        _space: function() {
          var used = [],
              inst = this;
          each(spaces, function(spaceName, space) {
            if (inst[space.cache]) {
              used.push(spaceName);
            }
          });
          return used.pop();
        },
        transition: function(other, distance) {
          var end = color(other),
              spaceName = end._space(),
              space = spaces[spaceName],
              startColor = this.alpha() === 0 ? color("transparent") : this,
              start = startColor[space.cache] || space.to(startColor._rgba),
              result = start.slice();
          end = end[space.cache];
          each(space.props, function(key, prop) {
            var index = prop.idx,
                startValue = start[index],
                endValue = end[index],
                type = propTypes[prop.type] || {};
            if (endValue === null) {
              return;
            }
            if (startValue === null) {
              result[index] = endValue;
            } else {
              if (type.mod) {
                if (endValue - startValue > type.mod / 2) {
                  startValue += type.mod;
                } else if (startValue - endValue > type.mod / 2) {
                  startValue -= type.mod;
                }
              }
              result[index] = clamp((endValue - startValue) * distance + startValue, prop);
            }
          });
          return this[spaceName](result);
        },
        blend: function(opaque) {
          if (this._rgba[3] === 1) {
            return this;
          }
          var rgb = this._rgba.slice(),
              a = rgb.pop(),
              blend = color(opaque)._rgba;
          return color(jQuery.map(rgb, function(v, i) {
            return (1 - a) * blend[i] + a * v;
          }));
        },
        toRgbaString: function() {
          var prefix = "rgba(",
              rgba = jQuery.map(this._rgba, function(v, i) {
                return v == null ? (i > 2 ? 1 : 0) : v;
              });
          if (rgba[3] === 1) {
            rgba.pop();
            prefix = "rgb(";
          }
          return prefix + rgba.join() + ")";
        },
        toHslaString: function() {
          var prefix = "hsla(",
              hsla = jQuery.map(this.hsla(), function(v, i) {
                if (v == null) {
                  v = i > 2 ? 1 : 0;
                }
                if (i && i < 3) {
                  v = Math.round(v * 100) + "%";
                }
                return v;
              });
          if (hsla[3] === 1) {
            hsla.pop();
            prefix = "hsl(";
          }
          return prefix + hsla.join() + ")";
        },
        toHexString: function(includeAlpha) {
          var rgba = this._rgba.slice(),
              alpha = rgba.pop();
          if (includeAlpha) {
            rgba.push(~~(alpha * 255));
          }
          return "#" + jQuery.map(rgba, function(v) {
            v = (v || 0).toString(16);
            return v.length === 1 ? "0" + v : v;
          }).join("");
        },
        toString: function() {
          return this._rgba[3] === 0 ? "transparent" : this.toRgbaString();
        }
      });
      color.fn.parse.prototype = color.fn;
      function hue2rgb(p, q, h) {
        h = (h + 1) % 1;
        if (h * 6 < 1) {
          return p + (q - p) * h * 6;
        }
        if (h * 2 < 1) {
          return q;
        }
        if (h * 3 < 2) {
          return p + (q - p) * ((2 / 3) - h) * 6;
        }
        return p;
      }
      spaces.hsla.to = function(rgba) {
        if (rgba[0] == null || rgba[1] == null || rgba[2] == null) {
          return [null, null, null, rgba[3]];
        }
        var r = rgba[0] / 255,
            g = rgba[1] / 255,
            b = rgba[2] / 255,
            a = rgba[3],
            max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            diff = max - min,
            add = max + min,
            l = add * 0.5,
            h,
            s;
        if (min === max) {
          h = 0;
        } else if (r === max) {
          h = (60 * (g - b) / diff) + 360;
        } else if (g === max) {
          h = (60 * (b - r) / diff) + 120;
        } else {
          h = (60 * (r - g) / diff) + 240;
        }
        if (diff === 0) {
          s = 0;
        } else if (l <= 0.5) {
          s = diff / add;
        } else {
          s = diff / (2 - add);
        }
        return [Math.round(h) % 360, s, l, a == null ? 1 : a];
      };
      spaces.hsla.from = function(hsla) {
        if (hsla[0] == null || hsla[1] == null || hsla[2] == null) {
          return [null, null, null, hsla[3]];
        }
        var h = hsla[0] / 360,
            s = hsla[1],
            l = hsla[2],
            a = hsla[3],
            q = l <= 0.5 ? l * (1 + s) : l + s - l * s,
            p = 2 * l - q;
        return [Math.round(hue2rgb(p, q, h + (1 / 3)) * 255), Math.round(hue2rgb(p, q, h) * 255), Math.round(hue2rgb(p, q, h - (1 / 3)) * 255), a];
      };
      each(spaces, function(spaceName, space) {
        var props = space.props,
            cache = space.cache,
            to = space.to,
            from = space.from;
        color.fn[spaceName] = function(value) {
          if (to && !this[cache]) {
            this[cache] = to(this._rgba);
          }
          if (value === undefined) {
            return this[cache].slice();
          }
          var ret,
              type = jQuery.type(value),
              arr = (type === "array" || type === "object") ? value : arguments,
              local = this[cache].slice();
          each(props, function(key, prop) {
            var val = arr[type === "object" ? key : prop.idx];
            if (val == null) {
              val = local[prop.idx];
            }
            local[prop.idx] = clamp(val, prop);
          });
          if (from) {
            ret = color(from(local));
            ret[cache] = local;
            return ret;
          } else {
            return color(local);
          }
        };
        each(props, function(key, prop) {
          if (color.fn[key]) {
            return;
          }
          color.fn[key] = function(value) {
            var vtype = jQuery.type(value),
                fn = (key === "alpha" ? (this._hsla ? "hsla" : "rgba") : spaceName),
                local = this[fn](),
                cur = local[prop.idx],
                match;
            if (vtype === "undefined") {
              return cur;
            }
            if (vtype === "function") {
              value = value.call(this, cur);
              vtype = jQuery.type(value);
            }
            if (value == null && prop.empty) {
              return this;
            }
            if (vtype === "string") {
              match = rplusequals.exec(value);
              if (match) {
                value = cur + parseFloat(match[2]) * (match[1] === "+" ? 1 : -1);
              }
            }
            local[prop.idx] = value;
            return this[fn](local);
          };
        });
      });
      color.hook = function(hook) {
        var hooks = hook.split(" ");
        each(hooks, function(i, hook) {
          jQuery.cssHooks[hook] = {set: function(elem, value) {
              var parsed,
                  curElem,
                  backgroundColor = "";
              if (value !== "transparent" && (jQuery.type(value) !== "string" || (parsed = stringParse(value)))) {
                value = color(parsed || value);
                if (!support.rgba && value._rgba[3] !== 1) {
                  curElem = hook === "backgroundColor" ? elem.parentNode : elem;
                  while ((backgroundColor === "" || backgroundColor === "transparent") && curElem && curElem.style) {
                    try {
                      backgroundColor = jQuery.css(curElem, "backgroundColor");
                      curElem = curElem.parentNode;
                    } catch (e) {}
                  }
                  value = value.blend(backgroundColor && backgroundColor !== "transparent" ? backgroundColor : "_default");
                }
                value = value.toRgbaString();
              }
              try {
                elem.style[hook] = value;
              } catch (e) {}
            }};
          jQuery.fx.step[hook] = function(fx) {
            if (!fx.colorInit) {
              fx.start = color(fx.elem, hook);
              fx.end = color(fx.end);
              fx.colorInit = true;
            }
            jQuery.cssHooks[hook].set(fx.elem, fx.start.transition(fx.end, fx.pos));
          };
        });
      };
      color.hook(stepHooks);
      jQuery.cssHooks.borderColor = {expand: function(value) {
          var expanded = {};
          each(["Top", "Right", "Bottom", "Left"], function(i, part) {
            expanded["border" + part + "Color"] = value;
          });
          return expanded;
        }};
      colors = jQuery.Color.names = {
        aqua: "#00ffff",
        black: "#000000",
        blue: "#0000ff",
        fuchsia: "#ff00ff",
        gray: "#808080",
        green: "#008000",
        lime: "#00ff00",
        maroon: "#800000",
        navy: "#000080",
        olive: "#808000",
        purple: "#800080",
        red: "#ff0000",
        silver: "#c0c0c0",
        teal: "#008080",
        white: "#ffffff",
        yellow: "#ffff00",
        transparent: [null, null, null, 0],
        _default: "#ffffff"
      };
    })(jQuery);
    (function() {
      var classAnimationActions = ["add", "remove", "toggle"],
          shorthandStyles = {
            border: 1,
            borderBottom: 1,
            borderColor: 1,
            borderLeft: 1,
            borderRight: 1,
            borderTop: 1,
            borderWidth: 1,
            margin: 1,
            padding: 1
          };
      $.each(["borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle"], function(_, prop) {
        $.fx.step[prop] = function(fx) {
          if (fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr) {
            jQuery.style(fx.elem, prop, fx.end);
            fx.setAttr = true;
          }
        };
      });
      function getElementStyles(elem) {
        var key,
            len,
            style = elem.ownerDocument.defaultView ? elem.ownerDocument.defaultView.getComputedStyle(elem, null) : elem.currentStyle,
            styles = {};
        if (style && style.length && style[0] && style[style[0]]) {
          len = style.length;
          while (len--) {
            key = style[len];
            if (typeof style[key] === "string") {
              styles[$.camelCase(key)] = style[key];
            }
          }
        } else {
          for (key in style) {
            if (typeof style[key] === "string") {
              styles[key] = style[key];
            }
          }
        }
        return styles;
      }
      function styleDifference(oldStyle, newStyle) {
        var diff = {},
            name,
            value;
        for (name in newStyle) {
          value = newStyle[name];
          if (oldStyle[name] !== value) {
            if (!shorthandStyles[name]) {
              if ($.fx.step[name] || !isNaN(parseFloat(value))) {
                diff[name] = value;
              }
            }
          }
        }
        return diff;
      }
      if (!$.fn.addBack) {
        $.fn.addBack = function(selector) {
          return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        };
      }
      $.effects.animateClass = function(value, duration, easing, callback) {
        var o = $.speed(duration, easing, callback);
        return this.queue(function() {
          var animated = $(this),
              baseClass = animated.attr("class") || "",
              applyClassChange,
              allAnimations = o.children ? animated.find("*").addBack() : animated;
          allAnimations = allAnimations.map(function() {
            var el = $(this);
            return {
              el: el,
              start: getElementStyles(this)
            };
          });
          applyClassChange = function() {
            $.each(classAnimationActions, function(i, action) {
              if (value[action]) {
                animated[action + "Class"](value[action]);
              }
            });
          };
          applyClassChange();
          allAnimations = allAnimations.map(function() {
            this.end = getElementStyles(this.el[0]);
            this.diff = styleDifference(this.start, this.end);
            return this;
          });
          animated.attr("class", baseClass);
          allAnimations = allAnimations.map(function() {
            var styleInfo = this,
                dfd = $.Deferred(),
                opts = $.extend({}, o, {
                  queue: false,
                  complete: function() {
                    dfd.resolve(styleInfo);
                  }
                });
            this.el.animate(this.diff, opts);
            return dfd.promise();
          });
          $.when.apply($, allAnimations.get()).done(function() {
            applyClassChange();
            $.each(arguments, function() {
              var el = this.el;
              $.each(this.diff, function(key) {
                el.css(key, "");
              });
            });
            o.complete.call(animated[0]);
          });
        });
      };
      $.fn.extend({
        addClass: (function(orig) {
          return function(classNames, speed, easing, callback) {
            return speed ? $.effects.animateClass.call(this, {add: classNames}, speed, easing, callback) : orig.apply(this, arguments);
          };
        })($.fn.addClass),
        removeClass: (function(orig) {
          return function(classNames, speed, easing, callback) {
            return arguments.length > 1 ? $.effects.animateClass.call(this, {remove: classNames}, speed, easing, callback) : orig.apply(this, arguments);
          };
        })($.fn.removeClass),
        toggleClass: (function(orig) {
          return function(classNames, force, speed, easing, callback) {
            if (typeof force === "boolean" || force === undefined) {
              if (!speed) {
                return orig.apply(this, arguments);
              } else {
                return $.effects.animateClass.call(this, (force ? {add: classNames} : {remove: classNames}), speed, easing, callback);
              }
            } else {
              return $.effects.animateClass.call(this, {toggle: classNames}, force, speed, easing);
            }
          };
        })($.fn.toggleClass),
        switchClass: function(remove, add, speed, easing, callback) {
          return $.effects.animateClass.call(this, {
            add: add,
            remove: remove
          }, speed, easing, callback);
        }
      });
    })();
    (function() {
      $.extend($.effects, {
        version: "1.11.1",
        save: function(element, set) {
          for (var i = 0; i < set.length; i++) {
            if (set[i] !== null) {
              element.data(dataSpace + set[i], element[0].style[set[i]]);
            }
          }
        },
        restore: function(element, set) {
          var val,
              i;
          for (i = 0; i < set.length; i++) {
            if (set[i] !== null) {
              val = element.data(dataSpace + set[i]);
              if (val === undefined) {
                val = "";
              }
              element.css(set[i], val);
            }
          }
        },
        setMode: function(el, mode) {
          if (mode === "toggle") {
            mode = el.is(":hidden") ? "show" : "hide";
          }
          return mode;
        },
        getBaseline: function(origin, original) {
          var y,
              x;
          switch (origin[0]) {
            case "top":
              y = 0;
              break;
            case "middle":
              y = 0.5;
              break;
            case "bottom":
              y = 1;
              break;
            default:
              y = origin[0] / original.height;
          }
          switch (origin[1]) {
            case "left":
              x = 0;
              break;
            case "center":
              x = 0.5;
              break;
            case "right":
              x = 1;
              break;
            default:
              x = origin[1] / original.width;
          }
          return {
            x: x,
            y: y
          };
        },
        createWrapper: function(element) {
          if (element.parent().is(".ui-effects-wrapper")) {
            return element.parent();
          }
          var props = {
            width: element.outerWidth(true),
            height: element.outerHeight(true),
            "float": element.css("float")
          },
              wrapper = $("<div></div>").addClass("ui-effects-wrapper").css({
                fontSize: "100%",
                background: "transparent",
                border: "none",
                margin: 0,
                padding: 0
              }),
              size = {
                width: element.width(),
                height: element.height()
              },
              active = document.activeElement;
          try {
            active.id;
          } catch (e) {
            active = document.body;
          }
          element.wrap(wrapper);
          if (element[0] === active || $.contains(element[0], active)) {
            $(active).focus();
          }
          wrapper = element.parent();
          if (element.css("position") === "static") {
            wrapper.css({position: "relative"});
            element.css({position: "relative"});
          } else {
            $.extend(props, {
              position: element.css("position"),
              zIndex: element.css("z-index")
            });
            $.each(["top", "left", "bottom", "right"], function(i, pos) {
              props[pos] = element.css(pos);
              if (isNaN(parseInt(props[pos], 10))) {
                props[pos] = "auto";
              }
            });
            element.css({
              position: "relative",
              top: 0,
              left: 0,
              right: "auto",
              bottom: "auto"
            });
          }
          element.css(size);
          return wrapper.css(props).show();
        },
        removeWrapper: function(element) {
          var active = document.activeElement;
          if (element.parent().is(".ui-effects-wrapper")) {
            element.parent().replaceWith(element);
            if (element[0] === active || $.contains(element[0], active)) {
              $(active).focus();
            }
          }
          return element;
        },
        setTransition: function(element, list, factor, value) {
          value = value || {};
          $.each(list, function(i, x) {
            var unit = element.cssUnit(x);
            if (unit[0] > 0) {
              value[x] = unit[0] * factor + unit[1];
            }
          });
          return value;
        }
      });
      function _normalizeArguments(effect, options, speed, callback) {
        if ($.isPlainObject(effect)) {
          options = effect;
          effect = effect.effect;
        }
        effect = {effect: effect};
        if (options == null) {
          options = {};
        }
        if ($.isFunction(options)) {
          callback = options;
          speed = null;
          options = {};
        }
        if (typeof options === "number" || $.fx.speeds[options]) {
          callback = speed;
          speed = options;
          options = {};
        }
        if ($.isFunction(speed)) {
          callback = speed;
          speed = null;
        }
        if (options) {
          $.extend(effect, options);
        }
        speed = speed || options.duration;
        effect.duration = $.fx.off ? 0 : typeof speed === "number" ? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;
        effect.complete = callback || options.complete;
        return effect;
      }
      function standardAnimationOption(option) {
        if (!option || typeof option === "number" || $.fx.speeds[option]) {
          return true;
        }
        if (typeof option === "string" && !$.effects.effect[option]) {
          return true;
        }
        if ($.isFunction(option)) {
          return true;
        }
        if (typeof option === "object" && !option.effect) {
          return true;
        }
        return false;
      }
      $.fn.extend({
        effect: function() {
          var args = _normalizeArguments.apply(this, arguments),
              mode = args.mode,
              queue = args.queue,
              effectMethod = $.effects.effect[args.effect];
          if ($.fx.off || !effectMethod) {
            if (mode) {
              return this[mode](args.duration, args.complete);
            } else {
              return this.each(function() {
                if (args.complete) {
                  args.complete.call(this);
                }
              });
            }
          }
          function run(next) {
            var elem = $(this),
                complete = args.complete,
                mode = args.mode;
            function done() {
              if ($.isFunction(complete)) {
                complete.call(elem[0]);
              }
              if ($.isFunction(next)) {
                next();
              }
            }
            if (elem.is(":hidden") ? mode === "hide" : mode === "show") {
              elem[mode]();
              done();
            } else {
              effectMethod.call(elem[0], args, done);
            }
          }
          return queue === false ? this.each(run) : this.queue(queue || "fx", run);
        },
        show: (function(orig) {
          return function(option) {
            if (standardAnimationOption(option)) {
              return orig.apply(this, arguments);
            } else {
              var args = _normalizeArguments.apply(this, arguments);
              args.mode = "show";
              return this.effect.call(this, args);
            }
          };
        })($.fn.show),
        hide: (function(orig) {
          return function(option) {
            if (standardAnimationOption(option)) {
              return orig.apply(this, arguments);
            } else {
              var args = _normalizeArguments.apply(this, arguments);
              args.mode = "hide";
              return this.effect.call(this, args);
            }
          };
        })($.fn.hide),
        toggle: (function(orig) {
          return function(option) {
            if (standardAnimationOption(option) || typeof option === "boolean") {
              return orig.apply(this, arguments);
            } else {
              var args = _normalizeArguments.apply(this, arguments);
              args.mode = "toggle";
              return this.effect.call(this, args);
            }
          };
        })($.fn.toggle),
        cssUnit: function(key) {
          var style = this.css(key),
              val = [];
          $.each(["em", "px", "%", "pt"], function(i, unit) {
            if (style.indexOf(unit) > 0) {
              val = [parseFloat(style), unit];
            }
          });
          return val;
        }
      });
    })();
    (function() {
      var baseEasings = {};
      $.each(["Quad", "Cubic", "Quart", "Quint", "Expo"], function(i, name) {
        baseEasings[name] = function(p) {
          return Math.pow(p, i + 2);
        };
      });
      $.extend(baseEasings, {
        Sine: function(p) {
          return 1 - Math.cos(p * Math.PI / 2);
        },
        Circ: function(p) {
          return 1 - Math.sqrt(1 - p * p);
        },
        Elastic: function(p) {
          return p === 0 || p === 1 ? p : -Math.pow(2, 8 * (p - 1)) * Math.sin(((p - 1) * 80 - 7.5) * Math.PI / 15);
        },
        Back: function(p) {
          return p * p * (3 * p - 2);
        },
        Bounce: function(p) {
          var pow2,
              bounce = 4;
          while (p < ((pow2 = Math.pow(2, --bounce)) - 1) / 11) {}
          return 1 / Math.pow(4, 3 - bounce) - 7.5625 * Math.pow((pow2 * 3 - 2) / 22 - p, 2);
        }
      });
      $.each(baseEasings, function(name, easeIn) {
        $.easing["easeIn" + name] = easeIn;
        $.easing["easeOut" + name] = function(p) {
          return 1 - easeIn(1 - p);
        };
        $.easing["easeInOut" + name] = function(p) {
          return p < 0.5 ? easeIn(p * 2) / 2 : 1 - easeIn(p * -2 + 2) / 2;
        };
      });
    })();
    var effect = $.effects;
    var effectBlind = $.effects.effect.blind = function(o, done) {
      var el = $(this),
          rvertical = /up|down|vertical/,
          rpositivemotion = /up|left|vertical|horizontal/,
          props = ["position", "top", "bottom", "left", "right", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "hide"),
          direction = o.direction || "up",
          vertical = rvertical.test(direction),
          ref = vertical ? "height" : "width",
          ref2 = vertical ? "top" : "left",
          motion = rpositivemotion.test(direction),
          animation = {},
          show = mode === "show",
          wrapper,
          distance,
          margin;
      if (el.parent().is(".ui-effects-wrapper")) {
        $.effects.save(el.parent(), props);
      } else {
        $.effects.save(el, props);
      }
      el.show();
      wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
      distance = wrapper[ref]();
      margin = parseFloat(wrapper.css(ref2)) || 0;
      animation[ref] = show ? distance : 0;
      if (!motion) {
        el.css(vertical ? "bottom" : "right", 0).css(vertical ? "top" : "left", "auto").css({position: "absolute"});
        animation[ref2] = show ? margin : distance + margin;
      }
      if (show) {
        wrapper.css(ref, 0);
        if (!motion) {
          wrapper.css(ref2, margin + distance);
        }
      }
      wrapper.animate(animation, {
        duration: o.duration,
        easing: o.easing,
        queue: false,
        complete: function() {
          if (mode === "hide") {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
    var effectBounce = $.effects.effect.bounce = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "effect"),
          hide = mode === "hide",
          show = mode === "show",
          direction = o.direction || "up",
          distance = o.distance,
          times = o.times || 5,
          anims = times * 2 + (show || hide ? 1 : 0),
          speed = o.duration / anims,
          easing = o.easing,
          ref = (direction === "up" || direction === "down") ? "top" : "left",
          motion = (direction === "up" || direction === "left"),
          i,
          upAnim,
          downAnim,
          queue = el.queue(),
          queuelen = queue.length;
      if (show || hide) {
        props.push("opacity");
      }
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      if (!distance) {
        distance = el[ref === "top" ? "outerHeight" : "outerWidth"]() / 3;
      }
      if (show) {
        downAnim = {opacity: 1};
        downAnim[ref] = 0;
        el.css("opacity", 0).css(ref, motion ? -distance * 2 : distance * 2).animate(downAnim, speed, easing);
      }
      if (hide) {
        distance = distance / Math.pow(2, times - 1);
      }
      downAnim = {};
      downAnim[ref] = 0;
      for (i = 0; i < times; i++) {
        upAnim = {};
        upAnim[ref] = (motion ? "-=" : "+=") + distance;
        el.animate(upAnim, speed, easing).animate(downAnim, speed, easing);
        distance = hide ? distance * 2 : distance / 2;
      }
      if (hide) {
        upAnim = {opacity: 0};
        upAnim[ref] = (motion ? "-=" : "+=") + distance;
        el.animate(upAnim, speed, easing);
      }
      el.queue(function() {
        if (hide) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
      if (queuelen > 1) {
        queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
      }
      el.dequeue();
    };
    var effectClip = $.effects.effect.clip = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "hide"),
          show = mode === "show",
          direction = o.direction || "vertical",
          vert = direction === "vertical",
          size = vert ? "height" : "width",
          position = vert ? "top" : "left",
          animation = {},
          wrapper,
          animate,
          distance;
      $.effects.save(el, props);
      el.show();
      wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
      animate = (el[0].tagName === "IMG") ? wrapper : el;
      distance = animate[size]();
      if (show) {
        animate.css(size, 0);
        animate.css(position, distance / 2);
      }
      animation[size] = show ? distance : 0;
      animation[position] = show ? 0 : distance / 2;
      animate.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (!show) {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
    var effectDrop = $.effects.effect.drop = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "opacity", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "hide"),
          show = mode === "show",
          direction = o.direction || "left",
          ref = (direction === "up" || direction === "down") ? "top" : "left",
          motion = (direction === "up" || direction === "left") ? "pos" : "neg",
          animation = {opacity: show ? 1 : 0},
          distance;
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true) / 2;
      if (show) {
        el.css("opacity", 0).css(ref, motion === "pos" ? -distance : distance);
      }
      animation[ref] = (show ? (motion === "pos" ? "+=" : "-=") : (motion === "pos" ? "-=" : "+=")) + distance;
      el.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (mode === "hide") {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
    var effectExplode = $.effects.effect.explode = function(o, done) {
      var rows = o.pieces ? Math.round(Math.sqrt(o.pieces)) : 3,
          cells = rows,
          el = $(this),
          mode = $.effects.setMode(el, o.mode || "hide"),
          show = mode === "show",
          offset = el.show().css("visibility", "hidden").offset(),
          width = Math.ceil(el.outerWidth() / cells),
          height = Math.ceil(el.outerHeight() / rows),
          pieces = [],
          i,
          j,
          left,
          top,
          mx,
          my;
      function childComplete() {
        pieces.push(this);
        if (pieces.length === rows * cells) {
          animComplete();
        }
      }
      for (i = 0; i < rows; i++) {
        top = offset.top + i * height;
        my = i - (rows - 1) / 2;
        for (j = 0; j < cells; j++) {
          left = offset.left + j * width;
          mx = j - (cells - 1) / 2;
          el.clone().appendTo("body").wrap("<div></div>").css({
            position: "absolute",
            visibility: "visible",
            left: -j * width,
            top: -i * height
          }).parent().addClass("ui-effects-explode").css({
            position: "absolute",
            overflow: "hidden",
            width: width,
            height: height,
            left: left + (show ? mx * width : 0),
            top: top + (show ? my * height : 0),
            opacity: show ? 0 : 1
          }).animate({
            left: left + (show ? 0 : mx * width),
            top: top + (show ? 0 : my * height),
            opacity: show ? 1 : 0
          }, o.duration || 500, o.easing, childComplete);
        }
      }
      function animComplete() {
        el.css({visibility: "visible"});
        $(pieces).remove();
        if (!show) {
          el.hide();
        }
        done();
      }
    };
    var effectFade = $.effects.effect.fade = function(o, done) {
      var el = $(this),
          mode = $.effects.setMode(el, o.mode || "toggle");
      el.animate({opacity: mode}, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: done
      });
    };
    var effectFold = $.effects.effect.fold = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "hide"),
          show = mode === "show",
          hide = mode === "hide",
          size = o.size || 15,
          percent = /([0-9]+)%/.exec(size),
          horizFirst = !!o.horizFirst,
          widthFirst = show !== horizFirst,
          ref = widthFirst ? ["width", "height"] : ["height", "width"],
          duration = o.duration / 2,
          wrapper,
          distance,
          animation1 = {},
          animation2 = {};
      $.effects.save(el, props);
      el.show();
      wrapper = $.effects.createWrapper(el).css({overflow: "hidden"});
      distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
      if (percent) {
        size = parseInt(percent[1], 10) / 100 * distance[hide ? 0 : 1];
      }
      if (show) {
        wrapper.css(horizFirst ? {
          height: 0,
          width: size
        } : {
          height: size,
          width: 0
        });
      }
      animation1[ref[0]] = show ? distance[0] : size;
      animation2[ref[1]] = show ? distance[1] : 0;
      wrapper.animate(animation1, duration, o.easing).animate(animation2, duration, o.easing, function() {
        if (hide) {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
    };
    var effectHighlight = $.effects.effect.highlight = function(o, done) {
      var elem = $(this),
          props = ["backgroundImage", "backgroundColor", "opacity"],
          mode = $.effects.setMode(elem, o.mode || "show"),
          animation = {backgroundColor: elem.css("backgroundColor")};
      if (mode === "hide") {
        animation.opacity = 0;
      }
      $.effects.save(elem, props);
      elem.show().css({
        backgroundImage: "none",
        backgroundColor: o.color || "#ffff99"
      }).animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (mode === "hide") {
            elem.hide();
          }
          $.effects.restore(elem, props);
          done();
        }
      });
    };
    var effectSize = $.effects.effect.size = function(o, done) {
      var original,
          baseline,
          factor,
          el = $(this),
          props0 = ["position", "top", "bottom", "left", "right", "width", "height", "overflow", "opacity"],
          props1 = ["position", "top", "bottom", "left", "right", "overflow", "opacity"],
          props2 = ["width", "height", "overflow"],
          cProps = ["fontSize"],
          vProps = ["borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom"],
          hProps = ["borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight"],
          mode = $.effects.setMode(el, o.mode || "effect"),
          restore = o.restore || mode !== "effect",
          scale = o.scale || "both",
          origin = o.origin || ["middle", "center"],
          position = el.css("position"),
          props = restore ? props0 : props1,
          zero = {
            height: 0,
            width: 0,
            outerHeight: 0,
            outerWidth: 0
          };
      if (mode === "show") {
        el.show();
      }
      original = {
        height: el.height(),
        width: el.width(),
        outerHeight: el.outerHeight(),
        outerWidth: el.outerWidth()
      };
      if (o.mode === "toggle" && mode === "show") {
        el.from = o.to || zero;
        el.to = o.from || original;
      } else {
        el.from = o.from || (mode === "show" ? zero : original);
        el.to = o.to || (mode === "hide" ? zero : original);
      }
      factor = {
        from: {
          y: el.from.height / original.height,
          x: el.from.width / original.width
        },
        to: {
          y: el.to.height / original.height,
          x: el.to.width / original.width
        }
      };
      if (scale === "box" || scale === "both") {
        if (factor.from.y !== factor.to.y) {
          props = props.concat(vProps);
          el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
          el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
        }
        if (factor.from.x !== factor.to.x) {
          props = props.concat(hProps);
          el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
          el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
        }
      }
      if (scale === "content" || scale === "both") {
        if (factor.from.y !== factor.to.y) {
          props = props.concat(cProps).concat(props2);
          el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
          el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
        }
      }
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      el.css("overflow", "hidden").css(el.from);
      if (origin) {
        baseline = $.effects.getBaseline(origin, original);
        el.from.top = (original.outerHeight - el.outerHeight()) * baseline.y;
        el.from.left = (original.outerWidth - el.outerWidth()) * baseline.x;
        el.to.top = (original.outerHeight - el.to.outerHeight) * baseline.y;
        el.to.left = (original.outerWidth - el.to.outerWidth) * baseline.x;
      }
      el.css(el.from);
      if (scale === "content" || scale === "both") {
        vProps = vProps.concat(["marginTop", "marginBottom"]).concat(cProps);
        hProps = hProps.concat(["marginLeft", "marginRight"]);
        props2 = props0.concat(vProps).concat(hProps);
        el.find("*[width]").each(function() {
          var child = $(this),
              c_original = {
                height: child.height(),
                width: child.width(),
                outerHeight: child.outerHeight(),
                outerWidth: child.outerWidth()
              };
          if (restore) {
            $.effects.save(child, props2);
          }
          child.from = {
            height: c_original.height * factor.from.y,
            width: c_original.width * factor.from.x,
            outerHeight: c_original.outerHeight * factor.from.y,
            outerWidth: c_original.outerWidth * factor.from.x
          };
          child.to = {
            height: c_original.height * factor.to.y,
            width: c_original.width * factor.to.x,
            outerHeight: c_original.height * factor.to.y,
            outerWidth: c_original.width * factor.to.x
          };
          if (factor.from.y !== factor.to.y) {
            child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
            child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
          }
          if (factor.from.x !== factor.to.x) {
            child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
            child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
          }
          child.css(child.from);
          child.animate(child.to, o.duration, o.easing, function() {
            if (restore) {
              $.effects.restore(child, props2);
            }
          });
        });
      }
      el.animate(el.to, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (el.to.opacity === 0) {
            el.css("opacity", el.from.opacity);
          }
          if (mode === "hide") {
            el.hide();
          }
          $.effects.restore(el, props);
          if (!restore) {
            if (position === "static") {
              el.css({
                position: "relative",
                top: el.to.top,
                left: el.to.left
              });
            } else {
              $.each(["top", "left"], function(idx, pos) {
                el.css(pos, function(_, str) {
                  var val = parseInt(str, 10),
                      toRef = idx ? el.to.left : el.to.top;
                  if (str === "auto") {
                    return toRef + "px";
                  }
                  return val + toRef + "px";
                });
              });
            }
          }
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
    var effectScale = $.effects.effect.scale = function(o, done) {
      var el = $(this),
          options = $.extend(true, {}, o),
          mode = $.effects.setMode(el, o.mode || "effect"),
          percent = parseInt(o.percent, 10) || (parseInt(o.percent, 10) === 0 ? 0 : (mode === "hide" ? 0 : 100)),
          direction = o.direction || "both",
          origin = o.origin,
          original = {
            height: el.height(),
            width: el.width(),
            outerHeight: el.outerHeight(),
            outerWidth: el.outerWidth()
          },
          factor = {
            y: direction !== "horizontal" ? (percent / 100) : 1,
            x: direction !== "vertical" ? (percent / 100) : 1
          };
      options.effect = "size";
      options.queue = false;
      options.complete = done;
      if (mode !== "effect") {
        options.origin = origin || ["middle", "center"];
        options.restore = true;
      }
      options.from = o.from || (mode === "show" ? {
        height: 0,
        width: 0,
        outerHeight: 0,
        outerWidth: 0
      } : original);
      options.to = {
        height: original.height * factor.y,
        width: original.width * factor.x,
        outerHeight: original.outerHeight * factor.y,
        outerWidth: original.outerWidth * factor.x
      };
      if (options.fade) {
        if (mode === "show") {
          options.from.opacity = 0;
          options.to.opacity = 1;
        }
        if (mode === "hide") {
          options.from.opacity = 1;
          options.to.opacity = 0;
        }
      }
      el.effect(options);
    };
    var effectPuff = $.effects.effect.puff = function(o, done) {
      var elem = $(this),
          mode = $.effects.setMode(elem, o.mode || "hide"),
          hide = mode === "hide",
          percent = parseInt(o.percent, 10) || 150,
          factor = percent / 100,
          original = {
            height: elem.height(),
            width: elem.width(),
            outerHeight: elem.outerHeight(),
            outerWidth: elem.outerWidth()
          };
      $.extend(o, {
        effect: "scale",
        queue: false,
        fade: true,
        mode: mode,
        complete: done,
        percent: hide ? percent : 100,
        from: hide ? original : {
          height: original.height * factor,
          width: original.width * factor,
          outerHeight: original.outerHeight * factor,
          outerWidth: original.outerWidth * factor
        }
      });
      elem.effect(o);
    };
    var effectPulsate = $.effects.effect.pulsate = function(o, done) {
      var elem = $(this),
          mode = $.effects.setMode(elem, o.mode || "show"),
          show = mode === "show",
          hide = mode === "hide",
          showhide = (show || mode === "hide"),
          anims = ((o.times || 5) * 2) + (showhide ? 1 : 0),
          duration = o.duration / anims,
          animateTo = 0,
          queue = elem.queue(),
          queuelen = queue.length,
          i;
      if (show || !elem.is(":visible")) {
        elem.css("opacity", 0).show();
        animateTo = 1;
      }
      for (i = 1; i < anims; i++) {
        elem.animate({opacity: animateTo}, duration, o.easing);
        animateTo = 1 - animateTo;
      }
      elem.animate({opacity: animateTo}, duration, o.easing);
      elem.queue(function() {
        if (hide) {
          elem.hide();
        }
        done();
      });
      if (queuelen > 1) {
        queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
      }
      elem.dequeue();
    };
    var effectShake = $.effects.effect.shake = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "height", "width"],
          mode = $.effects.setMode(el, o.mode || "effect"),
          direction = o.direction || "left",
          distance = o.distance || 20,
          times = o.times || 3,
          anims = times * 2 + 1,
          speed = Math.round(o.duration / anims),
          ref = (direction === "up" || direction === "down") ? "top" : "left",
          positiveMotion = (direction === "up" || direction === "left"),
          animation = {},
          animation1 = {},
          animation2 = {},
          i,
          queue = el.queue(),
          queuelen = queue.length;
      $.effects.save(el, props);
      el.show();
      $.effects.createWrapper(el);
      animation[ref] = (positiveMotion ? "-=" : "+=") + distance;
      animation1[ref] = (positiveMotion ? "+=" : "-=") + distance * 2;
      animation2[ref] = (positiveMotion ? "-=" : "+=") + distance * 2;
      el.animate(animation, speed, o.easing);
      for (i = 1; i < times; i++) {
        el.animate(animation1, speed, o.easing).animate(animation2, speed, o.easing);
      }
      el.animate(animation1, speed, o.easing).animate(animation, speed / 2, o.easing).queue(function() {
        if (mode === "hide") {
          el.hide();
        }
        $.effects.restore(el, props);
        $.effects.removeWrapper(el);
        done();
      });
      if (queuelen > 1) {
        queue.splice.apply(queue, [1, 0].concat(queue.splice(queuelen, anims + 1)));
      }
      el.dequeue();
    };
    var effectSlide = $.effects.effect.slide = function(o, done) {
      var el = $(this),
          props = ["position", "top", "bottom", "left", "right", "width", "height"],
          mode = $.effects.setMode(el, o.mode || "show"),
          show = mode === "show",
          direction = o.direction || "left",
          ref = (direction === "up" || direction === "down") ? "top" : "left",
          positiveMotion = (direction === "up" || direction === "left"),
          distance,
          animation = {};
      $.effects.save(el, props);
      el.show();
      distance = o.distance || el[ref === "top" ? "outerHeight" : "outerWidth"](true);
      $.effects.createWrapper(el).css({overflow: "hidden"});
      if (show) {
        el.css(ref, positiveMotion ? (isNaN(distance) ? "-" + distance : -distance) : distance);
      }
      animation[ref] = (show ? (positiveMotion ? "+=" : "-=") : (positiveMotion ? "-=" : "+=")) + distance;
      el.animate(animation, {
        queue: false,
        duration: o.duration,
        easing: o.easing,
        complete: function() {
          if (mode === "hide") {
            el.hide();
          }
          $.effects.restore(el, props);
          $.effects.removeWrapper(el);
          done();
        }
      });
    };
    var effectTransfer = $.effects.effect.transfer = function(o, done) {
      var elem = $(this),
          target = $(o.to),
          targetFixed = target.css("position") === "fixed",
          body = $("body"),
          fixTop = targetFixed ? body.scrollTop() : 0,
          fixLeft = targetFixed ? body.scrollLeft() : 0,
          endPosition = target.offset(),
          animation = {
            top: endPosition.top - fixTop,
            left: endPosition.left - fixLeft,
            height: target.innerHeight(),
            width: target.innerWidth()
          },
          startPosition = elem.offset(),
          transfer = $("<div class='ui-effects-transfer'></div>").appendTo(document.body).addClass(o.className).css({
            top: startPosition.top - fixTop,
            left: startPosition.left - fixLeft,
            height: elem.innerHeight(),
            width: elem.innerWidth(),
            position: targetFixed ? "fixed" : "absolute"
          }).animate(animation, o.duration, o.easing, function() {
            transfer.remove();
            done();
          });
    };
    var progressbar = $.widget("ui.progressbar", {
      version: "1.11.1",
      options: {
        max: 100,
        value: 0,
        change: null,
        complete: null
      },
      min: 0,
      _create: function() {
        this.oldValue = this.options.value = this._constrainedValue();
        this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({
          role: "progressbar",
          "aria-valuemin": this.min
        });
        this.valueDiv = $("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element);
        this._refreshValue();
      },
      _destroy: function() {
        this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
        this.valueDiv.remove();
      },
      value: function(newValue) {
        if (newValue === undefined) {
          return this.options.value;
        }
        this.options.value = this._constrainedValue(newValue);
        this._refreshValue();
      },
      _constrainedValue: function(newValue) {
        if (newValue === undefined) {
          newValue = this.options.value;
        }
        this.indeterminate = newValue === false;
        if (typeof newValue !== "number") {
          newValue = 0;
        }
        return this.indeterminate ? false : Math.min(this.options.max, Math.max(this.min, newValue));
      },
      _setOptions: function(options) {
        var value = options.value;
        delete options.value;
        this._super(options);
        this.options.value = this._constrainedValue(value);
        this._refreshValue();
      },
      _setOption: function(key, value) {
        if (key === "max") {
          value = Math.max(this.min, value);
        }
        if (key === "disabled") {
          this.element.toggleClass("ui-state-disabled", !!value).attr("aria-disabled", value);
        }
        this._super(key, value);
      },
      _percentage: function() {
        return this.indeterminate ? 100 : 100 * (this.options.value - this.min) / (this.options.max - this.min);
      },
      _refreshValue: function() {
        var value = this.options.value,
            percentage = this._percentage();
        this.valueDiv.toggle(this.indeterminate || value > this.min).toggleClass("ui-corner-right", value === this.options.max).width(percentage.toFixed(0) + "%");
        this.element.toggleClass("ui-progressbar-indeterminate", this.indeterminate);
        if (this.indeterminate) {
          this.element.removeAttr("aria-valuenow");
          if (!this.overlayDiv) {
            this.overlayDiv = $("<div class='ui-progressbar-overlay'></div>").appendTo(this.valueDiv);
          }
        } else {
          this.element.attr({
            "aria-valuemax": this.options.max,
            "aria-valuenow": value
          });
          if (this.overlayDiv) {
            this.overlayDiv.remove();
            this.overlayDiv = null;
          }
        }
        if (this.oldValue !== value) {
          this.oldValue = value;
          this._trigger("change");
        }
        if (value === this.options.max) {
          this._trigger("complete");
        }
      }
    });
    var selectable = $.widget("ui.selectable", $.ui.mouse, {
      version: "1.11.1",
      options: {
        appendTo: "body",
        autoRefresh: true,
        distance: 0,
        filter: "*",
        tolerance: "touch",
        selected: null,
        selecting: null,
        start: null,
        stop: null,
        unselected: null,
        unselecting: null
      },
      _create: function() {
        var selectees,
            that = this;
        this.element.addClass("ui-selectable");
        this.dragged = false;
        this.refresh = function() {
          selectees = $(that.options.filter, that.element[0]);
          selectees.addClass("ui-selectee");
          selectees.each(function() {
            var $this = $(this),
                pos = $this.offset();
            $.data(this, "selectable-item", {
              element: this,
              $element: $this,
              left: pos.left,
              top: pos.top,
              right: pos.left + $this.outerWidth(),
              bottom: pos.top + $this.outerHeight(),
              startselected: false,
              selected: $this.hasClass("ui-selected"),
              selecting: $this.hasClass("ui-selecting"),
              unselecting: $this.hasClass("ui-unselecting")
            });
          });
        };
        this.refresh();
        this.selectees = selectees.addClass("ui-selectee");
        this._mouseInit();
        this.helper = $("<div class='ui-selectable-helper'></div>");
      },
      _destroy: function() {
        this.selectees.removeClass("ui-selectee").removeData("selectable-item");
        this.element.removeClass("ui-selectable ui-selectable-disabled");
        this._mouseDestroy();
      },
      _mouseStart: function(event) {
        var that = this,
            options = this.options;
        this.opos = [event.pageX, event.pageY];
        if (this.options.disabled) {
          return;
        }
        this.selectees = $(options.filter, this.element[0]);
        this._trigger("start", event);
        $(options.appendTo).append(this.helper);
        this.helper.css({
          "left": event.pageX,
          "top": event.pageY,
          "width": 0,
          "height": 0
        });
        if (options.autoRefresh) {
          this.refresh();
        }
        this.selectees.filter(".ui-selected").each(function() {
          var selectee = $.data(this, "selectable-item");
          selectee.startselected = true;
          if (!event.metaKey && !event.ctrlKey) {
            selectee.$element.removeClass("ui-selected");
            selectee.selected = false;
            selectee.$element.addClass("ui-unselecting");
            selectee.unselecting = true;
            that._trigger("unselecting", event, {unselecting: selectee.element});
          }
        });
        $(event.target).parents().addBack().each(function() {
          var doSelect,
              selectee = $.data(this, "selectable-item");
          if (selectee) {
            doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass("ui-selected");
            selectee.$element.removeClass(doSelect ? "ui-unselecting" : "ui-selected").addClass(doSelect ? "ui-selecting" : "ui-unselecting");
            selectee.unselecting = !doSelect;
            selectee.selecting = doSelect;
            selectee.selected = doSelect;
            if (doSelect) {
              that._trigger("selecting", event, {selecting: selectee.element});
            } else {
              that._trigger("unselecting", event, {unselecting: selectee.element});
            }
            return false;
          }
        });
      },
      _mouseDrag: function(event) {
        this.dragged = true;
        if (this.options.disabled) {
          return;
        }
        var tmp,
            that = this,
            options = this.options,
            x1 = this.opos[0],
            y1 = this.opos[1],
            x2 = event.pageX,
            y2 = event.pageY;
        if (x1 > x2) {
          tmp = x2;
          x2 = x1;
          x1 = tmp;
        }
        if (y1 > y2) {
          tmp = y2;
          y2 = y1;
          y1 = tmp;
        }
        this.helper.css({
          left: x1,
          top: y1,
          width: x2 - x1,
          height: y2 - y1
        });
        this.selectees.each(function() {
          var selectee = $.data(this, "selectable-item"),
              hit = false;
          if (!selectee || selectee.element === that.element[0]) {
            return;
          }
          if (options.tolerance === "touch") {
            hit = (!(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1));
          } else if (options.tolerance === "fit") {
            hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
          }
          if (hit) {
            if (selectee.selected) {
              selectee.$element.removeClass("ui-selected");
              selectee.selected = false;
            }
            if (selectee.unselecting) {
              selectee.$element.removeClass("ui-unselecting");
              selectee.unselecting = false;
            }
            if (!selectee.selecting) {
              selectee.$element.addClass("ui-selecting");
              selectee.selecting = true;
              that._trigger("selecting", event, {selecting: selectee.element});
            }
          } else {
            if (selectee.selecting) {
              if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
                selectee.$element.removeClass("ui-selecting");
                selectee.selecting = false;
                selectee.$element.addClass("ui-selected");
                selectee.selected = true;
              } else {
                selectee.$element.removeClass("ui-selecting");
                selectee.selecting = false;
                if (selectee.startselected) {
                  selectee.$element.addClass("ui-unselecting");
                  selectee.unselecting = true;
                }
                that._trigger("unselecting", event, {unselecting: selectee.element});
              }
            }
            if (selectee.selected) {
              if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
                selectee.$element.removeClass("ui-selected");
                selectee.selected = false;
                selectee.$element.addClass("ui-unselecting");
                selectee.unselecting = true;
                that._trigger("unselecting", event, {unselecting: selectee.element});
              }
            }
          }
        });
        return false;
      },
      _mouseStop: function(event) {
        var that = this;
        this.dragged = false;
        $(".ui-unselecting", this.element[0]).each(function() {
          var selectee = $.data(this, "selectable-item");
          selectee.$element.removeClass("ui-unselecting");
          selectee.unselecting = false;
          selectee.startselected = false;
          that._trigger("unselected", event, {unselected: selectee.element});
        });
        $(".ui-selecting", this.element[0]).each(function() {
          var selectee = $.data(this, "selectable-item");
          selectee.$element.removeClass("ui-selecting").addClass("ui-selected");
          selectee.selecting = false;
          selectee.selected = true;
          selectee.startselected = true;
          that._trigger("selected", event, {selected: selectee.element});
        });
        this._trigger("stop", event);
        this.helper.remove();
        return false;
      }
    });
    var selectmenu = $.widget("ui.selectmenu", {
      version: "1.11.1",
      defaultElement: "<select>",
      options: {
        appendTo: null,
        disabled: null,
        icons: {button: "ui-icon-triangle-1-s"},
        position: {
          my: "left top",
          at: "left bottom",
          collision: "none"
        },
        width: null,
        change: null,
        close: null,
        focus: null,
        open: null,
        select: null
      },
      _create: function() {
        var selectmenuId = this.element.uniqueId().attr("id");
        this.ids = {
          element: selectmenuId,
          button: selectmenuId + "-button",
          menu: selectmenuId + "-menu"
        };
        this._drawButton();
        this._drawMenu();
        if (this.options.disabled) {
          this.disable();
        }
      },
      _drawButton: function() {
        var that = this,
            tabindex = this.element.attr("tabindex");
        this.label = $("label[for='" + this.ids.element + "']").attr("for", this.ids.button);
        this._on(this.label, {click: function(event) {
            this.button.focus();
            event.preventDefault();
          }});
        this.element.hide();
        this.button = $("<span>", {
          "class": "ui-selectmenu-button ui-widget ui-state-default ui-corner-all",
          tabindex: tabindex || this.options.disabled ? -1 : 0,
          id: this.ids.button,
          role: "combobox",
          "aria-expanded": "false",
          "aria-autocomplete": "list",
          "aria-owns": this.ids.menu,
          "aria-haspopup": "true"
        }).insertAfter(this.element);
        $("<span>", {"class": "ui-icon " + this.options.icons.button}).prependTo(this.button);
        this.buttonText = $("<span>", {"class": "ui-selectmenu-text"}).appendTo(this.button);
        this._setText(this.buttonText, this.element.find("option:selected").text());
        this._resizeButton();
        this._on(this.button, this._buttonEvents);
        this.button.one("focusin", function() {
          if (!that.menuItems) {
            that._refreshMenu();
          }
        });
        this._hoverable(this.button);
        this._focusable(this.button);
      },
      _drawMenu: function() {
        var that = this;
        this.menu = $("<ul>", {
          "aria-hidden": "true",
          "aria-labelledby": this.ids.button,
          id: this.ids.menu
        });
        this.menuWrap = $("<div>", {"class": "ui-selectmenu-menu ui-front"}).append(this.menu).appendTo(this._appendTo());
        this.menuInstance = this.menu.menu({
          role: "listbox",
          select: function(event, ui) {
            event.preventDefault();
            that._select(ui.item.data("ui-selectmenu-item"), event);
          },
          focus: function(event, ui) {
            var item = ui.item.data("ui-selectmenu-item");
            if (that.focusIndex != null && item.index !== that.focusIndex) {
              that._trigger("focus", event, {item: item});
              if (!that.isOpen) {
                that._select(item, event);
              }
            }
            that.focusIndex = item.index;
            that.button.attr("aria-activedescendant", that.menuItems.eq(item.index).attr("id"));
          }
        }).menu("instance");
        this.menu.addClass("ui-corner-bottom").removeClass("ui-corner-all");
        this.menuInstance._off(this.menu, "mouseleave");
        this.menuInstance._closeOnDocumentClick = function() {
          return false;
        };
        this.menuInstance._isDivider = function() {
          return false;
        };
      },
      refresh: function() {
        this._refreshMenu();
        this._setText(this.buttonText, this._getSelectedItem().text());
        if (!this.options.width) {
          this._resizeButton();
        }
      },
      _refreshMenu: function() {
        this.menu.empty();
        var item,
            options = this.element.find("option");
        if (!options.length) {
          return;
        }
        this._parseOptions(options);
        this._renderMenu(this.menu, this.items);
        this.menuInstance.refresh();
        this.menuItems = this.menu.find("li").not(".ui-selectmenu-optgroup");
        item = this._getSelectedItem();
        this.menuInstance.focus(null, item);
        this._setAria(item.data("ui-selectmenu-item"));
        this._setOption("disabled", this.element.prop("disabled"));
      },
      open: function(event) {
        if (this.options.disabled) {
          return;
        }
        if (!this.menuItems) {
          this._refreshMenu();
        } else {
          this.menu.find(".ui-state-focus").removeClass("ui-state-focus");
          this.menuInstance.focus(null, this._getSelectedItem());
        }
        this.isOpen = true;
        this._toggleAttr();
        this._resizeMenu();
        this._position();
        this._on(this.document, this._documentClick);
        this._trigger("open", event);
      },
      _position: function() {
        this.menuWrap.position($.extend({of: this.button}, this.options.position));
      },
      close: function(event) {
        if (!this.isOpen) {
          return;
        }
        this.isOpen = false;
        this._toggleAttr();
        this._off(this.document);
        this._trigger("close", event);
      },
      widget: function() {
        return this.button;
      },
      menuWidget: function() {
        return this.menu;
      },
      _renderMenu: function(ul, items) {
        var that = this,
            currentOptgroup = "";
        $.each(items, function(index, item) {
          if (item.optgroup !== currentOptgroup) {
            $("<li>", {
              "class": "ui-selectmenu-optgroup ui-menu-divider" + (item.element.parent("optgroup").prop("disabled") ? " ui-state-disabled" : ""),
              text: item.optgroup
            }).appendTo(ul);
            currentOptgroup = item.optgroup;
          }
          that._renderItemData(ul, item);
        });
      },
      _renderItemData: function(ul, item) {
        return this._renderItem(ul, item).data("ui-selectmenu-item", item);
      },
      _renderItem: function(ul, item) {
        var li = $("<li>");
        if (item.disabled) {
          li.addClass("ui-state-disabled");
        }
        this._setText(li, item.label);
        return li.appendTo(ul);
      },
      _setText: function(element, value) {
        if (value) {
          element.text(value);
        } else {
          element.html("&#160;");
        }
      },
      _move: function(direction, event) {
        var item,
            next,
            filter = ".ui-menu-item";
        if (this.isOpen) {
          item = this.menuItems.eq(this.focusIndex);
        } else {
          item = this.menuItems.eq(this.element[0].selectedIndex);
          filter += ":not(.ui-state-disabled)";
        }
        if (direction === "first" || direction === "last") {
          next = item[direction === "first" ? "prevAll" : "nextAll"](filter).eq(-1);
        } else {
          next = item[direction + "All"](filter).eq(0);
        }
        if (next.length) {
          this.menuInstance.focus(event, next);
        }
      },
      _getSelectedItem: function() {
        return this.menuItems.eq(this.element[0].selectedIndex);
      },
      _toggle: function(event) {
        this[this.isOpen ? "close" : "open"](event);
      },
      _documentClick: {mousedown: function(event) {
          if (!this.isOpen) {
            return;
          }
          if (!$(event.target).closest(".ui-selectmenu-menu, #" + this.ids.button).length) {
            this.close(event);
          }
        }},
      _buttonEvents: {
        mousedown: function(event) {
          event.preventDefault();
        },
        click: "_toggle",
        keydown: function(event) {
          var preventDefault = true;
          switch (event.keyCode) {
            case $.ui.keyCode.TAB:
            case $.ui.keyCode.ESCAPE:
              this.close(event);
              preventDefault = false;
              break;
            case $.ui.keyCode.ENTER:
              if (this.isOpen) {
                this._selectFocusedItem(event);
              }
              break;
            case $.ui.keyCode.UP:
              if (event.altKey) {
                this._toggle(event);
              } else {
                this._move("prev", event);
              }
              break;
            case $.ui.keyCode.DOWN:
              if (event.altKey) {
                this._toggle(event);
              } else {
                this._move("next", event);
              }
              break;
            case $.ui.keyCode.SPACE:
              if (this.isOpen) {
                this._selectFocusedItem(event);
              } else {
                this._toggle(event);
              }
              break;
            case $.ui.keyCode.LEFT:
              this._move("prev", event);
              break;
            case $.ui.keyCode.RIGHT:
              this._move("next", event);
              break;
            case $.ui.keyCode.HOME:
            case $.ui.keyCode.PAGE_UP:
              this._move("first", event);
              break;
            case $.ui.keyCode.END:
            case $.ui.keyCode.PAGE_DOWN:
              this._move("last", event);
              break;
            default:
              this.menu.trigger(event);
              preventDefault = false;
          }
          if (preventDefault) {
            event.preventDefault();
          }
        }
      },
      _selectFocusedItem: function(event) {
        var item = this.menuItems.eq(this.focusIndex);
        if (!item.hasClass("ui-state-disabled")) {
          this._select(item.data("ui-selectmenu-item"), event);
        }
      },
      _select: function(item, event) {
        var oldIndex = this.element[0].selectedIndex;
        this.element[0].selectedIndex = item.index;
        this._setText(this.buttonText, item.label);
        this._setAria(item);
        this._trigger("select", event, {item: item});
        if (item.index !== oldIndex) {
          this._trigger("change", event, {item: item});
        }
        this.close(event);
      },
      _setAria: function(item) {
        var id = this.menuItems.eq(item.index).attr("id");
        this.button.attr({
          "aria-labelledby": id,
          "aria-activedescendant": id
        });
        this.menu.attr("aria-activedescendant", id);
      },
      _setOption: function(key, value) {
        if (key === "icons") {
          this.button.find("span.ui-icon").removeClass(this.options.icons.button).addClass(value.button);
        }
        this._super(key, value);
        if (key === "appendTo") {
          this.menuWrap.appendTo(this._appendTo());
        }
        if (key === "disabled") {
          this.menuInstance.option("disabled", value);
          this.button.toggleClass("ui-state-disabled", value).attr("aria-disabled", value);
          this.element.prop("disabled", value);
          if (value) {
            this.button.attr("tabindex", -1);
            this.close();
          } else {
            this.button.attr("tabindex", 0);
          }
        }
        if (key === "width") {
          this._resizeButton();
        }
      },
      _appendTo: function() {
        var element = this.options.appendTo;
        if (element) {
          element = element.jquery || element.nodeType ? $(element) : this.document.find(element).eq(0);
        }
        if (!element || !element[0]) {
          element = this.element.closest(".ui-front");
        }
        if (!element.length) {
          element = this.document[0].body;
        }
        return element;
      },
      _toggleAttr: function() {
        this.button.toggleClass("ui-corner-top", this.isOpen).toggleClass("ui-corner-all", !this.isOpen).attr("aria-expanded", this.isOpen);
        this.menuWrap.toggleClass("ui-selectmenu-open", this.isOpen);
        this.menu.attr("aria-hidden", !this.isOpen);
      },
      _resizeButton: function() {
        var width = this.options.width;
        if (!width) {
          width = this.element.show().outerWidth();
          this.element.hide();
        }
        this.button.outerWidth(width);
      },
      _resizeMenu: function() {
        this.menu.outerWidth(Math.max(this.button.outerWidth(), this.menu.width("").outerWidth() + 1));
      },
      _getCreateOptions: function() {
        return {disabled: this.element.prop("disabled")};
      },
      _parseOptions: function(options) {
        var data = [];
        options.each(function(index, item) {
          var option = $(item),
              optgroup = option.parent("optgroup");
          data.push({
            element: option,
            index: index,
            value: option.attr("value"),
            label: option.text(),
            optgroup: optgroup.attr("label") || "",
            disabled: optgroup.prop("disabled") || option.prop("disabled")
          });
        });
        this.items = data;
      },
      _destroy: function() {
        this.menuWrap.remove();
        this.button.remove();
        this.element.show();
        this.element.removeUniqueId();
        this.label.attr("for", this.ids.element);
      }
    });
    var slider = $.widget("ui.slider", $.ui.mouse, {
      version: "1.11.1",
      widgetEventPrefix: "slide",
      options: {
        animate: false,
        distance: 0,
        max: 100,
        min: 0,
        orientation: "horizontal",
        range: false,
        step: 1,
        value: 0,
        values: null,
        change: null,
        slide: null,
        start: null,
        stop: null
      },
      numPages: 5,
      _create: function() {
        this._keySliding = false;
        this._mouseSliding = false;
        this._animateOff = true;
        this._handleIndex = null;
        this._detectOrientation();
        this._mouseInit();
        this.element.addClass("ui-slider" + " ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all");
        this._refresh();
        this._setOption("disabled", this.options.disabled);
        this._animateOff = false;
      },
      _refresh: function() {
        this._createRange();
        this._createHandles();
        this._setupEvents();
        this._refreshValue();
      },
      _createHandles: function() {
        var i,
            handleCount,
            options = this.options,
            existingHandles = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
            handle = "<span class='ui-slider-handle ui-state-default ui-corner-all' tabindex='0'></span>",
            handles = [];
        handleCount = (options.values && options.values.length) || 1;
        if (existingHandles.length > handleCount) {
          existingHandles.slice(handleCount).remove();
          existingHandles = existingHandles.slice(0, handleCount);
        }
        for (i = existingHandles.length; i < handleCount; i++) {
          handles.push(handle);
        }
        this.handles = existingHandles.add($(handles.join("")).appendTo(this.element));
        this.handle = this.handles.eq(0);
        this.handles.each(function(i) {
          $(this).data("ui-slider-handle-index", i);
        });
      },
      _createRange: function() {
        var options = this.options,
            classes = "";
        if (options.range) {
          if (options.range === true) {
            if (!options.values) {
              options.values = [this._valueMin(), this._valueMin()];
            } else if (options.values.length && options.values.length !== 2) {
              options.values = [options.values[0], options.values[0]];
            } else if ($.isArray(options.values)) {
              options.values = options.values.slice(0);
            }
          }
          if (!this.range || !this.range.length) {
            this.range = $("<div></div>").appendTo(this.element);
            classes = "ui-slider-range" + " ui-widget-header ui-corner-all";
          } else {
            this.range.removeClass("ui-slider-range-min ui-slider-range-max").css({
              "left": "",
              "bottom": ""
            });
          }
          this.range.addClass(classes + ((options.range === "min" || options.range === "max") ? " ui-slider-range-" + options.range : ""));
        } else {
          if (this.range) {
            this.range.remove();
          }
          this.range = null;
        }
      },
      _setupEvents: function() {
        this._off(this.handles);
        this._on(this.handles, this._handleEvents);
        this._hoverable(this.handles);
        this._focusable(this.handles);
      },
      _destroy: function() {
        this.handles.remove();
        if (this.range) {
          this.range.remove();
        }
        this.element.removeClass("ui-slider" + " ui-slider-horizontal" + " ui-slider-vertical" + " ui-widget" + " ui-widget-content" + " ui-corner-all");
        this._mouseDestroy();
      },
      _mouseCapture: function(event) {
        var position,
            normValue,
            distance,
            closestHandle,
            index,
            allowed,
            offset,
            mouseOverHandle,
            that = this,
            o = this.options;
        if (o.disabled) {
          return false;
        }
        this.elementSize = {
          width: this.element.outerWidth(),
          height: this.element.outerHeight()
        };
        this.elementOffset = this.element.offset();
        position = {
          x: event.pageX,
          y: event.pageY
        };
        normValue = this._normValueFromMouse(position);
        distance = this._valueMax() - this._valueMin() + 1;
        this.handles.each(function(i) {
          var thisDistance = Math.abs(normValue - that.values(i));
          if ((distance > thisDistance) || (distance === thisDistance && (i === that._lastChangedValue || that.values(i) === o.min))) {
            distance = thisDistance;
            closestHandle = $(this);
            index = i;
          }
        });
        allowed = this._start(event, index);
        if (allowed === false) {
          return false;
        }
        this._mouseSliding = true;
        this._handleIndex = index;
        closestHandle.addClass("ui-state-active").focus();
        offset = closestHandle.offset();
        mouseOverHandle = !$(event.target).parents().addBack().is(".ui-slider-handle");
        this._clickOffset = mouseOverHandle ? {
          left: 0,
          top: 0
        } : {
          left: event.pageX - offset.left - (closestHandle.width() / 2),
          top: event.pageY - offset.top - (closestHandle.height() / 2) - (parseInt(closestHandle.css("borderTopWidth"), 10) || 0) - (parseInt(closestHandle.css("borderBottomWidth"), 10) || 0) + (parseInt(closestHandle.css("marginTop"), 10) || 0)
        };
        if (!this.handles.hasClass("ui-state-hover")) {
          this._slide(event, index, normValue);
        }
        this._animateOff = true;
        return true;
      },
      _mouseStart: function() {
        return true;
      },
      _mouseDrag: function(event) {
        var position = {
          x: event.pageX,
          y: event.pageY
        },
            normValue = this._normValueFromMouse(position);
        this._slide(event, this._handleIndex, normValue);
        return false;
      },
      _mouseStop: function(event) {
        this.handles.removeClass("ui-state-active");
        this._mouseSliding = false;
        this._stop(event, this._handleIndex);
        this._change(event, this._handleIndex);
        this._handleIndex = null;
        this._clickOffset = null;
        this._animateOff = false;
        return false;
      },
      _detectOrientation: function() {
        this.orientation = (this.options.orientation === "vertical") ? "vertical" : "horizontal";
      },
      _normValueFromMouse: function(position) {
        var pixelTotal,
            pixelMouse,
            percentMouse,
            valueTotal,
            valueMouse;
        if (this.orientation === "horizontal") {
          pixelTotal = this.elementSize.width;
          pixelMouse = position.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0);
        } else {
          pixelTotal = this.elementSize.height;
          pixelMouse = position.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0);
        }
        percentMouse = (pixelMouse / pixelTotal);
        if (percentMouse > 1) {
          percentMouse = 1;
        }
        if (percentMouse < 0) {
          percentMouse = 0;
        }
        if (this.orientation === "vertical") {
          percentMouse = 1 - percentMouse;
        }
        valueTotal = this._valueMax() - this._valueMin();
        valueMouse = this._valueMin() + percentMouse * valueTotal;
        return this._trimAlignValue(valueMouse);
      },
      _start: function(event, index) {
        var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        return this._trigger("start", event, uiHash);
      },
      _slide: function(event, index, newVal) {
        var otherVal,
            newValues,
            allowed;
        if (this.options.values && this.options.values.length) {
          otherVal = this.values(index ? 0 : 1);
          if ((this.options.values.length === 2 && this.options.range === true) && ((index === 0 && newVal > otherVal) || (index === 1 && newVal < otherVal))) {
            newVal = otherVal;
          }
          if (newVal !== this.values(index)) {
            newValues = this.values();
            newValues[index] = newVal;
            allowed = this._trigger("slide", event, {
              handle: this.handles[index],
              value: newVal,
              values: newValues
            });
            otherVal = this.values(index ? 0 : 1);
            if (allowed !== false) {
              this.values(index, newVal);
            }
          }
        } else {
          if (newVal !== this.value()) {
            allowed = this._trigger("slide", event, {
              handle: this.handles[index],
              value: newVal
            });
            if (allowed !== false) {
              this.value(newVal);
            }
          }
        }
      },
      _stop: function(event, index) {
        var uiHash = {
          handle: this.handles[index],
          value: this.value()
        };
        if (this.options.values && this.options.values.length) {
          uiHash.value = this.values(index);
          uiHash.values = this.values();
        }
        this._trigger("stop", event, uiHash);
      },
      _change: function(event, index) {
        if (!this._keySliding && !this._mouseSliding) {
          var uiHash = {
            handle: this.handles[index],
            value: this.value()
          };
          if (this.options.values && this.options.values.length) {
            uiHash.value = this.values(index);
            uiHash.values = this.values();
          }
          this._lastChangedValue = index;
          this._trigger("change", event, uiHash);
        }
      },
      value: function(newValue) {
        if (arguments.length) {
          this.options.value = this._trimAlignValue(newValue);
          this._refreshValue();
          this._change(null, 0);
          return;
        }
        return this._value();
      },
      values: function(index, newValue) {
        var vals,
            newValues,
            i;
        if (arguments.length > 1) {
          this.options.values[index] = this._trimAlignValue(newValue);
          this._refreshValue();
          this._change(null, index);
          return;
        }
        if (arguments.length) {
          if ($.isArray(arguments[0])) {
            vals = this.options.values;
            newValues = arguments[0];
            for (i = 0; i < vals.length; i += 1) {
              vals[i] = this._trimAlignValue(newValues[i]);
              this._change(null, i);
            }
            this._refreshValue();
          } else {
            if (this.options.values && this.options.values.length) {
              return this._values(index);
            } else {
              return this.value();
            }
          }
        } else {
          return this._values();
        }
      },
      _setOption: function(key, value) {
        var i,
            valsLength = 0;
        if (key === "range" && this.options.range === true) {
          if (value === "min") {
            this.options.value = this._values(0);
            this.options.values = null;
          } else if (value === "max") {
            this.options.value = this._values(this.options.values.length - 1);
            this.options.values = null;
          }
        }
        if ($.isArray(this.options.values)) {
          valsLength = this.options.values.length;
        }
        if (key === "disabled") {
          this.element.toggleClass("ui-state-disabled", !!value);
        }
        this._super(key, value);
        switch (key) {
          case "orientation":
            this._detectOrientation();
            this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation);
            this._refreshValue();
            this.handles.css(value === "horizontal" ? "bottom" : "left", "");
            break;
          case "value":
            this._animateOff = true;
            this._refreshValue();
            this._change(null, 0);
            this._animateOff = false;
            break;
          case "values":
            this._animateOff = true;
            this._refreshValue();
            for (i = 0; i < valsLength; i += 1) {
              this._change(null, i);
            }
            this._animateOff = false;
            break;
          case "min":
          case "max":
            this._animateOff = true;
            this._refreshValue();
            this._animateOff = false;
            break;
          case "range":
            this._animateOff = true;
            this._refresh();
            this._animateOff = false;
            break;
        }
      },
      _value: function() {
        var val = this.options.value;
        val = this._trimAlignValue(val);
        return val;
      },
      _values: function(index) {
        var val,
            vals,
            i;
        if (arguments.length) {
          val = this.options.values[index];
          val = this._trimAlignValue(val);
          return val;
        } else if (this.options.values && this.options.values.length) {
          vals = this.options.values.slice();
          for (i = 0; i < vals.length; i += 1) {
            vals[i] = this._trimAlignValue(vals[i]);
          }
          return vals;
        } else {
          return [];
        }
      },
      _trimAlignValue: function(val) {
        if (val <= this._valueMin()) {
          return this._valueMin();
        }
        if (val >= this._valueMax()) {
          return this._valueMax();
        }
        var step = (this.options.step > 0) ? this.options.step : 1,
            valModStep = (val - this._valueMin()) % step,
            alignValue = val - valModStep;
        if (Math.abs(valModStep) * 2 >= step) {
          alignValue += (valModStep > 0) ? step : (-step);
        }
        return parseFloat(alignValue.toFixed(5));
      },
      _valueMin: function() {
        return this.options.min;
      },
      _valueMax: function() {
        return this.options.max;
      },
      _refreshValue: function() {
        var lastValPercent,
            valPercent,
            value,
            valueMin,
            valueMax,
            oRange = this.options.range,
            o = this.options,
            that = this,
            animate = (!this._animateOff) ? o.animate : false,
            _set = {};
        if (this.options.values && this.options.values.length) {
          this.handles.each(function(i) {
            valPercent = (that.values(i) - that._valueMin()) / (that._valueMax() - that._valueMin()) * 100;
            _set[that.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
            $(this).stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
            if (that.options.range === true) {
              if (that.orientation === "horizontal") {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? "animate" : "css"]({left: valPercent + "%"}, o.animate);
                }
                if (i === 1) {
                  that.range[animate ? "animate" : "css"]({width: (valPercent - lastValPercent) + "%"}, {
                    queue: false,
                    duration: o.animate
                  });
                }
              } else {
                if (i === 0) {
                  that.range.stop(1, 1)[animate ? "animate" : "css"]({bottom: (valPercent) + "%"}, o.animate);
                }
                if (i === 1) {
                  that.range[animate ? "animate" : "css"]({height: (valPercent - lastValPercent) + "%"}, {
                    queue: false,
                    duration: o.animate
                  });
                }
              }
            }
            lastValPercent = valPercent;
          });
        } else {
          value = this.value();
          valueMin = this._valueMin();
          valueMax = this._valueMax();
          valPercent = (valueMax !== valueMin) ? (value - valueMin) / (valueMax - valueMin) * 100 : 0;
          _set[this.orientation === "horizontal" ? "left" : "bottom"] = valPercent + "%";
          this.handle.stop(1, 1)[animate ? "animate" : "css"](_set, o.animate);
          if (oRange === "min" && this.orientation === "horizontal") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({width: valPercent + "%"}, o.animate);
          }
          if (oRange === "max" && this.orientation === "horizontal") {
            this.range[animate ? "animate" : "css"]({width: (100 - valPercent) + "%"}, {
              queue: false,
              duration: o.animate
            });
          }
          if (oRange === "min" && this.orientation === "vertical") {
            this.range.stop(1, 1)[animate ? "animate" : "css"]({height: valPercent + "%"}, o.animate);
          }
          if (oRange === "max" && this.orientation === "vertical") {
            this.range[animate ? "animate" : "css"]({height: (100 - valPercent) + "%"}, {
              queue: false,
              duration: o.animate
            });
          }
        }
      },
      _handleEvents: {
        keydown: function(event) {
          var allowed,
              curVal,
              newVal,
              step,
              index = $(event.target).data("ui-slider-handle-index");
          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
            case $.ui.keyCode.END:
            case $.ui.keyCode.PAGE_UP:
            case $.ui.keyCode.PAGE_DOWN:
            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              event.preventDefault();
              if (!this._keySliding) {
                this._keySliding = true;
                $(event.target).addClass("ui-state-active");
                allowed = this._start(event, index);
                if (allowed === false) {
                  return;
                }
              }
              break;
          }
          step = this.options.step;
          if (this.options.values && this.options.values.length) {
            curVal = newVal = this.values(index);
          } else {
            curVal = newVal = this.value();
          }
          switch (event.keyCode) {
            case $.ui.keyCode.HOME:
              newVal = this._valueMin();
              break;
            case $.ui.keyCode.END:
              newVal = this._valueMax();
              break;
            case $.ui.keyCode.PAGE_UP:
              newVal = this._trimAlignValue(curVal + ((this._valueMax() - this._valueMin()) / this.numPages));
              break;
            case $.ui.keyCode.PAGE_DOWN:
              newVal = this._trimAlignValue(curVal - ((this._valueMax() - this._valueMin()) / this.numPages));
              break;
            case $.ui.keyCode.UP:
            case $.ui.keyCode.RIGHT:
              if (curVal === this._valueMax()) {
                return;
              }
              newVal = this._trimAlignValue(curVal + step);
              break;
            case $.ui.keyCode.DOWN:
            case $.ui.keyCode.LEFT:
              if (curVal === this._valueMin()) {
                return;
              }
              newVal = this._trimAlignValue(curVal - step);
              break;
          }
          this._slide(event, index, newVal);
        },
        keyup: function(event) {
          var index = $(event.target).data("ui-slider-handle-index");
          if (this._keySliding) {
            this._keySliding = false;
            this._stop(event, index);
            this._change(event, index);
            $(event.target).removeClass("ui-state-active");
          }
        }
      }
    });
    var sortable = $.widget("ui.sortable", $.ui.mouse, {
      version: "1.11.1",
      widgetEventPrefix: "sort",
      ready: false,
      options: {
        appendTo: "parent",
        axis: false,
        connectWith: false,
        containment: false,
        cursor: "auto",
        cursorAt: false,
        dropOnEmpty: true,
        forcePlaceholderSize: false,
        forceHelperSize: false,
        grid: false,
        handle: false,
        helper: "original",
        items: "> *",
        opacity: false,
        placeholder: false,
        revert: false,
        scroll: true,
        scrollSensitivity: 20,
        scrollSpeed: 20,
        scope: "default",
        tolerance: "intersect",
        zIndex: 1000,
        activate: null,
        beforeStop: null,
        change: null,
        deactivate: null,
        out: null,
        over: null,
        receive: null,
        remove: null,
        sort: null,
        start: null,
        stop: null,
        update: null
      },
      _isOverAxis: function(x, reference, size) {
        return (x >= reference) && (x < (reference + size));
      },
      _isFloating: function(item) {
        return (/left|right/).test(item.css("float")) || (/inline|table-cell/).test(item.css("display"));
      },
      _create: function() {
        var o = this.options;
        this.containerCache = {};
        this.element.addClass("ui-sortable");
        this.refresh();
        this.floating = this.items.length ? o.axis === "x" || this._isFloating(this.items[0].item) : false;
        this.offset = this.element.offset();
        this._mouseInit();
        this._setHandleClassName();
        this.ready = true;
      },
      _setOption: function(key, value) {
        this._super(key, value);
        if (key === "handle") {
          this._setHandleClassName();
        }
      },
      _setHandleClassName: function() {
        this.element.find(".ui-sortable-handle").removeClass("ui-sortable-handle");
        $.each(this.items, function() {
          (this.instance.options.handle ? this.item.find(this.instance.options.handle) : this.item).addClass("ui-sortable-handle");
        });
      },
      _destroy: function() {
        this.element.removeClass("ui-sortable ui-sortable-disabled").find(".ui-sortable-handle").removeClass("ui-sortable-handle");
        this._mouseDestroy();
        for (var i = this.items.length - 1; i >= 0; i--) {
          this.items[i].item.removeData(this.widgetName + "-item");
        }
        return this;
      },
      _mouseCapture: function(event, overrideHandle) {
        var currentItem = null,
            validHandle = false,
            that = this;
        if (this.reverting) {
          return false;
        }
        if (this.options.disabled || this.options.type === "static") {
          return false;
        }
        this._refreshItems(event);
        $(event.target).parents().each(function() {
          if ($.data(this, that.widgetName + "-item") === that) {
            currentItem = $(this);
            return false;
          }
        });
        if ($.data(event.target, that.widgetName + "-item") === that) {
          currentItem = $(event.target);
        }
        if (!currentItem) {
          return false;
        }
        if (this.options.handle && !overrideHandle) {
          $(this.options.handle, currentItem).find("*").addBack().each(function() {
            if (this === event.target) {
              validHandle = true;
            }
          });
          if (!validHandle) {
            return false;
          }
        }
        this.currentItem = currentItem;
        this._removeCurrentsFromItems();
        return true;
      },
      _mouseStart: function(event, overrideHandle, noActivation) {
        var i,
            body,
            o = this.options;
        this.currentContainer = this;
        this.refreshPositions();
        this.helper = this._createHelper(event);
        this._cacheHelperProportions();
        this._cacheMargins();
        this.scrollParent = this.helper.scrollParent();
        this.offset = this.currentItem.offset();
        this.offset = {
          top: this.offset.top - this.margins.top,
          left: this.offset.left - this.margins.left
        };
        $.extend(this.offset, {
          click: {
            left: event.pageX - this.offset.left,
            top: event.pageY - this.offset.top
          },
          parent: this._getParentOffset(),
          relative: this._getRelativeOffset()
        });
        this.helper.css("position", "absolute");
        this.cssPosition = this.helper.css("position");
        this.originalPosition = this._generatePosition(event);
        this.originalPageX = event.pageX;
        this.originalPageY = event.pageY;
        (o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));
        this.domPosition = {
          prev: this.currentItem.prev()[0],
          parent: this.currentItem.parent()[0]
        };
        if (this.helper[0] !== this.currentItem[0]) {
          this.currentItem.hide();
        }
        this._createPlaceholder();
        if (o.containment) {
          this._setContainment();
        }
        if (o.cursor && o.cursor !== "auto") {
          body = this.document.find("body");
          this.storedCursor = body.css("cursor");
          body.css("cursor", o.cursor);
          this.storedStylesheet = $("<style>*{ cursor: " + o.cursor + " !important; }</style>").appendTo(body);
        }
        if (o.opacity) {
          if (this.helper.css("opacity")) {
            this._storedOpacity = this.helper.css("opacity");
          }
          this.helper.css("opacity", o.opacity);
        }
        if (o.zIndex) {
          if (this.helper.css("zIndex")) {
            this._storedZIndex = this.helper.css("zIndex");
          }
          this.helper.css("zIndex", o.zIndex);
        }
        if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
          this.overflowOffset = this.scrollParent.offset();
        }
        this._trigger("start", event, this._uiHash());
        if (!this._preserveHelperProportions) {
          this._cacheHelperProportions();
        }
        if (!noActivation) {
          for (i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger("activate", event, this._uiHash(this));
          }
        }
        if ($.ui.ddmanager) {
          $.ui.ddmanager.current = this;
        }
        if ($.ui.ddmanager && !o.dropBehaviour) {
          $.ui.ddmanager.prepareOffsets(this, event);
        }
        this.dragging = true;
        this.helper.addClass("ui-sortable-helper");
        this._mouseDrag(event);
        return true;
      },
      _mouseDrag: function(event) {
        var i,
            item,
            itemElement,
            intersection,
            o = this.options,
            scrolled = false;
        this.position = this._generatePosition(event);
        this.positionAbs = this._convertPositionTo("absolute");
        if (!this.lastPositionAbs) {
          this.lastPositionAbs = this.positionAbs;
        }
        if (this.options.scroll) {
          if (this.scrollParent[0] !== document && this.scrollParent[0].tagName !== "HTML") {
            if ((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
            } else if (event.pageY - this.overflowOffset.top < o.scrollSensitivity) {
              this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;
            }
            if ((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
            } else if (event.pageX - this.overflowOffset.left < o.scrollSensitivity) {
              this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;
            }
          } else {
            if (event.pageY - $(document).scrollTop() < o.scrollSensitivity) {
              scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
            } else if ($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity) {
              scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
            }
            if (event.pageX - $(document).scrollLeft() < o.scrollSensitivity) {
              scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
            } else if ($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity) {
              scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
            }
          }
          if (scrolled !== false && $.ui.ddmanager && !o.dropBehaviour) {
            $.ui.ddmanager.prepareOffsets(this, event);
          }
        }
        this.positionAbs = this._convertPositionTo("absolute");
        if (!this.options.axis || this.options.axis !== "y") {
          this.helper[0].style.left = this.position.left + "px";
        }
        if (!this.options.axis || this.options.axis !== "x") {
          this.helper[0].style.top = this.position.top + "px";
        }
        for (i = this.items.length - 1; i >= 0; i--) {
          item = this.items[i];
          itemElement = item.item[0];
          intersection = this._intersectsWithPointer(item);
          if (!intersection) {
            continue;
          }
          if (item.instance !== this.currentContainer) {
            continue;
          }
          if (itemElement !== this.currentItem[0] && this.placeholder[intersection === 1 ? "next" : "prev"]()[0] !== itemElement && !$.contains(this.placeholder[0], itemElement) && (this.options.type === "semi-dynamic" ? !$.contains(this.element[0], itemElement) : true)) {
            this.direction = intersection === 1 ? "down" : "up";
            if (this.options.tolerance === "pointer" || this._intersectsWithSides(item)) {
              this._rearrange(event, item);
            } else {
              break;
            }
            this._trigger("change", event, this._uiHash());
            break;
          }
        }
        this._contactContainers(event);
        if ($.ui.ddmanager) {
          $.ui.ddmanager.drag(this, event);
        }
        this._trigger("sort", event, this._uiHash());
        this.lastPositionAbs = this.positionAbs;
        return false;
      },
      _mouseStop: function(event, noPropagation) {
        if (!event) {
          return;
        }
        if ($.ui.ddmanager && !this.options.dropBehaviour) {
          $.ui.ddmanager.drop(this, event);
        }
        if (this.options.revert) {
          var that = this,
              cur = this.placeholder.offset(),
              axis = this.options.axis,
              animation = {};
          if (!axis || axis === "x") {
            animation.left = cur.left - this.offset.parent.left - this.margins.left + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollLeft);
          }
          if (!axis || axis === "y") {
            animation.top = cur.top - this.offset.parent.top - this.margins.top + (this.offsetParent[0] === document.body ? 0 : this.offsetParent[0].scrollTop);
          }
          this.reverting = true;
          $(this.helper).animate(animation, parseInt(this.options.revert, 10) || 500, function() {
            that._clear(event);
          });
        } else {
          this._clear(event, noPropagation);
        }
        return false;
      },
      cancel: function() {
        if (this.dragging) {
          this._mouseUp({target: null});
          if (this.options.helper === "original") {
            this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
          } else {
            this.currentItem.show();
          }
          for (var i = this.containers.length - 1; i >= 0; i--) {
            this.containers[i]._trigger("deactivate", null, this._uiHash(this));
            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger("out", null, this._uiHash(this));
              this.containers[i].containerCache.over = 0;
            }
          }
        }
        if (this.placeholder) {
          if (this.placeholder[0].parentNode) {
            this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
          }
          if (this.options.helper !== "original" && this.helper && this.helper[0].parentNode) {
            this.helper.remove();
          }
          $.extend(this, {
            helper: null,
            dragging: false,
            reverting: false,
            _noFinalSort: null
          });
          if (this.domPosition.prev) {
            $(this.domPosition.prev).after(this.currentItem);
          } else {
            $(this.domPosition.parent).prepend(this.currentItem);
          }
        }
        return this;
      },
      serialize: function(o) {
        var items = this._getItemsAsjQuery(o && o.connected),
            str = [];
        o = o || {};
        $(items).each(function() {
          var res = ($(o.item || this).attr(o.attribute || "id") || "").match(o.expression || (/(.+)[\-=_](.+)/));
          if (res) {
            str.push((o.key || res[1] + "[]") + "=" + (o.key && o.expression ? res[1] : res[2]));
          }
        });
        if (!str.length && o.key) {
          str.push(o.key + "=");
        }
        return str.join("&");
      },
      toArray: function(o) {
        var items = this._getItemsAsjQuery(o && o.connected),
            ret = [];
        o = o || {};
        items.each(function() {
          ret.push($(o.item || this).attr(o.attribute || "id") || "");
        });
        return ret;
      },
      _intersectsWith: function(item) {
        var x1 = this.positionAbs.left,
            x2 = x1 + this.helperProportions.width,
            y1 = this.positionAbs.top,
            y2 = y1 + this.helperProportions.height,
            l = item.left,
            r = l + item.width,
            t = item.top,
            b = t + item.height,
            dyClick = this.offset.click.top,
            dxClick = this.offset.click.left,
            isOverElementHeight = (this.options.axis === "x") || ((y1 + dyClick) > t && (y1 + dyClick) < b),
            isOverElementWidth = (this.options.axis === "y") || ((x1 + dxClick) > l && (x1 + dxClick) < r),
            isOverElement = isOverElementHeight && isOverElementWidth;
        if (this.options.tolerance === "pointer" || this.options.forcePointerForContainers || (this.options.tolerance !== "pointer" && this.helperProportions[this.floating ? "width" : "height"] > item[this.floating ? "width" : "height"])) {
          return isOverElement;
        } else {
          return (l < x1 + (this.helperProportions.width / 2) && x2 - (this.helperProportions.width / 2) < r && t < y1 + (this.helperProportions.height / 2) && y2 - (this.helperProportions.height / 2) < b);
        }
      },
      _intersectsWithPointer: function(item) {
        var isOverElementHeight = (this.options.axis === "x") || this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
            isOverElementWidth = (this.options.axis === "y") || this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
            isOverElement = isOverElementHeight && isOverElementWidth,
            verticalDirection = this._getDragVerticalDirection(),
            horizontalDirection = this._getDragHorizontalDirection();
        if (!isOverElement) {
          return false;
        }
        return this.floating ? (((horizontalDirection && horizontalDirection === "right") || verticalDirection === "down") ? 2 : 1) : (verticalDirection && (verticalDirection === "down" ? 2 : 1));
      },
      _intersectsWithSides: function(item) {
        var isOverBottomHalf = this._isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height / 2), item.height),
            isOverRightHalf = this._isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width / 2), item.width),
            verticalDirection = this._getDragVerticalDirection(),
            horizontalDirection = this._getDragHorizontalDirection();
        if (this.floating && horizontalDirection) {
          return ((horizontalDirection === "right" && isOverRightHalf) || (horizontalDirection === "left" && !isOverRightHalf));
        } else {
          return verticalDirection && ((verticalDirection === "down" && isOverBottomHalf) || (verticalDirection === "up" && !isOverBottomHalf));
        }
      },
      _getDragVerticalDirection: function() {
        var delta = this.positionAbs.top - this.lastPositionAbs.top;
        return delta !== 0 && (delta > 0 ? "down" : "up");
      },
      _getDragHorizontalDirection: function() {
        var delta = this.positionAbs.left - this.lastPositionAbs.left;
        return delta !== 0 && (delta > 0 ? "right" : "left");
      },
      refresh: function(event) {
        this._refreshItems(event);
        this._setHandleClassName();
        this.refreshPositions();
        return this;
      },
      _connectWith: function() {
        var options = this.options;
        return options.connectWith.constructor === String ? [options.connectWith] : options.connectWith;
      },
      _getItemsAsjQuery: function(connected) {
        var i,
            j,
            cur,
            inst,
            items = [],
            queries = [],
            connectWith = this._connectWith();
        if (connectWith && connected) {
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i]);
            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);
              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), inst]);
              }
            }
          }
        }
        queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, {
          options: this.options,
          item: this.currentItem
        }) : $(this.options.items, this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"), this]);
        function addItems() {
          items.push(this);
        }
        for (i = queries.length - 1; i >= 0; i--) {
          queries[i][0].each(addItems);
        }
        return $(items);
      },
      _removeCurrentsFromItems: function() {
        var list = this.currentItem.find(":data(" + this.widgetName + "-item)");
        this.items = $.grep(this.items, function(item) {
          for (var j = 0; j < list.length; j++) {
            if (list[j] === item.item[0]) {
              return false;
            }
          }
          return true;
        });
      },
      _refreshItems: function(event) {
        this.items = [];
        this.containers = [this];
        var i,
            j,
            cur,
            inst,
            targetData,
            _queries,
            item,
            queriesLength,
            items = this.items,
            queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, {item: this.currentItem}) : $(this.options.items, this.element), this]],
            connectWith = this._connectWith();
        if (connectWith && this.ready) {
          for (i = connectWith.length - 1; i >= 0; i--) {
            cur = $(connectWith[i]);
            for (j = cur.length - 1; j >= 0; j--) {
              inst = $.data(cur[j], this.widgetFullName);
              if (inst && inst !== this && !inst.options.disabled) {
                queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, {item: this.currentItem}) : $(inst.options.items, inst.element), inst]);
                this.containers.push(inst);
              }
            }
          }
        }
        for (i = queries.length - 1; i >= 0; i--) {
          targetData = queries[i][1];
          _queries = queries[i][0];
          for (j = 0, queriesLength = _queries.length; j < queriesLength; j++) {
            item = $(_queries[j]);
            item.data(this.widgetName + "-item", targetData);
            items.push({
              item: item,
              instance: targetData,
              width: 0,
              height: 0,
              left: 0,
              top: 0
            });
          }
        }
      },
      refreshPositions: function(fast) {
        if (this.offsetParent && this.helper) {
          this.offset.parent = this._getParentOffset();
        }
        var i,
            item,
            t,
            p;
        for (i = this.items.length - 1; i >= 0; i--) {
          item = this.items[i];
          if (item.instance !== this.currentContainer && this.currentContainer && item.item[0] !== this.currentItem[0]) {
            continue;
          }
          t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;
          if (!fast) {
            item.width = t.outerWidth();
            item.height = t.outerHeight();
          }
          p = t.offset();
          item.left = p.left;
          item.top = p.top;
        }
        if (this.options.custom && this.options.custom.refreshContainers) {
          this.options.custom.refreshContainers.call(this);
        } else {
          for (i = this.containers.length - 1; i >= 0; i--) {
            p = this.containers[i].element.offset();
            this.containers[i].containerCache.left = p.left;
            this.containers[i].containerCache.top = p.top;
            this.containers[i].containerCache.width = this.containers[i].element.outerWidth();
            this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
          }
        }
        return this;
      },
      _createPlaceholder: function(that) {
        that = that || this;
        var className,
            o = that.options;
        if (!o.placeholder || o.placeholder.constructor === String) {
          className = o.placeholder;
          o.placeholder = {
            element: function() {
              var nodeName = that.currentItem[0].nodeName.toLowerCase(),
                  element = $("<" + nodeName + ">", that.document[0]).addClass(className || that.currentItem[0].className + " ui-sortable-placeholder").removeClass("ui-sortable-helper");
              if (nodeName === "tr") {
                that.currentItem.children().each(function() {
                  $("<td>&#160;</td>", that.document[0]).attr("colspan", $(this).attr("colspan") || 1).appendTo(element);
                });
              } else if (nodeName === "img") {
                element.attr("src", that.currentItem.attr("src"));
              }
              if (!className) {
                element.css("visibility", "hidden");
              }
              return element;
            },
            update: function(container, p) {
              if (className && !o.forcePlaceholderSize) {
                return;
              }
              if (!p.height()) {
                p.height(that.currentItem.innerHeight() - parseInt(that.currentItem.css("paddingTop") || 0, 10) - parseInt(that.currentItem.css("paddingBottom") || 0, 10));
              }
              if (!p.width()) {
                p.width(that.currentItem.innerWidth() - parseInt(that.currentItem.css("paddingLeft") || 0, 10) - parseInt(that.currentItem.css("paddingRight") || 0, 10));
              }
            }
          };
        }
        that.placeholder = $(o.placeholder.element.call(that.element, that.currentItem));
        that.currentItem.after(that.placeholder);
        o.placeholder.update(that, that.placeholder);
      },
      _contactContainers: function(event) {
        var i,
            j,
            dist,
            itemWithLeastDistance,
            posProperty,
            sizeProperty,
            cur,
            nearBottom,
            floating,
            axis,
            innermostContainer = null,
            innermostIndex = null;
        for (i = this.containers.length - 1; i >= 0; i--) {
          if ($.contains(this.currentItem[0], this.containers[i].element[0])) {
            continue;
          }
          if (this._intersectsWith(this.containers[i].containerCache)) {
            if (innermostContainer && $.contains(this.containers[i].element[0], innermostContainer.element[0])) {
              continue;
            }
            innermostContainer = this.containers[i];
            innermostIndex = i;
          } else {
            if (this.containers[i].containerCache.over) {
              this.containers[i]._trigger("out", event, this._uiHash(this));
              this.containers[i].containerCache.over = 0;
            }
          }
        }
        if (!innermostContainer) {
          return;
        }
        if (this.containers.length === 1) {
          if (!this.containers[innermostIndex].containerCache.over) {
            this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
            this.containers[innermostIndex].containerCache.over = 1;
          }
        } else {
          dist = 10000;
          itemWithLeastDistance = null;
          floating = innermostContainer.floating || this._isFloating(this.currentItem);
          posProperty = floating ? "left" : "top";
          sizeProperty = floating ? "width" : "height";
          axis = floating ? "clientX" : "clientY";
          for (j = this.items.length - 1; j >= 0; j--) {
            if (!$.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) {
              continue;
            }
            if (this.items[j].item[0] === this.currentItem[0]) {
              continue;
            }
            cur = this.items[j].item.offset()[posProperty];
            nearBottom = false;
            if (event[axis] - cur > this.items[j][sizeProperty] / 2) {
              nearBottom = true;
            }
            if (Math.abs(event[axis] - cur) < dist) {
              dist = Math.abs(event[axis] - cur);
              itemWithLeastDistance = this.items[j];
              this.direction = nearBottom ? "up" : "down";
            }
          }
          if (!itemWithLeastDistance && !this.options.dropOnEmpty) {
            return;
          }
          if (this.currentContainer === this.containers[innermostIndex]) {
            return;
          }
          itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
          this._trigger("change", event, this._uiHash());
          this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));
          this.currentContainer = this.containers[innermostIndex];
          this.options.placeholder.update(this.currentContainer, this.placeholder);
          this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
          this.containers[innermostIndex].containerCache.over = 1;
        }
      },
      _createHelper: function(event) {
        var o = this.options,
            helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper === "clone" ? this.currentItem.clone() : this.currentItem);
        if (!helper.parents("body").length) {
          $(o.appendTo !== "parent" ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);
        }
        if (helper[0] === this.currentItem[0]) {
          this._storedCSS = {
            width: this.currentItem[0].style.width,
            height: this.currentItem[0].style.height,
            position: this.currentItem.css("position"),
            top: this.currentItem.css("top"),
            left: this.currentItem.css("left")
          };
        }
        if (!helper[0].style.width || o.forceHelperSize) {
          helper.width(this.currentItem.width());
        }
        if (!helper[0].style.height || o.forceHelperSize) {
          helper.height(this.currentItem.height());
        }
        return helper;
      },
      _adjustOffsetFromHelper: function(obj) {
        if (typeof obj === "string") {
          obj = obj.split(" ");
        }
        if ($.isArray(obj)) {
          obj = {
            left: +obj[0],
            top: +obj[1] || 0
          };
        }
        if ("left" in obj) {
          this.offset.click.left = obj.left + this.margins.left;
        }
        if ("right" in obj) {
          this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
        }
        if ("top" in obj) {
          this.offset.click.top = obj.top + this.margins.top;
        }
        if ("bottom" in obj) {
          this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
        }
      },
      _getParentOffset: function() {
        this.offsetParent = this.helper.offsetParent();
        var po = this.offsetParent.offset();
        if (this.cssPosition === "absolute" && this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) {
          po.left += this.scrollParent.scrollLeft();
          po.top += this.scrollParent.scrollTop();
        }
        if (this.offsetParent[0] === document.body || (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() === "html" && $.ui.ie)) {
          po = {
            top: 0,
            left: 0
          };
        }
        return {
          top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0),
          left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
        };
      },
      _getRelativeOffset: function() {
        if (this.cssPosition === "relative") {
          var p = this.currentItem.position();
          return {
            top: p.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(),
            left: p.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
          };
        } else {
          return {
            top: 0,
            left: 0
          };
        }
      },
      _cacheMargins: function() {
        this.margins = {
          left: (parseInt(this.currentItem.css("marginLeft"), 10) || 0),
          top: (parseInt(this.currentItem.css("marginTop"), 10) || 0)
        };
      },
      _cacheHelperProportions: function() {
        this.helperProportions = {
          width: this.helper.outerWidth(),
          height: this.helper.outerHeight()
        };
      },
      _setContainment: function() {
        var ce,
            co,
            over,
            o = this.options;
        if (o.containment === "parent") {
          o.containment = this.helper[0].parentNode;
        }
        if (o.containment === "document" || o.containment === "window") {
          this.containment = [0 - this.offset.relative.left - this.offset.parent.left, 0 - this.offset.relative.top - this.offset.parent.top, $(o.containment === "document" ? document : window).width() - this.helperProportions.width - this.margins.left, ($(o.containment === "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
        }
        if (!(/^(document|window|parent)$/).test(o.containment)) {
          ce = $(o.containment)[0];
          co = $(o.containment).offset();
          over = ($(ce).css("overflow") !== "hidden");
          this.containment = [co.left + (parseInt($(ce).css("borderLeftWidth"), 10) || 0) + (parseInt($(ce).css("paddingLeft"), 10) || 0) - this.margins.left, co.top + (parseInt($(ce).css("borderTopWidth"), 10) || 0) + (parseInt($(ce).css("paddingTop"), 10) || 0) - this.margins.top, co.left + (over ? Math.max(ce.scrollWidth, ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"), 10) || 0) - (parseInt($(ce).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left, co.top + (over ? Math.max(ce.scrollHeight, ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"), 10) || 0) - (parseInt($(ce).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top];
        }
      },
      _convertPositionTo: function(d, pos) {
        if (!pos) {
          pos = this.position;
        }
        var mod = d === "absolute" ? 1 : -1,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
        return {
          top: (pos.top + this.offset.relative.top * mod + this.offset.parent.top * mod - ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())) * mod)),
          left: (pos.left + this.offset.relative.left * mod + this.offset.parent.left * mod - ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft()) * mod))
        };
      },
      _generatePosition: function(event) {
        var top,
            left,
            o = this.options,
            pageX = event.pageX,
            pageY = event.pageY,
            scroll = this.cssPosition === "absolute" && !(this.scrollParent[0] !== document && $.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
            scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
        if (this.cssPosition === "relative" && !(this.scrollParent[0] !== document && this.scrollParent[0] !== this.offsetParent[0])) {
          this.offset.relative = this._getRelativeOffset();
        }
        if (this.originalPosition) {
          if (this.containment) {
            if (event.pageX - this.offset.click.left < this.containment[0]) {
              pageX = this.containment[0] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top < this.containment[1]) {
              pageY = this.containment[1] + this.offset.click.top;
            }
            if (event.pageX - this.offset.click.left > this.containment[2]) {
              pageX = this.containment[2] + this.offset.click.left;
            }
            if (event.pageY - this.offset.click.top > this.containment[3]) {
              pageY = this.containment[3] + this.offset.click.top;
            }
          }
          if (o.grid) {
            top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
            pageY = this.containment ? ((top - this.offset.click.top >= this.containment[1] && top - this.offset.click.top <= this.containment[3]) ? top : ((top - this.offset.click.top >= this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;
            left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
            pageX = this.containment ? ((left - this.offset.click.left >= this.containment[0] && left - this.offset.click.left <= this.containment[2]) ? left : ((left - this.offset.click.left >= this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
          }
        }
        return {
          top: (pageY - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + ((this.cssPosition === "fixed" ? -this.scrollParent.scrollTop() : (scrollIsRootNode ? 0 : scroll.scrollTop())))),
          left: (pageX - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + ((this.cssPosition === "fixed" ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft())))
        };
      },
      _rearrange: function(event, i, a, hardRefresh) {
        a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction === "down" ? i.item[0] : i.item[0].nextSibling));
        this.counter = this.counter ? ++this.counter : 1;
        var counter = this.counter;
        this._delay(function() {
          if (counter === this.counter) {
            this.refreshPositions(!hardRefresh);
          }
        });
      },
      _clear: function(event, noPropagation) {
        this.reverting = false;
        var i,
            delayedTriggers = [];
        if (!this._noFinalSort && this.currentItem.parent().length) {
          this.placeholder.before(this.currentItem);
        }
        this._noFinalSort = null;
        if (this.helper[0] === this.currentItem[0]) {
          for (i in this._storedCSS) {
            if (this._storedCSS[i] === "auto" || this._storedCSS[i] === "static") {
              this._storedCSS[i] = "";
            }
          }
          this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
        } else {
          this.currentItem.show();
        }
        if (this.fromOutside && !noPropagation) {
          delayedTriggers.push(function(event) {
            this._trigger("receive", event, this._uiHash(this.fromOutside));
          });
        }
        if ((this.fromOutside || this.domPosition.prev !== this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent !== this.currentItem.parent()[0]) && !noPropagation) {
          delayedTriggers.push(function(event) {
            this._trigger("update", event, this._uiHash());
          });
        }
        if (this !== this.currentContainer) {
          if (!noPropagation) {
            delayedTriggers.push(function(event) {
              this._trigger("remove", event, this._uiHash());
            });
            delayedTriggers.push((function(c) {
              return function(event) {
                c._trigger("receive", event, this._uiHash(this));
              };
            }).call(this, this.currentContainer));
            delayedTriggers.push((function(c) {
              return function(event) {
                c._trigger("update", event, this._uiHash(this));
              };
            }).call(this, this.currentContainer));
          }
        }
        function delayEvent(type, instance, container) {
          return function(event) {
            container._trigger(type, event, instance._uiHash(instance));
          };
        }
        for (i = this.containers.length - 1; i >= 0; i--) {
          if (!noPropagation) {
            delayedTriggers.push(delayEvent("deactivate", this, this.containers[i]));
          }
          if (this.containers[i].containerCache.over) {
            delayedTriggers.push(delayEvent("out", this, this.containers[i]));
            this.containers[i].containerCache.over = 0;
          }
        }
        if (this.storedCursor) {
          this.document.find("body").css("cursor", this.storedCursor);
          this.storedStylesheet.remove();
        }
        if (this._storedOpacity) {
          this.helper.css("opacity", this._storedOpacity);
        }
        if (this._storedZIndex) {
          this.helper.css("zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex);
        }
        this.dragging = false;
        if (this.cancelHelperRemoval) {
          if (!noPropagation) {
            this._trigger("beforeStop", event, this._uiHash());
            for (i = 0; i < delayedTriggers.length; i++) {
              delayedTriggers[i].call(this, event);
            }
            this._trigger("stop", event, this._uiHash());
          }
          this.fromOutside = false;
          return false;
        }
        if (!noPropagation) {
          this._trigger("beforeStop", event, this._uiHash());
        }
        this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
        if (this.helper[0] !== this.currentItem[0]) {
          this.helper.remove();
        }
        this.helper = null;
        if (!noPropagation) {
          for (i = 0; i < delayedTriggers.length; i++) {
            delayedTriggers[i].call(this, event);
          }
          this._trigger("stop", event, this._uiHash());
        }
        this.fromOutside = false;
        return true;
      },
      _trigger: function() {
        if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
          this.cancel();
        }
      },
      _uiHash: function(_inst) {
        var inst = _inst || this;
        return {
          helper: inst.helper,
          placeholder: inst.placeholder || $([]),
          position: inst.position,
          originalPosition: inst.originalPosition,
          offset: inst.positionAbs,
          item: inst.currentItem,
          sender: _inst ? _inst.element : null
        };
      }
    });
    function spinner_modifier(fn) {
      return function() {
        var previous = this.element.val();
        fn.apply(this, arguments);
        this._refresh();
        if (previous !== this.element.val()) {
          this._trigger("change");
        }
      };
    }
    var spinner = $.widget("ui.spinner", {
      version: "1.11.1",
      defaultElement: "<input>",
      widgetEventPrefix: "spin",
      options: {
        culture: null,
        icons: {
          down: "ui-icon-triangle-1-s",
          up: "ui-icon-triangle-1-n"
        },
        incremental: true,
        max: null,
        min: null,
        numberFormat: null,
        page: 10,
        step: 1,
        change: null,
        spin: null,
        start: null,
        stop: null
      },
      _create: function() {
        this._setOption("max", this.options.max);
        this._setOption("min", this.options.min);
        this._setOption("step", this.options.step);
        if (this.value() !== "") {
          this._value(this.element.val(), true);
        }
        this._draw();
        this._on(this._events);
        this._refresh();
        this._on(this.window, {beforeunload: function() {
            this.element.removeAttr("autocomplete");
          }});
      },
      _getCreateOptions: function() {
        var options = {},
            element = this.element;
        $.each(["min", "max", "step"], function(i, option) {
          var value = element.attr(option);
          if (value !== undefined && value.length) {
            options[option] = value;
          }
        });
        return options;
      },
      _events: {
        keydown: function(event) {
          if (this._start(event) && this._keydown(event)) {
            event.preventDefault();
          }
        },
        keyup: "_stop",
        focus: function() {
          this.previous = this.element.val();
        },
        blur: function(event) {
          if (this.cancelBlur) {
            delete this.cancelBlur;
            return;
          }
          this._stop();
          this._refresh();
          if (this.previous !== this.element.val()) {
            this._trigger("change", event);
          }
        },
        mousewheel: function(event, delta) {
          if (!delta) {
            return;
          }
          if (!this.spinning && !this._start(event)) {
            return false;
          }
          this._spin((delta > 0 ? 1 : -1) * this.options.step, event);
          clearTimeout(this.mousewheelTimer);
          this.mousewheelTimer = this._delay(function() {
            if (this.spinning) {
              this._stop(event);
            }
          }, 100);
          event.preventDefault();
        },
        "mousedown .ui-spinner-button": function(event) {
          var previous;
          previous = this.element[0] === this.document[0].activeElement ? this.previous : this.element.val();
          function checkFocus() {
            var isActive = this.element[0] === this.document[0].activeElement;
            if (!isActive) {
              this.element.focus();
              this.previous = previous;
              this._delay(function() {
                this.previous = previous;
              });
            }
          }
          event.preventDefault();
          checkFocus.call(this);
          this.cancelBlur = true;
          this._delay(function() {
            delete this.cancelBlur;
            checkFocus.call(this);
          });
          if (this._start(event) === false) {
            return;
          }
          this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
        },
        "mouseup .ui-spinner-button": "_stop",
        "mouseenter .ui-spinner-button": function(event) {
          if (!$(event.currentTarget).hasClass("ui-state-active")) {
            return;
          }
          if (this._start(event) === false) {
            return false;
          }
          this._repeat(null, $(event.currentTarget).hasClass("ui-spinner-up") ? 1 : -1, event);
        },
        "mouseleave .ui-spinner-button": "_stop"
      },
      _draw: function() {
        var uiSpinner = this.uiSpinner = this.element.addClass("ui-spinner-input").attr("autocomplete", "off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml());
        this.element.attr("role", "spinbutton");
        this.buttons = uiSpinner.find(".ui-spinner-button").attr("tabIndex", -1).button().removeClass("ui-corner-all");
        if (this.buttons.height() > Math.ceil(uiSpinner.height() * 0.5) && uiSpinner.height() > 0) {
          uiSpinner.height(uiSpinner.height());
        }
        if (this.options.disabled) {
          this.disable();
        }
      },
      _keydown: function(event) {
        var options = this.options,
            keyCode = $.ui.keyCode;
        switch (event.keyCode) {
          case keyCode.UP:
            this._repeat(null, 1, event);
            return true;
          case keyCode.DOWN:
            this._repeat(null, -1, event);
            return true;
          case keyCode.PAGE_UP:
            this._repeat(null, options.page, event);
            return true;
          case keyCode.PAGE_DOWN:
            this._repeat(null, -options.page, event);
            return true;
        }
        return false;
      },
      _uiSpinnerHtml: function() {
        return "<span class='ui-spinner ui-widget ui-widget-content ui-corner-all'></span>";
      },
      _buttonHtml: function() {
        return "" + "<a class='ui-spinner-button ui-spinner-up ui-corner-tr'>" + "<span class='ui-icon " + this.options.icons.up + "'>&#9650;</span>" + "</a>" + "<a class='ui-spinner-button ui-spinner-down ui-corner-br'>" + "<span class='ui-icon " + this.options.icons.down + "'>&#9660;</span>" + "</a>";
      },
      _start: function(event) {
        if (!this.spinning && this._trigger("start", event) === false) {
          return false;
        }
        if (!this.counter) {
          this.counter = 1;
        }
        this.spinning = true;
        return true;
      },
      _repeat: function(i, steps, event) {
        i = i || 500;
        clearTimeout(this.timer);
        this.timer = this._delay(function() {
          this._repeat(40, steps, event);
        }, i);
        this._spin(steps * this.options.step, event);
      },
      _spin: function(step, event) {
        var value = this.value() || 0;
        if (!this.counter) {
          this.counter = 1;
        }
        value = this._adjustValue(value + step * this._increment(this.counter));
        if (!this.spinning || this._trigger("spin", event, {value: value}) !== false) {
          this._value(value);
          this.counter++;
        }
      },
      _increment: function(i) {
        var incremental = this.options.incremental;
        if (incremental) {
          return $.isFunction(incremental) ? incremental(i) : Math.floor(i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1);
        }
        return 1;
      },
      _precision: function() {
        var precision = this._precisionOf(this.options.step);
        if (this.options.min !== null) {
          precision = Math.max(precision, this._precisionOf(this.options.min));
        }
        return precision;
      },
      _precisionOf: function(num) {
        var str = num.toString(),
            decimal = str.indexOf(".");
        return decimal === -1 ? 0 : str.length - decimal - 1;
      },
      _adjustValue: function(value) {
        var base,
            aboveMin,
            options = this.options;
        base = options.min !== null ? options.min : 0;
        aboveMin = value - base;
        aboveMin = Math.round(aboveMin / options.step) * options.step;
        value = base + aboveMin;
        value = parseFloat(value.toFixed(this._precision()));
        if (options.max !== null && value > options.max) {
          return options.max;
        }
        if (options.min !== null && value < options.min) {
          return options.min;
        }
        return value;
      },
      _stop: function(event) {
        if (!this.spinning) {
          return;
        }
        clearTimeout(this.timer);
        clearTimeout(this.mousewheelTimer);
        this.counter = 0;
        this.spinning = false;
        this._trigger("stop", event);
      },
      _setOption: function(key, value) {
        if (key === "culture" || key === "numberFormat") {
          var prevValue = this._parse(this.element.val());
          this.options[key] = value;
          this.element.val(this._format(prevValue));
          return;
        }
        if (key === "max" || key === "min" || key === "step") {
          if (typeof value === "string") {
            value = this._parse(value);
          }
        }
        if (key === "icons") {
          this.buttons.first().find(".ui-icon").removeClass(this.options.icons.up).addClass(value.up);
          this.buttons.last().find(".ui-icon").removeClass(this.options.icons.down).addClass(value.down);
        }
        this._super(key, value);
        if (key === "disabled") {
          this.widget().toggleClass("ui-state-disabled", !!value);
          this.element.prop("disabled", !!value);
          this.buttons.button(value ? "disable" : "enable");
        }
      },
      _setOptions: spinner_modifier(function(options) {
        this._super(options);
      }),
      _parse: function(val) {
        if (typeof val === "string" && val !== "") {
          val = window.Globalize && this.options.numberFormat ? Globalize.parseFloat(val, 10, this.options.culture) : +val;
        }
        return val === "" || isNaN(val) ? null : val;
      },
      _format: function(value) {
        if (value === "") {
          return "";
        }
        return window.Globalize && this.options.numberFormat ? Globalize.format(value, this.options.numberFormat, this.options.culture) : value;
      },
      _refresh: function() {
        this.element.attr({
          "aria-valuemin": this.options.min,
          "aria-valuemax": this.options.max,
          "aria-valuenow": this._parse(this.element.val())
        });
      },
      isValid: function() {
        var value = this.value();
        if (value === null) {
          return false;
        }
        return value === this._adjustValue(value);
      },
      _value: function(value, allowAny) {
        var parsed;
        if (value !== "") {
          parsed = this._parse(value);
          if (parsed !== null) {
            if (!allowAny) {
              parsed = this._adjustValue(parsed);
            }
            value = this._format(parsed);
          }
        }
        this.element.val(value);
        this._refresh();
      },
      _destroy: function() {
        this.element.removeClass("ui-spinner-input").prop("disabled", false).removeAttr("autocomplete").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow");
        this.uiSpinner.replaceWith(this.element);
      },
      stepUp: spinner_modifier(function(steps) {
        this._stepUp(steps);
      }),
      _stepUp: function(steps) {
        if (this._start()) {
          this._spin((steps || 1) * this.options.step);
          this._stop();
        }
      },
      stepDown: spinner_modifier(function(steps) {
        this._stepDown(steps);
      }),
      _stepDown: function(steps) {
        if (this._start()) {
          this._spin((steps || 1) * -this.options.step);
          this._stop();
        }
      },
      pageUp: spinner_modifier(function(pages) {
        this._stepUp((pages || 1) * this.options.page);
      }),
      pageDown: spinner_modifier(function(pages) {
        this._stepDown((pages || 1) * this.options.page);
      }),
      value: function(newVal) {
        if (!arguments.length) {
          return this._parse(this.element.val());
        }
        spinner_modifier(this._value).call(this, newVal);
      },
      widget: function() {
        return this.uiSpinner;
      }
    });
    var tabs = $.widget("ui.tabs", {
      version: "1.11.1",
      delay: 300,
      options: {
        active: null,
        collapsible: false,
        event: "click",
        heightStyle: "content",
        hide: null,
        show: null,
        activate: null,
        beforeActivate: null,
        beforeLoad: null,
        load: null
      },
      _isLocal: (function() {
        var rhash = /#.*$/;
        return function(anchor) {
          var anchorUrl,
              locationUrl;
          anchor = anchor.cloneNode(false);
          anchorUrl = anchor.href.replace(rhash, "");
          locationUrl = location.href.replace(rhash, "");
          try {
            anchorUrl = decodeURIComponent(anchorUrl);
          } catch (error) {}
          try {
            locationUrl = decodeURIComponent(locationUrl);
          } catch (error) {}
          return anchor.hash.length > 1 && anchorUrl === locationUrl;
        };
      })(),
      _create: function() {
        var that = this,
            options = this.options;
        this.running = false;
        this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all").toggleClass("ui-tabs-collapsible", options.collapsible);
        this._processTabs();
        options.active = this._initialActive();
        if ($.isArray(options.disabled)) {
          options.disabled = $.unique(options.disabled.concat($.map(this.tabs.filter(".ui-state-disabled"), function(li) {
            return that.tabs.index(li);
          }))).sort();
        }
        if (this.options.active !== false && this.anchors.length) {
          this.active = this._findActive(options.active);
        } else {
          this.active = $();
        }
        this._refresh();
        if (this.active.length) {
          this.load(options.active);
        }
      },
      _initialActive: function() {
        var active = this.options.active,
            collapsible = this.options.collapsible,
            locationHash = location.hash.substring(1);
        if (active === null) {
          if (locationHash) {
            this.tabs.each(function(i, tab) {
              if ($(tab).attr("aria-controls") === locationHash) {
                active = i;
                return false;
              }
            });
          }
          if (active === null) {
            active = this.tabs.index(this.tabs.filter(".ui-tabs-active"));
          }
          if (active === null || active === -1) {
            active = this.tabs.length ? 0 : false;
          }
        }
        if (active !== false) {
          active = this.tabs.index(this.tabs.eq(active));
          if (active === -1) {
            active = collapsible ? false : 0;
          }
        }
        if (!collapsible && active === false && this.anchors.length) {
          active = 0;
        }
        return active;
      },
      _getCreateEventData: function() {
        return {
          tab: this.active,
          panel: !this.active.length ? $() : this._getPanelForTab(this.active)
        };
      },
      _tabKeydown: function(event) {
        var focusedTab = $(this.document[0].activeElement).closest("li"),
            selectedIndex = this.tabs.index(focusedTab),
            goingForward = true;
        if (this._handlePageNav(event)) {
          return;
        }
        switch (event.keyCode) {
          case $.ui.keyCode.RIGHT:
          case $.ui.keyCode.DOWN:
            selectedIndex++;
            break;
          case $.ui.keyCode.UP:
          case $.ui.keyCode.LEFT:
            goingForward = false;
            selectedIndex--;
            break;
          case $.ui.keyCode.END:
            selectedIndex = this.anchors.length - 1;
            break;
          case $.ui.keyCode.HOME:
            selectedIndex = 0;
            break;
          case $.ui.keyCode.SPACE:
            event.preventDefault();
            clearTimeout(this.activating);
            this._activate(selectedIndex);
            return;
          case $.ui.keyCode.ENTER:
            event.preventDefault();
            clearTimeout(this.activating);
            this._activate(selectedIndex === this.options.active ? false : selectedIndex);
            return;
          default:
            return;
        }
        event.preventDefault();
        clearTimeout(this.activating);
        selectedIndex = this._focusNextTab(selectedIndex, goingForward);
        if (!event.ctrlKey) {
          focusedTab.attr("aria-selected", "false");
          this.tabs.eq(selectedIndex).attr("aria-selected", "true");
          this.activating = this._delay(function() {
            this.option("active", selectedIndex);
          }, this.delay);
        }
      },
      _panelKeydown: function(event) {
        if (this._handlePageNav(event)) {
          return;
        }
        if (event.ctrlKey && event.keyCode === $.ui.keyCode.UP) {
          event.preventDefault();
          this.active.focus();
        }
      },
      _handlePageNav: function(event) {
        if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP) {
          this._activate(this._focusNextTab(this.options.active - 1, false));
          return true;
        }
        if (event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN) {
          this._activate(this._focusNextTab(this.options.active + 1, true));
          return true;
        }
      },
      _findNextTab: function(index, goingForward) {
        var lastTabIndex = this.tabs.length - 1;
        function constrain() {
          if (index > lastTabIndex) {
            index = 0;
          }
          if (index < 0) {
            index = lastTabIndex;
          }
          return index;
        }
        while ($.inArray(constrain(), this.options.disabled) !== -1) {
          index = goingForward ? index + 1 : index - 1;
        }
        return index;
      },
      _focusNextTab: function(index, goingForward) {
        index = this._findNextTab(index, goingForward);
        this.tabs.eq(index).focus();
        return index;
      },
      _setOption: function(key, value) {
        if (key === "active") {
          this._activate(value);
          return;
        }
        if (key === "disabled") {
          this._setupDisabled(value);
          return;
        }
        this._super(key, value);
        if (key === "collapsible") {
          this.element.toggleClass("ui-tabs-collapsible", value);
          if (!value && this.options.active === false) {
            this._activate(0);
          }
        }
        if (key === "event") {
          this._setupEvents(value);
        }
        if (key === "heightStyle") {
          this._setupHeightStyle(value);
        }
      },
      _sanitizeSelector: function(hash) {
        return hash ? hash.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&") : "";
      },
      refresh: function() {
        var options = this.options,
            lis = this.tablist.children(":has(a[href])");
        options.disabled = $.map(lis.filter(".ui-state-disabled"), function(tab) {
          return lis.index(tab);
        });
        this._processTabs();
        if (options.active === false || !this.anchors.length) {
          options.active = false;
          this.active = $();
        } else if (this.active.length && !$.contains(this.tablist[0], this.active[0])) {
          if (this.tabs.length === options.disabled.length) {
            options.active = false;
            this.active = $();
          } else {
            this._activate(this._findNextTab(Math.max(0, options.active - 1), false));
          }
        } else {
          options.active = this.tabs.index(this.active);
        }
        this._refresh();
      },
      _refresh: function() {
        this._setupDisabled(this.options.disabled);
        this._setupEvents(this.options.event);
        this._setupHeightStyle(this.options.heightStyle);
        this.tabs.not(this.active).attr({
          "aria-selected": "false",
          "aria-expanded": "false",
          tabIndex: -1
        });
        this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden": "true"});
        if (!this.active.length) {
          this.tabs.eq(0).attr("tabIndex", 0);
        } else {
          this.active.addClass("ui-tabs-active ui-state-active").attr({
            "aria-selected": "true",
            "aria-expanded": "true",
            tabIndex: 0
          });
          this._getPanelForTab(this.active).show().attr({"aria-hidden": "false"});
        }
      },
      _processTabs: function() {
        var that = this;
        this.tablist = this._getList().addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").attr("role", "tablist").delegate("> li", "mousedown" + this.eventNamespace, function(event) {
          if ($(this).is(".ui-state-disabled")) {
            event.preventDefault();
          }
        }).delegate(".ui-tabs-anchor", "focus" + this.eventNamespace, function() {
          if ($(this).closest("li").is(".ui-state-disabled")) {
            this.blur();
          }
        });
        this.tabs = this.tablist.find("> li:has(a[href])").addClass("ui-state-default ui-corner-top").attr({
          role: "tab",
          tabIndex: -1
        });
        this.anchors = this.tabs.map(function() {
          return $("a", this)[0];
        }).addClass("ui-tabs-anchor").attr({
          role: "presentation",
          tabIndex: -1
        });
        this.panels = $();
        this.anchors.each(function(i, anchor) {
          var selector,
              panel,
              panelId,
              anchorId = $(anchor).uniqueId().attr("id"),
              tab = $(anchor).closest("li"),
              originalAriaControls = tab.attr("aria-controls");
          if (that._isLocal(anchor)) {
            selector = anchor.hash;
            panelId = selector.substring(1);
            panel = that.element.find(that._sanitizeSelector(selector));
          } else {
            panelId = tab.attr("aria-controls") || $({}).uniqueId()[0].id;
            selector = "#" + panelId;
            panel = that.element.find(selector);
            if (!panel.length) {
              panel = that._createPanel(panelId);
              panel.insertAfter(that.panels[i - 1] || that.tablist);
            }
            panel.attr("aria-live", "polite");
          }
          if (panel.length) {
            that.panels = that.panels.add(panel);
          }
          if (originalAriaControls) {
            tab.data("ui-tabs-aria-controls", originalAriaControls);
          }
          tab.attr({
            "aria-controls": panelId,
            "aria-labelledby": anchorId
          });
          panel.attr("aria-labelledby", anchorId);
        });
        this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").attr("role", "tabpanel");
      },
      _getList: function() {
        return this.tablist || this.element.find("ol,ul").eq(0);
      },
      _createPanel: function(id) {
        return $("<div>").attr("id", id).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").data("ui-tabs-destroy", true);
      },
      _setupDisabled: function(disabled) {
        if ($.isArray(disabled)) {
          if (!disabled.length) {
            disabled = false;
          } else if (disabled.length === this.anchors.length) {
            disabled = true;
          }
        }
        for (var i = 0,
            li; (li = this.tabs[i]); i++) {
          if (disabled === true || $.inArray(i, disabled) !== -1) {
            $(li).addClass("ui-state-disabled").attr("aria-disabled", "true");
          } else {
            $(li).removeClass("ui-state-disabled").removeAttr("aria-disabled");
          }
        }
        this.options.disabled = disabled;
      },
      _setupEvents: function(event) {
        var events = {};
        if (event) {
          $.each(event.split(" "), function(index, eventName) {
            events[eventName] = "_eventHandler";
          });
        }
        this._off(this.anchors.add(this.tabs).add(this.panels));
        this._on(true, this.anchors, {click: function(event) {
            event.preventDefault();
          }});
        this._on(this.anchors, events);
        this._on(this.tabs, {keydown: "_tabKeydown"});
        this._on(this.panels, {keydown: "_panelKeydown"});
        this._focusable(this.tabs);
        this._hoverable(this.tabs);
      },
      _setupHeightStyle: function(heightStyle) {
        var maxHeight,
            parent = this.element.parent();
        if (heightStyle === "fill") {
          maxHeight = parent.height();
          maxHeight -= this.element.outerHeight() - this.element.height();
          this.element.siblings(":visible").each(function() {
            var elem = $(this),
                position = elem.css("position");
            if (position === "absolute" || position === "fixed") {
              return;
            }
            maxHeight -= elem.outerHeight(true);
          });
          this.element.children().not(this.panels).each(function() {
            maxHeight -= $(this).outerHeight(true);
          });
          this.panels.each(function() {
            $(this).height(Math.max(0, maxHeight - $(this).innerHeight() + $(this).height()));
          }).css("overflow", "auto");
        } else if (heightStyle === "auto") {
          maxHeight = 0;
          this.panels.each(function() {
            maxHeight = Math.max(maxHeight, $(this).height("").height());
          }).height(maxHeight);
        }
      },
      _eventHandler: function(event) {
        var options = this.options,
            active = this.active,
            anchor = $(event.currentTarget),
            tab = anchor.closest("li"),
            clickedIsActive = tab[0] === active[0],
            collapsing = clickedIsActive && options.collapsible,
            toShow = collapsing ? $() : this._getPanelForTab(tab),
            toHide = !active.length ? $() : this._getPanelForTab(active),
            eventData = {
              oldTab: active,
              oldPanel: toHide,
              newTab: collapsing ? $() : tab,
              newPanel: toShow
            };
        event.preventDefault();
        if (tab.hasClass("ui-state-disabled") || tab.hasClass("ui-tabs-loading") || this.running || (clickedIsActive && !options.collapsible) || (this._trigger("beforeActivate", event, eventData) === false)) {
          return;
        }
        options.active = collapsing ? false : this.tabs.index(tab);
        this.active = clickedIsActive ? $() : tab;
        if (this.xhr) {
          this.xhr.abort();
        }
        if (!toHide.length && !toShow.length) {
          $.error("jQuery UI Tabs: Mismatching fragment identifier.");
        }
        if (toShow.length) {
          this.load(this.tabs.index(tab), event);
        }
        this._toggle(event, eventData);
      },
      _toggle: function(event, eventData) {
        var that = this,
            toShow = eventData.newPanel,
            toHide = eventData.oldPanel;
        this.running = true;
        function complete() {
          that.running = false;
          that._trigger("activate", event, eventData);
        }
        function show() {
          eventData.newTab.closest("li").addClass("ui-tabs-active ui-state-active");
          if (toShow.length && that.options.show) {
            that._show(toShow, that.options.show, complete);
          } else {
            toShow.show();
            complete();
          }
        }
        if (toHide.length && this.options.hide) {
          this._hide(toHide, this.options.hide, function() {
            eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
            show();
          });
        } else {
          eventData.oldTab.closest("li").removeClass("ui-tabs-active ui-state-active");
          toHide.hide();
          show();
        }
        toHide.attr("aria-hidden", "true");
        eventData.oldTab.attr({
          "aria-selected": "false",
          "aria-expanded": "false"
        });
        if (toShow.length && toHide.length) {
          eventData.oldTab.attr("tabIndex", -1);
        } else if (toShow.length) {
          this.tabs.filter(function() {
            return $(this).attr("tabIndex") === 0;
          }).attr("tabIndex", -1);
        }
        toShow.attr("aria-hidden", "false");
        eventData.newTab.attr({
          "aria-selected": "true",
          "aria-expanded": "true",
          tabIndex: 0
        });
      },
      _activate: function(index) {
        var anchor,
            active = this._findActive(index);
        if (active[0] === this.active[0]) {
          return;
        }
        if (!active.length) {
          active = this.active;
        }
        anchor = active.find(".ui-tabs-anchor")[0];
        this._eventHandler({
          target: anchor,
          currentTarget: anchor,
          preventDefault: $.noop
        });
      },
      _findActive: function(index) {
        return index === false ? $() : this.tabs.eq(index);
      },
      _getIndex: function(index) {
        if (typeof index === "string") {
          index = this.anchors.index(this.anchors.filter("[href$='" + index + "']"));
        }
        return index;
      },
      _destroy: function() {
        if (this.xhr) {
          this.xhr.abort();
        }
        this.element.removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible");
        this.tablist.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all").removeAttr("role");
        this.anchors.removeClass("ui-tabs-anchor").removeAttr("role").removeAttr("tabIndex").removeUniqueId();
        this.tablist.unbind(this.eventNamespace);
        this.tabs.add(this.panels).each(function() {
          if ($.data(this, "ui-tabs-destroy")) {
            $(this).remove();
          } else {
            $(this).removeClass("ui-state-default ui-state-active ui-state-disabled " + "ui-corner-top ui-corner-bottom ui-widget-content ui-tabs-active ui-tabs-panel").removeAttr("tabIndex").removeAttr("aria-live").removeAttr("aria-busy").removeAttr("aria-selected").removeAttr("aria-labelledby").removeAttr("aria-hidden").removeAttr("aria-expanded").removeAttr("role");
          }
        });
        this.tabs.each(function() {
          var li = $(this),
              prev = li.data("ui-tabs-aria-controls");
          if (prev) {
            li.attr("aria-controls", prev).removeData("ui-tabs-aria-controls");
          } else {
            li.removeAttr("aria-controls");
          }
        });
        this.panels.show();
        if (this.options.heightStyle !== "content") {
          this.panels.css("height", "");
        }
      },
      enable: function(index) {
        var disabled = this.options.disabled;
        if (disabled === false) {
          return;
        }
        if (index === undefined) {
          disabled = false;
        } else {
          index = this._getIndex(index);
          if ($.isArray(disabled)) {
            disabled = $.map(disabled, function(num) {
              return num !== index ? num : null;
            });
          } else {
            disabled = $.map(this.tabs, function(li, num) {
              return num !== index ? num : null;
            });
          }
        }
        this._setupDisabled(disabled);
      },
      disable: function(index) {
        var disabled = this.options.disabled;
        if (disabled === true) {
          return;
        }
        if (index === undefined) {
          disabled = true;
        } else {
          index = this._getIndex(index);
          if ($.inArray(index, disabled) !== -1) {
            return;
          }
          if ($.isArray(disabled)) {
            disabled = $.merge([index], disabled).sort();
          } else {
            disabled = [index];
          }
        }
        this._setupDisabled(disabled);
      },
      load: function(index, event) {
        index = this._getIndex(index);
        var that = this,
            tab = this.tabs.eq(index),
            anchor = tab.find(".ui-tabs-anchor"),
            panel = this._getPanelForTab(tab),
            eventData = {
              tab: tab,
              panel: panel
            };
        if (this._isLocal(anchor[0])) {
          return;
        }
        this.xhr = $.ajax(this._ajaxSettings(anchor, event, eventData));
        if (this.xhr && this.xhr.statusText !== "canceled") {
          tab.addClass("ui-tabs-loading");
          panel.attr("aria-busy", "true");
          this.xhr.success(function(response) {
            setTimeout(function() {
              panel.html(response);
              that._trigger("load", event, eventData);
            }, 1);
          }).complete(function(jqXHR, status) {
            setTimeout(function() {
              if (status === "abort") {
                that.panels.stop(false, true);
              }
              tab.removeClass("ui-tabs-loading");
              panel.removeAttr("aria-busy");
              if (jqXHR === that.xhr) {
                delete that.xhr;
              }
            }, 1);
          });
        }
      },
      _ajaxSettings: function(anchor, event, eventData) {
        var that = this;
        return {
          url: anchor.attr("href"),
          beforeSend: function(jqXHR, settings) {
            return that._trigger("beforeLoad", event, $.extend({
              jqXHR: jqXHR,
              ajaxSettings: settings
            }, eventData));
          }
        };
      },
      _getPanelForTab: function(tab) {
        var id = $(tab).attr("aria-controls");
        return this.element.find(this._sanitizeSelector("#" + id));
      }
    });
    var tooltip = $.widget("ui.tooltip", {
      version: "1.11.1",
      options: {
        content: function() {
          var title = $(this).attr("title") || "";
          return $("<a>").text(title).html();
        },
        hide: true,
        items: "[title]:not([disabled])",
        position: {
          my: "left top+15",
          at: "left bottom",
          collision: "flipfit flip"
        },
        show: true,
        tooltipClass: null,
        track: false,
        close: null,
        open: null
      },
      _addDescribedBy: function(elem, id) {
        var describedby = (elem.attr("aria-describedby") || "").split(/\s+/);
        describedby.push(id);
        elem.data("ui-tooltip-id", id).attr("aria-describedby", $.trim(describedby.join(" ")));
      },
      _removeDescribedBy: function(elem) {
        var id = elem.data("ui-tooltip-id"),
            describedby = (elem.attr("aria-describedby") || "").split(/\s+/),
            index = $.inArray(id, describedby);
        if (index !== -1) {
          describedby.splice(index, 1);
        }
        elem.removeData("ui-tooltip-id");
        describedby = $.trim(describedby.join(" "));
        if (describedby) {
          elem.attr("aria-describedby", describedby);
        } else {
          elem.removeAttr("aria-describedby");
        }
      },
      _create: function() {
        this._on({
          mouseover: "open",
          focusin: "open"
        });
        this.tooltips = {};
        this.parents = {};
        if (this.options.disabled) {
          this._disable();
        }
        this.liveRegion = $("<div>").attr({
          role: "log",
          "aria-live": "assertive",
          "aria-relevant": "additions"
        }).addClass("ui-helper-hidden-accessible").appendTo(this.document[0].body);
      },
      _setOption: function(key, value) {
        var that = this;
        if (key === "disabled") {
          this[value ? "_disable" : "_enable"]();
          this.options[key] = value;
          return;
        }
        this._super(key, value);
        if (key === "content") {
          $.each(this.tooltips, function(id, element) {
            that._updateContent(element);
          });
        }
      },
      _disable: function() {
        var that = this;
        $.each(this.tooltips, function(id, element) {
          var event = $.Event("blur");
          event.target = event.currentTarget = element[0];
          that.close(event, true);
        });
        this.element.find(this.options.items).addBack().each(function() {
          var element = $(this);
          if (element.is("[title]")) {
            element.data("ui-tooltip-title", element.attr("title")).removeAttr("title");
          }
        });
      },
      _enable: function() {
        this.element.find(this.options.items).addBack().each(function() {
          var element = $(this);
          if (element.data("ui-tooltip-title")) {
            element.attr("title", element.data("ui-tooltip-title"));
          }
        });
      },
      open: function(event) {
        var that = this,
            target = $(event ? event.target : this.element).closest(this.options.items);
        if (!target.length || target.data("ui-tooltip-id")) {
          return;
        }
        if (target.attr("title")) {
          target.data("ui-tooltip-title", target.attr("title"));
        }
        target.data("ui-tooltip-open", true);
        if (event && event.type === "mouseover") {
          target.parents().each(function() {
            var parent = $(this),
                blurEvent;
            if (parent.data("ui-tooltip-open")) {
              blurEvent = $.Event("blur");
              blurEvent.target = blurEvent.currentTarget = this;
              that.close(blurEvent, true);
            }
            if (parent.attr("title")) {
              parent.uniqueId();
              that.parents[this.id] = {
                element: this,
                title: parent.attr("title")
              };
              parent.attr("title", "");
            }
          });
        }
        this._updateContent(target, event);
      },
      _updateContent: function(target, event) {
        var content,
            contentOption = this.options.content,
            that = this,
            eventType = event ? event.type : null;
        if (typeof contentOption === "string") {
          return this._open(event, target, contentOption);
        }
        content = contentOption.call(target[0], function(response) {
          if (!target.data("ui-tooltip-open")) {
            return;
          }
          that._delay(function() {
            if (event) {
              event.type = eventType;
            }
            this._open(event, target, response);
          });
        });
        if (content) {
          this._open(event, target, content);
        }
      },
      _open: function(event, target, content) {
        var tooltip,
            events,
            delayedShow,
            a11yContent,
            positionOption = $.extend({}, this.options.position);
        if (!content) {
          return;
        }
        tooltip = this._find(target);
        if (tooltip.length) {
          tooltip.find(".ui-tooltip-content").html(content);
          return;
        }
        if (target.is("[title]")) {
          if (event && event.type === "mouseover") {
            target.attr("title", "");
          } else {
            target.removeAttr("title");
          }
        }
        tooltip = this._tooltip(target);
        this._addDescribedBy(target, tooltip.attr("id"));
        tooltip.find(".ui-tooltip-content").html(content);
        this.liveRegion.children().hide();
        if (content.clone) {
          a11yContent = content.clone();
          a11yContent.removeAttr("id").find("[id]").removeAttr("id");
        } else {
          a11yContent = content;
        }
        $("<div>").html(a11yContent).appendTo(this.liveRegion);
        function position(event) {
          positionOption.of = event;
          if (tooltip.is(":hidden")) {
            return;
          }
          tooltip.position(positionOption);
        }
        if (this.options.track && event && /^mouse/.test(event.type)) {
          this._on(this.document, {mousemove: position});
          position(event);
        } else {
          tooltip.position($.extend({of: target}, this.options.position));
        }
        this.hiding = false;
        this.closing = false;
        tooltip.hide();
        this._show(tooltip, this.options.show);
        if (this.options.show && this.options.show.delay) {
          delayedShow = this.delayedShow = setInterval(function() {
            if (tooltip.is(":visible")) {
              position(positionOption.of);
              clearInterval(delayedShow);
            }
          }, $.fx.interval);
        }
        this._trigger("open", event, {tooltip: tooltip});
        events = {keyup: function(event) {
            if (event.keyCode === $.ui.keyCode.ESCAPE) {
              var fakeEvent = $.Event(event);
              fakeEvent.currentTarget = target[0];
              this.close(fakeEvent, true);
            }
          }};
        if (target[0] !== this.element[0]) {
          events.remove = function() {
            this._removeTooltip(tooltip);
          };
        }
        if (!event || event.type === "mouseover") {
          events.mouseleave = "close";
        }
        if (!event || event.type === "focusin") {
          events.focusout = "close";
        }
        this._on(true, target, events);
      },
      close: function(event) {
        var that = this,
            target = $(event ? event.currentTarget : this.element),
            tooltip = this._find(target);
        if (this.closing) {
          return;
        }
        clearInterval(this.delayedShow);
        if (target.data("ui-tooltip-title") && !target.attr("title")) {
          target.attr("title", target.data("ui-tooltip-title"));
        }
        this._removeDescribedBy(target);
        this.hiding = true;
        tooltip.stop(true);
        this._hide(tooltip, this.options.hide, function() {
          that._removeTooltip($(this));
          this.hiding = false;
          this.closing = false;
        });
        target.removeData("ui-tooltip-open");
        this._off(target, "mouseleave focusout keyup");
        if (target[0] !== this.element[0]) {
          this._off(target, "remove");
        }
        this._off(this.document, "mousemove");
        if (event && event.type === "mouseleave") {
          $.each(this.parents, function(id, parent) {
            $(parent.element).attr("title", parent.title);
            delete that.parents[id];
          });
        }
        this.closing = true;
        this._trigger("close", event, {tooltip: tooltip});
        if (!this.hiding) {
          this.closing = false;
        }
      },
      _tooltip: function(element) {
        var tooltip = $("<div>").attr("role", "tooltip").addClass("ui-tooltip ui-widget ui-corner-all ui-widget-content " + (this.options.tooltipClass || "")),
            id = tooltip.uniqueId().attr("id");
        $("<div>").addClass("ui-tooltip-content").appendTo(tooltip);
        tooltip.appendTo(this.document[0].body);
        this.tooltips[id] = element;
        return tooltip;
      },
      _find: function(target) {
        var id = target.data("ui-tooltip-id");
        return id ? $("#" + id) : $();
      },
      _removeTooltip: function(tooltip) {
        tooltip.remove();
        delete this.tooltips[tooltip.attr("id")];
      },
      _destroy: function() {
        var that = this;
        $.each(this.tooltips, function(id, element) {
          var event = $.Event("blur");
          event.target = event.currentTarget = element[0];
          that.close(event, true);
          $("#" + id).remove();
          if (element.data("ui-tooltip-title")) {
            if (!element.attr("title")) {
              element.attr("title", element.data("ui-tooltip-title"));
            }
            element.removeData("ui-tooltip-title");
          }
        });
        this.liveRegion.remove();
      }
    });
  }));
  return module.exports;
});

$__System.registerDynamic("30", ["2f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('2f');
  return module.exports;
});

$__System.register('29', ['16', '17'], function (_export) {
    var _createClass, _classCallCheck, _os, _keyControls, Environment;

    return {
        setters: [function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }],
        execute: function () {
            'use strict';

            _os = null;
            _keyControls = {
                'Windows': {
                    'range': 'shiftKey',
                    'multiple': 'ctrlKey'
                },
                'MacOS': {
                    'range': 'shiftKey',
                    'multiple': 'metaKey'
                },
                'Linux': {
                    'range': 'shiftKey',
                    'multiple': 'ctrlKey'
                },
                'UNIX': {
                    'range': 'shiftKey',
                    'multiple': 'ctrlKey'
                },
                'Unknown OS': {
                    'range': 'shiftKey',
                    'multiple': 'ctrlKey'
                }
            };

            /**
             * Global environment constants.
             */

            Environment = (function () {
                function Environment() {
                    _classCallCheck(this, Environment);
                }

                _createClass(Environment, null, [{
                    key: 'getOS',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS - Static
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns string denoting detected operating system.
                     *
                     * @return {string} 'Windows', 'MacOS', 'UNIX', 'Linux', or 'Unknown OS'
                     */
                    value: function getOS() {
                        if (_os === null) {
                            _os = 'Unknown OS';
                            if (navigator.appVersion.indexOf('Win') !== -1) {
                                _os = 'Windows';
                            }
                            if (navigator.appVersion.indexOf('Mac') !== -1) {
                                _os = 'MacOS';
                            }
                            if (navigator.appVersion.indexOf('X11') !== -1) {
                                _os = 'UNIX';
                            }
                            if (navigator.appVersion.indexOf('Linux') !== -1) {
                                _os = 'Linux';
                            }
                        }
                        return _os;
                    }

                    /**
                     * Get multiple selection key.
                     *
                     * @return {string} returns 'contol' or 'command', depending on OS
                     */
                }, {
                    key: 'getMultipleSelectionKey',
                    value: function getMultipleSelectionKey() {
                        return _keyControls[Environment.getOS()].multiple;
                    }

                    /**
                     * Get range selection key.
                     *
                     * @return {string} returns range selection key (e.g. 'shift'), depending on OS
                     */
                }, {
                    key: 'getRangeSelectionKey',
                    value: function getRangeSelectionKey() {
                        return _keyControls[Environment.getOS()].range;
                    }
                }]);

                return Environment;
            })();

            _export('default', Environment);
        }
    };
});

$__System.register('31', ['10', '11', '14', '15', '16', '17', '20', '27', '29', '30', '32', '33', '2e'], function (_export) {
    var Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, Environment, _, BaseCollection, datetimepicker, BehaviorTable;

    return {
        setters: [function (_9) {
            Configuration = _9['default'];
        }, function (_13) {
            RODAN_EVENTS = _13['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_12) {
            Radio = _12['default'];
        }, function (_11) {
            Marionette = _11['default'];
        }, function (_10) {
            Environment = _10['default'];
        }, function (_7) {}, function (_6) {
            _ = _6['default'];
        }, function (_8) {
            BaseCollection = _8['default'];
        }, function (_e) {
            datetimepicker = _e['default'];
        }],
        execute: function () {

            /**
             * A Marionette Behavior for tables. This class defines sorting and filtering.
             */
            'use strict';

            BehaviorTable = (function (_Marionette$Behavior) {
                _inherits(BehaviorTable, _Marionette$Behavior);

                function BehaviorTable() {
                    _classCallCheck(this, BehaviorTable);

                    _get(Object.getPrototypeOf(BehaviorTable.prototype), 'constructor', this).apply(this, arguments);
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PROTOTYPE
                ///////////////////////////////////////////////////////////////////////////////////////

                _createClass(BehaviorTable, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        this._filtersInjected = false;
                        this._datetimepickerElements = [];
                        this._lastTarget = null;
                        this._multipleSelectionKey = Environment.getMultipleSelectionKey();
                        this._rangeSelectionKey = Environment.getRangeSelectionKey();
                    }

                    /**
                     * Delegate events and inject table controls after render.
                     *
                     * @param {Marionette.View} view View from which the Behavior will get events
                     */
                }, {
                    key: 'onRender',
                    value: function onRender(view) {
                        // Not really pretty, but works for now. Marionette calls 'delegateEvents'
                        // before our custom 'initialize' on the view. However, at that point, the
                        // collection is not yet set in the view, so binding doesn't work. This next
                        // line is a work around.
                        // TODO - fix/find better way
                        this.view.delegateEvents();

                        // Inject controls and initialize.
                        this._injectControl();
                        this._processPagination(null);

                        // Inject the controls.
                        if (view.collection) {
                            this._handleCollectionEventSync(view.collection);
                        }
                    }

                    /**
                     * Destroy instance. This takes care of destroying any known DateTimePicker instances before moving to the next View.
                     * Also reset last target.
                     */
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        var datetimePickerElementIds = $(this.el).find(':data(DateTimePicker)').map(function () {
                            return $(this).attr('id');
                        }).get();
                        for (var index in datetimePickerElementIds) {
                            $(this.el).find('#' + datetimePickerElementIds[index]).data('DateTimePicker').destroy();
                        }
                        this._lastTarget = null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - injectors
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Injects control template.
                     */
                }, {
                    key: '_injectControl',
                    value: function _injectControl() {
                        if (this.$el.find('.table-control').length === 0) {
                            this.$el.find('div.table-responsive').before($(this.options.templateControl).html());
                        }
                    }

                    /**
                     * Returns the filters for the associated Collection.
                     */
                }, {
                    key: '_getFilters',
                    value: function _getFilters(collection, filterFields) {
                        // Get those columns with data names.
                        var filters = [];
                        this._datetimepickerElements = [];
                        var columns = $(this.el).find(this.options.table + ' thead th').filter(function () {
                            return $(this).attr('data-name');
                        });
                        for (var i = 0; i < columns.length; i++) {
                            var column = $(columns[i]);
                            var field = column.attr('data-name');
                            var datetimeLtFilter = false;
                            var datetimeGtFilter = false;
                            if (filterFields[field]) {
                                for (var j = 0; j < filterFields[field].length; j++) {
                                    var filter = filterFields[field][j];
                                    switch (filter) {
                                        case 'icontains':
                                            {
                                                filters.push(this._getFilterText(column.text(), field));
                                                break;
                                            }

                                        case 'gt':
                                            {
                                                datetimeGtFilter = true;
                                                break;
                                            }

                                        case 'lt':
                                            {
                                                datetimeLtFilter = true;
                                                break;
                                            }

                                        default:
                                            {
                                                break;
                                            }
                                    }
                                }

                                // Check for datetime filters.
                                if (datetimeGtFilter || datetimeLtFilter) {
                                    if (datetimeGtFilter) {
                                        var elementId = '#' + field + '__gt';
                                        this._datetimepickerElements.push(elementId);
                                    }
                                    if (datetimeLtFilter) {
                                        elementId = '#' + field + '__lt';
                                        this._datetimepickerElements.push(elementId);
                                    }
                                    filters.push(this._getFilterDatetime(column.text(), field));
                                }
                            }
                        }

                        // Finally, get enumerations.
                        var enumerations = collection.getEnumerations();
                        for (i in enumerations) {
                            var enumeration = enumerations[i];
                            var templateChoice = _.template($(this.options.templateFilterChoice).html());
                            var templateInput = _.template($(this.options.templateFilterEnum).html());
                            var htmlChoice = templateChoice({ label: enumeration.label, field: enumeration.field });
                            var htmlInput = templateInput({ label: enumeration.label, field: enumeration.field, values: enumeration.values });
                            var filterObject = { listItem: htmlChoice, input: htmlInput };
                            filters.push(filterObject);
                        }

                        return filters;
                    }

                    /**
                     * Injects filtering functionality into template.
                     */
                }, {
                    key: '_injectFiltering',
                    value: function _injectFiltering(filterFields) {
                        var _this = this;

                        var filters = this._getFilters(this.view.collection, filterFields);
                        for (var index in filters) {
                            var $listItem = $(filters[index].listItem);
                            var $formInput = $(filters[index].input);
                            $listItem.click(function (event) {
                                return _this._handleFilterClick(event);
                            });
                            $(this.el).find('#filter-menu ul').append($listItem);
                            $(this.el).find('#filter-inputs').append($formInput);
                        }

                        // Setup datetimepickers.
                        for (index in this._datetimepickerElements) {
                            var elementId = this._datetimepickerElements[index];
                            $(this.el).find(elementId).datetimepicker();
                            $(this.el).find(elementId).data('DateTimePicker').format(Configuration.DATETIME_FORMAT);
                            $(this.el).find(elementId).on('dp.change', function () {
                                return _this._handleSearch();
                            });
                        }

                        $(this.el).find('#filter-inputs input').on('change keyup paste mouseup', function () {
                            return _this._handleSearch();
                        });
                        $(this.el).find('#filter-inputs select').on('change keyup paste mouseup', function () {
                            return _this._handleSearch();
                        });

                        this._filtersInjected = true;
                        this._hideFormElements();
                    }

                    /**
                     * Get text filter.
                     */
                }, {
                    key: '_getFilterText',
                    value: function _getFilterText(label, field) {
                        var templateChoice = _.template($(this.options.templateFilterChoice).html());
                        var templateInput = _.template($(this.options.templateFilterText).html());
                        var htmlChoice = templateChoice({ label: label, field: field });
                        var htmlInput = templateInput({ label: label, field: field });
                        return { listItem: htmlChoice, input: htmlInput };
                    }

                    /**
                     * Get master datetime filter template.
                     */
                }, {
                    key: '_getFilterDatetime',
                    value: function _getFilterDatetime(label, field) {
                        var templateChoice = _.template($(this.options.templateFilterChoice).html());
                        var templateInput = _.template($(this.options.templateFilterDatetime).html());
                        var htmlChoice = templateChoice({ label: label, field: field });
                        var htmlInput = templateInput({ label: label, field: field });
                        return { listItem: htmlChoice, input: htmlInput };
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Event handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles filter click.
                     */
                }, {
                    key: '_handleFilterClick',
                    value: function _handleFilterClick(event) {
                        var data = $(event.target).data();
                        //this._hideFormElements();
                        if (data.id) {
                            this._showFormElement(data.id);
                        }
                    }

                    /**
                     * Handle search.
                     */
                }, {
                    key: '_handleSearch',
                    value: function _handleSearch() {
                        // Only use this if the collection has a URL.
                        if (!this.view.collection.route) {
                            return;
                        }

                        var values = $(this.el).find('form').serializeArray();
                        var filters = {};
                        for (var index in values) {
                            var name = values[index].name;
                            var value = values[index].value;
                            filters[name] = value;
                        }
                        this.view.collection.fetchFilter(filters);
                    }

                    /**
                     * Handles sort request.
                     *
                     * Defaults to ascending. Only goes descending if the associated ascending
                     * CSS style is currently attached to the target th.
                     */
                }, {
                    key: '_handleSort',
                    value: function _handleSort(event) {
                        // Only use this if the collection has a route.
                        if (!this.view.collection.route) {
                            return;
                        }

                        var sortField = $(event.currentTarget).attr('data-name');
                        if (sortField) {
                            // Check for sort arrow "up" already there. If so, we want down (else, up).
                            var ascending = true;
                            if ($(event.currentTarget).find('span.glyphicon-arrow-up').length > 0) {
                                ascending = false;
                            }

                            // Do the sort.
                            this.view.collection.fetchSort(ascending, sortField);

                            // Set the sort arrows properly.
                            $(event.currentTarget).parent().find('th span.glyphicon').remove();
                            if (ascending) {
                                $(event.currentTarget).append('<span class="glyphicon glyphicon-arrow-up"></span>');
                            } else {
                                $(event.currentTarget).append('<span class="glyphicon glyphicon-arrow-down"></span>');
                            }
                        }
                    }

                    /**
                     * Handle pagination previous.
                     */
                }, {
                    key: '_handlePaginationPrevious',
                    value: function _handlePaginationPrevious() {
                        var pagination = this.view.collection.getPagination();
                        var data = this._getURLQueryParameters(pagination.get('previous'));
                        if (data.page) {
                            this.view.collection.fetchPage({ page: data.page });
                        } else {
                            this.view.collection.fetchPage({});
                        }
                    }

                    /**
                     * Handle pagination next.
                     */
                }, {
                    key: '_handlePaginationNext',
                    value: function _handlePaginationNext() {
                        var pagination = this.view.collection.getPagination();
                        var data = this._getURLQueryParameters(pagination.get('next'));
                        this.view.collection.fetchPage({ page: data.page });
                    }

                    /**
                     * Handle pagination first.
                     */
                }, {
                    key: '_handlePaginationFirst',
                    value: function _handlePaginationFirst() {
                        this.view.collection.fetchPage({ page: 1 });
                    }

                    /**
                     * Handle pagination last.
                     */
                }, {
                    key: '_handlePaginationLast',
                    value: function _handlePaginationLast() {
                        var pagination = this.view.collection.getPagination();
                        this.view.collection.fetchPage({ page: pagination.get('total') });
                    }

                    /**
                     * Handles collection event.
                     */
                }, {
                    key: '_handleCollectionEventSync',
                    value: function _handleCollectionEventSync(collection) {
                        if (collection instanceof BaseCollection) {
                            // We only inject if: the table exists, a route exists, we haven't injected yet, and the table has items.
                            if ($(this.el).find(this.options.table).length > 0 && collection.route && !this._filtersInjected && collection.length > 0) {
                                var options = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE_OPTIONS, { route: collection.route });
                                if (options) {
                                    this._injectFiltering(options.filter_fields);
                                }
                            }

                            // Handle pagination.
                            this._processPagination(collection);
                        }
                    }

                    /**
                     * Handle button remove.
                     */
                }, {
                    key: '_handleButtonRemove',
                    value: function _handleButtonRemove(event) {
                        var data = $(event.target).data();
                        this._hideFormElement(data.id);
                        this._handleSearch();
                    }

                    /**
                     * Handle button clear all.
                     */
                }, {
                    key: '_handleButtonClearAll',
                    value: function _handleButtonClearAll() {
                        var data = $(event.target).data();
                        this._hideFormElements();
                        this._handleSearch();
                    }

                    /**
                     * Handle row left click.
                     */
                }, {
                    key: '_handleLeftClickRow',
                    value: function _handleLeftClickRow(event) {
                        if (this.view.allowMultipleSelection) {
                            // Wipe everything if ctrl key not selected.
                            if (!event[this._multipleSelectionKey]) {
                                $(event.currentTarget).addClass('active clickable-row').siblings().removeClass('active');
                            } else {
                                $(event.currentTarget).toggleClass('active');
                            }

                            // If shift down, select range.
                            if (event[this._rangeSelectionKey]) {
                                $(this._lastTarget).addClass('active clickable-row');
                                if ($(this._lastTarget).index() <= $(event.currentTarget).index()) {
                                    $(this._lastTarget).nextUntil(event.currentTarget).addClass('active clickable-row');
                                } else {
                                    $(event.currentTarget).nextUntil(this._lastTarget).addClass('active clickable-row');
                                }
                            } else {
                                this._lastTarget = event.currentTarget;
                            }
                        } else {
                            $(event.currentTarget).addClass('active clickable-row').siblings().removeClass('active');
                            this._lastTarget = event.currentTarget;
                        }
                    }

                    /**
                     * Handles right click on row.
                     */
                }, {
                    key: '_handleRowRightClick',
                    value: function _handleRowRightClick(event) {
                        if (this.view.contextMenu) {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__CONTEXTMENU_SHOW, { top: event.pageY,
                                left: event.pageX,
                                items: this.view.contextMenu });
                        }
                        return false;
                    }

                    /**
                     * Handle pagination change.
                     */
                }, {
                    key: '_handlePaginationSelect',
                    value: function _handlePaginationSelect(event) {
                        this.view.collection.fetchPage({ page: parseInt(event.currentTarget.value) });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Returns query parameters from passed URL string.
                     *
                     * TODO: move this out of here...
                     */
                }, {
                    key: '_getURLQueryParameters',
                    value: function _getURLQueryParameters(string) {
                        var queryString = string.substr(string.indexOf('?') + 1),
                            match,
                            pl = /\+/g,
                            // Regex for replacing addition symbol with a space
                        search = /([^&=]+)=?([^&]*)/g,
                            decode = function decode(s) {
                            return decodeURIComponent(s.replace(pl, " "));
                        };

                        var urlParams = {};
                        while (match = search.exec(queryString)) urlParams[decode(match[1])] = decode(match[2]);
                        return urlParams;
                    }

                    /**
                     * Hide all form elements for the table control.
                     */
                }, {
                    key: '_hideFormElements',
                    value: function _hideFormElements() {
                        $(this.el).find('#filter-inputs div input').val('');
                        $(this.el).find('#filter-inputs div select').val('');
                        $(this.el).find('#filter-inputs').children().hide();
                    }

                    /**
                     * Hide form element of given ID.
                     */
                }, {
                    key: '_hideFormElement',
                    value: function _hideFormElement(elementId) {
                        $(this.el).find('#filter-inputs div#' + elementId + ' input').val('');
                        $(this.el).find('#filter-inputs div#' + elementId + ' select').val('');
                        $(this.el).find('#filter-inputs div#' + elementId).hide();
                    }

                    /**
                     * Shows form element of given ID.
                     */
                }, {
                    key: '_showFormElement',
                    value: function _showFormElement(elementId) {
                        $(this.el).find('#filter-inputs div#' + elementId).show();
                    }

                    /**
                     * Process pagination.
                     */
                }, {
                    key: '_processPagination',
                    value: function _processPagination(collection) {
                        // Initialize pagination controls.
                        $(this.el).find('.table-control #pagination-previous').prop('disabled', true);
                        $(this.el).find('.table-control #pagination-next').prop('disabled', true);
                        $(this.el).find('.table-control #pagination-first').prop('disabled', true);
                        $(this.el).find('.table-control #pagination-last').prop('disabled', true);
                        $(this.el).find('.table-control #pagination-select').prop('disabled', true);
                        $(this.el).find('.table-control #pagination-select').empty();

                        // If collection, setup pagination.
                        if (collection) {
                            var pagination = collection.getPagination();
                            if (pagination !== null) {
                                // Setup buttons.
                                if (pagination.get('current') < pagination.get('total')) {
                                    $(this.el).find('.table-control div#pagination').show();
                                    $(this.el).find('.table-control #pagination-next').prop('disabled', false);
                                    $(this.el).find('.table-control #pagination-last').prop('disabled', false);
                                }
                                if (pagination.get('current') > 1) {
                                    $(this.el).find('.table-control div#pagination').show();
                                    $(this.el).find('.table-control #pagination-previous').prop('disabled', false);
                                    $(this.el).find('.table-control #pagination-first').prop('disabled', false);
                                }

                                // Handle select.
                                if (pagination.get('total') > 1) {
                                    var select = $(this.el).find('.table-control #pagination-select');
                                    select.prop('disabled', false);
                                    for (var i = 1; i <= pagination.get('total'); i++) {
                                        select.append($('<option>', { value: i, text: i }));
                                    }
                                    select.val(pagination.get('current'));
                                }
                            }
                        }
                    }
                }]);

                return BehaviorTable;
            })(Marionette.Behavior);

            _export('default', BehaviorTable);

            BehaviorTable.prototype.ui = {
                paginationPrevious: '#pagination-previous',
                paginationNext: '#pagination-next',
                paginationFirst: '#pagination-first',
                paginationLast: '#pagination-last',
                buttonSearch: '#button-search',
                buttonRemove: '#button-remove',
                buttonClearAll: '#button-clearall',
                paginationSelect: '#pagination-select'
            };
            BehaviorTable.prototype.events = {
                'click @ui.paginationPrevious': '_handlePaginationPrevious',
                'click @ui.paginationNext': '_handlePaginationNext',
                'click @ui.paginationFirst': '_handlePaginationFirst',
                'click @ui.paginationLast': '_handlePaginationLast',
                'click th': '_handleSort',
                'click @ui.buttonSearch': '_handleSearch',
                'click @ui.buttonRemove': '_handleButtonRemove',
                'click @ui.buttonClearAll': '_handleButtonClearAll',
                'click tbody tr': '_handleLeftClickRow',
                'contextmenu tbody tr': '_handleRowRightClick',
                'change @ui.paginationSelect': '_handlePaginationSelect'
            };
            BehaviorTable.prototype.defaults = {
                'templateControl': '#template-table_control',
                'templateFilterChoice': '#template-filter_choice',
                'templateFilterText': '#template-filter_text',
                'templateFilterEnum': '#template-filter_enumeration',
                'templateFilterDatetime': '#template-filter_datetime',
                'table': 'table'
            };
            BehaviorTable.prototype.collectionEvents = {
                'sync': '_handleCollectionEventSync'
            };
        }
    };
});

$__System.register('34', ['16', '17'], function (_export) {
    var _createClass, _classCallCheck, Cookie;

    return {
        setters: [function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }],
        execute: function () {
            /**
             * ES6 Port of the Cappuccino CPCookie Class.
             */
            'use strict';

            Cookie = (function () {
                /**
                 * Constructor.
                 *
                 * @param {string} name name of cookie
                 */

                function Cookie(name) {
                    _classCallCheck(this, Cookie);

                    this._cookieName = name;
                    this._cookieValue = this._readCookieValue();
                    this._expires = null;
                }

                /**
                 * Saves provided info as cookie.
                 *
                 * @param {string} name name of cookie
                 * @param {string} value value of cookie
                 * @param {integer} days days until expiration of cookie
                 */

                _createClass(Cookie, [{
                    key: '_readCookieValue',

                    /**
                     * Returns value of cookie.
                     *
                     * @return {string} value of cookie
                     */
                    value: function _readCookieValue() {
                        var name = this._cookieName + '=',
                            ca = document.cookie.split(';');

                        for (var i = 0, len = ca.length; i < len; i++) {
                            var c = ca[i];
                            while (c.charAt(0) === ' ') {
                                c = c.substring(1, c.length);
                            }

                            if (c.indexOf(name) === 0) {
                                return c.substring(name.length, c.length);
                            }
                        }
                        return '';
                    }
                }, {
                    key: 'name',

                    /**
                     * Returns name.
                     *
                     * @return {string} name
                     */
                    get: function get() {
                        return this._cookieName;
                    }

                    /**
                     * Returns value.
                     *
                     * @return {string} value
                     */
                }, {
                    key: 'value',
                    get: function get() {
                        return this._cookieValue;
                    }

                    /**
                     * Returns expiration date.
                     *
                     * @return {Date} expiration date
                     */
                }, {
                    key: 'expires',
                    get: function get() {
                        return this._expires;
                    }
                }], [{
                    key: 'saveCookie',
                    value: function saveCookie(name, value, days) {
                        var date = new Date();
                        date.setTime(date.getTime() + days * 86400000);
                        var expires = 'expires=' + date.toUTCString();
                        document.cookie = name + '=' + value + '; ' + expires;
                    }
                }]);

                return Cookie;
            })();

            _export('default', Cookie);
        }
    };
});

$__System.register('35', ['14', '15', '17', '1d'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseModel, User;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * User.
       */
      'use strict';

      User = (function (_BaseModel) {
        _inherits(User, _BaseModel);

        function User() {
          _classCallCheck(this, User);

          _get(Object.getPrototypeOf(User.prototype), 'constructor', this).apply(this, arguments);
        }

        return User;
      })(BaseModel);

      _export('default', User);

      User.prototype.routeName = 'users';
    }
  };
});

$__System.register('36', ['10', '11', '14', '15', '16', '17', '20', '34', '35', '37'], function (_export) {
    var Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Cookie, User, BaseController, ControllerAuthentication;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_8) {
            RODAN_EVENTS = _8['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_9) {
            Radio = _9['default'];
        }, function (_7) {
            Cookie = _7['default'];
        }, function (_10) {
            User = _10['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }],
        execute: function () {

            /**
             * Controls authentication.
             */
            'use strict';

            ControllerAuthentication = (function (_BaseController) {
                _inherits(ControllerAuthentication, _BaseController);

                function ControllerAuthentication() {
                    _classCallCheck(this, ControllerAuthentication);

                    _get(Object.getPrototypeOf(ControllerAuthentication.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerAuthentication, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * How authentication behaves depends on Configuration.SERVER_AUTHENTICATION_TYPE.
                     */
                    value: function initialize() {
                        this._user = null;
                        if (Configuration.SERVER_AUTHENTICATION_TYPE === 'session') {
                            this._token = new Cookie('csrftoken');
                        } else if (Configuration.SERVER_AUTHENTICATION_TYPE === 'token') {
                            this._token = new Cookie('token');
                        } else {
                            /** @todo throw error if bad authentication type. */
                        }
                    }

                    /**
                     * AJAX prefilter associated with authentication.
                     *
                     * This will make sure that the appropriate request headers for authentication are set on all AJAX requests to the server.
                     *
                     * @param {object} options object.beforeSend (optional) is a function that takes in the XmlHTTPRequest before sending; this may be useful for doing pre-processing of AJAX requests
                     */
                }, {
                    key: 'ajaxPrefilter',
                    value: function ajaxPrefilter(options) {
                        var that = this;
                        var oldOnBeforeSend = options.beforeSend;
                        if (Configuration.SERVER_AUTHENTICATION_TYPE === 'session' && !options.beforeSend) {
                            options.xhrFields = { withCredentials: true };
                            options.beforeSend = function (xhr) {
                                if (oldOnBeforeSend) {
                                    oldOnBeforeSend(xhr);
                                }
                                xhr.setRequestHeader('X-CSRFToken', that._token.value);
                            };
                        } else if (Configuration.SERVER_AUTHENTICATION_TYPE === 'token') {
                            options.beforeSend = function (xhr) {
                                if (oldOnBeforeSend) {
                                    oldOnBeforeSend(xhr);
                                }
                                xhr.setRequestHeader('Authorization', 'Token ' + that._token.value);
                            };
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER, function () {
                            return _this._handleRequestUser();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__AUTHENTICATION_LOGIN, function (options) {
                            return _this._login(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__AUTHENTICATION_CHECK, function () {
                            return _this._checkAuthenticationStatus();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__AUTHENTICATION_LOGOUT, function () {
                            return _this._logout();
                        });
                    }

                    /**
                     * Handle authentication response.
                     */
                }, {
                    key: '_handleAuthenticationResponse',
                    value: function _handleAuthenticationResponse(event) {
                        var request = event.currentTarget;
                        if (request.responseText === null) {
                            Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_ERROR_NULL);
                        }

                        switch (request.status) {
                            case 200:
                                var parsed = JSON.parse(request.responseText);
                                this._user = new User(parsed);
                                this._processAuthenticationData();
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGIN_SUCCESS, { user: this._user });
                                break;
                            case 400:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGINREQUIRED);
                                break;
                            case 401:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request,
                                    message: 'Incorrect username/password.' });
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGINREQUIRED);
                                break;
                            case 403:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGINREQUIRED);
                                break;
                            default:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                break;
                        }
                    }

                    /**
                     * Handle deauthentication response.
                     */
                }, {
                    key: '_handleDeauthenticationResponse',
                    value: function _handleDeauthenticationResponse(event) {
                        var request = event.currentTarget;
                        if (request.responseText === null) {
                            Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_ERROR_NULL);
                        }

                        switch (request.status) {
                            case 200:
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGOUT_SUCCESS);
                                break;
                            case 400:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                break;
                            case 401:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                break;
                            case 403:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                break;
                            default:
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { response: request });
                                break;
                        }
                    }

                    /**
                     * Handle timeout.
                     */
                }, {
                    key: '_handleTimeout',
                    value: function _handleTimeout(event) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_WENTAWAY, { event: event });
                    }

                    /**
                     * Sends request to check authentication.
                     */
                }, {
                    key: '_checkAuthenticationStatus',
                    value: function _checkAuthenticationStatus() {
                        var _this2 = this;

                        // First, check if we have the appropriate authentication data. If we do, check it.
                        // If we don't, trigger an event to inform of login require.
                        if (this._token.value === '') {
                            Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGINREQUIRED);
                        } else {
                            var authRoute = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, 'auth-me');
                            var request = new XMLHttpRequest();
                            request.onload = function (event) {
                                return _this2._handleAuthenticationResponse(event);
                            };
                            request.ontimeout = function (event) {
                                return _this2._handleTimeout(event);
                            };
                            request.open('GET', authRoute, true);
                            request.setRequestHeader('Accept', 'application/json');
                            this._setAuthenticationData(request);
                            request.send();
                        }
                    }

                    /**
                     * Login.
                     */
                }, {
                    key: '_login',
                    value: function _login(options) {
                        var _this3 = this;

                        var authRoute = this._getAuthenticationRoute();
                        var authType = Configuration.SERVER_AUTHENTICATION_TYPE;
                        var request = new XMLHttpRequest();
                        request.onload = function (event) {
                            return _this3._handleAuthenticationResponse(event);
                        };
                        request.ontimeout = function (event) {
                            return _this3._handleTimeout(event);
                        };
                        request.open('POST', authRoute, true);
                        if (authType === 'session') {
                            request.withCredentials = true;
                        }
                        request.setRequestHeader('Accept', 'application/json');
                        request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
                        request.send('username=' + options.username + '&password=' + options.password);
                    }

                    /**
                     * Logout.
                     */
                }, {
                    key: '_logout',
                    value: function _logout() {
                        var _this4 = this;

                        var authRoute = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, 'auth-reset-token');
                        var request = new XMLHttpRequest();
                        request.onload = function (event) {
                            return _this4._handleDeauthenticationResponse(event);
                        };
                        request.ontimeout = function (event) {
                            return _this4._handleTimeout(event);
                        };
                        request.open('POST', authRoute, true);
                        request.setRequestHeader('Accept', 'application/json');
                        this._setAuthenticationData(request);
                        this._deleteAuthenticationData();
                        request.send();
                        this._user = null;
                    }

                    /**
                     * Sets the appropriate authentication data to the request.
                     */
                }, {
                    key: '_setAuthenticationData',
                    value: function _setAuthenticationData(request) {
                        if (Configuration.SERVER_AUTHENTICATION_TYPE === 'token') {
                            request.setRequestHeader('Authorization', 'Token ' + this._token.value);
                        } else if (Configuration.SERVER_AUTHENTICATION_TYPE === 'session') {
                            request.withCredentials = true;
                            request.setRequestHeader('X-CSRFToken', this._token.value);
                        }
                    }

                    /**
                     * Deletes authentication data.
                     */
                }, {
                    key: '_deleteAuthenticationData',
                    value: function _deleteAuthenticationData() {
                        // Only need to worry about token authentication.
                        if (Configuration.SERVER_AUTHENTICATION_TYPE === 'token') {
                            Cookie.saveCookie('token', '', 0);
                            this._token = new Cookie('token');
                        }
                    }

                    /** 
                     * Save authentication data.
                     */
                }, {
                    key: '_processAuthenticationData',
                    value: function _processAuthenticationData() {
                        if (Configuration.SERVER_AUTHENTICATION_TYPE === 'token' && this._user.has('token')) {
                            Cookie.saveCookie('token', this._user.get('token'), 365);
                            this._token = new Cookie('token');
                        } else if (Configuration.SERVER_AUTHENTICATION_TYPE === 'session') {
                            this._token = new Cookie('csrftoken');
                        }
                    }

                    /**
                     * Send out active user.
                     */
                }, {
                    key: '_handleRequestUser',
                    value: function _handleRequestUser() {
                        return this._user;
                    }

                    /**
                     * Returns authentication route.
                     */
                }, {
                    key: '_getAuthenticationRoute',
                    value: function _getAuthenticationRoute() {
                        switch (Configuration.SERVER_AUTHENTICATION_TYPE) {
                            case 'session':
                                {
                                    return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, 'session-auth');
                                }

                            case 'token':
                                {
                                    return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, 'auth-token');
                                }

                            default:
                                {
                                    console.error('An acceptable Authentication Type was not provided');
                                    break;
                                }
                        }
                    }
                }]);

                return ControllerAuthentication;
            })(BaseController);

            _export('default', ControllerAuthentication);
        }
    };
});

$__System.register('38', ['3', '11', '14', '15', '16', '17', '20', '37'], function (_export) {
    var $, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, ControllerContextMenu;

    return {
        setters: [function (_5) {
            $ = _5['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_6) {
            BaseController = _6['default'];
        }],
        execute: function () {

            /**
             * Controls context menus.
             */
            'use strict';

            ControllerContextMenu = (function (_BaseController) {
                _inherits(ControllerContextMenu, _BaseController);

                function ControllerContextMenu() {
                    _classCallCheck(this, ControllerContextMenu);

                    _get(Object.getPrototypeOf(ControllerContextMenu.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerContextMenu, [{
                    key: '_initializeRadio',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize radio.
                     */
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__CONTEXTMENU_HIDE, function () {
                            return _this._handleRequestContextMenuHide();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__CONTEXTMENU_SHOW, function (options) {
                            return _this._handleRequestContextMenuShow(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle request context menu hide.
                     */
                }, {
                    key: '_handleRequestContextMenuHide',
                    value: function _handleRequestContextMenuHide() {
                        $('#menu-context').hide();
                    }

                    /**
                     * Handle request context menu show.
                     */
                }, {
                    key: '_handleRequestContextMenuShow',
                    value: function _handleRequestContextMenuShow(options) {
                        $('#menu-context').empty();
                        for (var index in options.items) {
                            var listItemData = options.items[index];
                            var callOptions = listItemData.options ? listItemData.options : {};
                            var label = listItemData.label;
                            var channel = listItemData.channel ? listItemData.channel : 'rodan';
                            var radiorequest = listItemData.radiorequest;

                            var functionCall = function functionCall(event) {
                                var data = $(event.currentTarget).data('radio');
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__CONTEXTMENU_HIDE);
                                Radio.channel(channel).request(data.request, data.options);
                            };

                            var anchor = $('<a>' + label + '</a>');
                            anchor.data('radio', { request: radiorequest, options: callOptions });
                            anchor.click(functionCall);
                            $('#menu-context').append($('<li></li>').append(anchor));
                        }
                        $('#menu-context').css('top', options.top);
                        $('#menu-context').css('left', options.left);
                        $('#menu-context').show();
                        $('body').one('click', this._handleRequestContextMenuHide);
                    }
                }]);

                return ControllerContextMenu;
            })(BaseController);

            _export('default', ControllerContextMenu);
        }
    };
});

$__System.register('39', ['3', '11', '14', '15', '16', '17', '20', '27', '37'], function (_export) {
    var $, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, BaseController, ControllerModal;

    return {
        setters: [function (_5) {
            $ = _5['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_9) {
            Radio = _9['default'];
        }, function (_8) {
            Marionette = _8['default'];
        }, function (_6) {
            BaseController = _6['default'];
        }],
        execute: function () {

            /**
             * Controls modals.
             */
            'use strict';

            ControllerModal = (function (_BaseController) {
                _inherits(ControllerModal, _BaseController);

                function ControllerModal() {
                    _classCallCheck(this, ControllerModal);

                    _get(Object.getPrototypeOf(ControllerModal.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerModal, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        this._waiting = true;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        // Events.
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__SERVER_IDLE, function () {
                            return _this._handleOnServerIdle();
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__SERVER_PANIC, function () {
                            return _this._handleOnServerPanic();
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__SERVER_WAITING, function () {
                            return _this._handleOnServerWaiting();
                        });

                        // Requests.
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__MODAL_HIDE, function () {
                            return _this._handleRequestModalHide();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__MODAL_SHOW, function (options) {
                            return _this._handleRequestModalShow(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__MODAL_SHOW_SIMPLE, function (options) {
                            return _this._handleRequestModalSimpleShow(options);
                        });
                    }

                    /**
                     * Show waiting modal.
                     */
                }, {
                    key: '_showWaitingModal',
                    value: function _showWaitingModal() {
                        var $modalEl = $('modal-generic');
                        if ($modalEl.is(':visible')) {
                            return;
                        }
                        this._layoutViewModal = new Marionette.LayoutView({ template: '#template-modal_waiting' });
                        this._layoutViewModal.render();
                        $modalEl.css({ top: 0, left: 0, position: 'absolute' });
                        $modalEl.html(this._layoutViewModal.el);
                        $modalEl.modal({ backdrop: 'static', keyboard: false });
                        this._waiting = true;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle on server idle.
                     */
                }, {
                    key: '_handleOnServerIdle',
                    value: function _handleOnServerIdle() {
                        var $modalEl = $('#modal-generic');
                        if ($modalEl.is(':visible') && this._waiting) {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        }
                    }

                    /**
                     * Handle on server panic.
                     */
                }, {
                    key: '_handleOnServerPanic',
                    value: function _handleOnServerPanic() {
                        console.log('server panic');
                    }

                    /**
                     * Handle on server waiting.
                     */
                }, {
                    key: '_handleOnServerWaiting',
                    value: function _handleOnServerWaiting() {
                        var $modalEl = $('#modal-generic');
                        if (!$modalEl.is(':visible')) {
                            this._showWaitingModal();
                        }
                    }

                    /**
                     * Handle request modal hide.
                     */
                }, {
                    key: '_handleRequestModalHide',
                    value: function _handleRequestModalHide() {
                        var $modalElement = $('#modal-generic');
                        $modalElement.modal('hide');
                        this._waiting = false;
                    }

                    /**
                     * Handle request modal simple show.
                     */
                }, {
                    key: '_handleRequestModalSimpleShow',
                    value: function _handleRequestModalSimpleShow(options) {
                        var $modalEl = $('#modal-generic');
                        if ($modalEl.is(':visible')) {
                            return;
                        }
                        this._layoutViewModal = new Marionette.LayoutView({ template: '#template-modal_simple' });
                        this._layoutViewModal.render();
                        $modalEl.css({ top: 0, left: 0, position: 'absolute' });
                        $modalEl.html(this._layoutViewModal.el);
                        $('.modal-title').text(options.title);
                        $('.modal-body').append(options.text);
                        $modalEl.modal({ backdrop: 'static', keyboard: false });
                    }

                    /**
                     * Handle request modal show.
                     */
                }, {
                    key: '_handleRequestModalShow',
                    value: function _handleRequestModalShow(options) {
                        var $modalEl = $('#modal-generic');
                        if ($modalEl.is(':visible')) {
                            return;
                        }
                        this._layoutViewModal = new Marionette.LayoutView({ template: '#template-modal' });
                        this._layoutViewModal.addRegions({ modal_body: '#region-modal_body' });
                        this._layoutViewModal.render();
                        this._layoutViewModal.getRegion('modal_body').show(options.view);
                        $modalEl.css({ top: 0, left: 0, position: 'absolute' });
                        $modalEl.html(this._layoutViewModal.el);
                        $modalEl.draggable({ handle: '.modal-header' });
                        $('.modal-title').text(options.title);
                        $modalEl.modal({ backdrop: 'static' });
                    }
                }]);

                return ControllerModal;
            })(BaseController);

            _export('default', ControllerModal);
        }
    };
});

$__System.register('3a', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewProject;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }],
        execute: function () {

            /**
             * Project view.
             */
            'use strict';

            ViewProject = (function (_Marionette$CompositeView) {
                _inherits(ViewProject, _Marionette$CompositeView);

                function ViewProject() {
                    _classCallCheck(this, ViewProject);

                    _get(Object.getPrototypeOf(ViewProject.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewProject, [{
                    key: '_handleButtonSave',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle save button.
                     */
                    value: function _handleButtonSave() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_SAVE, { project: this.model,
                            fields: { name: this.ui.textName.val(), description: this.ui.textDescription.val() } });
                    }

                    /**
                     * Handle delete button.
                     */
                }, {
                    key: '_handleButtonDelete',
                    value: function _handleButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_DELETE, { project: this.model });
                    }

                    /**
                     * Handle RunJob button.
                     */
                }, {
                    key: '_handleButtonRunJobs',
                    value: function _handleButtonRunJobs() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RUNJOB_SELECTED_COLLECTION, { project: this.model });
                    }

                    /**
                     * Handle click resource count.
                     */
                }, {
                    key: '_handleClickResourceCount',
                    value: function _handleClickResourceCount() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_SELECTED_COLLECTION, { project: this.model });
                    }

                    /**
                     * Handle click workflow count.
                     */
                }, {
                    key: '_handleClickWorkflowCount',
                    value: function _handleClickWorkflowCount() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED_COLLECTION, { project: this.model });
                    }
                }]);

                return ViewProject;
            })(Marionette.CompositeView);

            _export('default', ViewProject);

            ViewProject.prototype.modelEvents = {
                'all': 'render'
            };
            ViewProject.prototype.ui = {
                buttonSave: '#button-save_project',
                buttonDelete: '#button-delete_project',
                resourceCount: '#resource_count',
                workflowCount: '#workflow_count',
                buttonRunJobs: '#button-runjobs',
                textName: '#text-project_name',
                textDescription: '#text-project_description'
            };
            ViewProject.prototype.events = {
                'click @ui.buttonSave': '_handleButtonSave',
                'click @ui.buttonDelete': '_handleButtonDelete',
                'click @ui.resourceCount': '_handleClickResourceCount',
                'click @ui.workflowCount': '_handleClickWorkflowCount',
                'click @ui.buttonRunJobs': '_handleButtonRunJobs'
            };
            ViewProject.prototype.template = '#template-main_project_individual';
        }
    };
});

$__System.register('3b', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewProjectListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * Project list item view.
             */
            'use strict';

            ViewProjectListItem = (function (_BaseViewListItem) {
                _inherits(ViewProjectListItem, _BaseViewListItem);

                function ViewProjectListItem() {
                    _classCallCheck(this, ViewProjectListItem);

                    _get(Object.getPrototypeOf(ViewProjectListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewProjectListItem, [{
                    key: '_handleDoubleClick',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles double click.
                     */
                    value: function _handleDoubleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SELECTED, { project: this.model });
                    }
                }]);

                return ViewProjectListItem;
            })(BaseViewListItem);

            _export('default', ViewProjectListItem);

            ViewProjectListItem.prototype.template = '#template-main_project_list_item';
            ViewProjectListItem.prototype.tagName = 'tr';
            ViewProjectListItem.prototype.events = {
                'dblclick': '_handleDoubleClick'
            };
        }
    };
});

$__System.register('3d', ['11', '14', '15', '16', '17', '20', '3e', '3b'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewList, ViewProjectListItem, ViewProjectList;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_e) {
            BaseViewList = _e['default'];
        }, function (_b) {
            ViewProjectListItem = _b['default'];
        }],
        execute: function () {

            /**
             * Project list view.
             */
            'use strict';

            ViewProjectList = (function (_BaseViewList) {
                _inherits(ViewProjectList, _BaseViewList);

                function ViewProjectList() {
                    _classCallCheck(this, ViewProjectList);

                    _get(Object.getPrototypeOf(ViewProjectList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewProjectList, [{
                    key: '_handleButtonNewProject',
                    value: function _handleButtonNewProject() {
                        var user = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_CREATE, { creator: user });
                    }
                }]);

                return ViewProjectList;
            })(BaseViewList);

            _export('default', ViewProjectList);

            ViewProjectList.prototype.ui = {
                buttonNewProject: '#button-new_project'
            };
            ViewProjectList.prototype.events = {
                'click @ui.buttonNewProject': '_handleButtonNewProject'
            };
            ViewProjectList.prototype.template = '#template-main_project_list';
            ViewProjectList.prototype.childView = ViewProjectListItem;
            ViewProjectList.prototype.behaviors = { Table: { 'table': '#table-projects' } };
        }
    };
});

$__System.register('3f', ['11', '14', '15', '16', '17', '20', '37', '40', '41', '42', '43', '3a', '3d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, LayoutViewModel, Project, ViewWorkflowRunList, WorkflowRunCollection, ViewProject, ViewProjectList, ControllerProject;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_9) {
            Radio = _9['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_7) {
            LayoutViewModel = _7['default'];
        }, function (_8) {
            Project = _8['default'];
        }, function (_10) {
            ViewWorkflowRunList = _10['default'];
        }, function (_11) {
            WorkflowRunCollection = _11['default'];
        }, function (_a) {
            ViewProject = _a['default'];
        }, function (_d) {
            ViewProjectList = _d['default'];
        }],
        execute: function () {

            /**
             * Controller for Projects.
             */
            'use strict';

            ControllerProject = (function (_BaseController) {
                _inherits(ControllerProject, _BaseController);

                function ControllerProject() {
                    _classCallCheck(this, ControllerProject);

                    _get(Object.getPrototypeOf(ControllerProject.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerProject, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize the instance.
                     */
                    value: function initialize() {
                        this._activeProject = null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        // Events.
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_CREATED, function (options) {
                            return _this._handleEventProjectGenericResponse(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_DELETED, function (options) {
                            return _this._handleEventProjectDeleteResponse(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_SAVED, function (options) {
                            return _this._handleEventProjectGenericResponse(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_SELECTED, function (options) {
                            return _this._handleEventItemSelected(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_SELECTED_COLLECTION, function () {
                            return _this._handleEventListSelected();
                        });

                        // Requests.
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE, function () {
                            return _this._handleRequestProjectActive();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__PROJECT_CREATE, function (options) {
                            return _this._handleRequestCreateProject(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__PROJECT_SET_ACTIVE, function (options) {
                            return _this._handleRequestSetActiveProject(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__PROJECT_SAVE, function (options) {
                            return _this._handleRequestProjectSave(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__PROJECT_DELETE, function (options) {
                            return _this._handleRequestProjectDelete(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Event handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event Project generic response.
                     */
                }, {
                    key: '_handleEventProjectGenericResponse',
                    value: function _handleEventProjectGenericResponse() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_PROJECTS_LOAD, {});
                    }

                    /**
                     * Handle event Project delete response.
                     */
                }, {
                    key: '_handleEventProjectDeleteResponse',
                    value: function _handleEventProjectDeleteResponse() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_PROJECTS_LOAD, {});
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SELECTED_COLLECTION);
                    }

                    /**
                     * Handle request Project save.
                     */
                }, {
                    key: '_handleRequestProjectSave',
                    value: function _handleRequestProjectSave(options) {
                        options.project.save(options.fields, { patch: true, success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SAVED, { project: model });
                            } });
                    }

                    /**
                     * Handle request Project create.
                     */
                }, {
                    key: '_handleRequestCreateProject',
                    value: function _handleRequestCreateProject(options) {
                        var project = new Project({ creator: options.user });
                        project.save({}, { success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_CREATED, { project: model });
                            } });
                    }

                    /**
                     * Handle request Project delete.
                     */
                }, {
                    key: '_handleRequestProjectDelete',
                    value: function _handleRequestProjectDelete(options) {
                        this._activeProject = null;
                        options.project.destroy({ success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_DELETED, { project: model });
                            } });
                    }

                    /**
                     * Handle request set active Project.
                     */
                }, {
                    key: '_handleRequestSetActiveProject',
                    value: function _handleRequestSetActiveProject(options) {
                        this._activeProject = options.project;
                    }

                    /**
                     * Handle item selection.
                     */
                }, {
                    key: '_handleEventItemSelected',
                    value: function _handleEventItemSelected(options) {
                        this._activeProject = options.project;
                        this._activeProject.fetch();
                        var collection = new WorkflowRunCollection();
                        collection.fetch({ data: { project: this._activeProject.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [collection] });
                        var layoutView = new LayoutViewModel({ template: '#template-main_layoutview_model_inverse' });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: layoutView });
                        layoutView.showItem(new ViewProject({ model: this._activeProject }));
                        layoutView.showList(new ViewWorkflowRunList({ collection: collection }));
                    }

                    /**
                     * Handle list selection.
                     */
                }, {
                    key: '_handleEventListSelected',
                    value: function _handleEventListSelected() {
                        var collection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_PROJECT_COLLECTION);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [collection] });
                        var view = new ViewProjectList({ collection: collection });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: view });
                    }

                    /**
                     * Handle request for current active project. Returns null.
                     */
                }, {
                    key: '_handleRequestProjectActive',
                    value: function _handleRequestProjectActive() {
                        return this._activeProject;
                    }
                }]);

                return ControllerProject;
            })(BaseController);

            _export('default', ControllerProject);
        }
    };
});

$__System.register('44', ['14', '15', '16', '17', '3c'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseViewListItem, ViewResourceTypeListItem;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * ResourceType view.
             */
            'use strict';

            ViewResourceTypeListItem = (function (_BaseViewListItem) {
                _inherits(ViewResourceTypeListItem, _BaseViewListItem);

                function ViewResourceTypeListItem() {
                    _classCallCheck(this, ViewResourceTypeListItem);

                    _get(Object.getPrototypeOf(ViewResourceTypeListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewResourceTypeListItem, [{
                    key: 'onRender',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * After render, set the value of the 'option.value'.
                     */
                    value: function onRender() {
                        _get(Object.getPrototypeOf(ViewResourceTypeListItem.prototype), 'onRender', this).call(this);
                        this.$el.attr('value', this.model.get('url'));
                        if (this.model.has('selected')) {
                            this.$el.attr('selected', 'selected');
                        }
                    }
                }]);

                return ViewResourceTypeListItem;
            })(BaseViewListItem);

            _export('default', ViewResourceTypeListItem);

            ViewResourceTypeListItem.prototype.template = '#template-main_resource_individual_resourcetype_list_item';
            ViewResourceTypeListItem.prototype.tagName = 'option';
        }
    };
});

$__System.register('45', ['11', '14', '15', '16', '17', '20', '27', '44'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewResourceTypeListItem, ViewResource;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }, function (_8) {
            ViewResourceTypeListItem = _8['default'];
        }],
        execute: function () {

            /**
             * Resource view.
             */
            'use strict';

            ViewResource = (function (_Marionette$CompositeView) {
                _inherits(ViewResource, _Marionette$CompositeView);

                function ViewResource() {
                    _classCallCheck(this, ViewResource);

                    _get(Object.getPrototypeOf(ViewResource.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewResource, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        /** @ignore */
                        this.collection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION);
                        this.collection.each(function (model) {
                            model.unset('selected');
                        });
                        var resourceType = this.collection.findWhere({ url: this.model.get('resource_type') });
                        resourceType.set('selected', 'selected');
                    }

                    /**
                     * Initialize buttons after render.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        var disabledDelete = this.model.get('origin') !== null;
                        $(this.ui.buttonDelete).attr('disabled', disabledDelete);
                        var disabledDownload = this.model.get('download') === null;
                        $(this.ui.buttonDownload).attr('disabled', disabledDownload);
                        var disableView = this.model.get('viewer_url') === null || disabledDownload;
                        $(this.ui.buttonView).attr('disabled', disableView);
                    }

                    /**
                     * Destroy callback.
                     */
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        this.collection = null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle button save.
                     */
                }, {
                    key: '_handleClickButtonSave',
                    value: function _handleClickButtonSave() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_SAVE, { resource: this.model, fields: { resource_type: this.ui.selectResourceType.val(),
                                name: this.ui.resourceName.val(),
                                description: this.ui.resourceDescription.val() } });
                    }

                    /**
                     * Handle button delete.
                     */
                }, {
                    key: '_handleClickButtonDelete',
                    value: function _handleClickButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_DELETE, { resource: this.model });
                    }

                    /**
                     * Handle button download.
                     */
                }, {
                    key: '_handleClickDownload',
                    value: function _handleClickDownload() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_DOWNLOAD, { resource: this.model });
                    }

                    /**
                     * Handle button view.
                     */
                }, {
                    key: '_handleClickView',
                    value: function _handleClickView() {
                        window.open(this.model.get('viewer_url'));
                    }
                }]);

                return ViewResource;
            })(Marionette.CompositeView);

            _export('default', ViewResource);

            ViewResource.prototype.modelEvents = {
                'all': 'render'
            };
            ViewResource.prototype.ui = {
                buttonSave: '#button-main_resource_individual_save',
                buttonDelete: '#button-main_resource_individual_delete',
                selectResourceType: '#select-resourcetype',
                resourceName: '#text-resource_name',
                resourceDescription: '#text-resource_description',
                buttonDownload: '#button-main_resource_individual_download',
                buttonView: '#button-main_resource_individual_view'
            };
            ViewResource.prototype.events = {
                'click @ui.buttonSave': '_handleClickButtonSave',
                'click @ui.buttonDelete': '_handleClickButtonDelete',
                'click @ui.buttonDownload': '_handleClickDownload',
                'click @ui.buttonView': '_handleClickView'
            };
            ViewResource.prototype.template = '#template-main_resource_individual';
            ViewResource.prototype.childView = ViewResourceTypeListItem;
            ViewResource.prototype.childViewContainer = '#select-resourcetype';
        }
    };
});

$__System.register('46', ['11', '14', '15', '16', '17', '20', '37', '40', '45', '47', '48', '49', '4a'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, LayoutViewModel, ViewResource, Resource, ResourceCollection, ViewResourceList, ViewResourceListItem, ControllerResource;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_7) {
            LayoutViewModel = _7['default'];
        }, function (_11) {
            ViewResource = _11['default'];
        }, function (_9) {
            Resource = _9['default'];
        }, function (_10) {
            ResourceCollection = _10['default'];
        }, function (_12) {
            ViewResourceList = _12['default'];
        }, function (_a) {
            ViewResourceListItem = _a['default'];
        }],
        execute: function () {

            /**
             * Controller for Resources.
             */
            'use strict';

            ControllerResource = (function (_BaseController) {
                _inherits(ControllerResource, _BaseController);

                function ControllerResource() {
                    _classCallCheck(this, ControllerResource);

                    _get(Object.getPrototypeOf(ControllerResource.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerResource, [{
                    key: '_initializeRadio',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                    value: function _initializeRadio() {
                        var _this = this;

                        // Events
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RESOURCE_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventListSelected(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RESOURCE_SELECTED, function (options) {
                            return _this._handleEventItemSelected(options);
                        });

                        // Requests
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCE_CREATE, function (options) {
                            return _this._handleRequestResourceCreate(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCE_DELETE, function (options) {
                            return _this._handleCommandResourceDelete(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCE_DOWNLOAD, function (options) {
                            return _this._handleRequestResourceDownload(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCE_SAVE, function (options) {
                            return _this._handleCommandResourceSave(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCE_SHOWLAYOUTVIEW, function (options) {
                            return _this._handleCommandShowLayoutView(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RESOURCES_LOAD, function (options) {
                            return _this._handleRequestResources(options);
                        });
                    }

                    /**
                     * Handle show LayoutView.
                     */
                }, {
                    key: '_handleCommandShowLayoutView',
                    value: function _handleCommandShowLayoutView(options) {
                        this._layoutView = options.layoutView;
                    }

                    /**
                     * Handle list selection.
                     */
                }, {
                    key: '_handleEventListSelected',
                    value: function _handleEventListSelected(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCES_LOAD, { data: { project: options.project.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [this._collection] });
                        this._layoutView = new LayoutViewModel();
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: this._layoutView });
                        var view = new ViewResourceList({ collection: this._collection,
                            template: '#template-main_resource_list',
                            childView: ViewResourceListItem,
                            model: options.project });
                        this._layoutView.showList(view);
                    }

                    /**
                     * Handle item selection.
                     */
                }, {
                    key: '_handleEventItemSelected',
                    value: function _handleEventItemSelected(options) {
                        this._layoutView.showItem(new ViewResource({ model: options.resource }));
                    }

                    /**
                     * Handle command add Resource.
                     */
                }, {
                    key: '_handleRequestResourceCreate',
                    value: function _handleRequestResourceCreate(options) {
                        var _this2 = this;

                        var resource = null;
                        if (options.resourcetype) {
                            resource = new Resource({ project: options.project.get('url'), file: options.file, resource_type: options.resourcetype });
                        } else {
                            resource = new Resource({ project: options.project.get('url'), file: options.file });
                        }
                        var jqXHR = resource.save({}, { success: function success(model) {
                                return _this2._handleCreateSuccess(model, _this2._collection);
                            } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__TRANSFERMANAGER_MONITOR_UPLOAD, { request: jqXHR, file: options.file });
                    }

                    /**
                     * Handle command delete Resource.
                     */
                }, {
                    key: '_handleCommandResourceDelete',
                    value: function _handleCommandResourceDelete(options) {
                        var _this3 = this;

                        this._layoutView.clearItemView();
                        options.resource.destroy({ success: function success(model) {
                                return _this3._handleDeleteSuccess(model, _this3._collection);
                            } });
                    }

                    /**
                     * Handle command download Resource.
                     */
                }, {
                    key: '_handleRequestResourceDownload',
                    value: function _handleRequestResourceDownload(options) {
                        var mimetype = options.resource.get('resource_type_full').mimetype;
                        var ext = options.resource.get('resource_type_full').extension;
                        var filename = options.resource.get('name') + '.' + ext;
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__TRANSFERMANAGER_DOWNLOAD, { url: options.resource.get('download'), filename: filename, mimetype: mimetype });
                    }

                    /**
                     * Handle command save Resource.
                     */
                }, {
                    key: '_handleCommandResourceSave',
                    value: function _handleCommandResourceSave(options) {
                        options.resource.save(options.fields, { patch: true, success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_SAVED, { resource: model });
                            } });
                    }

                    /**
                     * Handle request Resources.
                     */
                }, {
                    key: '_handleRequestResources',
                    value: function _handleRequestResources(options) {
                        this._collection = new ResourceCollection();
                        this._collection.fetch(options);
                        return this._collection;
                    }

                    /**
                     * Handle create success.
                     */
                }, {
                    key: '_handleCreateSuccess',
                    value: function _handleCreateSuccess(resource, collection) {
                        collection.add(resource);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_CREATED, { resource: resource });
                    }

                    /**
                     * Handle delete success.
                     */
                }, {
                    key: '_handleDeleteSuccess',
                    value: function _handleDeleteSuccess(model, collection) {
                        collection.remove(model);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_DELETED, { resource: model });
                    }
                }]);

                return ControllerResource;
            })(BaseController);

            _export('default', ControllerResource);

            _export('default', ControllerResource);
        }
    };
});

$__System.register('4b', ['11', '14', '15', '16', '17', '20', '1d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseModel, RunJob;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * RunJob.
             */
            'use strict';

            RunJob = (function (_BaseModel) {
                _inherits(RunJob, _BaseModel);

                function RunJob() {
                    _classCallCheck(this, RunJob);

                    _get(Object.getPrototypeOf(RunJob.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(RunJob, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this.set('statusText', this._getStatusText(this.get('status')));
                        this.set('available', this.available());
                    }

                    /**
                     * Return true iff the current user can lock as a manual RunJob.
                     *
                     * @return {boolean} true iff the current user can lock as a manual RunJob
                     */
                }, {
                    key: 'available',
                    value: function available() {
                        var currentUser = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER);
                        if (this.get('interactive_acquire') !== null && this.get('status') === 2) {
                            var serverDate = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_DATE);
                            var expiryDate = new Date(this.get('working_user_expiry'));
                            if (this.get('working_user') === null || this.get('working_user') === currentUser.get('url') || serverDate.getTime() > expiryDate.getTime()) {
                                return true;
                            }
                        }
                        return false;
                    }

                    /**
                     * Override of Backbone.Model.parse. Sets the 'statusText' field.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        response.statusText = this._getStatusText(response.status);
                        return response;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Return text based on status.
                     */
                }, {
                    key: '_getStatusText',
                    value: function _getStatusText(status) {
                        switch (status) {
                            case -1:
                                {
                                    return 'Failed';
                                }

                            case 0:
                                {
                                    return 'Scheduled';
                                }

                            case 1:
                                {
                                    return 'Processing';
                                }

                            case 2:
                                {
                                    return 'Waiting for input';
                                }

                            case 4:
                                {
                                    return 'Finished';
                                }

                            case 8:
                                {
                                    return 'Expired';
                                }

                            case 9:
                                {
                                    return 'Cancelled';
                                }

                            case 11:
                                {
                                    return 'Retrying';
                                }

                            default:
                                {
                                    return 'Unknown status';
                                }
                        }
                    }
                }]);

                return RunJob;
            })(BaseModel);

            _export('default', RunJob);

            RunJob.prototype.routeName = 'runjobs';
        }
    };
});

$__System.register('4c', ['14', '15', '16', '17', '33', '4b'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, RunJob, RunJobCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_b) {
      RunJob = _b['default'];
    }],
    execute: function () {

      /**
       * Collection of RunJob models.
       */
      'use strict';

      RunJobCollection = (function (_BaseCollection) {
        _inherits(RunJobCollection, _BaseCollection);

        function RunJobCollection() {
          _classCallCheck(this, RunJobCollection);

          _get(Object.getPrototypeOf(RunJobCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(RunJobCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance. This will create custom enumerations for known RunJob states.
           */
          value: function initialize() {
            /** @ignore */
            this.model = RunJob;
            this._route = 'runjobs';
            this._enumerations = [{ field: 'status', label: 'Status', values: [{ value: -1, label: 'Failed' }, { value: 0, label: 'Scheduled' }, { value: 1, label: 'Processing' }, { value: 2, label: 'Waiting for input' }, { value: 4, label: 'Finished' }, { value: 8, label: 'Expired' }, { value: 9, label: 'Cancelled' }, { value: 11, label: 'Retrying' }] }];
          }
        }]);

        return RunJobCollection;
      })(BaseCollection);

      _export('default', RunJobCollection);
    }
  };
});

$__System.register('4d', ['14', '15', '17', '27'], function (_export) {
  var _get, _inherits, _classCallCheck, Marionette, ViewRunJob;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      Marionette = _4['default'];
    }],
    execute: function () {

      /**
       * RunJob view.
       */
      'use strict';

      ViewRunJob = (function (_Marionette$ItemView) {
        _inherits(ViewRunJob, _Marionette$ItemView);

        function ViewRunJob() {
          _classCallCheck(this, ViewRunJob);

          _get(Object.getPrototypeOf(ViewRunJob.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewRunJob;
      })(Marionette.ItemView);

      _export('default', ViewRunJob);

      ViewRunJob.prototype.modelEvents = {
        'all': 'render'
      };
      ViewRunJob.prototype.template = '#template-main_runjob_individual';
    }
  };
});

$__System.register('4e', ['10', '11', '14', '15', '16', '17', '20', '37', '40', '50', '4c', '4d', '4f'], function (_export) {
    var Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, LayoutViewModel, ViewRunJobListItem, RunJobCollection, ViewRunJob, ViewRunJobList, ControllerRunJob;

    return {
        setters: [function (_6) {
            Configuration = _6['default'];
        }, function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_9) {
            Radio = _9['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_8) {
            LayoutViewModel = _8['default'];
        }, function (_10) {
            ViewRunJobListItem = _10['default'];
        }, function (_c) {
            RunJobCollection = _c['default'];
        }, function (_d) {
            ViewRunJob = _d['default'];
        }, function (_f) {
            ViewRunJobList = _f['default'];
        }],
        execute: function () {

            /**
             * Controller for RunJobs.
             */
            'use strict';

            ControllerRunJob = (function (_BaseController) {
                _inherits(ControllerRunJob, _BaseController);

                function ControllerRunJob() {
                    _classCallCheck(this, ControllerRunJob);

                    _get(Object.getPrototypeOf(ControllerRunJob.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerRunJob, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        var _this = this;

                        this._runJobLocks = {};
                        setInterval(function () {
                            return _this._reacquire();
                        }, Configuration.RUNJOB_ACQUIRE_INTERVAL);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this2 = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RUNJOB_SHOWLAYOUTVIEW, function (options) {
                            return _this2._handleCommandShowLayoutView(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RUNJOB_SELECTED, function (options) {
                            return _this2._handleEventItemSelected(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RUNJOB_SELECTED_COLLECTION, function (options) {
                            return _this2._handleEventCollectionSelected(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RUNJOB_ACQUIRE, function (options) {
                            return _this2._handleRequestAcquire(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__RUNJOBS_LOAD, function (options) {
                            return _this2._handleRequestRunJobs(options);
                        });
                    }

                    /**
                     * Handle show LayoutView.
                     */
                }, {
                    key: '_handleCommandShowLayoutView',
                    value: function _handleCommandShowLayoutView(options) {
                        this._layoutView = options.layoutView;
                    }

                    /**
                     * Handle item selection.
                     */
                }, {
                    key: '_handleEventItemSelected',
                    value: function _handleEventItemSelected(options) {
                        this._layoutView.showItem(new ViewRunJob({ model: options.runjob }));
                    }

                    /**
                     * Handle event collection selected.
                     */
                }, {
                    key: '_handleEventCollectionSelected',
                    value: function _handleEventCollectionSelected(options) {
                        this._collection = new RunJobCollection();
                        this._collection.fetch({ data: { project: options.project.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [this._collection] });
                        this._layoutView = new LayoutViewModel();
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: this._layoutView });
                        var view = new ViewRunJobList({ collection: this._collection,
                            template: '#template-main_runjob_list',
                            childView: ViewRunJobListItem });
                        this._layoutView.showList(view);
                    }

                    /**
                     * Handle request acquire.
                     */
                }, {
                    key: '_handleRequestAcquire',
                    value: function _handleRequestAcquire(options) {
                        var _this3 = this;

                        // Get lock if available. Else, if we already have the lock, simply open the interface.
                        var user = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER);
                        var runJobUrl = options.runjob.get('url');
                        if (options.runjob.available()) {
                            var ajaxOptions = {
                                url: options.runjob.get('interactive_acquire'),
                                type: 'POST',
                                dataType: 'json',
                                success: function success(response) {
                                    return _this3._handleSuccessAcquire(response, runJobUrl, options.runjob);
                                },
                                error: function error() {
                                    return _this3._removeRunJobLock(runJobUrl);
                                }
                            };
                            $.ajax(ajaxOptions);
                        } else if (options.runjob.get('working_user') === user.get('url')) {
                            var url = this._getWorkingUrl(runJobUrl);
                            this._openRunJobInterface(url);
                        }
                    }

                    /**
                     * Handle success of interactive acquire.
                     */
                }, {
                    key: '_handleSuccessAcquire',
                    value: function _handleSuccessAcquire(response, runJobUrl, runJob) {
                        this._registerRunJobForReacquire(runJobUrl, response.working_url, runJob.get('interactive_acquire'));
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RUNJOB_ACQUIRED, { runjob: runJob });
                        this._openRunJobInterface(response.working_url);
                    }

                    /**
                     * Opens interface.
                     */
                }, {
                    key: '_openRunJobInterface',
                    value: function _openRunJobInterface(url) {
                        window.open(url, '', '_blank');
                    }

                    /**
                     * Registers an interactive job to be relocked.
                     */
                }, {
                    key: '_registerRunJobForReacquire',
                    value: function _registerRunJobForReacquire(runJobUrl, workingUrl, acquireUrl) {
                        var date = new Date();
                        this._runJobLocks[runJobUrl] = { date: date.getTime(), working_url: workingUrl, acquire_url: acquireUrl };
                    }

                    /**
                     * Get working URL for acquired RunJob.
                     */
                }, {
                    key: '_getWorkingUrl',
                    value: function _getWorkingUrl(runJobUrl) {
                        var object = this._runJobLocks[runJobUrl];
                        if (object) {
                            return object.working_url;
                        }
                        return null;
                    }

                    /**
                     * Handle reacquire callback.
                     */
                }, {
                    key: '_reacquire',
                    value: function _reacquire() {
                        var _this4 = this;

                        var date = new Date();
                        for (var runJobUrl in this._runJobLocks) {
                            var runJob = this._collection.findWhere({ url: runJobUrl });

                            // If the RunJob is available, renew. Else, get rid of the lock.
                            if (runJob.available()) {
                                var data = this._runJobLocks[runJobUrl];
                                if (data) {
                                    var timeElapsed = date.getTime() - data.date;
                                    if (timeElapsed < Configuration.RUNJOB_ACQUIRE_DURATION) {
                                        $.ajax({ url: data.acquire_url, type: 'POST', dataType: 'json', error: function error() {
                                                return _this4._removeRunJobLock(runJobUrl);
                                            } });
                                    } else {
                                        this._removeRunJobLock(runJobUrl);
                                    }
                                }
                            } else {
                                this._removeRunJobLock(runJobUrl);
                            }
                        }
                    }

                    /**
                     * Remove RunJob lock.
                     */
                }, {
                    key: '_removeRunJobLock',
                    value: function _removeRunJobLock(runJobUrl) {
                        this._runJobLocks[runJobUrl] = null;
                    }

                    /**
                     * Handle request RunJobs.
                     */
                }, {
                    key: '_handleRequestRunJobs',
                    value: function _handleRequestRunJobs(options) {
                        this._collection = new RunJobCollection();
                        this._collection.fetch(options);
                        return this._collection;
                    }
                }]);

                return ControllerRunJob;
            })(BaseController);

            _export('default', ControllerRunJob);
        }
    };
});

$__System.register('51', ['3', '10', '11', '14', '15', '16', '17', '20', '37', '52'], function (_export) {
    var $, Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, Backbone, oldsync, ControllerServer;

    return {
        setters: [function (_5) {
            $ = _5['default'];
        }, function (_8) {
            Configuration = _8['default'];
        }, function (_9) {
            RODAN_EVENTS = _9['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_10) {
            Radio = _10['default'];
        }, function (_7) {
            BaseController = _7['default'];
        }, function (_6) {
            Backbone = _6['default'];
        }],
        execute: function () {
            'use strict';

            oldsync = Backbone.sync;

            Backbone.sync = function (method, model, options) {
                'use strict';return oldsync(method, model, options);
            };

            /**
             * Server controller.
             */

            ControllerServer = (function (_BaseController) {
                _inherits(ControllerServer, _BaseController);

                function ControllerServer() {
                    _classCallCheck(this, ControllerServer);

                    _get(Object.getPrototypeOf(ControllerServer.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerServer, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        var _this = this;

                        this._serverDate = null;
                        this._server = null;
                        this._originalSync = Backbone.sync;
                        this._responseTimeout = null;
                        this._responsePanic = null;
                        this._waitingEventTriggered = false;
                        Backbone.sync = function (method, model, options) {
                            return _this._sync(method, model, options);
                        };
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Sends dummy request to get server time.
                     */
                }, {
                    key: '_sendTimeGetterRequest',
                    value: function _sendTimeGetterRequest() {
                        var _this2 = this;

                        var request = new XMLHttpRequest();
                        request.open('HEAD', Configuration.getServerURL());
                        request.onreadystatechange = function (event) {
                            return _this2._handleTimeRequest(event);
                        };
                        request.setRequestHeader('Content-Type', 'text/html');
                        request.send('');
                    }

                    /**
                     * Sync override. This is needed if we want to use WebSockets.
                     */
                }, {
                    key: '_sync',
                    value: function _sync(method, model, options) {
                        var _this3 = this;

                        // Set a timeout for x seconds.
                        if (this._responseTimeout === null) {
                            this._responseTimeout = setTimeout(function () {
                                return _this3._sendWaitingNotification();
                            }, Configuration.SERVER_WAIT_TIMER);
                        }

                        // Set a timeout for panic.
                        if (this._responsePanic === null) {
                            this._responsePanic = setTimeout(function () {
                                return _this3._sendPanicNotification();
                            }, Configuration.SERVER_PANIC_TIMER);
                        }

                        // Apply generic handler for timeout.
                        options = this._applyResponseHandlers(options);

                        // Do call.
                        return this._originalSync(method, model, options);
                    }

                    /**
                     * Event bindings.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this4 = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_CONFIGURATION, function () {
                            return _this4._handleRequestConfiguration();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_DATE, function () {
                            return _this4._handleRequestDate();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_LOAD_ROUTES, function () {
                            return _this4._getRoutes();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_LOAD_ROUTE_OPTIONS, function () {
                            return _this4._handleGetRouteOptions();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, function (routeName) {
                            return _this4._handleRequestServerRoute(routeName);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE_OPTIONS, function (options) {
                            return _this4._handleRequestServerRouteOptions(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_GET_HOSTNAME, function () {
                            return _this4._handleRequestServerHostname();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SERVER_GET_VERSION, function () {
                            return _this4._handleRequestServerVersionRodan();
                        });
                    }

                    /**
                     * Return server config.
                     */
                }, {
                    key: '_handleRequestConfiguration',
                    value: function _handleRequestConfiguration() {
                        return this._server.configuration;
                    }

                    /**
                     * Return server date.
                     */
                }, {
                    key: '_handleRequestDate',
                    value: function _handleRequestDate() {
                        return this._serverDate;
                    }

                    /**
                     * Returns associated route.
                     */
                }, {
                    key: '_handleRequestServerRoute',
                    value: function _handleRequestServerRoute(routeName) {
                        return this._server.routes[routeName].url;
                    }

                    /**
                     * Returns associated route options.
                     */
                }, {
                    key: '_handleRequestServerRouteOptions',
                    value: function _handleRequestServerRouteOptions(options) {
                        return this._server.routes[options.route].options;
                    }

                    /**
                     * Returns server hostname.
                     */
                }, {
                    key: '_handleRequestServerHostname',
                    value: function _handleRequestServerHostname() {
                        return Configuration.SERVER_HOST;
                    }

                    /**
                     * Returns server version - Rodan.
                     */
                }, {
                    key: '_handleRequestServerVersionRodan',
                    value: function _handleRequestServerVersionRodan() {
                        return this._server.version;
                    }

                    /*
                    * Fetches the routes from the Rodan server. This is the first function to be called in the
                    * Rodan loading process. It hits the root endpoint on the Rodan server and from there downloads
                    * all of the path endpoints required to automatically configure the client application.
                    * */
                }, {
                    key: '_getRoutes',
                    value: function _getRoutes() {
                        var _this5 = this;

                        var routeRequest = new XMLHttpRequest();

                        // FYI: the use of the Fat arrow maps `this` to `ServerController`, not the request object.
                        routeRequest.onload = function (event) {
                            if (routeRequest.responseText && routeRequest.status === 200) {
                                _this5._server = JSON.parse(routeRequest.responseText);
                                for (var routeName in _this5._server.routes) {
                                    _this5._server.routes[routeName] = { url: _this5._server.routes[routeName] };
                                }
                                Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_ROUTESLOADED);
                            } else {
                                console.error('Routes could not be loaded from the server.');
                                console.error(event);
                            }
                        };

                        routeRequest.open('GET', Configuration.getServerURL(), true);
                        routeRequest.setRequestHeader('Accept', 'application/json');
                        routeRequest.send();
                    }

                    /**
                     * Fetches the OPTIONS (arguments for sorting, filtering, etc).
                     */
                }, {
                    key: '_handleGetRouteOptions',
                    value: function _handleGetRouteOptions() {
                        var _this6 = this;

                        for (var key in this._server.routes) {
                            // Skip routes that don't have any options.
                            if (Configuration.ROUTES_WITHOUT_OPTIONS.indexOf(key) >= 0) {
                                continue;
                            }

                            var ajaxSettings = { success: function success(result, status, xhr) {
                                    return _this6._handleGetRouteOptionsSuccess(result, status, xhr);
                                },
                                type: 'OPTIONS',
                                url: this._server.routes[key].url,
                                dataType: 'json' };
                            var request = $.ajax(ajaxSettings);
                            request.key = key;
                        }
                    }

                    /**
                     * Handle get route options success.
                     */
                }, {
                    key: '_handleGetRouteOptionsSuccess',
                    value: function _handleGetRouteOptionsSuccess(result, status, xhr) {
                        this._server.routes[xhr.key].options = result;
                    }

                    /**
                     * Apply success/error handlers to HTTP request.
                     */
                }, {
                    key: '_applyResponseHandlers',
                    value: function _applyResponseHandlers(options) {
                        var _this7 = this;

                        var genericResponseFunction = function genericResponseFunction(model, response, options) {
                            return _this7._handleResponse(model, response, options);
                        };

                        // Success.
                        if (!options.hasOwnProperty('success')) {
                            options.success = genericResponseFunction;
                        } else {
                            var customSuccessFunction = options.success;
                            options.success = function (model, response, options) {
                                customSuccessFunction(model, response, options);
                                genericResponseFunction(model, response, options);
                            };
                        }

                        // Error
                        if (!options.hasOwnProperty('error')) {
                            options.error = genericResponseFunction;
                        } else {
                            var customErrorFunction = options.error;
                            options.error = function (model, response, options) {
                                customErrorFunction(model, response, options);
                                genericResponseFunction(model, response, options);
                            };
                        }

                        // Complete
                        if (!options.hasOwnProperty('complete')) {
                            options.complete = genericResponseFunction;
                        }

                        return options;
                    }

                    /**
                     * Handle response.
                     */
                }, {
                    key: '_handleResponse',
                    value: function _handleResponse(model, response, options) {
                        var _this8 = this;

                        if (document.readyState === 'complete') {
                            clearTimeout(this._responseTimeout);
                            clearTimeout(this._responsePanic);
                            this._responseTimeout = null;
                            this._responsePanic = null;
                            if (this._waitingEventTriggered) {
                                this._sendIdleNotification();
                            }
                        }

                        // Get the time.
                        if (options && options.getResponseHeader && options.getResponseHeader('Date')) {
                            var dateResponse = new Date(options.getResponseHeader('Date'));
                            if (this._serverDate === null || this._serverDate.getTime() < dateResponse.getTime()) {
                                this._updateServerDate(dateResponse);
                                clearInterval(this._timeGetterInterval);
                                this._timeGetterInterval = null;
                            }
                        }

                        if (!this._timeGetterInterval) {
                            this._timeGetterInterval = setInterval(function () {
                                return _this8._sendTimeGetterRequest();
                            }, Configuration.SERVER_REQUEST_TIME_INTERVAL);
                        }
                    }

                    /**
                     * Sends a notification that queries are still pending.
                     */
                }, {
                    key: '_sendWaitingNotification',
                    value: function _sendWaitingNotification() {
                        this._waitingEventTriggered = true;
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_WAITING);
                    }

                    /**
                     * Send idle notification.
                     */
                }, {
                    key: '_sendIdleNotification',
                    value: function _sendIdleNotification() {
                        this._waitingEventTriggered = false;
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_IDLE);
                    }

                    /**
                     * Sends a panic notification
                     */
                }, {
                    key: '_sendPanicNotification',
                    value: function _sendPanicNotification() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_PANIC);
                    }

                    /**
                     * Handle time getter request response.
                     */
                }, {
                    key: '_handleTimeRequest',
                    value: function _handleTimeRequest(event) {
                        var request = event.currentTarget;
                        if (request && request.getResponseHeader('Date')) {
                            var dateResponse = new Date(request.getResponseHeader('Date'));
                            if (this._serverDate === null || this._serverDate.getTime() < dateResponse.getTime()) {
                                this._updateServerDate(dateResponse);
                            }
                        }
                    }

                    /**
                     * Updates recorded server date.
                     */
                }, {
                    key: '_updateServerDate',
                    value: function _updateServerDate(date) {
                        this._serverDate = date;
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_DATE_UPDATED, { date: this._serverDate });
                    }
                }]);

                return ControllerServer;
            })(BaseController);

            _export('default', ControllerServer);
        }
    };
});

$__System.register('53', ['11', '14', '15', '16', '17', '20', '37', '40', '54', '55', '56', '57'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, LayoutViewModel, ViewWorkflow, ViewWorkflowList, Workflow, WorkflowCollection, ControllerWorkflow;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_7) {
            LayoutViewModel = _7['default'];
        }, function (_9) {
            ViewWorkflow = _9['default'];
        }, function (_10) {
            ViewWorkflowList = _10['default'];
        }, function (_11) {
            Workflow = _11['default'];
        }, function (_12) {
            WorkflowCollection = _12['default'];
        }],
        execute: function () {

            /**
             * Controller for Workflows.
             */
            'use strict';

            ControllerWorkflow = (function (_BaseController) {
                _inherits(ControllerWorkflow, _BaseController);

                function ControllerWorkflow() {
                    _classCallCheck(this, ControllerWorkflow);

                    _get(Object.getPrototypeOf(ControllerWorkflow.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerWorkflow, [{
                    key: '_initializeRadio',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Initialization
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                    value: function _initializeRadio() {
                        var _this = this;

                        // Events.
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventListSelected(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED, function (options) {
                            return _this._handleEventItemSelected(options);
                        });

                        // Requests.
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOW_SAVE, function (options) {
                            return _this._handleRequestSaveWorkflow(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOW_DELETE, function (options) {
                            return _this._handleCommandDeleteWorkflow(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOW_CREATE, function (options) {
                            return _this._handleCommandAddWorkflow(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle list selection.
                     */
                }, {
                    key: '_handleEventListSelected',
                    value: function _handleEventListSelected(options) {
                        this._collection = new WorkflowCollection();
                        this._collection.fetch({ data: { project: options.project.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [this._collection] });
                        this._layoutView = new LayoutViewModel();
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: this._layoutView });
                        this._viewList = new ViewWorkflowList({ collection: this._collection });
                        this._layoutView.showList(this._viewList);
                    }

                    /**
                     * Handle item selection.
                     */
                }, {
                    key: '_handleEventItemSelected',
                    value: function _handleEventItemSelected(options) {
                        this._viewItem = new ViewWorkflow({ model: options.workflow });
                        this._layoutView.showItem(this._viewItem);
                    }

                    /**
                     * Handle command delete workflow.
                     */
                }, {
                    key: '_handleCommandDeleteWorkflow',
                    value: function _handleCommandDeleteWorkflow(options) {
                        var _this2 = this;

                        // Clear the individual view (if there).
                        if (this._viewItem !== null && options.workflow === this._viewItem.model) {
                            this._layoutView.clearItemView();
                        }
                        options.workflow.destroy({ success: function success(model) {
                                return _this2._handleDeleteSuccess(model, _this2._collection);
                            } });
                    }

                    /**
                     * Handle command add workflow.
                     */
                }, {
                    key: '_handleCommandAddWorkflow',
                    value: function _handleCommandAddWorkflow(options) {
                        var _this3 = this;

                        var workflow = new Workflow({ project: options.project.get('url'), name: 'untitled' });
                        workflow.save({}, { success: function success(model) {
                                return _this3._handleCreateSuccess(model, _this3._collection);
                            } });
                    }

                    /**
                     * Handle save workflow.
                     */
                }, {
                    key: '_handleRequestSaveWorkflow',
                    value: function _handleRequestSaveWorkflow(options) {
                        options.workflow.save(options.fields, { patch: true, success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_SAVED, { workflow: model });
                            } });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - REST handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle create success.
                     */
                }, {
                    key: '_handleCreateSuccess',
                    value: function _handleCreateSuccess(model, collection) {
                        collection.add(model);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_CREATED, { workflow: model });
                    }

                    /**
                     * Handle delete success.
                     */
                }, {
                    key: '_handleDeleteSuccess',
                    value: function _handleDeleteSuccess(model, collection) {
                        collection.remove(model);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_DELETED, { workflow: model });
                    }
                }]);

                return ControllerWorkflow;
            })(BaseController);

            _export('default', ControllerWorkflow);
        }
    };
});

$__System.register('58', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewControlWorkflowJob;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }],
        execute: function () {

            /**
             * View for editing WorkflowJob.
             */
            'use strict';

            ViewControlWorkflowJob = (function (_Marionette$ItemView) {
                _inherits(ViewControlWorkflowJob, _Marionette$ItemView);

                function ViewControlWorkflowJob() {
                    _classCallCheck(this, ViewControlWorkflowJob);

                    _get(Object.getPrototypeOf(ViewControlWorkflowJob.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewControlWorkflowJob, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle save button.
                     */
                }, {
                    key: '_handleButtonSave',
                    value: function _handleButtonSave() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        this.model.set({ 'name': this.ui.textName.val() });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOB_SAVE, { workflowjob: this.model });
                    }

                    /**
                     * Handle delete button.
                     */
                }, {
                    key: '_handleButtonDelete',
                    value: function _handleButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB, { workflowjob: this.model, workflow: this._workflow });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                    }
                }]);

                return ViewControlWorkflowJob;
            })(Marionette.ItemView);

            _export('default', ViewControlWorkflowJob);

            ViewControlWorkflowJob.prototype.template = '#template-main_workflowjob';
            ViewControlWorkflowJob.prototype.ui = {
                buttonSave: '#button-save_workflowjob_data',
                buttonDelete: '#button-delete_workflowjob',
                textName: '#text-workflowjob_name'
            };
            ViewControlWorkflowJob.prototype.events = {
                'click @ui.buttonSave': '_handleButtonSave',
                'click @ui.buttonDelete': '_handleButtonDelete'
            };
        }
    };
});

$__System.register('59', ['11', '14', '15', '16', '17', '20', '33', '5a'], function (_export) {
  var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseCollection, Job, JobCollection;

  return {
    setters: [function (_7) {
      RODAN_EVENTS = _7['default'];
    }, function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      Radio = _5['default'];
    }, function (_6) {
      BaseCollection = _6['default'];
    }, function (_a) {
      Job = _a['default'];
    }],
    execute: function () {

      /**
       * Collection of Job models.
       */
      'use strict';

      JobCollection = (function (_BaseCollection) {
        _inherits(JobCollection, _BaseCollection);

        function JobCollection() {
          _classCallCheck(this, JobCollection);

          _get(Object.getPrototypeOf(JobCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(JobCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           *
           * @todo currently getting GlobalJobCollection enumerations for these enums; need a better way
           */
          value: function initialize() {
            var globalJobCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION);
            /** @ignore */
            this.model = Job;
            this._route = 'jobs';
            this._enumerations = globalJobCollection._enumerations;
          }
        }]);

        return JobCollection;
      })(BaseCollection);

      _export('default', JobCollection);
    }
  };
});

$__System.register('5b', ['14', '15', '17', '3e'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseViewList, ViewInputPortList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_e) {
      BaseViewList = _e['default'];
    }],
    execute: function () {

      /**
       * View for InputPort list.
       */
      'use strict';

      ViewInputPortList = (function (_BaseViewList) {
        _inherits(ViewInputPortList, _BaseViewList);

        function ViewInputPortList() {
          _classCallCheck(this, ViewInputPortList);

          _get(Object.getPrototypeOf(ViewInputPortList.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewInputPortList;
      })(BaseViewList);

      _export('default', ViewInputPortList);

      ViewInputPortList.prototype.template = '#template-main_inputport_list';
    }
  };
});

$__System.register('5c', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewInputPortListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * InputPort list item view.
             */
            'use strict';

            ViewInputPortListItem = (function (_BaseViewListItem) {
                _inherits(ViewInputPortListItem, _BaseViewListItem);

                function ViewInputPortListItem() {
                    _classCallCheck(this, ViewInputPortListItem);

                    _get(Object.getPrototypeOf(ViewInputPortListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewInputPortListItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) and 'options.workflowjob' (WorkflowJob) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                        this._workflowJob = options.workflowjob;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle delete.
                     */
                }, {
                    key: '_handleButtonDelete',
                    value: function _handleButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_INPUTPORT, { inputport: this.model, workflow: this._workflow, workflowjob: this._workflowJob });
                    }
                }]);

                return ViewInputPortListItem;
            })(BaseViewListItem);

            _export('default', ViewInputPortListItem);

            ViewInputPortListItem.prototype.ui = {
                buttonDelete: '#button-delete'
            };
            ViewInputPortListItem.prototype.events = {
                'click @ui.buttonDelete': '_handleButtonDelete'
            };
            ViewInputPortListItem.prototype.template = '#template-main_inputport_list_item';
            ViewInputPortListItem.prototype.tagName = 'tr';
        }
    };
});

$__System.register('5d', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewInputPortTypeListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * InputPortType list item view.
             */
            'use strict';

            ViewInputPortTypeListItem = (function (_BaseViewListItem) {
                _inherits(ViewInputPortTypeListItem, _BaseViewListItem);

                function ViewInputPortTypeListItem() {
                    _classCallCheck(this, ViewInputPortTypeListItem);

                    _get(Object.getPrototypeOf(ViewInputPortTypeListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewInputPortTypeListItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflowjob' (WorkflowJob) and 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflowJob = options.workflowjob;
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles input port add.
                     */
                }, {
                    key: '_handleButtonNewInputPort',
                    value: function _handleButtonNewInputPort() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_INPUTPORT, { inputporttype: this.model, workflowjob: this._workflowJob, workflow: this._workflow });
                    }
                }]);

                return ViewInputPortTypeListItem;
            })(BaseViewListItem);

            _export('default', ViewInputPortTypeListItem);

            ViewInputPortTypeListItem.prototype.tagName = 'tr';
            ViewInputPortTypeListItem.prototype.template = '#template-main_inputporttype_list_item';
            ViewInputPortTypeListItem.prototype.events = {
                'click @ui.buttonNewInputPort': '_handleButtonNewInputPort'
            };
            ViewInputPortTypeListItem.prototype.ui = {
                buttonNewInputPort: '#button-new_inputport'
            };
        }
    };
});

$__System.register('5e', ['11', '14', '15', '16', '17', '20', '27', '5d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewInputPortTypeListItem, ViewInputPortTypeList;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }, function (_d) {
            ViewInputPortTypeListItem = _d['default'];
        }],
        execute: function () {

            /**
             * InputPortType list view.
             */
            'use strict';

            ViewInputPortTypeList = (function (_Marionette$CompositeView) {
                _inherits(ViewInputPortTypeList, _Marionette$CompositeView);

                function ViewInputPortTypeList() {
                    _classCallCheck(this, ViewInputPortTypeList);

                    _get(Object.getPrototypeOf(ViewInputPortTypeList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewInputPortTypeList, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflowjob' (WorkflowJob) must also be provided
                     */
                    value: function initialize(options) {
                        var jobCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION);
                        var job = jobCollection.get(options.workflowjob.getJobUuid());
                        /** @ignore */
                        this.collection = job.get('input_port_types');
                    }
                }]);

                return ViewInputPortTypeList;
            })(Marionette.CompositeView);

            _export('default', ViewInputPortTypeList);

            ViewInputPortTypeList.prototype.modelEvents = {
                'all': 'render'
            };
            ViewInputPortTypeList.prototype.template = '#template-main_inputporttype_list';
            ViewInputPortTypeList.prototype.childView = ViewInputPortTypeListItem;
            ViewInputPortTypeList.prototype.childViewContainer = 'tbody';
        }
    };
});

$__System.register('5f', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewOutputPortListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * OutputPort list item view.
             */
            'use strict';

            ViewOutputPortListItem = (function (_BaseViewListItem) {
                _inherits(ViewOutputPortListItem, _BaseViewListItem);

                function ViewOutputPortListItem() {
                    _classCallCheck(this, ViewOutputPortListItem);

                    _get(Object.getPrototypeOf(ViewOutputPortListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewOutputPortListItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) and 'options.workflowjob' (WorkflowJob) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                        this._workflowJob = options.workflowjob;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle delete.
                     */
                }, {
                    key: '_handleButtonDelete',
                    value: function _handleButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_OUTPUTPORT, { outputport: this.model, workflow: this._workflow, workflowjob: this._workflowJob });
                    }
                }]);

                return ViewOutputPortListItem;
            })(BaseViewListItem);

            _export('default', ViewOutputPortListItem);

            ViewOutputPortListItem.prototype.ui = {
                buttonDelete: '#button-delete'
            };
            ViewOutputPortListItem.prototype.events = {
                'click @ui.buttonDelete': '_handleButtonDelete'
            };
            ViewOutputPortListItem.prototype.template = '#template-main_outputport_list_item';
            ViewOutputPortListItem.prototype.tagName = 'tr';
        }
    };
});

$__System.register('60', ['14', '15', '17', '3e', '5f'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseViewList, ViewOutputPortListItem, ViewOutputPortList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_e) {
      BaseViewList = _e['default'];
    }, function (_f) {
      ViewOutputPortListItem = _f['default'];
    }],
    execute: function () {

      /**
       * OutputPort list view.
       */
      'use strict';

      ViewOutputPortList = (function (_BaseViewList) {
        _inherits(ViewOutputPortList, _BaseViewList);

        function ViewOutputPortList() {
          _classCallCheck(this, ViewOutputPortList);

          _get(Object.getPrototypeOf(ViewOutputPortList.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewOutputPortList;
      })(BaseViewList);

      _export('default', ViewOutputPortList);

      ViewOutputPortList.prototype.template = '#template-main_outputport_list';
      ViewOutputPortList.prototype.childView = ViewOutputPortListItem;
    }
  };
});

$__System.register('61', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewOutputPortTypeListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * OutputPortType list item view.
             */
            'use strict';

            ViewOutputPortTypeListItem = (function (_BaseViewListItem) {
                _inherits(ViewOutputPortTypeListItem, _BaseViewListItem);

                function ViewOutputPortTypeListItem() {
                    _classCallCheck(this, ViewOutputPortTypeListItem);

                    _get(Object.getPrototypeOf(ViewOutputPortTypeListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewOutputPortTypeListItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflowjob' (WorkflowJob) and 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflowJob = options.workflowjob;
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles output port add.
                     */
                }, {
                    key: '_handleButtonNewOutputPort',
                    value: function _handleButtonNewOutputPort() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_OUTPUTPORT, { outputporttype: this.model, workflowjob: this._workflowJob, workflow: this._workflow });
                    }
                }]);

                return ViewOutputPortTypeListItem;
            })(BaseViewListItem);

            _export('default', ViewOutputPortTypeListItem);

            ViewOutputPortTypeListItem.prototype.tagName = 'tr';
            ViewOutputPortTypeListItem.prototype.template = '#template-main_outputporttype_list_item';
            ViewOutputPortTypeListItem.prototype.events = {
                'click @ui.buttonNewOutputPort': '_handleButtonNewOutputPort'
            };
            ViewOutputPortTypeListItem.prototype.ui = {
                buttonNewOutputPort: '#button-new_outputport'
            };
        }
    };
});

$__System.register('62', ['11', '14', '15', '16', '17', '20', '27', '61'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewOutputPortTypeListItem, ViewOutputPortTypeList;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }, function (_8) {
            ViewOutputPortTypeListItem = _8['default'];
        }],
        execute: function () {

            /**
             * OutputPortTYpe list view.
             */
            'use strict';

            ViewOutputPortTypeList = (function (_Marionette$CompositeView) {
                _inherits(ViewOutputPortTypeList, _Marionette$CompositeView);

                function ViewOutputPortTypeList() {
                    _classCallCheck(this, ViewOutputPortTypeList);

                    _get(Object.getPrototypeOf(ViewOutputPortTypeList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewOutputPortTypeList, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflowjob' (WorkflowJob) must also be provided
                     */
                    value: function initialize(options) {
                        var jobCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION);
                        var job = jobCollection.get(options.workflowjob.getJobUuid());
                        /** @ignore */
                        this.collection = job.get('output_port_types');
                    }
                }]);

                return ViewOutputPortTypeList;
            })(Marionette.CompositeView);

            _export('default', ViewOutputPortTypeList);

            ViewOutputPortTypeList.prototype.modelEvents = {
                'all': 'render'
            };
            ViewOutputPortTypeList.prototype.template = '#template-main_outputporttype_list';
            ViewOutputPortTypeList.prototype.childView = ViewOutputPortTypeListItem;
            ViewOutputPortTypeList.prototype.childViewContainer = 'tbody';
        }
    };
});

$__System.register('63', ['14', '15', '16', '17', '27', '60', '62', '5b', '5c', '5e'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Marionette, ViewOutputPortList, ViewOutputPortTypeList, ViewInputPortList, ViewInputPortListItem, ViewInputPortTypeList, LayoutViewControlPorts;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }, function (_6) {
            ViewOutputPortList = _6['default'];
        }, function (_7) {
            ViewOutputPortTypeList = _7['default'];
        }, function (_b) {
            ViewInputPortList = _b['default'];
        }, function (_c) {
            ViewInputPortListItem = _c['default'];
        }, function (_e) {
            ViewInputPortTypeList = _e['default'];
        }],
        execute: function () {

            /**
             * View for editing ports.
             */
            'use strict';

            LayoutViewControlPorts = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewControlPorts, _Marionette$LayoutView);

                function LayoutViewControlPorts() {
                    _classCallCheck(this, LayoutViewControlPorts);

                    _get(Object.getPrototypeOf(LayoutViewControlPorts.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewControlPorts, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflowjob' (WorkflowJob) must also be provided
                     */
                    value: function initialize(options) {
                        this.addRegions({
                            regionControlInputPortTypes: '#region-main_inputporttypes',
                            regionControlInputPorts: '#region-main_inputports',
                            regionControlOutputPortTypes: '#region-main_outputporttypes',
                            regionControlOutputPorts: '#region-main_outputports'
                        });
                        this._workflowJob = options.workflowjob;
                        this._initializeViews(options);
                    }

                    /**
                     * Show the subviews before showing this view.
                     */
                }, {
                    key: 'onBeforeShow',
                    value: function onBeforeShow() {
                        this.regionControlInputPortTypes.show(this._inputPortTypeListView);
                        this.regionControlInputPorts.show(this._inputPortListView);
                        this.regionControlOutputPortTypes.show(this._outputPortTypeListView);
                        this.regionControlOutputPorts.show(this._outputPortListView);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle workflowjob selection.
                     */
                }, {
                    key: '_initializeViews',
                    value: function _initializeViews(options) {
                        this._inputPortListView = new ViewInputPortList({ collection: options.workflowjob.get('input_ports'),
                            template: '#template-main_inputport_list',
                            childView: ViewInputPortListItem,
                            childViewOptions: options });
                        this._outputPortListView = new ViewOutputPortList({ collection: options.workflowjob.get('output_ports'),
                            childViewOptions: options });
                        this._inputPortTypeListView = new ViewInputPortTypeList({ workflowjob: options.workflowjob,
                            childViewOptions: options });
                        this._outputPortTypeListView = new ViewOutputPortTypeList({ workflowjob: options.workflowjob,
                            childViewOptions: options });
                    }
                }]);

                return LayoutViewControlPorts;
            })(Marionette.LayoutView);

            _export('default', LayoutViewControlPorts);

            LayoutViewControlPorts.prototype.template = '#template-main_workflowjob_ports';
        }
    };
});

$__System.register('64', ['14', '15', '16', '17', '20', '27'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, LayoutViewResourceAssignment;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }],
        execute: function () {

            /**
             * ResourceAssignment view.
             */
            'use strict';

            LayoutViewResourceAssignment = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewResourceAssignment, _Marionette$LayoutView);

                function LayoutViewResourceAssignment() {
                    _classCallCheck(this, LayoutViewResourceAssignment);

                    _get(Object.getPrototypeOf(LayoutViewResourceAssignment.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewResourceAssignment, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.viewavailableresources' and 'options.viewassignedresources' must be provided (each being Marionette.Views); also required is 'options.workflow' (Workflow) and 'options.inputport' (InputPort)
                     */
                    value: function initialize(options) {
                        this.addRegions({
                            regionAvailableResources: '#region-main_workflowbuilder_resourceassignment_availableresources',
                            regionAssignedResources: '#region-main_workflowbuilder_resourceassignment_assignedresources'
                        });
                        this._viewAvailableResources = options.viewavailableresources;
                        this._viewAssignedResources = options.viewassignedresources;
                        this._workflow = options.workflow;
                        this._inputPort = options.inputport;
                    }

                    /**
                     * Unbind from events.
                     */
                }, {
                    key: 'onDestroy',
                    value: function onDestroy() {
                        Radio.channel('rodan').off(null, null, this);
                        Radio.channel('rodan').stopReplying(null, null, this);
                    }

                    /**
                     * Before the view shows we make sure the subviews are shown.
                     */
                }, {
                    key: 'onBeforeShow',
                    value: function onBeforeShow() {
                        this.regionAvailableResources.show(this._viewAvailableResources);
                        this.regionAssignedResources.show(this._viewAssignedResources);
                    }

                    /**
                     * Handle button add all.
                     */
                }, {
                    key: '_handleButtonAddAll',
                    value: function _handleButtonAddAll() {}

                    /**
                     * Handle button add selected.
                     */
                }, {
                    key: '_handleButtonAddSelected',
                    value: function _handleButtonAddSelected() {
                        $(this.regionAvailableResources.el).find('tr.active').trigger('dblclick');
                    }

                    /**
                     * Handle button remove all.
                     */
                }, {
                    key: '_handleButtonRemoveAll',
                    value: function _handleButtonRemoveAll() {}

                    /**
                     * Handle button remove selected.
                     */
                }, {
                    key: '_handleButtonRemoveSelected',
                    value: function _handleButtonRemoveSelected() {
                        $(this.regionAssignedResources.el).find('tr.active').trigger('dblclick');
                    }
                }]);

                return LayoutViewResourceAssignment;
            })(Marionette.LayoutView);

            _export('default', LayoutViewResourceAssignment);

            LayoutViewResourceAssignment.prototype.template = '#template-main_workflowbuilder_resourceassignment';
            LayoutViewResourceAssignment.prototype.ui = {
                buttonAddAll: '#button-add_all',
                buttonAddSelected: '#button-add_selected',
                buttonRemoveAll: '#button-remove_all',
                buttonRemoveSelected: '#button-remove_selected'
            };
            LayoutViewResourceAssignment.prototype.events = {
                'click @ui.buttonAddAll': '_handleButtonAddAll',
                'click @ui.buttonAddSelected': '_handleButtonAddSelected',
                'click @ui.buttonRemoveAll': '_handleButtonRemoveAll',
                'click @ui.buttonRemoveSelected': '_handleButtonRemoveSelected'
            };
        }
    };
});

$__System.register('47', ['11', '14', '15', '16', '17', '20', '32', '52', '1d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, _, Backbone, BaseModel, Resource;

    return {
        setters: [function (_9) {
            RODAN_EVENTS = _9['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_8) {
            _ = _8['default'];
        }, function (_6) {
            Backbone = _6['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * Resource.
             */
            'use strict';

            Resource = (function (_BaseModel) {
                _inherits(Resource, _BaseModel);

                function Resource() {
                    _classCallCheck(this, Resource);

                    _get(Object.getPrototypeOf(Resource.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(Resource, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        var _this = this;

                        this._updateResourceTypeFull();
                        this.on('change:resource_type', function () {
                            return _this._updateResourceTypeFull();
                        });
                        this.set('download', this._getDownloadUrl());

                        // If the creator is null (i.e. was not uploaded by a person), inject a dummy.
                        if (this.get('creator') === null) {
                            this.set('creator', 'generated result');
                        }
                    }

                    /**
                     * Override of Backbone.Model.parse. If the 'creator' is null it gets set to 'generated result'.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        if (response.creator === null) {
                            response.creator = 'generated result';
                        }
                        return response;
                    }

                    /**
                     * Returns defaults.
                     *
                     * @return {object} object holding default values
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return {
                            creator: { first_name: null, last_name: null, username: null },
                            created: null,
                            updated: null
                        };
                    }

                    /**
                     * Override of Backbone.Model.sync. This is done to facilitate file uploads.
                     *
                     * @param {string} method synce method (@see Backbone.sync)
                     * @param {object} model JavaScript object that holds properties for Resource
                     * @param {object} options options to be passed to the AJAX call
                     * @return {object} XmlHttpRequest instance 
                     */
                }, {
                    key: 'sync',
                    value: function sync(method, model, options) {
                        if (method === 'create') {
                            var formData = new FormData();
                            formData.append('project', model.get('project'));
                            formData.append('files', model.get('file'));
                            if (model.has('resource_type')) {
                                formData.append('type', model.get('resource_type'));
                            }

                            // Set processData and contentType to false so data is sent as FormData
                            _.defaults(options || (options = {}), {
                                url: this.url(),
                                data: formData,
                                processData: false,
                                contentType: false
                            });
                        }
                        return Backbone.sync.call(this, method, model, options);
                    }

                    /**
                     * Returns UUID of associated ResourceType.
                     *
                     * @return {string} UUID of associated ResourceType; null if DNE
                     */
                }, {
                    key: 'getResourceTypeUuid',
                    value: function getResourceTypeUuid() {
                        if (this.get('resource_type') !== undefined) {
                            var lastSlash = this.get('resource_type').lastIndexOf('/');
                            var subString = this.get('resource_type').substring(0, lastSlash);
                            var secondLastSlash = subString.lastIndexOf('/');
                            return this.get('resource_type').substring(secondLastSlash + 1, lastSlash);
                        }
                        return null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Updates full description of resource type.
                     */
                }, {
                    key: '_updateResourceTypeFull',
                    value: function _updateResourceTypeFull() {
                        var resourceTypeCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION);
                        var resourceTypeId = this.getResourceTypeUuid();
                        var jsonString = {};
                        if (resourceTypeId !== null) {
                            jsonString = resourceTypeCollection.get(resourceTypeId).toJSON();
                        }
                        this.set('resource_type_full', jsonString);
                    }

                    /**
                     * Returns download URL.
                     */
                }, {
                    key: '_getDownloadUrl',
                    value: function _getDownloadUrl() {
                        if (this.get('resource_file')) {
                            return this.get('resource_file');
                        } else if (this.get('compat_resource_file')) {
                            return this.get('compat_resource_file');
                        }
                        return null;
                    }
                }]);

                return Resource;
            })(BaseModel);

            _export('default', Resource);

            Resource.prototype.routeName = 'resources';
        }
    };
});

$__System.register('48', ['14', '15', '16', '17', '33', '47'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, Resource, ResourceCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      Resource = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of Resource models.
       */
      'use strict';

      ResourceCollection = (function (_BaseCollection) {
        _inherits(ResourceCollection, _BaseCollection);

        function ResourceCollection() {
          _classCallCheck(this, ResourceCollection);

          _get(Object.getPrototypeOf(ResourceCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(ResourceCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = Resource;
            this._route = 'resources';
            this._enumerations = [{ field: 'uploaded',
              label: 'Uploaded or generated',
              values: [{ value: 'False', label: 'Generated' }, { value: 'True', label: 'User' }] }];
          }
        }]);

        return ResourceCollection;
      })(BaseCollection);

      _export('default', ResourceCollection);
    }
  };
});

$__System.register('65', ['11', '14', '15', '16', '17', '20', '1d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseModel, ResourceList;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * ResourceList.
             */
            'use strict';

            ResourceList = (function (_BaseModel) {
                _inherits(ResourceList, _BaseModel);

                function ResourceList() {
                    _classCallCheck(this, ResourceList);

                    _get(Object.getPrototypeOf(ResourceList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ResourceList, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        var _this = this;

                        this._updateResourceTypeFull();
                        this.on('change:resource_type', function () {
                            return _this._updateResourceTypeFull();
                        });

                        // If the creator is null (i.e. was not uploaded by a person), inject a dummy.
                        if (this.get('creator') === null) {
                            this.set('creator', 'generated result');
                        }
                    }

                    /**
                     * Override of Backbone.Model.parse. If the 'creator' is null it gets set to 'generated result'.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        if (response.creator === null) {
                            response.creator = 'generated result';
                        }
                        return response;
                    }

                    /**
                     * Returns defaults.
                     *
                     * @return {object} object holding default values
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return {
                            creator: { first_name: null, last_name: null, username: null },
                            created: null,
                            updated: null
                        };
                    }

                    /**
                     * Returns UUID of associated ResourceType.
                     *
                     * @return {string} UUID of associated ResourceType; null if DNE
                     */
                }, {
                    key: 'getResourceTypeUuid',
                    value: function getResourceTypeUuid() {
                        if (this.get('resource_type') !== undefined) {
                            var lastSlash = this.get('resource_type').lastIndexOf('/');
                            var subString = this.get('resource_type').substring(0, lastSlash);
                            var secondLastSlash = subString.lastIndexOf('/');
                            return this.get('resource_type').substring(secondLastSlash + 1, lastSlash);
                        }
                        return null;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Updates full description of resource type.
                     */
                }, {
                    key: '_updateResourceTypeFull',
                    value: function _updateResourceTypeFull() {
                        var resourceTypeId = this.getResourceTypeUuid();
                        var jsonString = {};
                        if (resourceTypeId !== null) {
                            var resourceTypeCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION);
                            jsonString = resourceTypeCollection.get(resourceTypeId).toJSON();
                        }
                        this.set('resource_type_full', jsonString);
                    }
                }]);

                return ResourceList;
            })(BaseModel);

            _export('default', ResourceList);

            ResourceList.prototype.routeName = 'resourcelists';
        }
    };
});

$__System.register('66', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewJobListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * View for Jot item in Job list.
             */
            'use strict';

            ViewJobListItem = (function (_BaseViewListItem) {
                _inherits(ViewJobListItem, _BaseViewListItem);

                function ViewJobListItem() {
                    _classCallCheck(this, ViewJobListItem);

                    _get(Object.getPrototypeOf(ViewJobListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewJobListItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) must also be provided for the associated Workflow
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle add button.
                     */
                }, {
                    key: '_handleClickButtonAdd',
                    value: function _handleClickButtonAdd() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOB, { job: this.model, workflow: this._workflow });
                    }
                }]);

                return ViewJobListItem;
            })(BaseViewListItem);

            _export('default', ViewJobListItem);

            ViewJobListItem.prototype.template = '#template-main_job_list_item';
            ViewJobListItem.prototype.tagName = 'tr';
            ViewJobListItem.prototype.ui = {
                buttonAdd: '#button-main_job_button_add'
            };
            ViewJobListItem.prototype.events = {
                'click @ui.buttonAdd': '_handleClickButtonAdd',
                'dblclick': '_handleClickButtonAdd'
            };
        }
    };
});

$__System.register('67', ['14', '15', '17', '66', '3e'], function (_export) {
  var _get, _inherits, _classCallCheck, ViewJobListItem, BaseViewList, ViewJobList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      ViewJobListItem = _4['default'];
    }, function (_e) {
      BaseViewList = _e['default'];
    }],
    execute: function () {

      /**
       * View for Job list.
       */
      'use strict';

      ViewJobList = (function (_BaseViewList) {
        _inherits(ViewJobList, _BaseViewList);

        function ViewJobList() {
          _classCallCheck(this, ViewJobList);

          _get(Object.getPrototypeOf(ViewJobList.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewJobList;
      })(BaseViewList);

      _export('default', ViewJobList);

      ViewJobList.prototype.template = '#template-main_job_list';
      ViewJobList.prototype.childView = ViewJobListItem;
      ViewJobList.prototype.behaviors = { Table: { 'table': '#table-jobs' } };

      _export('default', ViewJobList);
    }
  };
});

$__System.register('68', ['14', '15', '17', '49', '69'], function (_export) {
  var _get, _inherits, _classCallCheck, ViewResourceList, ViewResourceListItemModal, ViewResourceListAssigned;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      ViewResourceList = _4['default'];
    }, function (_5) {
      ViewResourceListItemModal = _5['default'];
    }],
    execute: function () {

      /**
       * View for assigned Resources when assigning to InputPort.
       */
      'use strict';

      ViewResourceListAssigned = (function (_ViewResourceList) {
        _inherits(ViewResourceListAssigned, _ViewResourceList);

        function ViewResourceListAssigned() {
          _classCallCheck(this, ViewResourceListAssigned);

          _get(Object.getPrototypeOf(ViewResourceListAssigned.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewResourceListAssigned;
      })(ViewResourceList);

      _export('default', ViewResourceListAssigned);

      ViewResourceListAssigned.prototype.allowMultipleSelection = true;
      ViewResourceListAssigned.prototype.template = '#template-modal_resource_list';
      ViewResourceListAssigned.prototype.childView = ViewResourceListItemModal;
    }
  };
});

$__System.register('69', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewResourceListItemModal;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * Resource item View for Collection in modal.
             */
            'use strict';

            ViewResourceListItemModal = (function (_BaseViewListItem) {
                _inherits(ViewResourceListItemModal, _BaseViewListItem);

                function ViewResourceListItemModal() {
                    _classCallCheck(this, ViewResourceListItemModal);

                    _get(Object.getPrototypeOf(ViewResourceListItemModal.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewResourceListItemModal, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.inputport' (InputPort), 'options.assigned' (boolean; is this item assigned for a WorkflowRun), and 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._inputPort = options.inputport;
                        this._assigned = options.assigned;
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles double click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick() {
                        if (this._assigned) {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_UNASSIGN_RESOURCE, { inputport: this._inputPort, resource: this.model, workflow: this._workflow });
                        } else {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ASSIGN_RESOURCE, { inputport: this._inputPort, resource: this.model, workflow: this._workflow });
                        }
                    }
                }]);

                return ViewResourceListItemModal;
            })(BaseViewListItem);

            _export('default', ViewResourceListItemModal);

            ViewResourceListItemModal.prototype.template = '#template-modal_resource_list_item';
            ViewResourceListItemModal.prototype.tagName = 'tr';
            ViewResourceListItemModal.prototype.events = {
                'dblclick': '_handleDoubleClick'
            };
        }
    };
});

$__System.register('6a', ['14', '15', '17', '49', '69'], function (_export) {
  var _get, _inherits, _classCallCheck, ViewResourceList, ViewResourceListItemModal, ViewResourceListAvailable;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      ViewResourceList = _4['default'];
    }, function (_5) {
      ViewResourceListItemModal = _5['default'];
    }],
    execute: function () {

      /**
       * View for available Resources when assigning to InputPort.
       */
      'use strict';

      ViewResourceListAvailable = (function (_ViewResourceList) {
        _inherits(ViewResourceListAvailable, _ViewResourceList);

        function ViewResourceListAvailable() {
          _classCallCheck(this, ViewResourceListAvailable);

          _get(Object.getPrototypeOf(ViewResourceListAvailable.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewResourceListAvailable;
      })(ViewResourceList);

      _export('default', ViewResourceListAvailable);

      ViewResourceListAvailable.prototype.allowMultipleSelection = true;
      ViewResourceListAvailable.prototype.template = '#template-modal_resource_list';
      ViewResourceListAvailable.prototype.childView = ViewResourceListItemModal;
    }
  };
});

$__System.register('54', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewWorkflow;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }],
        execute: function () {

            /**
             * Workflow view.
             */
            'use strict';

            ViewWorkflow = (function (_Marionette$ItemView) {
                _inherits(ViewWorkflow, _Marionette$ItemView);

                function ViewWorkflow() {
                    _classCallCheck(this, ViewWorkflow);

                    _get(Object.getPrototypeOf(ViewWorkflow.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflow, [{
                    key: '_handleButtonRunWorkflow',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle button run workflow.
                     */
                    value: function _handleButtonRunWorkflow() {
                        if (!this.model.get('valid')) {
                            alert('The workflow must be valid prior to run.');
                        } else {
                            Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_CREATE_WORKFLOWRUN, { workflow: this.model });
                        }
                    }

                    /**
                     * Handle button delete workflow.
                     */
                }, {
                    key: '_handleButtonDeleteWorkflow',
                    value: function _handleButtonDeleteWorkflow() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOW_DELETE, { workflow: this.model });
                    }

                    /**
                     * Handle button edit workflow.
                     */
                }, {
                    key: '_handleButtonEditWorkflow',
                    value: function _handleButtonEditWorkflow() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_SELECTED, { workflow: this.model });
                    }

                    /**
                     * Handle button copy workflow.
                     */
                }, {
                    key: '_handleButtonCopyWorkflow',
                    value: function _handleButtonCopyWorkflow() {
                        alert('not yet implemented');
                    }

                    /**
                     * Handle save button.
                     */
                }, {
                    key: '_handleButtonSave',
                    value: function _handleButtonSave() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOW_SAVE, { workflow: this.model, fields: { name: this.ui.textName.val(), description: this.ui.textDescription.val() } });
                    }
                }]);

                return ViewWorkflow;
            })(Marionette.ItemView);

            _export('default', ViewWorkflow);

            ViewWorkflow.prototype.modelEvents = {
                'all': 'render'
            };
            ViewWorkflow.prototype.ui = {
                runWorkflowButton: '#button-run_workflow',
                deleteWorkflowButton: '#button-delete_workflow',
                copyWorkflowButton: '#button-copy_workflow',
                editWorkflowButton: '#button-edit_workflow',
                buttonSaveData: '#button-save_workflow_data',
                buttonSave: '#button-save_workflow',
                textName: '#text-workflow_name',
                textDescription: '#text-workflow_description'
            };
            ViewWorkflow.prototype.events = {
                'click @ui.runWorkflowButton': '_handleButtonRunWorkflow',
                'click @ui.deleteWorkflowButton': '_handleButtonDeleteWorkflow',
                'click @ui.editWorkflowButton': '_handleButtonEditWorkflow',
                'click @ui.copyWorkflowButton': '_handleButtonCopyWorkflow',
                'click @ui.buttonSaveData': '_handleButtonSave',
                'click @ui.buttonSave': '_handleButtonSave'
            };
            ViewWorkflow.prototype.template = '#template-main_workflow_individual';
        }
    };
});

$__System.register('6b', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewWorkflowListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * View for Workflow list.
             */
            'use strict';

            ViewWorkflowListItem = (function (_BaseViewListItem) {
                _inherits(ViewWorkflowListItem, _BaseViewListItem);

                function ViewWorkflowListItem() {
                    _classCallCheck(this, ViewWorkflowListItem);

                    _get(Object.getPrototypeOf(ViewWorkflowListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflowListItem, [{
                    key: '_handleClick',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles click.
                     */
                    value: function _handleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED, { workflow: this.model });
                    }

                    /**
                     * Handle double-click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_SELECTED, { workflow: this.model });
                    }
                }]);

                return ViewWorkflowListItem;
            })(BaseViewListItem);

            _export('default', ViewWorkflowListItem);

            ViewWorkflowListItem.prototype.template = '#template-main_workflow_list_item';
            ViewWorkflowListItem.prototype.tagName = 'tr';
            ViewWorkflowListItem.prototype.events = {
                'click': '_handleClick',
                'dblclick': '_handleDoubleClick'
            };
        }
    };
});

$__System.register('55', ['11', '14', '15', '16', '17', '20', '3e', '6b'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewList, ViewWorkflowListItem, ViewWorkflowList;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_e) {
            BaseViewList = _e['default'];
        }, function (_b) {
            ViewWorkflowListItem = _b['default'];
        }],
        execute: function () {

            /**
             * Workflow list view.
             */
            'use strict';

            ViewWorkflowList = (function (_BaseViewList) {
                _inherits(ViewWorkflowList, _BaseViewList);

                function ViewWorkflowList() {
                    _classCallCheck(this, ViewWorkflowList);

                    _get(Object.getPrototypeOf(ViewWorkflowList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflowList, [{
                    key: '_handleButtonNewWorkflow',
                    value: function _handleButtonNewWorkflow() {
                        var project = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOW_CREATE, { project: project });
                    }
                }]);

                return ViewWorkflowList;
            })(BaseViewList);

            _export('default', ViewWorkflowList);

            ViewWorkflowList.prototype.template = '#template-main_workflow_list';
            ViewWorkflowList.prototype.childView = ViewWorkflowListItem;
            ViewWorkflowList.prototype.behaviors = { Table: { 'table': '#table-workflows' } };
            ViewWorkflowList.prototype.ui = {
                newWorkflowButton: '#button-new_workflow'
            };
            ViewWorkflowList.prototype.events = {
                'click @ui.newWorkflowButton': '_handleButtonNewWorkflow'
            };
        }
    };
});

$__System.register('6c', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewWorkflowListImportItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * Workflow list item for importing into another Workflow.
             */
            'use strict';

            ViewWorkflowListImportItem = (function (_BaseViewListItem) {
                _inherits(ViewWorkflowListImportItem, _BaseViewListItem);

                function ViewWorkflowListImportItem() {
                    _classCallCheck(this, ViewWorkflowListImportItem);

                    _get(Object.getPrototypeOf(ViewWorkflowListImportItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflowListImportItem, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                }, {
                    key: '_handleButtonImportWorkflow',
                    value: function _handleButtonImportWorkflow() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_IMPORT_WORKFLOW, { origin: this.model, target: this._workflow });
                    }
                }]);

                return ViewWorkflowListImportItem;
            })(BaseViewListItem);

            _export('default', ViewWorkflowListImportItem);

            ViewWorkflowListImportItem.prototype.template = '#template-main_workflowbuilder_workflow_list_item_import';
            ViewWorkflowListImportItem.prototype.tagName = 'tr';
            ViewWorkflowListImportItem.prototype.ui = {
                buttonImportWorkflow: '#button-main_workflowbuilder_workflow_import'
            };
            ViewWorkflowListImportItem.prototype.events = {
                'click @ui.buttonImportWorkflow': '_handleButtonImportWorkflow',
                'dblclick': '_handleButtonImportWorkflow'
            };
        }
    };
});

$__System.register('6d', ['14', '15', '17', '1d'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseModel, Connection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * Connection.
       */
      'use strict';

      Connection = (function (_BaseModel) {
        _inherits(Connection, _BaseModel);

        function Connection() {
          _classCallCheck(this, Connection);

          _get(Object.getPrototypeOf(Connection.prototype), 'constructor', this).apply(this, arguments);
        }

        return Connection;
      })(BaseModel);

      _export('default', Connection);

      Connection.prototype.routeName = 'connections';
    }
  };
});

$__System.register('6e', ['14', '15', '16', '17', '33', '6d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, Connection, ConnectionCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_d) {
      Connection = _d['default'];
    }],
    execute: function () {

      /**
       * Collection of Connection models.
       */
      'use strict';

      ConnectionCollection = (function (_BaseCollection) {
        _inherits(ConnectionCollection, _BaseCollection);

        function ConnectionCollection() {
          _classCallCheck(this, ConnectionCollection);

          _get(Object.getPrototypeOf(ConnectionCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(ConnectionCollection, [{
          key: 'initialize',

          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = Connection;
            this._route = 'connections';
          }
        }]);

        return ConnectionCollection;
      })(BaseCollection);

      _export('default', ConnectionCollection);
    }
  };
});

$__System.register('6f', ['14', '15', '16', '17', '33', '70'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, WorkflowJob, WorkflowJobCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      WorkflowJob = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of WorkflowJob models.
       */
      'use strict';

      WorkflowJobCollection = (function (_BaseCollection) {
        _inherits(WorkflowJobCollection, _BaseCollection);

        function WorkflowJobCollection() {
          _classCallCheck(this, WorkflowJobCollection);

          _get(Object.getPrototypeOf(WorkflowJobCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(WorkflowJobCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = WorkflowJob;
            this._route = 'workflowjobs';
          }
        }]);

        return WorkflowJobCollection;
      })(BaseCollection);

      _export('default', WorkflowJobCollection);
    }
  };
});

$__System.register('56', ['14', '15', '16', '17', '43', '71', '72', '1d', '6e', '6f'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, WorkflowRunCollection, InputPortCollection, OutputPortCollection, BaseModel, ConnectionCollection, WorkflowJobCollection, Workflow;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            WorkflowRunCollection = _7['default'];
        }, function (_5) {
            InputPortCollection = _5['default'];
        }, function (_6) {
            OutputPortCollection = _6['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }, function (_e) {
            ConnectionCollection = _e['default'];
        }, function (_f) {
            WorkflowJobCollection = _f['default'];
        }],
        execute: function () {

            /**
             * Workflow.
             */
            'use strict';

            Workflow = (function (_BaseModel) {
                _inherits(Workflow, _BaseModel);

                function Workflow() {
                    _classCallCheck(this, Workflow);

                    _get(Object.getPrototypeOf(Workflow.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(Workflow, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize
                     *
                     * @param {object} options Backbone.Model options object; 'options.connections' (ConnectionCollection or associated Backbone.Collection raw-object representation), 'options.workflow_input_ports' (InputPortCollection or associated Backbone.Collection raw-object representation), 'options.workflow_output_ports' (OutputPortCollection or associated Backbone.Collection raw-object representation), 'options.workflow_jobs' (WorkflowJobCollection or associated Backbone.Collection raw-object representation), and 'options.workflow_runs' (WorkflowRunCollection or associated Backbone.Collection raw-object representation) must also be provided
                     */
                    value: function initialize(options) {
                        this.set('connections', new ConnectionCollection(options.connections));
                        this.set('workflow_input_ports', new InputPortCollection(options.workflow_input_ports));
                        this.set('workflow_output_ports', new OutputPortCollection(options.workflow_output_ports));
                        this.set('workflow_jobs', new WorkflowJobCollection(options.workflow_jobs));
                        this.set('workflow_runs', new WorkflowRunCollection(options.workflow_runs));
                    }

                    /**
                     * Returns defaults.
                     *
                     * @return {object} object holding default values
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return { description: null, name: null, created: null, updated: null, valid: false };
                    }

                    /**
                     * Override of Backbone.Model.parse. This will populate 'workflow_runs', 'workflow_jobs', 'workflow_input_ports', and 'workflow_output_ports' with the appropriate models.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        for (var i in response.workflow_runs) {
                            var modelClass = this.get('workflow_runs').model;
                            var model = new modelClass(response.workflow_runs[i]);
                            this.get('workflow_runs').add(model, { merge: true });
                        }
                        response.workflow_runs = this.get('workflow_runs');

                        for (var i in response.workflow_jobs) {
                            var modelClass = this.get('workflow_jobs').model;
                            var model = new modelClass(response.workflow_jobs[i]);
                            this.get('workflow_jobs').add(model, { merge: true });
                        }
                        response.workflow_jobs = this.get('workflow_jobs');

                        this.get('workflow_input_ports').set(response.workflow_input_ports, { merge: true, remove: true });
                        response.workflow_input_ports = this.get('workflow_input_ports');

                        for (var i in response.workflow_output_ports) {
                            var modelClass = this.get('workflow_output_ports').model;
                            var model = new modelClass(response.workflow_output_ports[i]);
                            this.get('workflow_output_ports').add(model, { merge: true });
                        }
                        response.workflow_output_ports = this.get('workflow_output_ports');

                        return response;
                    }
                }]);

                return Workflow;
            })(BaseModel);

            _export('default', Workflow);

            Workflow.prototype.routeName = 'workflows';
        }
    };
});

$__System.register('57', ['14', '15', '16', '17', '33', '56'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, Workflow, WorkflowCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      Workflow = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of Workflow models.
       */
      'use strict';

      WorkflowCollection = (function (_BaseCollection) {
        _inherits(WorkflowCollection, _BaseCollection);

        function WorkflowCollection() {
          _classCallCheck(this, WorkflowCollection);

          _get(Object.getPrototypeOf(WorkflowCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(WorkflowCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = Workflow;
            this._route = 'workflows';
          }
        }]);

        return WorkflowCollection;
      })(BaseCollection);

      _export('default', WorkflowCollection);
    }
  };
});

$__System.register('73', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewWorkflowJobGroup;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }],
        execute: function () {

            /**
             * WorkflowJobGroup view.
             */
            'use strict';

            ViewWorkflowJobGroup = (function (_Marionette$ItemView) {
                _inherits(ViewWorkflowJobGroup, _Marionette$ItemView);

                function ViewWorkflowJobGroup() {
                    _classCallCheck(this, ViewWorkflowJobGroup);

                    _get(Object.getPrototypeOf(ViewWorkflowJobGroup.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflowJobGroup, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) and 'options.workflowjobgroup' (WorkflowJobGroup) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                        /** @ignore */
                        this.model = options.workflowjobgroup;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle button delete.
                     */
                }, {
                    key: '_handleButtonDelete',
                    value: function _handleButtonDelete() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_DELETE, { workflowjobgroup: this.model, workflow: this._workflow });
                    }

                    /**
                     * Handle button ungroup.
                     *
                     * @todo this shouldn't be calling the workflowbuilder
                     */
                }, {
                    key: '_handleButtonUngroup',
                    value: function _handleButtonUngroup() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_UNGROUP_WORKFLOWJOBGROUP, { workflowjobgroup: this.model, workflow: this._workflow });
                    }

                    /**
                     * Handle button save.
                     */
                }, {
                    key: '_handleButtonSave',
                    value: function _handleButtonSave() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        this.model.set({ name: this.ui.textName.val() });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_SAVE, { workflowjobgroup: this.model });
                    }
                }]);

                return ViewWorkflowJobGroup;
            })(Marionette.ItemView);

            _export('default', ViewWorkflowJobGroup);

            ViewWorkflowJobGroup.prototype.template = '#template-main_workflowjobgroup';
            ViewWorkflowJobGroup.prototype.ui = {
                buttonSave: '#button-save_workflowjobgroup_data',
                buttonDelete: '#button-delete_workflowjobgroup',
                buttonUngroup: '#button-ungroup_workflowjobgroup',
                textName: '#text-workflowjobgroup_name'
            };
            ViewWorkflowJobGroup.prototype.events = {
                'click @ui.buttonSave': '_handleButtonSave',
                'click @ui.buttonDelete': '_handleButtonDelete',
                'click @ui.buttonUngroup': '_handleButtonUngroup'
            };
        }
    };
});

$__System.registerDynamic("74", [], false, function($__require, $__exports, $__module) {
  var _retrieveGlobal = $__System.get("@@global-helpers").prepareGlobal($__module.id, null, null);
  (function() {
    (function() {
      var Class;
      (function() {
        var initializing = false,
            fnTest = /xyz/.test(function() {
              window.postMessage("xyz");
            }) ? /\b_super\b/ : /.*/;
        Class = function() {};
        Class.extend = function(prop) {
          var _super = this.prototype;
          initializing = true;
          var prototype = new this();
          initializing = false;
          for (var name in prop) {
            prototype[name] = typeof prop[name] == "function" && typeof _super[name] == "function" && fnTest.test(prop[name]) ? (function(name, fn) {
              return function() {
                var tmp = this._super;
                this._super = _super[name];
                var ret = fn.apply(this, arguments);
                this._super = tmp;
                return ret;
              };
            })(name, prop[name]) : prop[name];
          }
          function Class() {
            if (!initializing && this.init)
              this.init.apply(this, arguments);
          }
          Class.prototype = prototype;
          Class.prototype.constructor = Class;
          Class.extend = arguments.callee;
          return Class;
        };
        return Class;
      })();
      (function() {
        function CustomEvent(event, params) {
          params = params || {
            bubbles: false,
            cancelable: false,
            detail: undefined
          };
          var evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(event, params.bubbles, params.cancelable, params.detail);
          return evt;
        }
        CustomEvent.prototype = window.Event.prototype;
        window.CustomEvent = CustomEvent;
      })();
      (function() {
        var lastTime = 0;
        var vendors = ['ms', 'moz', 'webkit', 'o'];
        for (var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
          window.requestAnimationFrame = window[vendors[x] + 'RequestAnimationFrame'];
          window.cancelAnimationFrame = window[vendors[x] + 'CancelAnimationFrame'] || window[vendors[x] + 'CancelRequestAnimationFrame'];
        }
        if (!window.requestAnimationFrame)
          window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            var id = window.setTimeout(function() {
              callback(currTime + timeToCall);
            }, timeToCall);
            lastTime = currTime + timeToCall;
            return id;
          };
        if (!window.cancelAnimationFrame)
          window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
          };
      }());
      (function() {
        if (!Array.isArray) {
          Array.isArray = function(arg) {
            return Object.prototype.toString.call(arg) === '[object Array]';
          };
        }
      }());
      var $isplainobject = function(obj) {
        if (typeof obj !== "object" || obj.nodeType || (obj !== null && obj === obj.window)) {
          return false;
        }
        if (obj.constructor && !Object.prototype.hasOwnProperty.call(obj.constructor.prototype, "isPrototypeOf")) {
          return false;
        }
        return true;
      };
      var $extend = function(destination) {
        var source,
            i,
            property;
        for (i = 1; i < arguments.length; i++) {
          source = arguments[i];
          for (property in source) {
            if (!source.hasOwnProperty(property))
              continue;
            if (source[property] && $isplainobject(source[property])) {
              if (!destination.hasOwnProperty(property))
                destination[property] = {};
              $extend(destination[property], source[property]);
            } else {
              destination[property] = source[property];
            }
          }
        }
        return destination;
      };
      var $each = function(obj, callback) {
        if (!obj || typeof obj !== "object")
          return;
        var i;
        if (Array.isArray(obj) || (typeof obj.length === 'number' && obj.length > 0 && (obj.length - 1) in obj)) {
          for (i = 0; i < obj.length; i++) {
            if (callback(i, obj[i]) === false)
              return;
          }
        } else {
          if (Object.keys) {
            var keys = Object.keys(obj);
            for (i = 0; i < keys.length; i++) {
              if (callback(keys[i], obj[keys[i]]) === false)
                return;
            }
          } else {
            for (i in obj) {
              if (!obj.hasOwnProperty(i))
                continue;
              if (callback(i, obj[i]) === false)
                return;
            }
          }
        }
      };
      var $trigger = function(el, event) {
        var e = document.createEvent('HTMLEvents');
        e.initEvent(event, true, true);
        el.dispatchEvent(e);
      };
      var $triggerc = function(el, event) {
        var e = new CustomEvent(event, {
          bubbles: true,
          cancelable: true
        });
        el.dispatchEvent(e);
      };
      var JSONEditor = function(element, options) {
        if (!(element instanceof Element)) {
          throw new Error('element should be an instance of Element');
        }
        options = $extend({}, JSONEditor.defaults.options, options || {});
        this.element = element;
        this.options = options;
        this.init();
      };
      JSONEditor.prototype = {
        constructor: JSONEditor,
        init: function() {
          var self = this;
          this.ready = false;
          var theme_class = JSONEditor.defaults.themes[this.options.theme || JSONEditor.defaults.theme];
          if (!theme_class)
            throw "Unknown theme " + (this.options.theme || JSONEditor.defaults.theme);
          this.schema = this.options.schema;
          this.theme = new theme_class();
          this.template = this.options.template;
          this.refs = this.options.refs || {};
          this.uuid = 0;
          this.__data = {};
          var icon_class = JSONEditor.defaults.iconlibs[this.options.iconlib || JSONEditor.defaults.iconlib];
          if (icon_class)
            this.iconlib = new icon_class();
          this.root_container = this.theme.getContainer();
          this.element.appendChild(this.root_container);
          this.translate = this.options.translate || JSONEditor.defaults.translate;
          this._loadExternalRefs(this.schema, function() {
            self._getDefinitions(self.schema);
            var validator_options = {};
            if (self.options.custom_validators) {
              validator_options.custom_validators = self.options.custom_validators;
            }
            self.validator = new JSONEditor.Validator(self, null, validator_options);
            var editor_class = self.getEditorClass(self.schema);
            self.root = self.createEditor(editor_class, {
              jsoneditor: self,
              schema: self.schema,
              required: true,
              container: self.root_container
            });
            self.root.preBuild();
            self.root.build();
            self.root.postBuild();
            if (self.options.startval)
              self.root.setValue(self.options.startval);
            self.validation_results = self.validator.validate(self.root.getValue());
            self.root.showValidationErrors(self.validation_results);
            self.ready = true;
            window.requestAnimationFrame(function() {
              if (!self.ready)
                return;
              self.validation_results = self.validator.validate(self.root.getValue());
              self.root.showValidationErrors(self.validation_results);
              self.trigger('ready');
              self.trigger('change');
            });
          });
        },
        getValue: function() {
          if (!this.ready)
            throw "JSON Editor not ready yet.  Listen for 'ready' event before getting the value";
          return this.root.getValue();
        },
        setValue: function(value) {
          if (!this.ready)
            throw "JSON Editor not ready yet.  Listen for 'ready' event before setting the value";
          this.root.setValue(value);
          return this;
        },
        validate: function(value) {
          if (!this.ready)
            throw "JSON Editor not ready yet.  Listen for 'ready' event before validating";
          if (arguments.length === 1) {
            return this.validator.validate(value);
          } else {
            return this.validation_results;
          }
        },
        destroy: function() {
          if (this.destroyed)
            return;
          if (!this.ready)
            return;
          this.schema = null;
          this.options = null;
          this.root.destroy();
          this.root = null;
          this.root_container = null;
          this.validator = null;
          this.validation_results = null;
          this.theme = null;
          this.iconlib = null;
          this.template = null;
          this.__data = null;
          this.ready = false;
          this.element.innerHTML = '';
          this.destroyed = true;
        },
        on: function(event, callback) {
          this.callbacks = this.callbacks || {};
          this.callbacks[event] = this.callbacks[event] || [];
          this.callbacks[event].push(callback);
          return this;
        },
        off: function(event, callback) {
          if (event && callback) {
            this.callbacks = this.callbacks || {};
            this.callbacks[event] = this.callbacks[event] || [];
            var newcallbacks = [];
            for (var i = 0; i < this.callbacks[event].length; i++) {
              if (this.callbacks[event][i] === callback)
                continue;
              newcallbacks.push(this.callbacks[event][i]);
            }
            this.callbacks[event] = newcallbacks;
          } else if (event) {
            this.callbacks = this.callbacks || {};
            this.callbacks[event] = [];
          } else {
            this.callbacks = {};
          }
          return this;
        },
        trigger: function(event) {
          if (this.callbacks && this.callbacks[event] && this.callbacks[event].length) {
            for (var i = 0; i < this.callbacks[event].length; i++) {
              this.callbacks[event][i]();
            }
          }
          return this;
        },
        setOption: function(option, value) {
          if (option === "show_errors") {
            this.options.show_errors = value;
            this.onChange();
          } else {
            throw "Option " + option + " must be set during instantiation and cannot be changed later";
          }
          return this;
        },
        getEditorClass: function(schema) {
          var classname;
          schema = this.expandSchema(schema);
          $each(JSONEditor.defaults.resolvers, function(i, resolver) {
            var tmp = resolver(schema);
            if (tmp) {
              if (JSONEditor.defaults.editors[tmp]) {
                classname = tmp;
                return false;
              }
            }
          });
          if (!classname)
            throw "Unknown editor for schema " + JSON.stringify(schema);
          if (!JSONEditor.defaults.editors[classname])
            throw "Unknown editor " + classname;
          return JSONEditor.defaults.editors[classname];
        },
        createEditor: function(editor_class, options) {
          options = $extend({}, editor_class.options || {}, options);
          return new editor_class(options);
        },
        onChange: function() {
          if (!this.ready)
            return;
          if (this.firing_change)
            return;
          this.firing_change = true;
          var self = this;
          window.requestAnimationFrame(function() {
            self.firing_change = false;
            if (!self.ready)
              return;
            self.validation_results = self.validator.validate(self.root.getValue());
            if (self.options.show_errors !== "never") {
              self.root.showValidationErrors(self.validation_results);
            } else {
              self.root.showValidationErrors([]);
            }
            self.trigger('change');
          });
          return this;
        },
        compileTemplate: function(template, name) {
          name = name || JSONEditor.defaults.template;
          var engine;
          if (typeof name === 'string') {
            if (!JSONEditor.defaults.templates[name])
              throw "Unknown template engine " + name;
            engine = JSONEditor.defaults.templates[name]();
            if (!engine)
              throw "Template engine " + name + " missing required library.";
          } else {
            engine = name;
          }
          if (!engine)
            throw "No template engine set";
          if (!engine.compile)
            throw "Invalid template engine set";
          return engine.compile(template);
        },
        _data: function(el, key, value) {
          if (arguments.length === 3) {
            var uuid;
            if (el.hasAttribute('data-jsoneditor-' + key)) {
              uuid = el.getAttribute('data-jsoneditor-' + key);
            } else {
              uuid = this.uuid++;
              el.setAttribute('data-jsoneditor-' + key, uuid);
            }
            this.__data[uuid] = value;
          } else {
            if (!el.hasAttribute('data-jsoneditor-' + key))
              return null;
            return this.__data[el.getAttribute('data-jsoneditor-' + key)];
          }
        },
        registerEditor: function(editor) {
          this.editors = this.editors || {};
          this.editors[editor.path] = editor;
          return this;
        },
        unregisterEditor: function(editor) {
          this.editors = this.editors || {};
          this.editors[editor.path] = null;
          return this;
        },
        getEditor: function(path) {
          if (!this.editors)
            return;
          return this.editors[path];
        },
        watch: function(path, callback) {
          this.watchlist = this.watchlist || {};
          this.watchlist[path] = this.watchlist[path] || [];
          this.watchlist[path].push(callback);
          return this;
        },
        unwatch: function(path, callback) {
          if (!this.watchlist || !this.watchlist[path])
            return this;
          if (!callback) {
            this.watchlist[path] = null;
            return this;
          }
          var newlist = [];
          for (var i = 0; i < this.watchlist[path].length; i++) {
            if (this.watchlist[path][i] === callback)
              continue;
            else
              newlist.push(this.watchlist[path][i]);
          }
          this.watchlist[path] = newlist.length ? newlist : null;
          return this;
        },
        notifyWatchers: function(path) {
          if (!this.watchlist || !this.watchlist[path])
            return this;
          for (var i = 0; i < this.watchlist[path].length; i++) {
            this.watchlist[path][i]();
          }
        },
        isEnabled: function() {
          return !this.root || this.root.isEnabled();
        },
        enable: function() {
          this.root.enable();
        },
        disable: function() {
          this.root.disable();
        },
        _getDefinitions: function(schema, path) {
          path = path || '#/definitions/';
          if (schema.definitions) {
            for (var i in schema.definitions) {
              if (!schema.definitions.hasOwnProperty(i))
                continue;
              this.refs[path + i] = schema.definitions[i];
              if (schema.definitions[i].definitions) {
                this._getDefinitions(schema.definitions[i], path + i + '/definitions/');
              }
            }
          }
        },
        _getExternalRefs: function(schema) {
          var refs = {};
          var merge_refs = function(newrefs) {
            for (var i in newrefs) {
              if (newrefs.hasOwnProperty(i)) {
                refs[i] = true;
              }
            }
          };
          if (schema.$ref && typeof schema.$ref !== "object" && schema.$ref.substr(0, 1) !== "#" && !this.refs[schema.$ref]) {
            refs[schema.$ref] = true;
          }
          for (var i in schema) {
            if (!schema.hasOwnProperty(i))
              continue;
            if (schema[i] && typeof schema[i] === "object" && Array.isArray(schema[i])) {
              for (var j = 0; j < schema[i].length; j++) {
                if (typeof schema[i][j] === "object") {
                  merge_refs(this._getExternalRefs(schema[i][j]));
                }
              }
            } else if (schema[i] && typeof schema[i] === "object") {
              merge_refs(this._getExternalRefs(schema[i]));
            }
          }
          return refs;
        },
        _loadExternalRefs: function(schema, callback) {
          var self = this;
          var refs = this._getExternalRefs(schema);
          var done = 0,
              waiting = 0,
              callback_fired = false;
          $each(refs, function(url) {
            if (self.refs[url])
              return;
            if (!self.options.ajax)
              throw "Must set ajax option to true to load external ref " + url;
            self.refs[url] = 'loading';
            waiting++;
            var r = new XMLHttpRequest();
            r.open("GET", url, true);
            r.onreadystatechange = function() {
              if (r.readyState != 4)
                return;
              if (r.status === 200) {
                var response;
                try {
                  response = JSON.parse(r.responseText);
                } catch (e) {
                  window.console.log(e);
                  throw "Failed to parse external ref " + url;
                }
                if (!response || typeof response !== "object")
                  throw "External ref does not contain a valid schema - " + url;
                self.refs[url] = response;
                self._loadExternalRefs(response, function() {
                  done++;
                  if (done >= waiting && !callback_fired) {
                    callback_fired = true;
                    callback();
                  }
                });
              } else {
                window.console.log(r);
                throw "Failed to fetch ref via ajax- " + url;
              }
            };
            r.send();
          });
          if (!waiting) {
            callback();
          }
        },
        expandRefs: function(schema) {
          schema = $extend({}, schema);
          while (schema.$ref) {
            var ref = schema.$ref;
            delete schema.$ref;
            if (!this.refs[ref])
              ref = decodeURIComponent(ref);
            schema = this.extendSchemas(schema, this.refs[ref]);
          }
          return schema;
        },
        expandSchema: function(schema) {
          var self = this;
          var extended = $extend({}, schema);
          var i;
          if (typeof schema.type === 'object') {
            if (Array.isArray(schema.type)) {
              $each(schema.type, function(key, value) {
                if (typeof value === 'object') {
                  schema.type[key] = self.expandSchema(value);
                }
              });
            } else {
              schema.type = self.expandSchema(schema.type);
            }
          }
          if (typeof schema.disallow === 'object') {
            if (Array.isArray(schema.disallow)) {
              $each(schema.disallow, function(key, value) {
                if (typeof value === 'object') {
                  schema.disallow[key] = self.expandSchema(value);
                }
              });
            } else {
              schema.disallow = self.expandSchema(schema.disallow);
            }
          }
          if (schema.anyOf) {
            $each(schema.anyOf, function(key, value) {
              schema.anyOf[key] = self.expandSchema(value);
            });
          }
          if (schema.dependencies) {
            $each(schema.dependencies, function(key, value) {
              if (typeof value === "object" && !(Array.isArray(value))) {
                schema.dependencies[key] = self.expandSchema(value);
              }
            });
          }
          if (schema.not) {
            schema.not = this.expandSchema(schema.not);
          }
          if (schema.allOf) {
            for (i = 0; i < schema.allOf.length; i++) {
              extended = this.extendSchemas(extended, this.expandSchema(schema.allOf[i]));
            }
            delete extended.allOf;
          }
          if (schema["extends"]) {
            if (!(Array.isArray(schema["extends"]))) {
              extended = this.extendSchemas(extended, this.expandSchema(schema["extends"]));
            } else {
              for (i = 0; i < schema["extends"].length; i++) {
                extended = this.extendSchemas(extended, this.expandSchema(schema["extends"][i]));
              }
            }
            delete extended["extends"];
          }
          if (schema.oneOf) {
            var tmp = $extend({}, extended);
            delete tmp.oneOf;
            for (i = 0; i < schema.oneOf.length; i++) {
              extended.oneOf[i] = this.extendSchemas(this.expandSchema(schema.oneOf[i]), tmp);
            }
          }
          return this.expandRefs(extended);
        },
        extendSchemas: function(obj1, obj2) {
          obj1 = $extend({}, obj1);
          obj2 = $extend({}, obj2);
          var self = this;
          var extended = {};
          $each(obj1, function(prop, val) {
            if (typeof obj2[prop] !== "undefined") {
              if (prop === 'required' && typeof val === "object" && Array.isArray(val)) {
                extended.required = val.concat(obj2[prop]).reduce(function(p, c) {
                  if (p.indexOf(c) < 0)
                    p.push(c);
                  return p;
                }, []);
              } else if (prop === 'type' && (typeof val === "string" || Array.isArray(val))) {
                if (typeof val === "string")
                  val = [val];
                if (typeof obj2.type === "string")
                  obj2.type = [obj2.type];
                extended.type = val.filter(function(n) {
                  return obj2.type.indexOf(n) !== -1;
                });
                if (extended.type.length === 1 && typeof extended.type[0] === "string") {
                  extended.type = extended.type[0];
                }
              } else if (typeof val === "object" && Array.isArray(val)) {
                extended[prop] = val.filter(function(n) {
                  return obj2[prop].indexOf(n) !== -1;
                });
              } else if (typeof val === "object" && val !== null) {
                extended[prop] = self.extendSchemas(val, obj2[prop]);
              } else {
                extended[prop] = val;
              }
            } else {
              extended[prop] = val;
            }
          });
          $each(obj2, function(prop, val) {
            if (typeof obj1[prop] === "undefined") {
              extended[prop] = val;
            }
          });
          return extended;
        }
      };
      JSONEditor.defaults = {
        themes: {},
        templates: {},
        iconlibs: {},
        editors: {},
        languages: {},
        resolvers: [],
        custom_validators: []
      };
      JSONEditor.Validator = Class.extend({
        init: function(jsoneditor, schema, options) {
          this.jsoneditor = jsoneditor;
          this.schema = schema || this.jsoneditor.schema;
          this.options = options || {};
          this.translate = this.jsoneditor.translate || JSONEditor.defaults.translate;
        },
        validate: function(value) {
          return this._validateSchema(this.schema, value);
        },
        _validateSchema: function(schema, value, path) {
          var self = this;
          var errors = [];
          var valid,
              i,
              j;
          var stringified = JSON.stringify(value);
          path = path || 'root';
          schema = $extend({}, this.jsoneditor.expandRefs(schema));
          if (schema.required && schema.required === true) {
            if (typeof value === "undefined") {
              errors.push({
                path: path,
                property: 'required',
                message: this.translate("error_notset")
              });
              return errors;
            }
          } else if (typeof value === "undefined") {
            if (this.jsoneditor.options.required_by_default) {
              errors.push({
                path: path,
                property: 'required',
                message: this.translate("error_notset")
              });
            } else {
              return errors;
            }
          }
          if (schema["enum"]) {
            valid = false;
            for (i = 0; i < schema["enum"].length; i++) {
              if (stringified === JSON.stringify(schema["enum"][i]))
                valid = true;
            }
            if (!valid) {
              errors.push({
                path: path,
                property: 'enum',
                message: this.translate("error_enum")
              });
            }
          }
          if (schema["extends"]) {
            for (i = 0; i < schema["extends"].length; i++) {
              errors = errors.concat(this._validateSchema(schema["extends"][i], value, path));
            }
          }
          if (schema.allOf) {
            for (i = 0; i < schema.allOf.length; i++) {
              errors = errors.concat(this._validateSchema(schema.allOf[i], value, path));
            }
          }
          if (schema.anyOf) {
            valid = false;
            for (i = 0; i < schema.anyOf.length; i++) {
              if (!this._validateSchema(schema.anyOf[i], value, path).length) {
                valid = true;
                break;
              }
            }
            if (!valid) {
              errors.push({
                path: path,
                property: 'anyOf',
                message: this.translate('error_anyOf')
              });
            }
          }
          if (schema.oneOf) {
            valid = 0;
            var oneof_errors = [];
            for (i = 0; i < schema.oneOf.length; i++) {
              var tmp = this._validateSchema(schema.oneOf[i], value, path);
              if (!tmp.length) {
                valid++;
              }
              for (j = 0; j < tmp.length; j++) {
                tmp[j].path = path + '.oneOf[' + i + ']' + tmp[j].path.substr(path.length);
              }
              oneof_errors = oneof_errors.concat(tmp);
            }
            if (valid !== 1) {
              errors.push({
                path: path,
                property: 'oneOf',
                message: this.translate('error_oneOf', [valid])
              });
              errors = errors.concat(oneof_errors);
            }
          }
          if (schema.not) {
            if (!this._validateSchema(schema.not, value, path).length) {
              errors.push({
                path: path,
                property: 'not',
                message: this.translate('error_not')
              });
            }
          }
          if (schema.type) {
            if (Array.isArray(schema.type)) {
              valid = false;
              for (i = 0; i < schema.type.length; i++) {
                if (this._checkType(schema.type[i], value)) {
                  valid = true;
                  break;
                }
              }
              if (!valid) {
                errors.push({
                  path: path,
                  property: 'type',
                  message: this.translate('error_type_union')
                });
              }
            } else {
              if (!this._checkType(schema.type, value)) {
                errors.push({
                  path: path,
                  property: 'type',
                  message: this.translate('error_type', [schema.type])
                });
              }
            }
          }
          if (schema.disallow) {
            if (Array.isArray(schema.disallow)) {
              valid = true;
              for (i = 0; i < schema.disallow.length; i++) {
                if (this._checkType(schema.disallow[i], value)) {
                  valid = false;
                  break;
                }
              }
              if (!valid) {
                errors.push({
                  path: path,
                  property: 'disallow',
                  message: this.translate('error_disallow_union')
                });
              }
            } else {
              if (this._checkType(schema.disallow, value)) {
                errors.push({
                  path: path,
                  property: 'disallow',
                  message: this.translate('error_disallow', [schema.disallow])
                });
              }
            }
          }
          if (typeof value === "number") {
            if (schema.multipleOf || schema.divisibleBy) {
              var divisor = schema.multipleOf || schema.divisibleBy;
              valid = (value / divisor === Math.floor(value / divisor));
              if (window.math) {
                valid = window.math.mod(window.math.bignumber(value), window.math.bignumber(divisor)).equals(0);
              } else if (window.Decimal) {
                valid = (new window.Decimal(value)).mod(new window.Decimal(divisor)).equals(0);
              }
              if (!valid) {
                errors.push({
                  path: path,
                  property: schema.multipleOf ? 'multipleOf' : 'divisibleBy',
                  message: this.translate('error_multipleOf', [divisor])
                });
              }
            }
            if (schema.hasOwnProperty('maximum')) {
              valid = schema.exclusiveMaximum ? (value < schema.maximum) : (value <= schema.maximum);
              if (window.math) {
                valid = window.math[schema.exclusiveMaximum ? 'smaller' : 'smallerEq'](window.math.bignumber(value), window.math.bignumber(schema.maximum));
              } else if (window.Decimal) {
                valid = (new window.Decimal(value))[schema.exclusiveMaximum ? 'lt' : 'lte'](new window.Decimal(schema.maximum));
              }
              if (!valid) {
                errors.push({
                  path: path,
                  property: 'maximum',
                  message: this.translate((schema.exclusiveMaximum ? 'error_maximum_excl' : 'error_maximum_incl'), [schema.maximum])
                });
              }
            }
            if (schema.hasOwnProperty('minimum')) {
              valid = schema.exclusiveMinimum ? (value > schema.minimum) : (value >= schema.minimum);
              if (window.math) {
                valid = window.math[schema.exclusiveMinimum ? 'larger' : 'largerEq'](window.math.bignumber(value), window.math.bignumber(schema.minimum));
              } else if (window.Decimal) {
                valid = (new window.Decimal(value))[schema.exclusiveMinimum ? 'gt' : 'gte'](new window.Decimal(schema.minimum));
              }
              if (!valid) {
                errors.push({
                  path: path,
                  property: 'minimum',
                  message: this.translate((schema.exclusiveMinimum ? 'error_minimum_excl' : 'error_minimum_incl'), [schema.minimum])
                });
              }
            }
          } else if (typeof value === "string") {
            if (schema.maxLength) {
              if ((value + "").length > schema.maxLength) {
                errors.push({
                  path: path,
                  property: 'maxLength',
                  message: this.translate('error_maxLength', [schema.maxLength])
                });
              }
            }
            if (schema.minLength) {
              if ((value + "").length < schema.minLength) {
                errors.push({
                  path: path,
                  property: 'minLength',
                  message: this.translate((schema.minLength === 1 ? 'error_notempty' : 'error_minLength'), [schema.minLength])
                });
              }
            }
            if (schema.pattern) {
              if (!(new RegExp(schema.pattern)).test(value)) {
                errors.push({
                  path: path,
                  property: 'pattern',
                  message: this.translate('error_pattern', [schema.pattern])
                });
              }
            }
          } else if (typeof value === "object" && value !== null && Array.isArray(value)) {
            if (schema.items) {
              if (Array.isArray(schema.items)) {
                for (i = 0; i < value.length; i++) {
                  if (schema.items[i]) {
                    errors = errors.concat(this._validateSchema(schema.items[i], value[i], path + '.' + i));
                  } else if (schema.additionalItems === true) {
                    break;
                  } else if (schema.additionalItems) {
                    errors = errors.concat(this._validateSchema(schema.additionalItems, value[i], path + '.' + i));
                  } else if (schema.additionalItems === false) {
                    errors.push({
                      path: path,
                      property: 'additionalItems',
                      message: this.translate('error_additionalItems')
                    });
                    break;
                  } else {
                    break;
                  }
                }
              } else {
                for (i = 0; i < value.length; i++) {
                  errors = errors.concat(this._validateSchema(schema.items, value[i], path + '.' + i));
                }
              }
            }
            if (schema.maxItems) {
              if (value.length > schema.maxItems) {
                errors.push({
                  path: path,
                  property: 'maxItems',
                  message: this.translate('error_maxItems', [schema.maxItems])
                });
              }
            }
            if (schema.minItems) {
              if (value.length < schema.minItems) {
                errors.push({
                  path: path,
                  property: 'minItems',
                  message: this.translate('error_minItems', [schema.minItems])
                });
              }
            }
            if (schema.uniqueItems) {
              var seen = {};
              for (i = 0; i < value.length; i++) {
                valid = JSON.stringify(value[i]);
                if (seen[valid]) {
                  errors.push({
                    path: path,
                    property: 'uniqueItems',
                    message: this.translate('error_uniqueItems')
                  });
                  break;
                }
                seen[valid] = true;
              }
            }
          } else if (typeof value === "object" && value !== null) {
            if (schema.maxProperties) {
              valid = 0;
              for (i in value) {
                if (!value.hasOwnProperty(i))
                  continue;
                valid++;
              }
              if (valid > schema.maxProperties) {
                errors.push({
                  path: path,
                  property: 'maxProperties',
                  message: this.translate('error_maxProperties', [schema.maxProperties])
                });
              }
            }
            if (schema.minProperties) {
              valid = 0;
              for (i in value) {
                if (!value.hasOwnProperty(i))
                  continue;
                valid++;
              }
              if (valid < schema.minProperties) {
                errors.push({
                  path: path,
                  property: 'minProperties',
                  message: this.translate('error_minProperties', [schema.minProperties])
                });
              }
            }
            if (schema.required && Array.isArray(schema.required)) {
              for (i = 0; i < schema.required.length; i++) {
                if (typeof value[schema.required[i]] === "undefined") {
                  errors.push({
                    path: path,
                    property: 'required',
                    message: this.translate('error_required', [schema.required[i]])
                  });
                }
              }
            }
            var validated_properties = {};
            if (schema.properties) {
              for (i in schema.properties) {
                if (!schema.properties.hasOwnProperty(i))
                  continue;
                validated_properties[i] = true;
                errors = errors.concat(this._validateSchema(schema.properties[i], value[i], path + '.' + i));
              }
            }
            if (schema.patternProperties) {
              for (i in schema.patternProperties) {
                if (!schema.patternProperties.hasOwnProperty(i))
                  continue;
                var regex = new RegExp(i);
                for (j in value) {
                  if (!value.hasOwnProperty(j))
                    continue;
                  if (regex.test(j)) {
                    validated_properties[j] = true;
                    errors = errors.concat(this._validateSchema(schema.patternProperties[i], value[j], path + '.' + j));
                  }
                }
              }
            }
            if (typeof schema.additionalProperties === "undefined" && this.jsoneditor.options.no_additional_properties && !schema.oneOf && !schema.anyOf) {
              schema.additionalProperties = false;
            }
            if (typeof schema.additionalProperties !== "undefined") {
              for (i in value) {
                if (!value.hasOwnProperty(i))
                  continue;
                if (!validated_properties[i]) {
                  if (!schema.additionalProperties) {
                    errors.push({
                      path: path,
                      property: 'additionalProperties',
                      message: this.translate('error_additional_properties', [i])
                    });
                    break;
                  } else if (schema.additionalProperties === true) {
                    break;
                  } else {
                    errors = errors.concat(this._validateSchema(schema.additionalProperties, value[i], path + '.' + i));
                  }
                }
              }
            }
            if (schema.dependencies) {
              for (i in schema.dependencies) {
                if (!schema.dependencies.hasOwnProperty(i))
                  continue;
                if (typeof value[i] === "undefined")
                  continue;
                if (Array.isArray(schema.dependencies[i])) {
                  for (j = 0; j < schema.dependencies[i].length; j++) {
                    if (typeof value[schema.dependencies[i][j]] === "undefined") {
                      errors.push({
                        path: path,
                        property: 'dependencies',
                        message: this.translate('error_dependency', [schema.dependencies[i][j]])
                      });
                    }
                  }
                } else {
                  errors = errors.concat(this._validateSchema(schema.dependencies[i], value, path));
                }
              }
            }
          }
          $each(JSONEditor.defaults.custom_validators, function(i, validator) {
            errors = errors.concat(validator.call(self, schema, value, path));
          });
          if (this.options.custom_validators) {
            $each(this.options.custom_validators, function(i, validator) {
              errors = errors.concat(validator.call(self, schema, value, path));
            });
          }
          return errors;
        },
        _checkType: function(type, value) {
          if (typeof type === "string") {
            if (type === "string")
              return typeof value === "string";
            else if (type === "number")
              return typeof value === "number";
            else if (type === "integer")
              return typeof value === "number" && value === Math.floor(value);
            else if (type === "boolean")
              return typeof value === "boolean";
            else if (type === "array")
              return Array.isArray(value);
            else if (type === "object")
              return value !== null && !(Array.isArray(value)) && typeof value === "object";
            else if (type === "null")
              return value === null;
            else
              return true;
          } else {
            return !this._validateSchema(type, value).length;
          }
        }
      });
      JSONEditor.AbstractEditor = Class.extend({
        onChildEditorChange: function(editor) {
          this.onChange(true);
        },
        notify: function() {
          this.jsoneditor.notifyWatchers(this.path);
        },
        change: function() {
          if (this.parent)
            this.parent.onChildEditorChange(this);
          else
            this.jsoneditor.onChange();
        },
        onChange: function(bubble) {
          this.notify();
          if (this.watch_listener)
            this.watch_listener();
          if (bubble)
            this.change();
        },
        register: function() {
          this.jsoneditor.registerEditor(this);
          this.onChange();
        },
        unregister: function() {
          if (!this.jsoneditor)
            return;
          this.jsoneditor.unregisterEditor(this);
        },
        getNumColumns: function() {
          return 12;
        },
        init: function(options) {
          this.jsoneditor = options.jsoneditor;
          this.theme = this.jsoneditor.theme;
          this.template_engine = this.jsoneditor.template;
          this.iconlib = this.jsoneditor.iconlib;
          this.translate = this.jsoneditor.translate || JSONEditor.defaults.translate;
          this.original_schema = options.schema;
          this.schema = this.jsoneditor.expandSchema(this.original_schema);
          this.options = $extend({}, (this.options || {}), (options.schema.options || {}), options);
          if (!options.path && !this.schema.id)
            this.schema.id = 'root';
          this.path = options.path || 'root';
          this.formname = options.formname || this.path.replace(/\.([^.]+)/g, '[$1]');
          if (this.jsoneditor.options.form_name_root)
            this.formname = this.formname.replace(/^root\[/, this.jsoneditor.options.form_name_root + '[');
          this.key = this.path.split('.').pop();
          this.parent = options.parent;
          this.link_watchers = [];
          if (options.container)
            this.setContainer(options.container);
        },
        setContainer: function(container) {
          this.container = container;
          if (this.schema.id)
            this.container.setAttribute('data-schemaid', this.schema.id);
          if (this.schema.type && typeof this.schema.type === "string")
            this.container.setAttribute('data-schematype', this.schema.type);
          this.container.setAttribute('data-schemapath', this.path);
        },
        preBuild: function() {},
        build: function() {},
        postBuild: function() {
          this.setupWatchListeners();
          this.addLinks();
          this.setValue(this.getDefault(), true);
          this.updateHeaderText();
          this.register();
          this.onWatchedFieldChange();
        },
        setupWatchListeners: function() {
          var self = this;
          this.watched = {};
          if (this.schema.vars)
            this.schema.watch = this.schema.vars;
          this.watched_values = {};
          this.watch_listener = function() {
            if (self.refreshWatchedFieldValues()) {
              self.onWatchedFieldChange();
            }
          };
          this.register();
          if (this.schema.hasOwnProperty('watch')) {
            var path,
                path_parts,
                first,
                root,
                adjusted_path;
            for (var name in this.schema.watch) {
              if (!this.schema.watch.hasOwnProperty(name))
                continue;
              path = this.schema.watch[name];
              if (Array.isArray(path)) {
                path_parts = [path[0]].concat(path[1].split('.'));
              } else {
                path_parts = path.split('.');
                if (!self.theme.closest(self.container, '[data-schemaid="' + path_parts[0] + '"]'))
                  path_parts.unshift('#');
              }
              first = path_parts.shift();
              if (first === '#')
                first = self.jsoneditor.schema.id || 'root';
              root = self.theme.closest(self.container, '[data-schemaid="' + first + '"]');
              if (!root)
                throw "Could not find ancestor node with id " + first;
              adjusted_path = root.getAttribute('data-schemapath') + '.' + path_parts.join('.');
              self.jsoneditor.watch(adjusted_path, self.watch_listener);
              self.watched[name] = adjusted_path;
            }
          }
          if (this.schema.headerTemplate) {
            this.header_template = this.jsoneditor.compileTemplate(this.schema.headerTemplate, this.template_engine);
          }
        },
        addLinks: function() {
          if (!this.no_link_holder) {
            this.link_holder = this.theme.getLinksHolder();
            this.container.appendChild(this.link_holder);
            if (this.schema.links) {
              for (var i = 0; i < this.schema.links.length; i++) {
                this.addLink(this.getLink(this.schema.links[i]));
              }
            }
          }
        },
        getButton: function(text, icon, title) {
          var btnClass = 'json-editor-btn-' + icon;
          if (!this.iconlib)
            icon = null;
          else
            icon = this.iconlib.getIcon(icon);
          if (!icon && title) {
            text = title;
            title = null;
          }
          var btn = this.theme.getButton(text, icon, title);
          btn.className += ' ' + btnClass + ' ';
          return btn;
        },
        setButtonText: function(button, text, icon, title) {
          if (!this.iconlib)
            icon = null;
          else
            icon = this.iconlib.getIcon(icon);
          if (!icon && title) {
            text = title;
            title = null;
          }
          return this.theme.setButtonText(button, text, icon, title);
        },
        addLink: function(link) {
          if (this.link_holder)
            this.link_holder.appendChild(link);
        },
        getLink: function(data) {
          var holder,
              link;
          var mime = data.mediaType || 'application/javascript';
          var type = mime.split('/')[0];
          var href = this.jsoneditor.compileTemplate(data.href, this.template_engine);
          var download = null;
          if (data.download)
            download = data.download;
          if (download && download !== true) {
            download = this.jsoneditor.compileTemplate(download, this.template_engine);
          }
          if (type === 'image') {
            holder = this.theme.getBlockLinkHolder();
            link = document.createElement('a');
            link.setAttribute('target', '_blank');
            var image = document.createElement('img');
            this.theme.createImageLink(holder, link, image);
            this.link_watchers.push(function(vars) {
              var url = href(vars);
              link.setAttribute('href', url);
              link.setAttribute('title', data.rel || url);
              image.setAttribute('src', url);
            });
          } else if (['audio', 'video'].indexOf(type) >= 0) {
            holder = this.theme.getBlockLinkHolder();
            link = this.theme.getBlockLink();
            link.setAttribute('target', '_blank');
            var media = document.createElement(type);
            media.setAttribute('controls', 'controls');
            this.theme.createMediaLink(holder, link, media);
            this.link_watchers.push(function(vars) {
              var url = href(vars);
              link.setAttribute('href', url);
              link.textContent = data.rel || url;
              media.setAttribute('src', url);
            });
          } else {
            link = holder = this.theme.getBlockLink();
            holder.setAttribute('target', '_blank');
            holder.textContent = data.rel;
            this.link_watchers.push(function(vars) {
              var url = href(vars);
              holder.setAttribute('href', url);
              holder.textContent = data.rel || url;
            });
          }
          if (download && link) {
            if (download === true) {
              link.setAttribute('download', '');
            } else {
              this.link_watchers.push(function(vars) {
                link.setAttribute('download', download(vars));
              });
            }
          }
          return holder;
        },
        refreshWatchedFieldValues: function() {
          if (!this.watched_values)
            return;
          var watched = {};
          var changed = false;
          var self = this;
          if (this.watched) {
            var val,
                editor;
            for (var name in this.watched) {
              if (!this.watched.hasOwnProperty(name))
                continue;
              editor = self.jsoneditor.getEditor(this.watched[name]);
              val = editor ? editor.getValue() : null;
              if (self.watched_values[name] !== val)
                changed = true;
              watched[name] = val;
            }
          }
          watched.self = this.getValue();
          if (this.watched_values.self !== watched.self)
            changed = true;
          this.watched_values = watched;
          return changed;
        },
        getWatchedFieldValues: function() {
          return this.watched_values;
        },
        updateHeaderText: function() {
          if (this.header) {
            if (this.header.children.length) {
              for (var i = 0; i < this.header.childNodes.length; i++) {
                if (this.header.childNodes[i].nodeType === 3) {
                  this.header.childNodes[i].nodeValue = this.getHeaderText();
                  break;
                }
              }
            } else {
              this.header.textContent = this.getHeaderText();
            }
          }
        },
        getHeaderText: function(title_only) {
          if (this.header_text)
            return this.header_text;
          else if (title_only)
            return this.schema.title;
          else
            return this.getTitle();
        },
        onWatchedFieldChange: function() {
          var vars;
          if (this.header_template) {
            vars = $extend(this.getWatchedFieldValues(), {
              key: this.key,
              i: this.key,
              i0: (this.key * 1),
              i1: (this.key * 1 + 1),
              title: this.getTitle()
            });
            var header_text = this.header_template(vars);
            if (header_text !== this.header_text) {
              this.header_text = header_text;
              this.updateHeaderText();
              this.notify();
            }
          }
          if (this.link_watchers.length) {
            vars = this.getWatchedFieldValues();
            for (var i = 0; i < this.link_watchers.length; i++) {
              this.link_watchers[i](vars);
            }
          }
        },
        setValue: function(value) {
          this.value = value;
        },
        getValue: function() {
          return this.value;
        },
        refreshValue: function() {},
        getChildEditors: function() {
          return false;
        },
        destroy: function() {
          var self = this;
          this.unregister(this);
          $each(this.watched, function(name, adjusted_path) {
            self.jsoneditor.unwatch(adjusted_path, self.watch_listener);
          });
          this.watched = null;
          this.watched_values = null;
          this.watch_listener = null;
          this.header_text = null;
          this.header_template = null;
          this.value = null;
          if (this.container && this.container.parentNode)
            this.container.parentNode.removeChild(this.container);
          this.container = null;
          this.jsoneditor = null;
          this.schema = null;
          this.path = null;
          this.key = null;
          this.parent = null;
        },
        getDefault: function() {
          if (this.schema["default"])
            return this.schema["default"];
          if (this.schema["enum"])
            return this.schema["enum"][0];
          var type = this.schema.type || this.schema.oneOf;
          if (type && Array.isArray(type))
            type = type[0];
          if (type && typeof type === "object")
            type = type.type;
          if (type && Array.isArray(type))
            type = type[0];
          if (typeof type === "string") {
            if (type === "number")
              return 0.0;
            if (type === "boolean")
              return false;
            if (type === "integer")
              return 0;
            if (type === "string")
              return "";
            if (type === "object")
              return {};
            if (type === "array")
              return [];
          }
          return null;
        },
        getTitle: function() {
          return this.schema.title || this.key;
        },
        enable: function() {
          this.disabled = false;
        },
        disable: function() {
          this.disabled = true;
        },
        isEnabled: function() {
          return !this.disabled;
        },
        isRequired: function() {
          if (typeof this.schema.required === "boolean")
            return this.schema.required;
          else if (this.parent && this.parent.schema && Array.isArray(this.parent.schema.required))
            return this.parent.schema.required.indexOf(this.key) > -1;
          else if (this.jsoneditor.options.required_by_default)
            return true;
          else
            return false;
        },
        getDisplayText: function(arr) {
          var disp = [];
          var used = {};
          $each(arr, function(i, el) {
            if (el.title) {
              used[el.title] = used[el.title] || 0;
              used[el.title]++;
            }
            if (el.description) {
              used[el.description] = used[el.description] || 0;
              used[el.description]++;
            }
            if (el.format) {
              used[el.format] = used[el.format] || 0;
              used[el.format]++;
            }
            if (el.type) {
              used[el.type] = used[el.type] || 0;
              used[el.type]++;
            }
          });
          $each(arr, function(i, el) {
            var name;
            if (typeof el === "string")
              name = el;
            else if (el.title && used[el.title] <= 1)
              name = el.title;
            else if (el.format && used[el.format] <= 1)
              name = el.format;
            else if (el.type && used[el.type] <= 1)
              name = el.type;
            else if (el.description && used[el.description] <= 1)
              name = el.descripton;
            else if (el.title)
              name = el.title;
            else if (el.format)
              name = el.format;
            else if (el.type)
              name = el.type;
            else if (el.description)
              name = el.description;
            else if (JSON.stringify(el).length < 50)
              name = JSON.stringify(el);
            else
              name = "type";
            disp.push(name);
          });
          var inc = {};
          $each(disp, function(i, name) {
            inc[name] = inc[name] || 0;
            inc[name]++;
            if (used[name] > 1)
              disp[i] = name + " " + inc[name];
          });
          return disp;
        },
        getOption: function(key) {
          try {
            throw "getOption is deprecated";
          } catch (e) {
            window.console.error(e);
          }
          return this.options[key];
        },
        showValidationErrors: function(errors) {}
      });
      JSONEditor.defaults.editors["null"] = JSONEditor.AbstractEditor.extend({
        getValue: function() {
          return null;
        },
        setValue: function() {
          this.onChange();
        },
        getNumColumns: function() {
          return 2;
        }
      });
      JSONEditor.defaults.editors.string = JSONEditor.AbstractEditor.extend({
        register: function() {
          this._super();
          if (!this.input)
            return;
          this.input.setAttribute('name', this.formname);
        },
        unregister: function() {
          this._super();
          if (!this.input)
            return;
          this.input.removeAttribute('name');
        },
        setValue: function(value, initial, from_template) {
          var self = this;
          if (this.template && !from_template) {
            return;
          }
          if (value === null || typeof value === 'undefined')
            value = "";
          else if (typeof value === "object")
            value = JSON.stringify(value);
          else if (typeof value !== "string")
            value = "" + value;
          if (value === this.serialized)
            return;
          var sanitized = this.sanitize(value);
          if (this.input.value === sanitized) {
            return;
          }
          this.input.value = sanitized;
          if (this.sceditor_instance) {
            this.sceditor_instance.val(sanitized);
          } else if (this.epiceditor) {
            this.epiceditor.importFile(null, sanitized);
          } else if (this.ace_editor) {
            this.ace_editor.setValue(sanitized);
          }
          var changed = from_template || this.getValue() !== value;
          this.refreshValue();
          if (initial)
            this.is_dirty = false;
          else if (this.jsoneditor.options.show_errors === "change")
            this.is_dirty = true;
          if (this.adjust_height)
            this.adjust_height(this.input);
          this.onChange(changed);
        },
        getNumColumns: function() {
          var min = Math.ceil(Math.max(this.getTitle().length, this.schema.maxLength || 0, this.schema.minLength || 0) / 5);
          var num;
          if (this.input_type === 'textarea')
            num = 6;
          else if (['text', 'email'].indexOf(this.input_type) >= 0)
            num = 4;
          else
            num = 2;
          return Math.min(12, Math.max(min, num));
        },
        build: function() {
          var self = this,
              i;
          if (!this.options.compact)
            this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          if (this.schema.description)
            this.description = this.theme.getFormInputDescription(this.schema.description);
          this.format = this.schema.format;
          if (!this.format && this.schema.media && this.schema.media.type) {
            this.format = this.schema.media.type.replace(/(^(application|text)\/(x-)?(script\.)?)|(-source$)/g, '');
          }
          if (!this.format && this.options.default_format) {
            this.format = this.options.default_format;
          }
          if (this.options.format) {
            this.format = this.options.format;
          }
          if (this.format) {
            if (this.format === 'textarea') {
              this.input_type = 'textarea';
              this.input = this.theme.getTextareaInput();
            } else if (this.format === 'range') {
              this.input_type = 'range';
              var min = this.schema.minimum || 0;
              var max = this.schema.maximum || Math.max(100, min + 1);
              var step = 1;
              if (this.schema.multipleOf) {
                if (min % this.schema.multipleOf)
                  min = Math.ceil(min / this.schema.multipleOf) * this.schema.multipleOf;
                if (max % this.schema.multipleOf)
                  max = Math.floor(max / this.schema.multipleOf) * this.schema.multipleOf;
                step = this.schema.multipleOf;
              }
              this.input = this.theme.getRangeInput(min, max, step);
            } else if (['actionscript', 'batchfile', 'bbcode', 'c', 'c++', 'cpp', 'coffee', 'csharp', 'css', 'dart', 'django', 'ejs', 'erlang', 'golang', 'groovy', 'handlebars', 'haskell', 'haxe', 'html', 'ini', 'jade', 'java', 'javascript', 'json', 'less', 'lisp', 'lua', 'makefile', 'markdown', 'matlab', 'mysql', 'objectivec', 'pascal', 'perl', 'pgsql', 'php', 'python', 'r', 'ruby', 'sass', 'scala', 'scss', 'smarty', 'sql', 'stylus', 'svg', 'twig', 'vbscript', 'xml', 'yaml'].indexOf(this.format) >= 0) {
              this.input_type = this.format;
              this.source_code = true;
              this.input = this.theme.getTextareaInput();
            } else {
              this.input_type = this.format;
              this.input = this.theme.getFormInputField(this.input_type);
            }
          } else {
            this.input_type = 'text';
            this.input = this.theme.getFormInputField(this.input_type);
          }
          if (typeof this.schema.maxLength !== "undefined")
            this.input.setAttribute('maxlength', this.schema.maxLength);
          if (typeof this.schema.pattern !== "undefined")
            this.input.setAttribute('pattern', this.schema.pattern);
          else if (typeof this.schema.minLength !== "undefined")
            this.input.setAttribute('pattern', '.{' + this.schema.minLength + ',}');
          if (this.options.compact) {
            this.container.className += ' compact';
          } else {
            if (this.options.input_width)
              this.input.style.width = this.options.input_width;
          }
          if (this.schema.readOnly || this.schema.readonly || this.schema.template) {
            this.always_disabled = true;
            this.input.disabled = true;
          }
          this.input.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (self.schema.template) {
              this.value = self.value;
              return;
            }
            var val = this.value;
            var sanitized = self.sanitize(val);
            if (val !== sanitized) {
              this.value = sanitized;
            }
            self.is_dirty = true;
            self.refreshValue();
            self.onChange(true);
          });
          if (this.options.input_height)
            this.input.style.height = this.options.input_height;
          if (this.options.expand_height) {
            this.adjust_height = function(el) {
              if (!el)
                return;
              var i,
                  ch = el.offsetHeight;
              if (el.offsetHeight < el.scrollHeight) {
                i = 0;
                while (el.offsetHeight < el.scrollHeight + 3) {
                  if (i > 100)
                    break;
                  i++;
                  ch++;
                  el.style.height = ch + 'px';
                }
              } else {
                i = 0;
                while (el.offsetHeight >= el.scrollHeight + 3) {
                  if (i > 100)
                    break;
                  i++;
                  ch--;
                  el.style.height = ch + 'px';
                }
                el.style.height = (ch + 1) + 'px';
              }
            };
            this.input.addEventListener('keyup', function(e) {
              self.adjust_height(this);
            });
            this.input.addEventListener('change', function(e) {
              self.adjust_height(this);
            });
            this.adjust_height();
          }
          if (this.format)
            this.input.setAttribute('data-schemaformat', this.format);
          this.control = this.theme.getFormControl(this.label, this.input, this.description);
          this.container.appendChild(this.control);
          window.requestAnimationFrame(function() {
            if (self.input.parentNode)
              self.afterInputReady();
            if (self.adjust_height)
              self.adjust_height(self.input);
          });
          if (this.schema.template) {
            this.template = this.jsoneditor.compileTemplate(this.schema.template, this.template_engine);
            this.refreshValue();
          } else {
            this.refreshValue();
          }
        },
        enable: function() {
          if (!this.always_disabled) {
            this.input.disabled = false;
          }
          this._super();
        },
        disable: function() {
          this.input.disabled = true;
          this._super();
        },
        afterInputReady: function() {
          var self = this,
              options;
          if (this.source_code) {
            if (this.options.wysiwyg && ['html', 'bbcode'].indexOf(this.input_type) >= 0 && window.jQuery && window.jQuery.fn && window.jQuery.fn.sceditor) {
              options = $extend({}, {
                plugins: self.input_type === 'html' ? 'xhtml' : 'bbcode',
                emoticonsEnabled: false,
                width: '100%',
                height: 300
              }, JSONEditor.plugins.sceditor, self.options.sceditor_options || {});
              window.jQuery(self.input).sceditor(options);
              self.sceditor_instance = window.jQuery(self.input).sceditor('instance');
              self.sceditor_instance.blur(function() {
                var val = window.jQuery("<div>" + self.sceditor_instance.val() + "</div>");
                window.jQuery('#sceditor-start-marker,#sceditor-end-marker,.sceditor-nlf', val).remove();
                self.input.value = val.html();
                self.value = self.input.value;
                self.is_dirty = true;
                self.onChange(true);
              });
            } else if (this.input_type === 'markdown' && window.EpicEditor) {
              this.epiceditor_container = document.createElement('div');
              this.input.parentNode.insertBefore(this.epiceditor_container, this.input);
              this.input.style.display = 'none';
              options = $extend({}, JSONEditor.plugins.epiceditor, {
                container: this.epiceditor_container,
                clientSideStorage: false
              });
              this.epiceditor = new window.EpicEditor(options).load();
              this.epiceditor.importFile(null, this.getValue());
              this.epiceditor.on('update', function() {
                var val = self.epiceditor.exportFile();
                self.input.value = val;
                self.value = val;
                self.is_dirty = true;
                self.onChange(true);
              });
            } else if (window.ace) {
              var mode = this.input_type;
              if (mode === 'cpp' || mode === 'c++' || mode === 'c') {
                mode = 'c_cpp';
              }
              this.ace_container = document.createElement('div');
              this.ace_container.style.width = '100%';
              this.ace_container.style.position = 'relative';
              this.ace_container.style.height = '400px';
              this.input.parentNode.insertBefore(this.ace_container, this.input);
              this.input.style.display = 'none';
              this.ace_editor = window.ace.edit(this.ace_container);
              this.ace_editor.setValue(this.getValue());
              if (JSONEditor.plugins.ace.theme)
                this.ace_editor.setTheme('ace/theme/' + JSONEditor.plugins.ace.theme);
              mode = window.ace.require("ace/mode/" + mode);
              if (mode)
                this.ace_editor.getSession().setMode(new mode.Mode());
              this.ace_editor.on('change', function() {
                var val = self.ace_editor.getValue();
                self.input.value = val;
                self.refreshValue();
                self.is_dirty = true;
                self.onChange(true);
              });
            }
          }
          self.theme.afterInputReady(self.input);
        },
        refreshValue: function() {
          this.value = this.input.value;
          if (typeof this.value !== "string")
            this.value = '';
          this.serialized = this.value;
        },
        destroy: function() {
          if (this.sceditor_instance) {
            this.sceditor_instance.destroy();
          } else if (this.epiceditor) {
            this.epiceditor.unload();
          } else if (this.ace_editor) {
            this.ace_editor.destroy();
          }
          this.template = null;
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          if (this.label && this.label.parentNode)
            this.label.parentNode.removeChild(this.label);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          this._super();
        },
        sanitize: function(value) {
          return value;
        },
        onWatchedFieldChange: function() {
          var self = this,
              vars,
              j;
          if (this.template) {
            vars = this.getWatchedFieldValues();
            this.setValue(this.template(vars), false, true);
          }
          this._super();
        },
        showValidationErrors: function(errors) {
          var self = this;
          if (this.jsoneditor.options.show_errors === "always") {} else if (!this.is_dirty && this.previous_error_setting === this.jsoneditor.options.show_errors)
            return;
          this.previous_error_setting = this.jsoneditor.options.show_errors;
          var messages = [];
          $each(errors, function(i, error) {
            if (error.path === self.path) {
              messages.push(error.message);
            }
          });
          if (messages.length) {
            this.theme.addInputError(this.input, messages.join('. ') + '.');
          } else {
            this.theme.removeInputError(this.input);
          }
        }
      });
      JSONEditor.defaults.editors.number = JSONEditor.defaults.editors.string.extend({
        sanitize: function(value) {
          return (value + "").replace(/[^0-9\.\-eE]/g, '');
        },
        getNumColumns: function() {
          return 2;
        },
        getValue: function() {
          return this.value * 1;
        }
      });
      JSONEditor.defaults.editors.integer = JSONEditor.defaults.editors.number.extend({
        sanitize: function(value) {
          value = value + "";
          return value.replace(/[^0-9\-]/g, '');
        },
        getNumColumns: function() {
          return 2;
        }
      });
      JSONEditor.defaults.editors.object = JSONEditor.AbstractEditor.extend({
        getDefault: function() {
          return $extend({}, this.schema["default"] || {});
        },
        getChildEditors: function() {
          return this.editors;
        },
        register: function() {
          this._super();
          if (this.editors) {
            for (var i in this.editors) {
              if (!this.editors.hasOwnProperty(i))
                continue;
              this.editors[i].register();
            }
          }
        },
        unregister: function() {
          this._super();
          if (this.editors) {
            for (var i in this.editors) {
              if (!this.editors.hasOwnProperty(i))
                continue;
              this.editors[i].unregister();
            }
          }
        },
        getNumColumns: function() {
          return Math.max(Math.min(12, this.maxwidth), 3);
        },
        enable: function() {
          if (this.editjson_button)
            this.editjson_button.disabled = false;
          if (this.addproperty_button)
            this.addproperty_button.disabled = false;
          this._super();
          if (this.editors) {
            for (var i in this.editors) {
              if (!this.editors.hasOwnProperty(i))
                continue;
              this.editors[i].enable();
            }
          }
        },
        disable: function() {
          if (this.editjson_button)
            this.editjson_button.disabled = true;
          if (this.addproperty_button)
            this.addproperty_button.disabled = true;
          this.hideEditJSON();
          this._super();
          if (this.editors) {
            for (var i in this.editors) {
              if (!this.editors.hasOwnProperty(i))
                continue;
              this.editors[i].disable();
            }
          }
        },
        layoutEditors: function() {
          var self = this,
              i,
              j;
          if (!this.row_container)
            return;
          this.property_order = Object.keys(this.editors);
          this.property_order = this.property_order.sort(function(a, b) {
            var ordera = self.editors[a].schema.propertyOrder;
            var orderb = self.editors[b].schema.propertyOrder;
            if (typeof ordera !== "number")
              ordera = 1000;
            if (typeof orderb !== "number")
              orderb = 1000;
            return ordera - orderb;
          });
          var container;
          if (this.format === 'grid') {
            var rows = [];
            $each(this.property_order, function(j, key) {
              var editor = self.editors[key];
              if (editor.property_removed)
                return;
              var found = false;
              var width = editor.options.hidden ? 0 : (editor.options.grid_columns || editor.getNumColumns());
              var height = editor.options.hidden ? 0 : editor.container.offsetHeight;
              for (var i = 0; i < rows.length; i++) {
                if (rows[i].width + width <= 12) {
                  if (!height || (rows[i].minh * 0.5 < height && rows[i].maxh * 2 > height)) {
                    found = i;
                  }
                }
              }
              if (found === false) {
                rows.push({
                  width: 0,
                  minh: 999999,
                  maxh: 0,
                  editors: []
                });
                found = rows.length - 1;
              }
              rows[found].editors.push({
                key: key,
                width: width,
                height: height
              });
              rows[found].width += width;
              rows[found].minh = Math.min(rows[found].minh, height);
              rows[found].maxh = Math.max(rows[found].maxh, height);
            });
            for (i = 0; i < rows.length; i++) {
              if (rows[i].width < 12) {
                var biggest = false;
                var new_width = 0;
                for (j = 0; j < rows[i].editors.length; j++) {
                  if (biggest === false)
                    biggest = j;
                  else if (rows[i].editors[j].width > rows[i].editors[biggest].width)
                    biggest = j;
                  rows[i].editors[j].width *= 12 / rows[i].width;
                  rows[i].editors[j].width = Math.floor(rows[i].editors[j].width);
                  new_width += rows[i].editors[j].width;
                }
                if (new_width < 12)
                  rows[i].editors[biggest].width += 12 - new_width;
                rows[i].width = 12;
              }
            }
            if (this.layout === JSON.stringify(rows))
              return false;
            this.layout = JSON.stringify(rows);
            container = document.createElement('div');
            for (i = 0; i < rows.length; i++) {
              var row = this.theme.getGridRow();
              container.appendChild(row);
              for (j = 0; j < rows[i].editors.length; j++) {
                var key = rows[i].editors[j].key;
                var editor = this.editors[key];
                if (editor.options.hidden)
                  editor.container.style.display = 'none';
                else
                  this.theme.setGridColumnSize(editor.container, rows[i].editors[j].width);
                row.appendChild(editor.container);
              }
            }
          } else {
            container = document.createElement('div');
            $each(this.property_order, function(i, key) {
              var editor = self.editors[key];
              if (editor.property_removed)
                return;
              var row = self.theme.getGridRow();
              container.appendChild(row);
              if (editor.options.hidden)
                editor.container.style.display = 'none';
              else
                self.theme.setGridColumnSize(editor.container, 12);
              row.appendChild(editor.container);
            });
          }
          this.row_container.innerHTML = '';
          this.row_container.appendChild(container);
        },
        getPropertySchema: function(key) {
          var schema = this.schema.properties[key] || {};
          schema = $extend({}, schema);
          var matched = this.schema.properties[key] ? true : false;
          if (this.schema.patternProperties) {
            for (var i in this.schema.patternProperties) {
              if (!this.schema.patternProperties.hasOwnProperty(i))
                continue;
              var regex = new RegExp(i);
              if (regex.test(key)) {
                schema.allOf = schema.allOf || [];
                schema.allOf.push(this.schema.patternProperties[i]);
                matched = true;
              }
            }
          }
          if (!matched && this.schema.additionalProperties && typeof this.schema.additionalProperties === "object") {
            schema = $extend({}, this.schema.additionalProperties);
          }
          return schema;
        },
        preBuild: function() {
          this._super();
          this.editors = {};
          this.cached_editors = {};
          var self = this;
          this.format = this.options.layout || this.options.object_layout || this.schema.format || this.jsoneditor.options.object_layout || 'normal';
          this.schema.properties = this.schema.properties || {};
          this.minwidth = 0;
          this.maxwidth = 0;
          if (this.options.table_row) {
            $each(this.schema.properties, function(key, schema) {
              var editor = self.jsoneditor.getEditorClass(schema);
              self.editors[key] = self.jsoneditor.createEditor(editor, {
                jsoneditor: self.jsoneditor,
                schema: schema,
                path: self.path + '.' + key,
                parent: self,
                compact: true,
                required: true
              });
              self.editors[key].preBuild();
              var width = self.editors[key].options.hidden ? 0 : (self.editors[key].options.grid_columns || self.editors[key].getNumColumns());
              self.minwidth += width;
              self.maxwidth += width;
            });
            this.no_link_holder = true;
          } else if (this.options.table) {
            throw "Not supported yet";
          } else {
            this.defaultProperties = this.schema.defaultProperties || Object.keys(this.schema.properties);
            self.maxwidth += 1;
            $each(this.defaultProperties, function(i, key) {
              self.addObjectProperty(key, true);
              if (self.editors[key]) {
                self.minwidth = Math.max(self.minwidth, (self.editors[key].options.grid_columns || self.editors[key].getNumColumns()));
                self.maxwidth += (self.editors[key].options.grid_columns || self.editors[key].getNumColumns());
              }
            });
          }
          this.property_order = Object.keys(this.editors);
          this.property_order = this.property_order.sort(function(a, b) {
            var ordera = self.editors[a].schema.propertyOrder;
            var orderb = self.editors[b].schema.propertyOrder;
            if (typeof ordera !== "number")
              ordera = 1000;
            if (typeof orderb !== "number")
              orderb = 1000;
            return ordera - orderb;
          });
        },
        build: function() {
          var self = this;
          if (this.options.table_row) {
            this.editor_holder = this.container;
            $each(this.editors, function(key, editor) {
              var holder = self.theme.getTableCell();
              self.editor_holder.appendChild(holder);
              editor.setContainer(holder);
              editor.build();
              editor.postBuild();
              if (self.editors[key].options.hidden) {
                holder.style.display = 'none';
              }
              if (self.editors[key].options.input_width) {
                holder.style.width = self.editors[key].options.input_width;
              }
            });
          } else if (this.options.table) {
            throw "Not supported yet";
          } else {
            this.header = document.createElement('span');
            this.header.textContent = this.getTitle();
            this.title = this.theme.getHeader(this.header);
            this.container.appendChild(this.title);
            this.container.style.position = 'relative';
            this.editjson_holder = this.theme.getModal();
            this.editjson_textarea = this.theme.getTextareaInput();
            this.editjson_textarea.style.height = '170px';
            this.editjson_textarea.style.width = '300px';
            this.editjson_textarea.style.display = 'block';
            this.editjson_save = this.getButton('Save', 'save', 'Save');
            this.editjson_save.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              self.saveJSON();
            });
            this.editjson_cancel = this.getButton('Cancel', 'cancel', 'Cancel');
            this.editjson_cancel.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              self.hideEditJSON();
            });
            this.editjson_holder.appendChild(this.editjson_textarea);
            this.editjson_holder.appendChild(this.editjson_save);
            this.editjson_holder.appendChild(this.editjson_cancel);
            this.addproperty_holder = this.theme.getModal();
            this.addproperty_list = document.createElement('div');
            this.addproperty_list.style.width = '295px';
            this.addproperty_list.style.maxHeight = '160px';
            this.addproperty_list.style.padding = '5px 0';
            this.addproperty_list.style.overflowY = 'auto';
            this.addproperty_list.style.overflowX = 'hidden';
            this.addproperty_list.style.paddingLeft = '5px';
            this.addproperty_list.setAttribute('class', 'property-selector');
            this.addproperty_add = this.getButton('add', 'add', 'add');
            this.addproperty_input = this.theme.getFormInputField('text');
            this.addproperty_input.setAttribute('placeholder', 'Property name...');
            this.addproperty_input.style.width = '220px';
            this.addproperty_input.style.marginBottom = '0';
            this.addproperty_input.style.display = 'inline-block';
            this.addproperty_add.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (self.addproperty_input.value) {
                if (self.editors[self.addproperty_input.value]) {
                  window.alert('there is already a property with that name');
                  return;
                }
                self.addObjectProperty(self.addproperty_input.value);
                if (self.editors[self.addproperty_input.value]) {
                  self.editors[self.addproperty_input.value].disable();
                }
                self.onChange(true);
              }
            });
            this.addproperty_holder.appendChild(this.addproperty_list);
            this.addproperty_holder.appendChild(this.addproperty_input);
            this.addproperty_holder.appendChild(this.addproperty_add);
            var spacer = document.createElement('div');
            spacer.style.clear = 'both';
            this.addproperty_holder.appendChild(spacer);
            if (this.schema.description) {
              this.description = this.theme.getDescription(this.schema.description);
              this.container.appendChild(this.description);
            }
            this.error_holder = document.createElement('div');
            this.container.appendChild(this.error_holder);
            this.editor_holder = this.theme.getIndentedPanel();
            this.container.appendChild(this.editor_holder);
            this.row_container = this.theme.getGridContainer();
            this.editor_holder.appendChild(this.row_container);
            $each(this.editors, function(key, editor) {
              var holder = self.theme.getGridColumn();
              self.row_container.appendChild(holder);
              editor.setContainer(holder);
              editor.build();
              editor.postBuild();
            });
            this.title_controls = this.theme.getHeaderButtonHolder();
            this.editjson_controls = this.theme.getHeaderButtonHolder();
            this.addproperty_controls = this.theme.getHeaderButtonHolder();
            this.title.appendChild(this.title_controls);
            this.title.appendChild(this.editjson_controls);
            this.title.appendChild(this.addproperty_controls);
            this.collapsed = false;
            this.toggle_button = this.getButton('', 'collapse', 'Collapse');
            this.title_controls.appendChild(this.toggle_button);
            this.toggle_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (self.collapsed) {
                self.editor_holder.style.display = '';
                self.collapsed = false;
                self.setButtonText(self.toggle_button, '', 'collapse', 'Collapse');
              } else {
                self.editor_holder.style.display = 'none';
                self.collapsed = true;
                self.setButtonText(self.toggle_button, '', 'expand', 'Expand');
              }
            });
            if (this.options.collapsed) {
              $trigger(this.toggle_button, 'click');
            }
            if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
              if (this.schema.options.disable_collapse)
                this.toggle_button.style.display = 'none';
            } else if (this.jsoneditor.options.disable_collapse) {
              this.toggle_button.style.display = 'none';
            }
            this.editjson_button = this.getButton('JSON', 'edit', 'Edit JSON');
            this.editjson_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              self.toggleEditJSON();
            });
            this.editjson_controls.appendChild(this.editjson_button);
            this.editjson_controls.appendChild(this.editjson_holder);
            if (this.schema.options && typeof this.schema.options.disable_edit_json !== "undefined") {
              if (this.schema.options.disable_edit_json)
                this.editjson_button.style.display = 'none';
            } else if (this.jsoneditor.options.disable_edit_json) {
              this.editjson_button.style.display = 'none';
            }
            this.addproperty_button = this.getButton('Properties', 'edit', 'Object Properties');
            this.addproperty_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              self.toggleAddProperty();
            });
            this.addproperty_controls.appendChild(this.addproperty_button);
            this.addproperty_controls.appendChild(this.addproperty_holder);
            this.refreshAddProperties();
          }
          if (this.options.table_row) {
            this.editor_holder = this.container;
            $each(this.property_order, function(i, key) {
              self.editor_holder.appendChild(self.editors[key].container);
            });
          } else {
            this.layoutEditors();
            this.layoutEditors();
          }
        },
        showEditJSON: function() {
          if (!this.editjson_holder)
            return;
          this.hideAddProperty();
          this.editjson_holder.style.left = this.editjson_button.offsetLeft + "px";
          this.editjson_holder.style.top = this.editjson_button.offsetTop + this.editjson_button.offsetHeight + "px";
          this.editjson_textarea.value = JSON.stringify(this.getValue(), null, 2);
          this.disable();
          this.editjson_holder.style.display = '';
          this.editjson_button.disabled = false;
          this.editing_json = true;
        },
        hideEditJSON: function() {
          if (!this.editjson_holder)
            return;
          if (!this.editing_json)
            return;
          this.editjson_holder.style.display = 'none';
          this.enable();
          this.editing_json = false;
        },
        saveJSON: function() {
          if (!this.editjson_holder)
            return;
          try {
            var json = JSON.parse(this.editjson_textarea.value);
            this.setValue(json);
            this.hideEditJSON();
          } catch (e) {
            window.alert('invalid JSON');
            throw e;
          }
        },
        toggleEditJSON: function() {
          if (this.editing_json)
            this.hideEditJSON();
          else
            this.showEditJSON();
        },
        insertPropertyControlUsingPropertyOrder: function(property, control, container) {
          var propertyOrder;
          if (this.schema.properties[property])
            propertyOrder = this.schema.properties[property].propertyOrder;
          if (typeof propertyOrder !== "number")
            propertyOrder = 1000;
          control.propertyOrder = propertyOrder;
          for (var i = 0; i < container.childNodes.length; i++) {
            var child = container.childNodes[i];
            if (control.propertyOrder < child.propertyOrder) {
              this.addproperty_list.insertBefore(control, child);
              control = null;
              break;
            }
          }
          if (control) {
            this.addproperty_list.appendChild(control);
          }
        },
        addPropertyCheckbox: function(key) {
          var self = this;
          var checkbox,
              label,
              labelText,
              control;
          checkbox = self.theme.getCheckbox();
          checkbox.style.width = 'auto';
          if (this.schema.properties[key] && this.schema.properties[key].title)
            labelText = this.schema.properties[key].title;
          else
            labelText = key;
          label = self.theme.getCheckboxLabel(labelText);
          control = self.theme.getFormControl(label, checkbox);
          control.style.paddingBottom = control.style.marginBottom = control.style.paddingTop = control.style.marginTop = 0;
          control.style.height = 'auto';
          this.insertPropertyControlUsingPropertyOrder(key, control, this.addproperty_list);
          checkbox.checked = key in this.editors;
          checkbox.addEventListener('change', function() {
            if (checkbox.checked) {
              self.addObjectProperty(key);
            } else {
              self.removeObjectProperty(key);
            }
            self.onChange(true);
          });
          self.addproperty_checkboxes[key] = checkbox;
          return checkbox;
        },
        showAddProperty: function() {
          if (!this.addproperty_holder)
            return;
          this.hideEditJSON();
          this.addproperty_holder.style.left = this.addproperty_button.offsetLeft + "px";
          this.addproperty_holder.style.top = this.addproperty_button.offsetTop + this.addproperty_button.offsetHeight + "px";
          this.disable();
          this.adding_property = true;
          this.addproperty_button.disabled = false;
          this.addproperty_holder.style.display = '';
          this.refreshAddProperties();
        },
        hideAddProperty: function() {
          if (!this.addproperty_holder)
            return;
          if (!this.adding_property)
            return;
          this.addproperty_holder.style.display = 'none';
          this.enable();
          this.adding_property = false;
        },
        toggleAddProperty: function() {
          if (this.adding_property)
            this.hideAddProperty();
          else
            this.showAddProperty();
        },
        removeObjectProperty: function(property) {
          if (this.editors[property]) {
            this.editors[property].unregister();
            delete this.editors[property];
            this.refreshValue();
            this.layoutEditors();
          }
        },
        addObjectProperty: function(name, prebuild_only) {
          var self = this;
          if (this.editors[name])
            return;
          if (this.cached_editors[name]) {
            this.editors[name] = this.cached_editors[name];
            if (prebuild_only)
              return;
            this.editors[name].register();
          } else {
            if (!this.canHaveAdditionalProperties() && (!this.schema.properties || !this.schema.properties[name])) {
              return;
            }
            var schema = self.getPropertySchema(name);
            var editor = self.jsoneditor.getEditorClass(schema);
            self.editors[name] = self.jsoneditor.createEditor(editor, {
              jsoneditor: self.jsoneditor,
              schema: schema,
              path: self.path + '.' + name,
              parent: self
            });
            self.editors[name].preBuild();
            if (!prebuild_only) {
              var holder = self.theme.getChildEditorHolder();
              self.editor_holder.appendChild(holder);
              self.editors[name].setContainer(holder);
              self.editors[name].build();
              self.editors[name].postBuild();
            }
            self.cached_editors[name] = self.editors[name];
          }
          if (!prebuild_only) {
            self.refreshValue();
            self.layoutEditors();
          }
        },
        onChildEditorChange: function(editor) {
          this.refreshValue();
          this._super(editor);
        },
        canHaveAdditionalProperties: function() {
          if (typeof this.schema.additionalProperties === "boolean") {
            return this.schema.additionalProperties;
          }
          return !this.jsoneditor.options.no_additional_properties;
        },
        destroy: function() {
          $each(this.cached_editors, function(i, el) {
            el.destroy();
          });
          if (this.editor_holder)
            this.editor_holder.innerHTML = '';
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.error_holder && this.error_holder.parentNode)
            this.error_holder.parentNode.removeChild(this.error_holder);
          this.editors = null;
          this.cached_editors = null;
          if (this.editor_holder && this.editor_holder.parentNode)
            this.editor_holder.parentNode.removeChild(this.editor_holder);
          this.editor_holder = null;
          this._super();
        },
        getValue: function() {
          var result = this._super();
          if (this.jsoneditor.options.remove_empty_properties || this.options.remove_empty_properties) {
            for (var i in result) {
              if (result.hasOwnProperty(i)) {
                if (!result[i])
                  delete result[i];
              }
            }
          }
          return result;
        },
        refreshValue: function() {
          this.value = {};
          var self = this;
          for (var i in this.editors) {
            if (!this.editors.hasOwnProperty(i))
              continue;
            this.value[i] = this.editors[i].getValue();
          }
          if (this.adding_property)
            this.refreshAddProperties();
        },
        refreshAddProperties: function() {
          if (this.options.disable_properties || (this.options.disable_properties !== false && this.jsoneditor.options.disable_properties)) {
            this.addproperty_controls.style.display = 'none';
            return;
          }
          var can_add = false,
              can_remove = false,
              num_props = 0,
              i,
              show_modal = false;
          for (i in this.editors) {
            if (!this.editors.hasOwnProperty(i))
              continue;
            num_props++;
          }
          can_add = this.canHaveAdditionalProperties() && !(typeof this.schema.maxProperties !== "undefined" && num_props >= this.schema.maxProperties);
          if (this.addproperty_checkboxes) {
            this.addproperty_list.innerHTML = '';
          }
          this.addproperty_checkboxes = {};
          for (i in this.cached_editors) {
            if (!this.cached_editors.hasOwnProperty(i))
              continue;
            this.addPropertyCheckbox(i);
            if (this.isRequired(this.cached_editors[i]) && i in this.editors) {
              this.addproperty_checkboxes[i].disabled = true;
            }
            if (typeof this.schema.minProperties !== "undefined" && num_props <= this.schema.minProperties) {
              this.addproperty_checkboxes[i].disabled = this.addproperty_checkboxes[i].checked;
              if (!this.addproperty_checkboxes[i].checked)
                show_modal = true;
            } else if (!(i in this.editors)) {
              if (!can_add && !this.schema.properties.hasOwnProperty(i)) {
                this.addproperty_checkboxes[i].disabled = true;
              } else {
                this.addproperty_checkboxes[i].disabled = false;
                show_modal = true;
              }
            } else {
              show_modal = true;
              can_remove = true;
            }
          }
          if (this.canHaveAdditionalProperties()) {
            show_modal = true;
          }
          for (i in this.schema.properties) {
            if (!this.schema.properties.hasOwnProperty(i))
              continue;
            if (this.cached_editors[i])
              continue;
            show_modal = true;
            this.addPropertyCheckbox(i);
          }
          if (!show_modal) {
            this.hideAddProperty();
            this.addproperty_controls.style.display = 'none';
          } else if (!this.canHaveAdditionalProperties()) {
            this.addproperty_add.style.display = 'none';
            this.addproperty_input.style.display = 'none';
          } else if (!can_add) {
            this.addproperty_add.disabled = true;
          } else {
            this.addproperty_add.disabled = false;
          }
        },
        isRequired: function(editor) {
          if (typeof editor.schema.required === "boolean")
            return editor.schema.required;
          else if (Array.isArray(this.schema.required))
            return this.schema.required.indexOf(editor.key) > -1;
          else if (this.jsoneditor.options.required_by_default)
            return true;
          else
            return false;
        },
        setValue: function(value, initial) {
          var self = this;
          value = value || {};
          if (typeof value !== "object" || Array.isArray(value))
            value = {};
          $each(this.cached_editors, function(i, editor) {
            if (typeof value[i] !== "undefined") {
              self.addObjectProperty(i);
              editor.setValue(value[i], initial);
            } else if (!initial && !self.isRequired(editor)) {
              self.removeObjectProperty(i);
            } else {
              editor.setValue(editor.getDefault(), initial);
            }
          });
          $each(value, function(i, val) {
            if (!self.cached_editors[i]) {
              self.addObjectProperty(i);
              if (self.editors[i])
                self.editors[i].setValue(val, initial);
            }
          });
          this.refreshValue();
          this.layoutEditors();
          this.onChange();
        },
        showValidationErrors: function(errors) {
          var self = this;
          var my_errors = [];
          var other_errors = [];
          $each(errors, function(i, error) {
            if (error.path === self.path) {
              my_errors.push(error);
            } else {
              other_errors.push(error);
            }
          });
          if (this.error_holder) {
            if (my_errors.length) {
              var message = [];
              this.error_holder.innerHTML = '';
              this.error_holder.style.display = '';
              $each(my_errors, function(i, error) {
                self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
              });
            } else {
              this.error_holder.style.display = 'none';
            }
          }
          if (this.options.table_row) {
            if (my_errors.length) {
              this.theme.addTableRowError(this.container);
            } else {
              this.theme.removeTableRowError(this.container);
            }
          }
          $each(this.editors, function(i, editor) {
            editor.showValidationErrors(other_errors);
          });
        }
      });
      JSONEditor.defaults.editors.array = JSONEditor.AbstractEditor.extend({
        getDefault: function() {
          return this.schema["default"] || [];
        },
        register: function() {
          this._super();
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].register();
            }
          }
        },
        unregister: function() {
          this._super();
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].unregister();
            }
          }
        },
        getNumColumns: function() {
          var info = this.getItemInfo(0);
          if (this.tabs_holder) {
            return Math.max(Math.min(12, info.width + 2), 4);
          } else {
            return info.width;
          }
        },
        enable: function() {
          if (this.add_row_button)
            this.add_row_button.disabled = false;
          if (this.remove_all_rows_button)
            this.remove_all_rows_button.disabled = false;
          if (this.delete_last_row_button)
            this.delete_last_row_button.disabled = false;
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].enable();
              if (this.rows[i].moveup_button)
                this.rows[i].moveup_button.disabled = false;
              if (this.rows[i].movedown_button)
                this.rows[i].movedown_button.disabled = false;
              if (this.rows[i].delete_button)
                this.rows[i].delete_button.disabled = false;
            }
          }
          this._super();
        },
        disable: function() {
          if (this.add_row_button)
            this.add_row_button.disabled = true;
          if (this.remove_all_rows_button)
            this.remove_all_rows_button.disabled = true;
          if (this.delete_last_row_button)
            this.delete_last_row_button.disabled = true;
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].disable();
              if (this.rows[i].moveup_button)
                this.rows[i].moveup_button.disabled = true;
              if (this.rows[i].movedown_button)
                this.rows[i].movedown_button.disabled = true;
              if (this.rows[i].delete_button)
                this.rows[i].delete_button.disabled = true;
            }
          }
          this._super();
        },
        preBuild: function() {
          this._super();
          this.rows = [];
          this.row_cache = [];
          this.hide_delete_buttons = this.options.disable_array_delete || this.jsoneditor.options.disable_array_delete;
          this.hide_delete_all_rows_buttons = this.hide_delete_buttons || this.options.disable_array_delete_all_rows || this.jsoneditor.options.disable_array_delete_all_rows;
          this.hide_delete_last_row_buttons = this.hide_delete_buttons || this.options.disable_array_delete_last_row || this.jsoneditor.options.disable_array_delete_last_row;
          this.hide_move_buttons = this.options.disable_array_reorder || this.jsoneditor.options.disable_array_reorder;
          this.hide_add_button = this.options.disable_array_add || this.jsoneditor.options.disable_array_add;
        },
        build: function() {
          var self = this;
          if (!this.options.compact) {
            this.header = document.createElement('span');
            this.header.textContent = this.getTitle();
            this.title = this.theme.getHeader(this.header);
            this.container.appendChild(this.title);
            this.title_controls = this.theme.getHeaderButtonHolder();
            this.title.appendChild(this.title_controls);
            if (this.schema.description) {
              this.description = this.theme.getDescription(this.schema.description);
              this.container.appendChild(this.description);
            }
            this.error_holder = document.createElement('div');
            this.container.appendChild(this.error_holder);
            if (this.schema.format === 'tabs') {
              this.controls = this.theme.getHeaderButtonHolder();
              this.title.appendChild(this.controls);
              this.tabs_holder = this.theme.getTabHolder();
              this.container.appendChild(this.tabs_holder);
              this.row_holder = this.theme.getTabContentHolder(this.tabs_holder);
              this.active_tab = null;
            } else {
              this.panel = this.theme.getIndentedPanel();
              this.container.appendChild(this.panel);
              this.row_holder = document.createElement('div');
              this.panel.appendChild(this.row_holder);
              this.controls = this.theme.getButtonHolder();
              this.panel.appendChild(this.controls);
            }
          } else {
            this.panel = this.theme.getIndentedPanel();
            this.container.appendChild(this.panel);
            this.controls = this.theme.getButtonHolder();
            this.panel.appendChild(this.controls);
            this.row_holder = document.createElement('div');
            this.panel.appendChild(this.row_holder);
          }
          this.addControls();
        },
        onChildEditorChange: function(editor) {
          this.refreshValue();
          this.refreshTabs(true);
          this._super(editor);
        },
        getItemTitle: function() {
          if (!this.item_title) {
            if (this.schema.items && !Array.isArray(this.schema.items)) {
              var tmp = this.jsoneditor.expandRefs(this.schema.items);
              this.item_title = tmp.title || 'item';
            } else {
              this.item_title = 'item';
            }
          }
          return this.item_title;
        },
        getItemSchema: function(i) {
          if (Array.isArray(this.schema.items)) {
            if (i >= this.schema.items.length) {
              if (this.schema.additionalItems === true) {
                return {};
              } else if (this.schema.additionalItems) {
                return $extend({}, this.schema.additionalItems);
              }
            } else {
              return $extend({}, this.schema.items[i]);
            }
          } else if (this.schema.items) {
            return $extend({}, this.schema.items);
          } else {
            return {};
          }
        },
        getItemInfo: function(i) {
          var schema = this.getItemSchema(i);
          this.item_info = this.item_info || {};
          var stringified = JSON.stringify(schema);
          if (typeof this.item_info[stringified] !== "undefined")
            return this.item_info[stringified];
          schema = this.jsoneditor.expandRefs(schema);
          this.item_info[stringified] = {
            title: schema.title || "item",
            'default': schema["default"],
            width: 12,
            child_editors: schema.properties || schema.items
          };
          return this.item_info[stringified];
        },
        getElementEditor: function(i) {
          var item_info = this.getItemInfo(i);
          var schema = this.getItemSchema(i);
          schema = this.jsoneditor.expandRefs(schema);
          schema.title = item_info.title + ' ' + (i + 1);
          var editor = this.jsoneditor.getEditorClass(schema);
          var holder;
          if (this.tabs_holder) {
            holder = this.theme.getTabContent();
          } else if (item_info.child_editors) {
            holder = this.theme.getChildEditorHolder();
          } else {
            holder = this.theme.getIndentedPanel();
          }
          this.row_holder.appendChild(holder);
          var ret = this.jsoneditor.createEditor(editor, {
            jsoneditor: this.jsoneditor,
            schema: schema,
            container: holder,
            path: this.path + '.' + i,
            parent: this,
            required: true
          });
          ret.preBuild();
          ret.build();
          ret.postBuild();
          if (!ret.title_controls) {
            ret.array_controls = this.theme.getButtonHolder();
            holder.appendChild(ret.array_controls);
          }
          return ret;
        },
        destroy: function() {
          this.empty(true);
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.row_holder && this.row_holder.parentNode)
            this.row_holder.parentNode.removeChild(this.row_holder);
          if (this.controls && this.controls.parentNode)
            this.controls.parentNode.removeChild(this.controls);
          if (this.panel && this.panel.parentNode)
            this.panel.parentNode.removeChild(this.panel);
          this.rows = this.row_cache = this.title = this.description = this.row_holder = this.panel = this.controls = null;
          this._super();
        },
        empty: function(hard) {
          if (!this.rows)
            return;
          var self = this;
          $each(this.rows, function(i, row) {
            if (hard) {
              if (row.tab && row.tab.parentNode)
                row.tab.parentNode.removeChild(row.tab);
              self.destroyRow(row, true);
              self.row_cache[i] = null;
            }
            self.rows[i] = null;
          });
          self.rows = [];
          if (hard)
            self.row_cache = [];
        },
        destroyRow: function(row, hard) {
          var holder = row.container;
          if (hard) {
            row.destroy();
            if (holder.parentNode)
              holder.parentNode.removeChild(holder);
            if (row.tab && row.tab.parentNode)
              row.tab.parentNode.removeChild(row.tab);
          } else {
            if (row.tab)
              row.tab.style.display = 'none';
            holder.style.display = 'none';
            row.unregister();
          }
        },
        getMax: function() {
          if ((Array.isArray(this.schema.items)) && this.schema.additionalItems === false) {
            return Math.min(this.schema.items.length, this.schema.maxItems || Infinity);
          } else {
            return this.schema.maxItems || Infinity;
          }
        },
        refreshTabs: function(refresh_headers) {
          var self = this;
          $each(this.rows, function(i, row) {
            if (!row.tab)
              return;
            if (refresh_headers) {
              row.tab_text.textContent = row.getHeaderText();
            } else {
              if (row.tab === self.active_tab) {
                self.theme.markTabActive(row.tab);
                row.container.style.display = '';
              } else {
                self.theme.markTabInactive(row.tab);
                row.container.style.display = 'none';
              }
            }
          });
        },
        setValue: function(value, initial) {
          value = value || [];
          if (!(Array.isArray(value)))
            value = [value];
          var serialized = JSON.stringify(value);
          if (serialized === this.serialized)
            return;
          if (this.schema.minItems) {
            while (value.length < this.schema.minItems) {
              value.push(this.getItemInfo(value.length)["default"]);
            }
          }
          if (this.getMax() && value.length > this.getMax()) {
            value = value.slice(0, this.getMax());
          }
          var self = this;
          $each(value, function(i, val) {
            if (self.rows[i]) {
              self.rows[i].setValue(val, initial);
            } else if (self.row_cache[i]) {
              self.rows[i] = self.row_cache[i];
              self.rows[i].setValue(val, initial);
              self.rows[i].container.style.display = '';
              if (self.rows[i].tab)
                self.rows[i].tab.style.display = '';
              self.rows[i].register();
            } else {
              self.addRow(val, initial);
            }
          });
          for (var j = value.length; j < self.rows.length; j++) {
            self.destroyRow(self.rows[j]);
            self.rows[j] = null;
          }
          self.rows = self.rows.slice(0, value.length);
          var new_active_tab = null;
          $each(self.rows, function(i, row) {
            if (row.tab === self.active_tab) {
              new_active_tab = row.tab;
              return false;
            }
          });
          if (!new_active_tab && self.rows.length)
            new_active_tab = self.rows[0].tab;
          self.active_tab = new_active_tab;
          self.refreshValue(initial);
          self.refreshTabs(true);
          self.refreshTabs();
          self.onChange();
        },
        refreshValue: function(force) {
          var self = this;
          var oldi = this.value ? this.value.length : 0;
          this.value = [];
          $each(this.rows, function(i, editor) {
            self.value[i] = editor.getValue();
          });
          if (oldi !== this.value.length || force) {
            var minItems = this.schema.minItems && this.schema.minItems >= this.rows.length;
            $each(this.rows, function(i, editor) {
              if (editor.movedown_button) {
                if (i === self.rows.length - 1) {
                  editor.movedown_button.style.display = 'none';
                } else {
                  editor.movedown_button.style.display = '';
                }
              }
              if (editor.delete_button) {
                if (minItems) {
                  editor.delete_button.style.display = 'none';
                } else {
                  editor.delete_button.style.display = '';
                }
              }
              self.value[i] = editor.getValue();
            });
            var controls_needed = false;
            if (!this.value.length) {
              this.delete_last_row_button.style.display = 'none';
              this.remove_all_rows_button.style.display = 'none';
            } else if (this.value.length === 1) {
              this.remove_all_rows_button.style.display = 'none';
              if (minItems || this.hide_delete_last_row_buttons) {
                this.delete_last_row_button.style.display = 'none';
              } else {
                this.delete_last_row_button.style.display = '';
                controls_needed = true;
              }
            } else {
              if (minItems || this.hide_delete_last_row_buttons) {
                this.delete_last_row_button.style.display = 'none';
              } else {
                this.delete_last_row_button.style.display = '';
                controls_needed = true;
              }
              if (minItems || this.hide_delete_all_rows_buttons) {
                this.remove_all_rows_button.style.display = 'none';
              } else {
                this.remove_all_rows_button.style.display = '';
                controls_needed = true;
              }
            }
            if ((this.getMax() && this.getMax() <= this.rows.length) || this.hide_add_button) {
              this.add_row_button.style.display = 'none';
            } else {
              this.add_row_button.style.display = '';
              controls_needed = true;
            }
            if (!this.collapsed && controls_needed) {
              this.controls.style.display = 'inline-block';
            } else {
              this.controls.style.display = 'none';
            }
          }
        },
        addRow: function(value, initial) {
          var self = this;
          var i = this.rows.length;
          self.rows[i] = this.getElementEditor(i);
          self.row_cache[i] = self.rows[i];
          if (self.tabs_holder) {
            self.rows[i].tab_text = document.createElement('span');
            self.rows[i].tab_text.textContent = self.rows[i].getHeaderText();
            self.rows[i].tab = self.theme.getTab(self.rows[i].tab_text);
            self.rows[i].tab.addEventListener('click', function(e) {
              self.active_tab = self.rows[i].tab;
              self.refreshTabs();
              e.preventDefault();
              e.stopPropagation();
            });
            self.theme.addTab(self.tabs_holder, self.rows[i].tab);
          }
          var controls_holder = self.rows[i].title_controls || self.rows[i].array_controls;
          if (!self.hide_delete_buttons) {
            self.rows[i].delete_button = this.getButton(self.getItemTitle(), 'delete', this.translate('button_delete_row_title', [self.getItemTitle()]));
            self.rows[i].delete_button.className += ' delete';
            self.rows[i].delete_button.setAttribute('data-i', i);
            self.rows[i].delete_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              var value = self.getValue();
              var newval = [];
              var new_active_tab = null;
              $each(value, function(j, row) {
                if (j === i) {
                  if (self.rows[j].tab === self.active_tab) {
                    if (self.rows[j + 1])
                      new_active_tab = self.rows[j].tab;
                    else if (j)
                      new_active_tab = self.rows[j - 1].tab;
                  }
                  return;
                }
                newval.push(row);
              });
              self.setValue(newval);
              if (new_active_tab) {
                self.active_tab = new_active_tab;
                self.refreshTabs();
              }
              self.onChange(true);
            });
            if (controls_holder) {
              controls_holder.appendChild(self.rows[i].delete_button);
            }
          }
          if (i && !self.hide_move_buttons) {
            self.rows[i].moveup_button = this.getButton('', 'moveup', this.translate('button_move_up_title'));
            self.rows[i].moveup_button.className += ' moveup';
            self.rows[i].moveup_button.setAttribute('data-i', i);
            self.rows[i].moveup_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              if (i <= 0)
                return;
              var rows = self.getValue();
              var tmp = rows[i - 1];
              rows[i - 1] = rows[i];
              rows[i] = tmp;
              self.setValue(rows);
              self.active_tab = self.rows[i - 1].tab;
              self.refreshTabs();
              self.onChange(true);
            });
            if (controls_holder) {
              controls_holder.appendChild(self.rows[i].moveup_button);
            }
          }
          if (!self.hide_move_buttons) {
            self.rows[i].movedown_button = this.getButton('', 'movedown', this.translate('button_move_down_title'));
            self.rows[i].movedown_button.className += ' movedown';
            self.rows[i].movedown_button.setAttribute('data-i', i);
            self.rows[i].movedown_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              var rows = self.getValue();
              if (i >= rows.length - 1)
                return;
              var tmp = rows[i + 1];
              rows[i + 1] = rows[i];
              rows[i] = tmp;
              self.setValue(rows);
              self.active_tab = self.rows[i + 1].tab;
              self.refreshTabs();
              self.onChange(true);
            });
            if (controls_holder) {
              controls_holder.appendChild(self.rows[i].movedown_button);
            }
          }
          if (value)
            self.rows[i].setValue(value, initial);
          self.refreshTabs();
        },
        addControls: function() {
          var self = this;
          this.collapsed = false;
          this.toggle_button = this.getButton('', 'collapse', this.translate('button_collapse'));
          this.title_controls.appendChild(this.toggle_button);
          var row_holder_display = self.row_holder.style.display;
          var controls_display = self.controls.style.display;
          this.toggle_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            if (self.collapsed) {
              self.collapsed = false;
              if (self.panel)
                self.panel.style.display = '';
              self.row_holder.style.display = row_holder_display;
              if (self.tabs_holder)
                self.tabs_holder.style.display = '';
              self.controls.style.display = controls_display;
              self.setButtonText(this, '', 'collapse', 'Collapse');
            } else {
              self.collapsed = true;
              self.row_holder.style.display = 'none';
              if (self.tabs_holder)
                self.tabs_holder.style.display = 'none';
              self.controls.style.display = 'none';
              if (self.panel)
                self.panel.style.display = 'none';
              self.setButtonText(this, '', 'expand', 'Expand');
            }
          });
          if (this.options.collapsed) {
            $trigger(this.toggle_button, 'click');
          }
          if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
            if (this.schema.options.disable_collapse)
              this.toggle_button.style.display = 'none';
          } else if (this.jsoneditor.options.disable_collapse) {
            this.toggle_button.style.display = 'none';
          }
          this.add_row_button = this.getButton(this.getItemTitle(), 'add', this.translate('button_add_row_title', [this.getItemTitle()]));
          this.add_row_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            var i = self.rows.length;
            if (self.row_cache[i]) {
              self.rows[i] = self.row_cache[i];
              self.rows[i].setValue(self.rows[i].getDefault());
              self.rows[i].container.style.display = '';
              if (self.rows[i].tab)
                self.rows[i].tab.style.display = '';
              self.rows[i].register();
            } else {
              self.addRow();
            }
            self.active_tab = self.rows[i].tab;
            self.refreshTabs();
            self.refreshValue();
            self.onChange(true);
          });
          self.controls.appendChild(this.add_row_button);
          this.delete_last_row_button = this.getButton(this.translate('button_delete_last', [this.getItemTitle()]), 'delete', this.translate('button_delete_last_title', [this.getItemTitle()]));
          this.delete_last_row_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            var rows = self.getValue();
            var new_active_tab = null;
            if (self.rows.length > 1 && self.rows[self.rows.length - 1].tab === self.active_tab)
              new_active_tab = self.rows[self.rows.length - 2].tab;
            rows.pop();
            self.setValue(rows);
            if (new_active_tab) {
              self.active_tab = new_active_tab;
              self.refreshTabs();
            }
            self.onChange(true);
          });
          self.controls.appendChild(this.delete_last_row_button);
          this.remove_all_rows_button = this.getButton(this.translate('button_delete_all'), 'delete', this.translate('button_delete_all_title'));
          this.remove_all_rows_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.setValue([]);
            self.onChange(true);
          });
          self.controls.appendChild(this.remove_all_rows_button);
          if (self.tabs) {
            this.add_row_button.style.width = '100%';
            this.add_row_button.style.textAlign = 'left';
            this.add_row_button.style.marginBottom = '3px';
            this.delete_last_row_button.style.width = '100%';
            this.delete_last_row_button.style.textAlign = 'left';
            this.delete_last_row_button.style.marginBottom = '3px';
            this.remove_all_rows_button.style.width = '100%';
            this.remove_all_rows_button.style.textAlign = 'left';
            this.remove_all_rows_button.style.marginBottom = '3px';
          }
        },
        showValidationErrors: function(errors) {
          var self = this;
          var my_errors = [];
          var other_errors = [];
          $each(errors, function(i, error) {
            if (error.path === self.path) {
              my_errors.push(error);
            } else {
              other_errors.push(error);
            }
          });
          if (this.error_holder) {
            if (my_errors.length) {
              var message = [];
              this.error_holder.innerHTML = '';
              this.error_holder.style.display = '';
              $each(my_errors, function(i, error) {
                self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
              });
            } else {
              this.error_holder.style.display = 'none';
            }
          }
          $each(this.rows, function(i, row) {
            row.showValidationErrors(other_errors);
          });
        }
      });
      JSONEditor.defaults.editors.table = JSONEditor.defaults.editors.array.extend({
        register: function() {
          this._super();
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].register();
            }
          }
        },
        unregister: function() {
          this._super();
          if (this.rows) {
            for (var i = 0; i < this.rows.length; i++) {
              this.rows[i].unregister();
            }
          }
        },
        getNumColumns: function() {
          return Math.max(Math.min(12, this.width), 3);
        },
        preBuild: function() {
          var item_schema = this.jsoneditor.expandRefs(this.schema.items || {});
          this.item_title = item_schema.title || 'row';
          this.item_default = item_schema["default"] || null;
          this.item_has_child_editors = item_schema.properties || item_schema.items;
          this.width = 12;
          this._super();
        },
        build: function() {
          var self = this;
          this.table = this.theme.getTable();
          this.container.appendChild(this.table);
          this.thead = this.theme.getTableHead();
          this.table.appendChild(this.thead);
          this.header_row = this.theme.getTableRow();
          this.thead.appendChild(this.header_row);
          this.row_holder = this.theme.getTableBody();
          this.table.appendChild(this.row_holder);
          var tmp = this.getElementEditor(0, true);
          this.item_default = tmp.getDefault();
          this.width = tmp.getNumColumns() + 2;
          if (!this.options.compact) {
            this.title = this.theme.getHeader(this.getTitle());
            this.container.appendChild(this.title);
            this.title_controls = this.theme.getHeaderButtonHolder();
            this.title.appendChild(this.title_controls);
            if (this.schema.description) {
              this.description = this.theme.getDescription(this.schema.description);
              this.container.appendChild(this.description);
            }
            this.panel = this.theme.getIndentedPanel();
            this.container.appendChild(this.panel);
            this.error_holder = document.createElement('div');
            this.panel.appendChild(this.error_holder);
          } else {
            this.panel = document.createElement('div');
            this.container.appendChild(this.panel);
          }
          this.panel.appendChild(this.table);
          this.controls = this.theme.getButtonHolder();
          this.panel.appendChild(this.controls);
          if (this.item_has_child_editors) {
            var ce = tmp.getChildEditors();
            var order = tmp.property_order || Object.keys(ce);
            for (var i = 0; i < order.length; i++) {
              var th = self.theme.getTableHeaderCell(ce[order[i]].getTitle());
              if (ce[order[i]].options.hidden)
                th.style.display = 'none';
              self.header_row.appendChild(th);
            }
          } else {
            self.header_row.appendChild(self.theme.getTableHeaderCell(this.item_title));
          }
          tmp.destroy();
          this.row_holder.innerHTML = '';
          this.controls_header_cell = self.theme.getTableHeaderCell(" ");
          self.header_row.appendChild(this.controls_header_cell);
          this.addControls();
        },
        onChildEditorChange: function(editor) {
          this.refreshValue();
          this._super();
        },
        getItemDefault: function() {
          return $extend({}, {"default": this.item_default})["default"];
        },
        getItemTitle: function() {
          return this.item_title;
        },
        getElementEditor: function(i, ignore) {
          var schema_copy = $extend({}, this.schema.items);
          var editor = this.jsoneditor.getEditorClass(schema_copy, this.jsoneditor);
          var row = this.row_holder.appendChild(this.theme.getTableRow());
          var holder = row;
          if (!this.item_has_child_editors) {
            holder = this.theme.getTableCell();
            row.appendChild(holder);
          }
          var ret = this.jsoneditor.createEditor(editor, {
            jsoneditor: this.jsoneditor,
            schema: schema_copy,
            container: holder,
            path: this.path + '.' + i,
            parent: this,
            compact: true,
            table_row: true
          });
          ret.preBuild();
          if (!ignore) {
            ret.build();
            ret.postBuild();
            ret.controls_cell = row.appendChild(this.theme.getTableCell());
            ret.row = row;
            ret.table_controls = this.theme.getButtonHolder();
            ret.controls_cell.appendChild(ret.table_controls);
            ret.table_controls.style.margin = 0;
            ret.table_controls.style.padding = 0;
          }
          return ret;
        },
        destroy: function() {
          this.innerHTML = '';
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.row_holder && this.row_holder.parentNode)
            this.row_holder.parentNode.removeChild(this.row_holder);
          if (this.table && this.table.parentNode)
            this.table.parentNode.removeChild(this.table);
          if (this.panel && this.panel.parentNode)
            this.panel.parentNode.removeChild(this.panel);
          this.rows = this.title = this.description = this.row_holder = this.table = this.panel = null;
          this._super();
        },
        setValue: function(value, initial) {
          value = value || [];
          if (this.schema.minItems) {
            while (value.length < this.schema.minItems) {
              value.push(this.getItemDefault());
            }
          }
          if (this.schema.maxItems && value.length > this.schema.maxItems) {
            value = value.slice(0, this.schema.maxItems);
          }
          var serialized = JSON.stringify(value);
          if (serialized === this.serialized)
            return;
          var numrows_changed = false;
          var self = this;
          $each(value, function(i, val) {
            if (self.rows[i]) {
              self.rows[i].setValue(val);
            } else {
              self.addRow(val);
              numrows_changed = true;
            }
          });
          for (var j = value.length; j < self.rows.length; j++) {
            var holder = self.rows[j].container;
            if (!self.item_has_child_editors) {
              self.rows[j].row.parentNode.removeChild(self.rows[j].row);
            }
            self.rows[j].destroy();
            if (holder.parentNode)
              holder.parentNode.removeChild(holder);
            self.rows[j] = null;
            numrows_changed = true;
          }
          self.rows = self.rows.slice(0, value.length);
          self.refreshValue();
          if (numrows_changed || initial)
            self.refreshRowButtons();
          self.onChange();
        },
        refreshRowButtons: function() {
          var self = this;
          var minItems = this.schema.minItems && this.schema.minItems >= this.rows.length;
          var need_row_buttons = false;
          $each(this.rows, function(i, editor) {
            if (editor.movedown_button) {
              if (i === self.rows.length - 1) {
                editor.movedown_button.style.display = 'none';
              } else {
                need_row_buttons = true;
                editor.movedown_button.style.display = '';
              }
            }
            if (editor.delete_button) {
              if (minItems) {
                editor.delete_button.style.display = 'none';
              } else {
                need_row_buttons = true;
                editor.delete_button.style.display = '';
              }
            }
            if (editor.moveup_button) {
              need_row_buttons = true;
            }
          });
          $each(this.rows, function(i, editor) {
            if (need_row_buttons) {
              editor.controls_cell.style.display = '';
            } else {
              editor.controls_cell.style.display = 'none';
            }
          });
          if (need_row_buttons) {
            this.controls_header_cell.style.display = '';
          } else {
            this.controls_header_cell.style.display = 'none';
          }
          var controls_needed = false;
          if (!this.value.length) {
            this.delete_last_row_button.style.display = 'none';
            this.remove_all_rows_button.style.display = 'none';
            this.table.style.display = 'none';
          } else if (this.value.length === 1) {
            this.table.style.display = '';
            this.remove_all_rows_button.style.display = 'none';
            if (minItems || this.hide_delete_last_row_buttons) {
              this.delete_last_row_button.style.display = 'none';
            } else {
              this.delete_last_row_button.style.display = '';
              controls_needed = true;
            }
          } else {
            this.table.style.display = '';
            if (minItems || this.hide_delete_last_row_buttons) {
              this.delete_last_row_button.style.display = 'none';
            } else {
              this.delete_last_row_button.style.display = '';
              controls_needed = true;
            }
            if (minItems || this.hide_delete_all_rows_buttons) {
              this.remove_all_rows_button.style.display = 'none';
            } else {
              this.remove_all_rows_button.style.display = '';
              controls_needed = true;
            }
          }
          if ((this.schema.maxItems && this.schema.maxItems <= this.rows.length) || this.hide_add_button) {
            this.add_row_button.style.display = 'none';
          } else {
            this.add_row_button.style.display = '';
            controls_needed = true;
          }
          if (!controls_needed) {
            this.controls.style.display = 'none';
          } else {
            this.controls.style.display = '';
          }
        },
        refreshValue: function() {
          var self = this;
          this.value = [];
          $each(this.rows, function(i, editor) {
            self.value[i] = editor.getValue();
          });
          this.serialized = JSON.stringify(this.value);
        },
        addRow: function(value) {
          var self = this;
          var i = this.rows.length;
          self.rows[i] = this.getElementEditor(i);
          var controls_holder = self.rows[i].table_controls;
          if (!this.hide_delete_buttons) {
            self.rows[i].delete_button = this.getButton('', 'delete', this.translate('button_delete_row_title_short'));
            self.rows[i].delete_button.className += ' delete';
            self.rows[i].delete_button.setAttribute('data-i', i);
            self.rows[i].delete_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              var value = self.getValue();
              var newval = [];
              $each(value, function(j, row) {
                if (j === i)
                  return;
                newval.push(row);
              });
              self.setValue(newval);
              self.onChange(true);
            });
            controls_holder.appendChild(self.rows[i].delete_button);
          }
          if (i && !this.hide_move_buttons) {
            self.rows[i].moveup_button = this.getButton('', 'moveup', this.translate('button_move_up_title'));
            self.rows[i].moveup_button.className += ' moveup';
            self.rows[i].moveup_button.setAttribute('data-i', i);
            self.rows[i].moveup_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              if (i <= 0)
                return;
              var rows = self.getValue();
              var tmp = rows[i - 1];
              rows[i - 1] = rows[i];
              rows[i] = tmp;
              self.setValue(rows);
              self.onChange(true);
            });
            controls_holder.appendChild(self.rows[i].moveup_button);
          }
          if (!this.hide_move_buttons) {
            self.rows[i].movedown_button = this.getButton('', 'movedown', this.translate('button_move_down_title'));
            self.rows[i].movedown_button.className += ' movedown';
            self.rows[i].movedown_button.setAttribute('data-i', i);
            self.rows[i].movedown_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              var i = this.getAttribute('data-i') * 1;
              var rows = self.getValue();
              if (i >= rows.length - 1)
                return;
              var tmp = rows[i + 1];
              rows[i + 1] = rows[i];
              rows[i] = tmp;
              self.setValue(rows);
              self.onChange(true);
            });
            controls_holder.appendChild(self.rows[i].movedown_button);
          }
          if (value)
            self.rows[i].setValue(value);
        },
        addControls: function() {
          var self = this;
          this.collapsed = false;
          this.toggle_button = this.getButton('', 'collapse', this.translate('button_collapse'));
          if (this.title_controls) {
            this.title_controls.appendChild(this.toggle_button);
            this.toggle_button.addEventListener('click', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (self.collapsed) {
                self.collapsed = false;
                self.panel.style.display = '';
                self.setButtonText(this, '', 'collapse', 'Collapse');
              } else {
                self.collapsed = true;
                self.panel.style.display = 'none';
                self.setButtonText(this, '', 'expand', 'Expand');
              }
            });
            if (this.options.collapsed) {
              $trigger(this.toggle_button, 'click');
            }
            if (this.schema.options && typeof this.schema.options.disable_collapse !== "undefined") {
              if (this.schema.options.disable_collapse)
                this.toggle_button.style.display = 'none';
            } else if (this.jsoneditor.options.disable_collapse) {
              this.toggle_button.style.display = 'none';
            }
          }
          this.add_row_button = this.getButton(this.getItemTitle(), 'add', this.translate('button_add_row_title', [this.getItemTitle()]));
          this.add_row_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.addRow();
            self.refreshValue();
            self.refreshRowButtons();
            self.onChange(true);
          });
          self.controls.appendChild(this.add_row_button);
          this.delete_last_row_button = this.getButton(this.translate('button_delete_last', [this.getItemTitle()]), 'delete', this.translate('button_delete_last_title', [this.getItemTitle()]));
          this.delete_last_row_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            var rows = self.getValue();
            rows.pop();
            self.setValue(rows);
            self.onChange(true);
          });
          self.controls.appendChild(this.delete_last_row_button);
          this.remove_all_rows_button = this.getButton(this.translate('button_delete_all'), 'delete', this.translate('button_delete_all_title'));
          this.remove_all_rows_button.addEventListener('click', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.setValue([]);
            self.onChange(true);
          });
          self.controls.appendChild(this.remove_all_rows_button);
        }
      });
      JSONEditor.defaults.editors.multiple = JSONEditor.AbstractEditor.extend({
        register: function() {
          if (this.editors) {
            for (var i = 0; i < this.editors.length; i++) {
              if (!this.editors[i])
                continue;
              this.editors[i].unregister();
            }
            if (this.editors[this.type])
              this.editors[this.type].register();
          }
          this._super();
        },
        unregister: function() {
          this._super();
          if (this.editors) {
            for (var i = 0; i < this.editors.length; i++) {
              if (!this.editors[i])
                continue;
              this.editors[i].unregister();
            }
          }
        },
        getNumColumns: function() {
          if (!this.editors[this.type])
            return 4;
          return Math.max(this.editors[this.type].getNumColumns(), 4);
        },
        enable: function() {
          if (this.editors) {
            for (var i = 0; i < this.editors.length; i++) {
              if (!this.editors[i])
                continue;
              this.editors[i].enable();
            }
          }
          this.switcher.disabled = false;
          this._super();
        },
        disable: function() {
          if (this.editors) {
            for (var i = 0; i < this.editors.length; i++) {
              if (!this.editors[i])
                continue;
              this.editors[i].disable();
            }
          }
          this.switcher.disabled = true;
          this._super();
        },
        switchEditor: function(i) {
          var self = this;
          if (!this.editors[i]) {
            this.buildChildEditor(i);
          }
          self.type = i;
          self.register();
          var current_value = self.getValue();
          $each(self.editors, function(type, editor) {
            if (!editor)
              return;
            if (self.type === type) {
              if (self.keep_values)
                editor.setValue(current_value, true);
              editor.container.style.display = '';
            } else
              editor.container.style.display = 'none';
          });
          self.refreshValue();
          self.refreshHeaderText();
        },
        buildChildEditor: function(i) {
          var self = this;
          var type = this.types[i];
          var holder = self.theme.getChildEditorHolder();
          self.editor_holder.appendChild(holder);
          var schema;
          if (typeof type === "string") {
            schema = $extend({}, self.schema);
            schema.type = type;
          } else {
            schema = $extend({}, self.schema, type);
            schema = self.jsoneditor.expandRefs(schema);
            if (type.required && Array.isArray(type.required) && self.schema.required && Array.isArray(self.schema.required)) {
              schema.required = self.schema.required.concat(type.required);
            }
          }
          var editor = self.jsoneditor.getEditorClass(schema);
          self.editors[i] = self.jsoneditor.createEditor(editor, {
            jsoneditor: self.jsoneditor,
            schema: schema,
            container: holder,
            path: self.path,
            parent: self,
            required: true
          });
          self.editors[i].preBuild();
          self.editors[i].build();
          self.editors[i].postBuild();
          if (self.editors[i].header)
            self.editors[i].header.style.display = 'none';
          self.editors[i].option = self.switcher_options[i];
          holder.addEventListener('change_header_text', function() {
            self.refreshHeaderText();
          });
          if (i !== self.type)
            holder.style.display = 'none';
        },
        preBuild: function() {
          var self = this;
          this.types = [];
          this.type = 0;
          this.editors = [];
          this.validators = [];
          this.keep_values = true;
          if (typeof this.jsoneditor.options.keep_oneof_values !== "undefined")
            this.keep_values = this.jsoneditor.options.keep_oneof_values;
          if (typeof this.options.keep_oneof_values !== "undefined")
            this.keep_values = this.options.keep_oneof_values;
          if (this.schema.oneOf) {
            this.oneOf = true;
            this.types = this.schema.oneOf;
            $each(this.types, function(i, oneof) {});
            delete this.schema.oneOf;
          } else {
            if (!this.schema.type || this.schema.type === "any") {
              this.types = ['string', 'number', 'integer', 'boolean', 'object', 'array', 'null'];
              if (this.schema.disallow) {
                var disallow = this.schema.disallow;
                if (typeof disallow !== 'object' || !(Array.isArray(disallow))) {
                  disallow = [disallow];
                }
                var allowed_types = [];
                $each(this.types, function(i, type) {
                  if (disallow.indexOf(type) === -1)
                    allowed_types.push(type);
                });
                this.types = allowed_types;
              }
            } else if (Array.isArray(this.schema.type)) {
              this.types = this.schema.type;
            } else {
              this.types = [this.schema.type];
            }
            delete this.schema.type;
          }
          this.display_text = this.getDisplayText(this.types);
        },
        build: function() {
          var self = this;
          var container = this.container;
          this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          this.container.appendChild(this.header);
          this.switcher = this.theme.getSwitcher(this.display_text);
          container.appendChild(this.switcher);
          this.switcher.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.switchEditor(self.display_text.indexOf(this.value));
            self.onChange(true);
          });
          this.editor_holder = document.createElement('div');
          container.appendChild(this.editor_holder);
          var validator_options = {};
          if (self.jsoneditor.options.custom_validators) {
            validator_options.custom_validators = self.jsoneditor.options.custom_validators;
          }
          this.switcher_options = this.theme.getSwitcherOptions(this.switcher);
          $each(this.types, function(i, type) {
            self.editors[i] = false;
            var schema;
            if (typeof type === "string") {
              schema = $extend({}, self.schema);
              schema.type = type;
            } else {
              schema = $extend({}, self.schema, type);
              if (type.required && Array.isArray(type.required) && self.schema.required && Array.isArray(self.schema.required)) {
                schema.required = self.schema.required.concat(type.required);
              }
            }
            self.validators[i] = new JSONEditor.Validator(self.jsoneditor, schema, validator_options);
          });
          this.switchEditor(0);
        },
        onChildEditorChange: function(editor) {
          if (this.editors[this.type]) {
            this.refreshValue();
            this.refreshHeaderText();
          }
          this._super();
        },
        refreshHeaderText: function() {
          var display_text = this.getDisplayText(this.types);
          $each(this.switcher_options, function(i, option) {
            option.textContent = display_text[i];
          });
        },
        refreshValue: function() {
          this.value = this.editors[this.type].getValue();
        },
        setValue: function(val, initial) {
          var self = this;
          $each(this.validators, function(i, validator) {
            if (!validator.validate(val).length) {
              self.type = i;
              self.switcher.value = self.display_text[i];
              return false;
            }
          });
          this.switchEditor(this.type);
          this.editors[this.type].setValue(val, initial);
          this.refreshValue();
          self.onChange();
        },
        destroy: function() {
          $each(this.editors, function(type, editor) {
            if (editor)
              editor.destroy();
          });
          if (this.editor_holder && this.editor_holder.parentNode)
            this.editor_holder.parentNode.removeChild(this.editor_holder);
          if (this.switcher && this.switcher.parentNode)
            this.switcher.parentNode.removeChild(this.switcher);
          this._super();
        },
        showValidationErrors: function(errors) {
          var self = this;
          if (this.oneOf) {
            $each(this.editors, function(i, editor) {
              if (!editor)
                return;
              var check = self.path + '.oneOf[' + i + ']';
              var new_errors = [];
              $each(errors, function(j, error) {
                if (error.path.substr(0, check.length) === check) {
                  var new_error = $extend({}, error);
                  new_error.path = self.path + new_error.path.substr(check.length);
                  new_errors.push(new_error);
                }
              });
              editor.showValidationErrors(new_errors);
            });
          } else {
            $each(this.editors, function(type, editor) {
              if (!editor)
                return;
              editor.showValidationErrors(errors);
            });
          }
        }
      });
      JSONEditor.defaults.editors["enum"] = JSONEditor.AbstractEditor.extend({
        getNumColumns: function() {
          return 4;
        },
        build: function() {
          var container = this.container;
          this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          this.container.appendChild(this.title);
          this.options.enum_titles = this.options.enum_titles || [];
          this["enum"] = this.schema["enum"];
          this.selected = 0;
          this.select_options = [];
          this.html_values = [];
          var self = this;
          for (var i = 0; i < this["enum"].length; i++) {
            this.select_options[i] = this.options.enum_titles[i] || "Value " + (i + 1);
            this.html_values[i] = this.getHTML(this["enum"][i]);
          }
          this.switcher = this.theme.getSwitcher(this.select_options);
          this.container.appendChild(this.switcher);
          this.display_area = this.theme.getIndentedPanel();
          this.container.appendChild(this.display_area);
          if (this.options.hide_display)
            this.display_area.style.display = "none";
          this.switcher.addEventListener('change', function() {
            self.selected = self.select_options.indexOf(this.value);
            self.value = self["enum"][self.selected];
            self.refreshValue();
            self.onChange(true);
          });
          this.value = this["enum"][0];
          this.refreshValue();
          if (this["enum"].length === 1)
            this.switcher.style.display = 'none';
        },
        refreshValue: function() {
          var self = this;
          self.selected = -1;
          var stringified = JSON.stringify(this.value);
          $each(this["enum"], function(i, el) {
            if (stringified === JSON.stringify(el)) {
              self.selected = i;
              return false;
            }
          });
          if (self.selected < 0) {
            self.setValue(self["enum"][0]);
            return;
          }
          this.switcher.value = this.select_options[this.selected];
          this.display_area.innerHTML = this.html_values[this.selected];
        },
        enable: function() {
          if (!this.always_disabled)
            this.switcher.disabled = false;
          this._super();
        },
        disable: function() {
          this.switcher.disabled = true;
          this._super();
        },
        getHTML: function(el) {
          var self = this;
          if (el === null) {
            return '<em>null</em>';
          } else if (typeof el === "object") {
            var ret = '';
            $each(el, function(i, child) {
              var html = self.getHTML(child);
              if (!(Array.isArray(el))) {
                html = '<div><em>' + i + '</em>: ' + html + '</div>';
              }
              ret += '<li>' + html + '</li>';
            });
            if (Array.isArray(el))
              ret = '<ol>' + ret + '</ol>';
            else
              ret = "<ul style='margin-top:0;margin-bottom:0;padding-top:0;padding-bottom:0;'>" + ret + '</ul>';
            return ret;
          } else if (typeof el === "boolean") {
            return el ? 'true' : 'false';
          } else if (typeof el === "string") {
            return el.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
          } else {
            return el;
          }
        },
        setValue: function(val) {
          if (this.value !== val) {
            this.value = val;
            this.refreshValue();
            this.onChange();
          }
        },
        destroy: function() {
          if (this.display_area && this.display_area.parentNode)
            this.display_area.parentNode.removeChild(this.display_area);
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.switcher && this.switcher.parentNode)
            this.switcher.parentNode.removeChild(this.switcher);
          this._super();
        }
      });
      JSONEditor.defaults.editors.select = JSONEditor.AbstractEditor.extend({
        setValue: function(value, initial) {
          value = this.typecast(value || '');
          var sanitized = value;
          if (this.enum_values.indexOf(sanitized) < 0) {
            sanitized = this.enum_values[0];
          }
          if (this.value === sanitized) {
            return;
          }
          this.input.value = this.enum_options[this.enum_values.indexOf(sanitized)];
          if (this.select2)
            this.select2.select2('val', this.input.value);
          this.value = sanitized;
          this.onChange();
        },
        register: function() {
          this._super();
          if (!this.input)
            return;
          this.input.setAttribute('name', this.formname);
        },
        unregister: function() {
          this._super();
          if (!this.input)
            return;
          this.input.removeAttribute('name');
        },
        getNumColumns: function() {
          if (!this.enum_options)
            return 3;
          var longest_text = this.getTitle().length;
          for (var i = 0; i < this.enum_options.length; i++) {
            longest_text = Math.max(longest_text, this.enum_options[i].length + 4);
          }
          return Math.min(12, Math.max(longest_text / 7, 2));
        },
        typecast: function(value) {
          if (this.schema.type === "boolean") {
            return !!value;
          } else if (this.schema.type === "number") {
            return 1 * value;
          } else if (this.schema.type === "integer") {
            return Math.floor(value * 1);
          } else {
            return "" + value;
          }
        },
        getValue: function() {
          return this.value;
        },
        preBuild: function() {
          var self = this;
          this.input_type = 'select';
          this.enum_options = [];
          this.enum_values = [];
          this.enum_display = [];
          if (this.schema["enum"]) {
            var display = this.schema.options && this.schema.options.enum_titles || [];
            $each(this.schema["enum"], function(i, option) {
              self.enum_options[i] = "" + option;
              self.enum_display[i] = "" + (display[i] || option);
              self.enum_values[i] = self.typecast(option);
            });
            if (!this.isRequired()) {
              self.enum_display.unshift(' ');
              self.enum_options.unshift('undefined');
              self.enum_values.unshift(undefined);
            }
          } else if (this.schema.type === "boolean") {
            self.enum_display = this.schema.options && this.schema.options.enum_titles || ['true', 'false'];
            self.enum_options = ['1', ''];
            self.enum_values = [true, false];
            if (!this.isRequired()) {
              self.enum_display.unshift(' ');
              self.enum_options.unshift('undefined');
              self.enum_values.unshift(undefined);
            }
          } else if (this.schema.enumSource) {
            this.enumSource = [];
            this.enum_display = [];
            this.enum_options = [];
            this.enum_values = [];
            if (!(Array.isArray(this.schema.enumSource))) {
              if (this.schema.enumValue) {
                this.enumSource = [{
                  source: this.schema.enumSource,
                  value: this.schema.enumValue
                }];
              } else {
                this.enumSource = [{source: this.schema.enumSource}];
              }
            } else {
              for (i = 0; i < this.schema.enumSource.length; i++) {
                if (typeof this.schema.enumSource[i] === "string") {
                  this.enumSource[i] = {source: this.schema.enumSource[i]};
                } else if (!(Array.isArray(this.schema.enumSource[i]))) {
                  this.enumSource[i] = $extend({}, this.schema.enumSource[i]);
                } else {
                  this.enumSource[i] = this.schema.enumSource[i];
                }
              }
            }
            for (i = 0; i < this.enumSource.length; i++) {
              if (this.enumSource[i].value) {
                this.enumSource[i].value = this.jsoneditor.compileTemplate(this.enumSource[i].value, this.template_engine);
              }
              if (this.enumSource[i].title) {
                this.enumSource[i].title = this.jsoneditor.compileTemplate(this.enumSource[i].title, this.template_engine);
              }
              if (this.enumSource[i].filter) {
                this.enumSource[i].filter = this.jsoneditor.compileTemplate(this.enumSource[i].filter, this.template_engine);
              }
            }
          } else {
            throw "'select' editor requires the enum property to be set.";
          }
        },
        build: function() {
          var self = this;
          if (!this.options.compact)
            this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          if (this.schema.description)
            this.description = this.theme.getFormInputDescription(this.schema.description);
          if (this.options.compact)
            this.container.className += ' compact';
          this.input = this.theme.getSelectInput(this.enum_options);
          this.theme.setSelectOptions(this.input, this.enum_options, this.enum_display);
          if (this.schema.readOnly || this.schema.readonly) {
            this.always_disabled = true;
            this.input.disabled = true;
          }
          this.input.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.onInputChange();
          });
          this.control = this.theme.getFormControl(this.label, this.input, this.description);
          this.container.appendChild(this.control);
          this.value = this.enum_values[0];
        },
        onInputChange: function() {
          var val = this.input.value;
          var new_val;
          if (this.enum_options.indexOf(val) === -1) {
            new_val = this.enum_values[0];
          } else {
            new_val = this.enum_values[this.enum_options.indexOf(val)];
          }
          if (new_val === this.value)
            return;
          this.value = new_val;
          this.onChange(true);
        },
        setupSelect2: function() {
          if (window.jQuery && window.jQuery.fn && window.jQuery.fn.select2 && (this.enum_options.length > 2 || (this.enum_options.length && this.enumSource))) {
            var options = $extend({}, JSONEditor.plugins.select2);
            if (this.schema.options && this.schema.options.select2_options)
              options = $extend(options, this.schema.options.select2_options);
            this.select2 = window.jQuery(this.input).select2(options);
            var self = this;
            this.select2.on('select2-blur', function() {
              self.input.value = self.select2.select2('val');
              self.onInputChange();
            });
            this.select2.on('change', function() {
              self.input.value = self.select2.select2('val');
              self.onInputChange();
            });
          } else {
            this.select2 = null;
          }
        },
        postBuild: function() {
          this._super();
          this.theme.afterInputReady(this.input);
          this.setupSelect2();
        },
        onWatchedFieldChange: function() {
          var self = this,
              vars,
              j;
          if (this.enumSource) {
            vars = this.getWatchedFieldValues();
            var select_options = [];
            var select_titles = [];
            for (var i = 0; i < this.enumSource.length; i++) {
              if (Array.isArray(this.enumSource[i])) {
                select_options = select_options.concat(this.enumSource[i]);
                select_titles = select_titles.concat(this.enumSource[i]);
              } else {
                var items = [];
                if (Array.isArray(this.enumSource[i].source)) {
                  items = this.enumSource[i].source;
                } else {
                  items = vars[this.enumSource[i].source];
                }
                if (items) {
                  if (this.enumSource[i].slice) {
                    items = Array.prototype.slice.apply(items, this.enumSource[i].slice);
                  }
                  if (this.enumSource[i].filter) {
                    var new_items = [];
                    for (j = 0; j < items.length; j++) {
                      if (this.enumSource[i].filter({
                        i: j,
                        item: items[j],
                        watched: vars
                      }))
                        new_items.push(items[j]);
                    }
                    items = new_items;
                  }
                  var item_titles = [];
                  var item_values = [];
                  for (j = 0; j < items.length; j++) {
                    var item = items[j];
                    if (this.enumSource[i].value) {
                      item_values[j] = this.enumSource[i].value({
                        i: j,
                        item: item
                      });
                    } else {
                      item_values[j] = items[j];
                    }
                    if (this.enumSource[i].title) {
                      item_titles[j] = this.enumSource[i].title({
                        i: j,
                        item: item
                      });
                    } else {
                      item_titles[j] = item_values[j];
                    }
                  }
                  select_options = select_options.concat(item_values);
                  select_titles = select_titles.concat(item_titles);
                }
              }
            }
            var prev_value = this.value;
            this.theme.setSelectOptions(this.input, select_options, select_titles);
            this.enum_options = select_options;
            this.enum_display = select_titles;
            this.enum_values = select_options;
            if (this.select2) {
              this.select2.select2('destroy');
            }
            if (select_options.indexOf(prev_value) !== -1) {
              this.input.value = prev_value;
              this.value = prev_value;
            } else {
              this.input.value = select_options[0];
              this.value = select_options[0] || "";
              if (this.parent)
                this.parent.onChildEditorChange(this);
              else
                this.jsoneditor.onChange();
              this.jsoneditor.notifyWatchers(this.path);
            }
            this.setupSelect2();
          }
          this._super();
        },
        enable: function() {
          if (!this.always_disabled) {
            this.input.disabled = false;
            if (this.select2)
              this.select2.select2("enable", true);
          }
          this._super();
        },
        disable: function() {
          this.input.disabled = true;
          if (this.select2)
            this.select2.select2("enable", false);
          this._super();
        },
        destroy: function() {
          if (this.label && this.label.parentNode)
            this.label.parentNode.removeChild(this.label);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          if (this.select2) {
            this.select2.select2('destroy');
            this.select2 = null;
          }
          this._super();
        }
      });
      JSONEditor.defaults.editors.selectize = JSONEditor.AbstractEditor.extend({
        setValue: function(value, initial) {
          value = this.typecast(value || '');
          var sanitized = value;
          if (this.enum_values.indexOf(sanitized) < 0) {
            sanitized = this.enum_values[0];
          }
          if (this.value === sanitized) {
            return;
          }
          this.input.value = this.enum_options[this.enum_values.indexOf(sanitized)];
          if (this.selectize) {
            this.selectize[0].selectize.addItem(sanitized);
          }
          this.value = sanitized;
          this.onChange();
        },
        register: function() {
          this._super();
          if (!this.input)
            return;
          this.input.setAttribute('name', this.formname);
        },
        unregister: function() {
          this._super();
          if (!this.input)
            return;
          this.input.removeAttribute('name');
        },
        getNumColumns: function() {
          if (!this.enum_options)
            return 3;
          var longest_text = this.getTitle().length;
          for (var i = 0; i < this.enum_options.length; i++) {
            longest_text = Math.max(longest_text, this.enum_options[i].length + 4);
          }
          return Math.min(12, Math.max(longest_text / 7, 2));
        },
        typecast: function(value) {
          if (this.schema.type === "boolean") {
            return !!value;
          } else if (this.schema.type === "number") {
            return 1 * value;
          } else if (this.schema.type === "integer") {
            return Math.floor(value * 1);
          } else {
            return "" + value;
          }
        },
        getValue: function() {
          return this.value;
        },
        preBuild: function() {
          var self = this;
          this.input_type = 'select';
          this.enum_options = [];
          this.enum_values = [];
          this.enum_display = [];
          if (this.schema.enum) {
            var display = this.schema.options && this.schema.options.enum_titles || [];
            $each(this.schema.enum, function(i, option) {
              self.enum_options[i] = "" + option;
              self.enum_display[i] = "" + (display[i] || option);
              self.enum_values[i] = self.typecast(option);
            });
          } else if (this.schema.type === "boolean") {
            self.enum_display = this.schema.options && this.schema.options.enum_titles || ['true', 'false'];
            self.enum_options = ['1', '0'];
            self.enum_values = [true, false];
          } else if (this.schema.enumSource) {
            this.enumSource = [];
            this.enum_display = [];
            this.enum_options = [];
            this.enum_values = [];
            if (!(Array.isArray(this.schema.enumSource))) {
              if (this.schema.enumValue) {
                this.enumSource = [{
                  source: this.schema.enumSource,
                  value: this.schema.enumValue
                }];
              } else {
                this.enumSource = [{source: this.schema.enumSource}];
              }
            } else {
              for (i = 0; i < this.schema.enumSource.length; i++) {
                if (typeof this.schema.enumSource[i] === "string") {
                  this.enumSource[i] = {source: this.schema.enumSource[i]};
                } else if (!(Array.isArray(this.schema.enumSource[i]))) {
                  this.enumSource[i] = $extend({}, this.schema.enumSource[i]);
                } else {
                  this.enumSource[i] = this.schema.enumSource[i];
                }
              }
            }
            for (i = 0; i < this.enumSource.length; i++) {
              if (this.enumSource[i].value) {
                this.enumSource[i].value = this.jsoneditor.compileTemplate(this.enumSource[i].value, this.template_engine);
              }
              if (this.enumSource[i].title) {
                this.enumSource[i].title = this.jsoneditor.compileTemplate(this.enumSource[i].title, this.template_engine);
              }
              if (this.enumSource[i].filter) {
                this.enumSource[i].filter = this.jsoneditor.compileTemplate(this.enumSource[i].filter, this.template_engine);
              }
            }
          } else {
            throw "'select' editor requires the enum property to be set.";
          }
        },
        build: function() {
          var self = this;
          if (!this.options.compact)
            this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          if (this.schema.description)
            this.description = this.theme.getFormInputDescription(this.schema.description);
          if (this.options.compact)
            this.container.className += ' compact';
          this.input = this.theme.getSelectInput(this.enum_options);
          this.theme.setSelectOptions(this.input, this.enum_options, this.enum_display);
          if (this.schema.readOnly || this.schema.readonly) {
            this.always_disabled = true;
            this.input.disabled = true;
          }
          this.input.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.onInputChange();
          });
          this.control = this.theme.getFormControl(this.label, this.input, this.description);
          this.container.appendChild(this.control);
          this.value = this.enum_values[0];
        },
        onInputChange: function() {
          var val = this.input.value;
          var sanitized = val;
          if (this.enum_options.indexOf(val) === -1) {
            sanitized = this.enum_options[0];
          }
          this.value = this.enum_values[this.enum_options.indexOf(val)];
          this.onChange(true);
        },
        setupSelectize: function() {
          var self = this;
          if (window.jQuery && window.jQuery.fn && window.jQuery.fn.selectize && (this.enum_options.length >= 2 || (this.enum_options.length && this.enumSource))) {
            var options = $extend({}, JSONEditor.plugins.selectize);
            if (this.schema.options && this.schema.options.selectize_options)
              options = $extend(options, this.schema.options.selectize_options);
            this.selectize = window.jQuery(this.input).selectize($extend(options, {
              create: true,
              onChange: function() {
                self.onInputChange();
              }
            }));
          } else {
            this.selectize = null;
          }
        },
        postBuild: function() {
          this._super();
          this.theme.afterInputReady(this.input);
          this.setupSelectize();
        },
        onWatchedFieldChange: function() {
          var self = this,
              vars,
              j;
          if (this.enumSource) {
            vars = this.getWatchedFieldValues();
            var select_options = [];
            var select_titles = [];
            for (var i = 0; i < this.enumSource.length; i++) {
              if (Array.isArray(this.enumSource[i])) {
                select_options = select_options.concat(this.enumSource[i]);
                select_titles = select_titles.concat(this.enumSource[i]);
              } else if (vars[this.enumSource[i].source]) {
                var items = vars[this.enumSource[i].source];
                if (this.enumSource[i].slice) {
                  items = Array.prototype.slice.apply(items, this.enumSource[i].slice);
                }
                if (this.enumSource[i].filter) {
                  var new_items = [];
                  for (j = 0; j < items.length; j++) {
                    if (this.enumSource[i].filter({
                      i: j,
                      item: items[j]
                    }))
                      new_items.push(items[j]);
                  }
                  items = new_items;
                }
                var item_titles = [];
                var item_values = [];
                for (j = 0; j < items.length; j++) {
                  var item = items[j];
                  if (this.enumSource[i].value) {
                    item_values[j] = this.enumSource[i].value({
                      i: j,
                      item: item
                    });
                  } else {
                    item_values[j] = items[j];
                  }
                  if (this.enumSource[i].title) {
                    item_titles[j] = this.enumSource[i].title({
                      i: j,
                      item: item
                    });
                  } else {
                    item_titles[j] = item_values[j];
                  }
                }
                select_options = select_options.concat(item_values);
                select_titles = select_titles.concat(item_titles);
              }
            }
            var prev_value = this.value;
            this.theme.setSelectOptions(this.input, select_options, select_titles);
            this.enum_options = select_options;
            this.enum_display = select_titles;
            this.enum_values = select_options;
            if (select_options.indexOf(prev_value) !== -1) {
              this.input.value = prev_value;
              this.value = prev_value;
            } else {
              this.input.value = select_options[0];
              this.value = select_options[0] || "";
              if (this.parent)
                this.parent.onChildEditorChange(this);
              else
                this.jsoneditor.onChange();
              this.jsoneditor.notifyWatchers(this.path);
            }
            if (this.selectize) {
              this.updateSelectizeOptions(select_options);
            } else {
              this.setupSelectize();
            }
            this._super();
          }
        },
        updateSelectizeOptions: function(select_options) {
          var selectized = this.selectize[0].selectize,
              self = this;
          selectized.off();
          selectized.clearOptions();
          for (var n in select_options) {
            selectized.addOption({
              value: select_options[n],
              text: select_options[n]
            });
          }
          selectized.addItem(this.value);
          selectized.on('change', function() {
            self.onInputChange();
          });
        },
        enable: function() {
          if (!this.always_disabled) {
            this.input.disabled = false;
            if (this.selectize) {
              this.selectize[0].selectize.unlock();
            }
          }
          this._super();
        },
        disable: function() {
          this.input.disabled = true;
          if (this.selectize) {
            this.selectize[0].selectize.lock();
          }
          this._super();
        },
        destroy: function() {
          if (this.label && this.label.parentNode)
            this.label.parentNode.removeChild(this.label);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          if (this.selectize) {
            this.selectize[0].selectize.destroy();
            this.selectize = null;
          }
          this._super();
        }
      });
      JSONEditor.defaults.editors.multiselect = JSONEditor.AbstractEditor.extend({
        preBuild: function() {
          this._super();
          this.select_options = {};
          this.select_values = {};
          var items_schema = this.jsoneditor.expandRefs(this.schema.items || {});
          var e = items_schema["enum"] || [];
          this.option_keys = [];
          for (i = 0; i < e.length; i++) {
            if (this.sanitize(e[i]) !== e[i])
              continue;
            this.option_keys.push(e[i] + "");
            this.select_values[e[i] + ""] = e[i];
          }
        },
        build: function() {
          var self = this,
              i;
          if (!this.options.compact)
            this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          if (this.schema.description)
            this.description = this.theme.getFormInputDescription(this.schema.description);
          if ((!this.schema.format && this.option_keys.length < 8) || this.schema.format === "checkbox") {
            this.input_type = 'checkboxes';
            this.inputs = {};
            this.controls = {};
            for (i = 0; i < this.option_keys.length; i++) {
              this.inputs[this.option_keys[i]] = this.theme.getCheckbox();
              this.select_options[this.option_keys[i]] = this.inputs[this.option_keys[i]];
              var label = this.theme.getCheckboxLabel(this.option_keys[i]);
              this.controls[this.option_keys[i]] = this.theme.getFormControl(label, this.inputs[this.option_keys[i]]);
            }
            this.control = this.theme.getMultiCheckboxHolder(this.controls, this.label, this.description);
          } else {
            this.input_type = 'select';
            this.input = this.theme.getSelectInput(this.option_keys);
            this.input.multiple = true;
            this.input.size = Math.min(10, this.option_keys.length);
            for (i = 0; i < this.option_keys.length; i++) {
              this.select_options[this.option_keys[i]] = this.input.children[i];
            }
            if (this.schema.readOnly || this.schema.readonly) {
              this.always_disabled = true;
              this.input.disabled = true;
            }
            this.control = this.theme.getFormControl(this.label, this.input, this.description);
          }
          this.container.appendChild(this.control);
          this.control.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            var new_value = [];
            for (i = 0; i < self.option_keys.length; i++) {
              if (self.select_options[self.option_keys[i]].selected || self.select_options[self.option_keys[i]].checked)
                new_value.push(self.select_values[self.option_keys[i]]);
            }
            self.updateValue(new_value);
            self.onChange(true);
          });
        },
        setValue: function(value, initial) {
          var i;
          value = value || [];
          if (typeof value !== "object")
            value = [value];
          else if (!(Array.isArray(value)))
            value = [];
          for (i = 0; i < value.length; i++) {
            if (typeof value[i] !== "string")
              value[i] += "";
          }
          for (i in this.select_options) {
            if (!this.select_options.hasOwnProperty(i))
              continue;
            this.select_options[i][this.input_type === "select" ? "selected" : "checked"] = (value.indexOf(i) !== -1);
          }
          this.updateValue(value);
          this.onChange();
        },
        setupSelect2: function() {
          if (window.jQuery && window.jQuery.fn && window.jQuery.fn.select2) {
            var options = window.jQuery.extend({}, JSONEditor.plugins.select2);
            if (this.schema.options && this.schema.options.select2_options)
              options = $extend(options, this.schema.options.select2_options);
            this.select2 = window.jQuery(this.input).select2(options);
            var self = this;
            this.select2.on('select2-blur', function() {
              var val = self.select2.select2('val');
              self.value = val;
              self.onChange(true);
            });
          } else {
            this.select2 = null;
          }
        },
        onInputChange: function() {
          this.value = this.input.value;
          this.onChange(true);
        },
        postBuild: function() {
          this._super();
          this.setupSelect2();
        },
        register: function() {
          this._super();
          if (!this.input)
            return;
          this.input.setAttribute('name', this.formname);
        },
        unregister: function() {
          this._super();
          if (!this.input)
            return;
          this.input.removeAttribute('name');
        },
        getNumColumns: function() {
          var longest_text = this.getTitle().length;
          for (var i in this.select_values) {
            if (!this.select_values.hasOwnProperty(i))
              continue;
            longest_text = Math.max(longest_text, (this.select_values[i] + "").length + 4);
          }
          return Math.min(12, Math.max(longest_text / 7, 2));
        },
        updateValue: function(value) {
          var changed = false;
          var new_value = [];
          for (var i = 0; i < value.length; i++) {
            if (!this.select_options[value[i] + ""]) {
              changed = true;
              continue;
            }
            var sanitized = this.sanitize(this.select_values[value[i]]);
            new_value.push(sanitized);
            if (sanitized !== value[i])
              changed = true;
          }
          this.value = new_value;
          if (this.select2)
            this.select2.select2('val', this.value);
          return changed;
        },
        sanitize: function(value) {
          if (this.schema.items.type === "number") {
            return 1 * value;
          } else if (this.schema.items.type === "integer") {
            return Math.floor(value * 1);
          } else {
            return "" + value;
          }
        },
        enable: function() {
          if (!this.always_disabled) {
            if (this.input) {
              this.input.disabled = false;
            } else if (this.inputs) {
              for (var i in this.inputs) {
                if (!this.inputs.hasOwnProperty(i))
                  continue;
                this.inputs[i].disabled = false;
              }
            }
            if (this.select2)
              this.select2.select2("enable", true);
          }
          this._super();
        },
        disable: function() {
          if (this.input) {
            this.input.disabled = true;
          } else if (this.inputs) {
            for (var i in this.inputs) {
              if (!this.inputs.hasOwnProperty(i))
                continue;
              this.inputs[i].disabled = true;
            }
          }
          if (this.select2)
            this.select2.select2("enable", false);
          this._super();
        },
        destroy: function() {
          if (this.select2) {
            this.select2.select2('destroy');
            this.select2 = null;
          }
          this._super();
        }
      });
      JSONEditor.defaults.editors.base64 = JSONEditor.AbstractEditor.extend({
        getNumColumns: function() {
          return 4;
        },
        build: function() {
          var self = this;
          this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          this.input = this.theme.getFormInputField('hidden');
          this.container.appendChild(this.input);
          if (!this.schema.readOnly && !this.schema.readonly) {
            if (!window.FileReader)
              throw "FileReader required for base64 editor";
            this.uploader = this.theme.getFormInputField('file');
            this.uploader.addEventListener('change', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (this.files && this.files.length) {
                var fr = new FileReader();
                fr.onload = function(evt) {
                  self.value = evt.target.result;
                  self.refreshPreview();
                  self.onChange(true);
                  fr = null;
                };
                fr.readAsDataURL(this.files[0]);
              }
            });
          }
          this.preview = this.theme.getFormInputDescription(this.schema.description);
          this.container.appendChild(this.preview);
          this.control = this.theme.getFormControl(this.label, this.uploader || this.input, this.preview);
          this.container.appendChild(this.control);
        },
        refreshPreview: function() {
          if (this.last_preview === this.value)
            return;
          this.last_preview = this.value;
          this.preview.innerHTML = '';
          if (!this.value)
            return;
          var mime = this.value.match(/^data:([^;,]+)[;,]/);
          if (mime)
            mime = mime[1];
          if (!mime) {
            this.preview.innerHTML = '<em>Invalid data URI</em>';
          } else {
            this.preview.innerHTML = '<strong>Type:</strong> ' + mime + ', <strong>Size:</strong> ' + Math.floor((this.value.length - this.value.split(',')[0].length - 1) / 1.33333) + ' bytes';
            if (mime.substr(0, 5) === "image") {
              this.preview.innerHTML += '<br>';
              var img = document.createElement('img');
              img.style.maxWidth = '100%';
              img.style.maxHeight = '100px';
              img.src = this.value;
              this.preview.appendChild(img);
            }
          }
        },
        enable: function() {
          if (this.uploader)
            this.uploader.disabled = false;
          this._super();
        },
        disable: function() {
          if (this.uploader)
            this.uploader.disabled = true;
          this._super();
        },
        setValue: function(val) {
          if (this.value !== val) {
            this.value = val;
            this.input.value = this.value;
            this.refreshPreview();
            this.onChange();
          }
        },
        destroy: function() {
          if (this.preview && this.preview.parentNode)
            this.preview.parentNode.removeChild(this.preview);
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          if (this.uploader && this.uploader.parentNode)
            this.uploader.parentNode.removeChild(this.uploader);
          this._super();
        }
      });
      JSONEditor.defaults.editors.upload = JSONEditor.AbstractEditor.extend({
        getNumColumns: function() {
          return 4;
        },
        build: function() {
          var self = this;
          this.title = this.header = this.label = this.theme.getFormInputLabel(this.getTitle());
          this.input = this.theme.getFormInputField('hidden');
          this.container.appendChild(this.input);
          if (!this.schema.readOnly && !this.schema.readonly) {
            if (!this.jsoneditor.options.upload)
              throw "Upload handler required for upload editor";
            this.uploader = this.theme.getFormInputField('file');
            this.uploader.addEventListener('change', function(e) {
              e.preventDefault();
              e.stopPropagation();
              if (this.files && this.files.length) {
                var fr = new FileReader();
                fr.onload = function(evt) {
                  self.preview_value = evt.target.result;
                  self.refreshPreview();
                  self.onChange(true);
                  fr = null;
                };
                fr.readAsDataURL(this.files[0]);
              }
            });
          }
          var description = this.schema.description;
          if (!description)
            description = '';
          this.preview = this.theme.getFormInputDescription(description);
          this.container.appendChild(this.preview);
          this.control = this.theme.getFormControl(this.label, this.uploader || this.input, this.preview);
          this.container.appendChild(this.control);
        },
        refreshPreview: function() {
          if (this.last_preview === this.preview_value)
            return;
          this.last_preview = this.preview_value;
          this.preview.innerHTML = '';
          if (!this.preview_value)
            return;
          var self = this;
          var mime = this.preview_value.match(/^data:([^;,]+)[;,]/);
          if (mime)
            mime = mime[1];
          if (!mime)
            mime = 'unknown';
          var file = this.uploader.files[0];
          this.preview.innerHTML = '<strong>Type:</strong> ' + mime + ', <strong>Size:</strong> ' + file.size + ' bytes';
          if (mime.substr(0, 5) === "image") {
            this.preview.innerHTML += '<br>';
            var img = document.createElement('img');
            img.style.maxWidth = '100%';
            img.style.maxHeight = '100px';
            img.src = this.preview_value;
            this.preview.appendChild(img);
          }
          this.preview.innerHTML += '<br>';
          var uploadButton = this.getButton('Upload', 'upload', 'Upload');
          this.preview.appendChild(uploadButton);
          uploadButton.addEventListener('click', function(event) {
            event.preventDefault();
            uploadButton.setAttribute("disabled", "disabled");
            self.theme.removeInputError(self.uploader);
            if (self.theme.getProgressBar) {
              self.progressBar = self.theme.getProgressBar();
              self.preview.appendChild(self.progressBar);
            }
            self.jsoneditor.options.upload(self.path, file, {
              success: function(url) {
                self.setValue(url);
                if (self.parent)
                  self.parent.onChildEditorChange(self);
                else
                  self.jsoneditor.onChange();
                if (self.progressBar)
                  self.preview.removeChild(self.progressBar);
                uploadButton.removeAttribute("disabled");
              },
              failure: function(error) {
                self.theme.addInputError(self.uploader, error);
                if (self.progressBar)
                  self.preview.removeChild(self.progressBar);
                uploadButton.removeAttribute("disabled");
              },
              updateProgress: function(progress) {
                if (self.progressBar) {
                  if (progress)
                    self.theme.updateProgressBar(self.progressBar, progress);
                  else
                    self.theme.updateProgressBarUnknown(self.progressBar);
                }
              }
            });
          });
        },
        enable: function() {
          if (this.uploader)
            this.uploader.disabled = false;
          this._super();
        },
        disable: function() {
          if (this.uploader)
            this.uploader.disabled = true;
          this._super();
        },
        setValue: function(val) {
          if (this.value !== val) {
            this.value = val;
            this.input.value = this.value;
            this.onChange();
          }
        },
        destroy: function() {
          if (this.preview && this.preview.parentNode)
            this.preview.parentNode.removeChild(this.preview);
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          if (this.uploader && this.uploader.parentNode)
            this.uploader.parentNode.removeChild(this.uploader);
          this._super();
        }
      });
      JSONEditor.defaults.editors.checkbox = JSONEditor.AbstractEditor.extend({
        setValue: function(value, initial) {
          this.value = !!value;
          this.input.checked = this.value;
          this.onChange();
        },
        register: function() {
          this._super();
          if (!this.input)
            return;
          this.input.setAttribute('name', this.formname);
        },
        unregister: function() {
          this._super();
          if (!this.input)
            return;
          this.input.removeAttribute('name');
        },
        getNumColumns: function() {
          return Math.min(12, Math.max(this.getTitle().length / 7, 2));
        },
        build: function() {
          var self = this;
          if (!this.options.compact) {
            this.label = this.header = this.theme.getCheckboxLabel(this.getTitle());
          }
          if (this.schema.description)
            this.description = this.theme.getFormInputDescription(this.schema.description);
          if (this.options.compact)
            this.container.className += ' compact';
          this.input = this.theme.getCheckbox();
          this.control = this.theme.getFormControl(this.label, this.input, this.description);
          if (this.schema.readOnly || this.schema.readonly) {
            this.always_disabled = true;
            this.input.disabled = true;
          }
          this.input.addEventListener('change', function(e) {
            e.preventDefault();
            e.stopPropagation();
            self.value = this.checked;
            self.onChange(true);
          });
          this.container.appendChild(this.control);
        },
        enable: function() {
          if (!this.always_disabled) {
            this.input.disabled = false;
          }
          this._super();
        },
        disable: function() {
          this.input.disabled = true;
          this._super();
        },
        destroy: function() {
          if (this.label && this.label.parentNode)
            this.label.parentNode.removeChild(this.label);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          this._super();
        }
      });
      JSONEditor.defaults.editors.arraySelectize = JSONEditor.AbstractEditor.extend({
        build: function() {
          this.title = this.theme.getFormInputLabel(this.getTitle());
          this.title_controls = this.theme.getHeaderButtonHolder();
          this.title.appendChild(this.title_controls);
          this.error_holder = document.createElement('div');
          if (this.schema.description) {
            this.description = this.theme.getDescription(this.schema.description);
          }
          this.input = document.createElement('select');
          this.input.setAttribute('multiple', 'multiple');
          var group = this.theme.getFormControl(this.title, this.input, this.description);
          this.container.appendChild(group);
          this.container.appendChild(this.error_holder);
          window.jQuery(this.input).selectize({
            delimiter: false,
            createOnBlur: true,
            create: true
          });
        },
        postBuild: function() {
          var self = this;
          this.input.selectize.on('change', function(event) {
            self.refreshValue();
            self.onChange(true);
          });
        },
        destroy: function() {
          this.empty(true);
          if (this.title && this.title.parentNode)
            this.title.parentNode.removeChild(this.title);
          if (this.description && this.description.parentNode)
            this.description.parentNode.removeChild(this.description);
          if (this.input && this.input.parentNode)
            this.input.parentNode.removeChild(this.input);
          this._super();
        },
        empty: function(hard) {},
        setValue: function(value, initial) {
          var self = this;
          value = value || [];
          if (!(Array.isArray(value)))
            value = [value];
          this.input.selectize.clearOptions();
          this.input.selectize.clear(true);
          value.forEach(function(item) {
            self.input.selectize.addOption({
              text: item,
              value: item
            });
          });
          this.input.selectize.setValue(value);
          this.refreshValue(initial);
        },
        refreshValue: function(force) {
          this.value = this.input.selectize.getValue();
        },
        showValidationErrors: function(errors) {
          var self = this;
          var my_errors = [];
          var other_errors = [];
          $each(errors, function(i, error) {
            if (error.path === self.path) {
              my_errors.push(error);
            } else {
              other_errors.push(error);
            }
          });
          if (this.error_holder) {
            if (my_errors.length) {
              var message = [];
              this.error_holder.innerHTML = '';
              this.error_holder.style.display = '';
              $each(my_errors, function(i, error) {
                self.error_holder.appendChild(self.theme.getErrorMessage(error.message));
              });
            } else {
              this.error_holder.style.display = 'none';
            }
          }
        }
      });
      var matchKey = (function() {
        var elem = document.documentElement;
        if (elem.matches)
          return 'matches';
        else if (elem.webkitMatchesSelector)
          return 'webkitMatchesSelector';
        else if (elem.mozMatchesSelector)
          return 'mozMatchesSelector';
        else if (elem.msMatchesSelector)
          return 'msMatchesSelector';
        else if (elem.oMatchesSelector)
          return 'oMatchesSelector';
      })();
      JSONEditor.AbstractTheme = Class.extend({
        getContainer: function() {
          return document.createElement('div');
        },
        getFloatRightLinkHolder: function() {
          var el = document.createElement('div');
          el.style = el.style || {};
          el.style.cssFloat = 'right';
          el.style.marginLeft = '10px';
          return el;
        },
        getModal: function() {
          var el = document.createElement('div');
          el.style.backgroundColor = 'white';
          el.style.border = '1px solid black';
          el.style.boxShadow = '3px 3px black';
          el.style.position = 'absolute';
          el.style.zIndex = '10';
          el.style.display = 'none';
          return el;
        },
        getGridContainer: function() {
          var el = document.createElement('div');
          return el;
        },
        getGridRow: function() {
          var el = document.createElement('div');
          el.className = 'row';
          return el;
        },
        getGridColumn: function() {
          var el = document.createElement('div');
          return el;
        },
        setGridColumnSize: function(el, size) {},
        getLink: function(text) {
          var el = document.createElement('a');
          el.setAttribute('href', '#');
          el.appendChild(document.createTextNode(text));
          return el;
        },
        disableHeader: function(header) {
          header.style.color = '#ccc';
        },
        disableLabel: function(label) {
          label.style.color = '#ccc';
        },
        enableHeader: function(header) {
          header.style.color = '';
        },
        enableLabel: function(label) {
          label.style.color = '';
        },
        getFormInputLabel: function(text) {
          var el = document.createElement('label');
          el.appendChild(document.createTextNode(text));
          return el;
        },
        getCheckboxLabel: function(text) {
          var el = this.getFormInputLabel(text);
          el.style.fontWeight = 'normal';
          return el;
        },
        getHeader: function(text) {
          var el = document.createElement('h3');
          if (typeof text === "string") {
            el.textContent = text;
          } else {
            el.appendChild(text);
          }
          return el;
        },
        getCheckbox: function() {
          var el = this.getFormInputField('checkbox');
          el.style.display = 'inline-block';
          el.style.width = 'auto';
          return el;
        },
        getMultiCheckboxHolder: function(controls, label, description) {
          var el = document.createElement('div');
          if (label) {
            label.style.display = 'block';
            el.appendChild(label);
          }
          for (var i in controls) {
            if (!controls.hasOwnProperty(i))
              continue;
            controls[i].style.display = 'inline-block';
            controls[i].style.marginRight = '20px';
            el.appendChild(controls[i]);
          }
          if (description)
            el.appendChild(description);
          return el;
        },
        getSelectInput: function(options) {
          var select = document.createElement('select');
          if (options)
            this.setSelectOptions(select, options);
          return select;
        },
        getSwitcher: function(options) {
          var switcher = this.getSelectInput(options);
          switcher.style.backgroundColor = 'transparent';
          switcher.style.display = 'inline-block';
          switcher.style.fontStyle = 'italic';
          switcher.style.fontWeight = 'normal';
          switcher.style.height = 'auto';
          switcher.style.marginBottom = 0;
          switcher.style.marginLeft = '5px';
          switcher.style.padding = '0 0 0 3px';
          switcher.style.width = 'auto';
          return switcher;
        },
        getSwitcherOptions: function(switcher) {
          return switcher.getElementsByTagName('option');
        },
        setSwitcherOptions: function(switcher, options, titles) {
          this.setSelectOptions(switcher, options, titles);
        },
        setSelectOptions: function(select, options, titles) {
          titles = titles || [];
          select.innerHTML = '';
          for (var i = 0; i < options.length; i++) {
            var option = document.createElement('option');
            option.setAttribute('value', options[i]);
            option.textContent = titles[i] || options[i];
            select.appendChild(option);
          }
        },
        getTextareaInput: function() {
          var el = document.createElement('textarea');
          el.style = el.style || {};
          el.style.width = '100%';
          el.style.height = '300px';
          el.style.boxSizing = 'border-box';
          return el;
        },
        getRangeInput: function(min, max, step) {
          var el = this.getFormInputField('range');
          el.setAttribute('min', min);
          el.setAttribute('max', max);
          el.setAttribute('step', step);
          return el;
        },
        getFormInputField: function(type) {
          var el = document.createElement('input');
          el.setAttribute('type', type);
          return el;
        },
        afterInputReady: function(input) {},
        getFormControl: function(label, input, description) {
          var el = document.createElement('div');
          el.className = 'form-control';
          if (label)
            el.appendChild(label);
          if (input.type === 'checkbox') {
            label.insertBefore(input, label.firstChild);
          } else {
            el.appendChild(input);
          }
          if (description)
            el.appendChild(description);
          return el;
        },
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.style = el.style || {};
          el.style.paddingLeft = '10px';
          el.style.marginLeft = '10px';
          el.style.borderLeft = '1px solid #ccc';
          return el;
        },
        getChildEditorHolder: function() {
          return document.createElement('div');
        },
        getDescription: function(text) {
          var el = document.createElement('p');
          el.innerHTML = text;
          return el;
        },
        getCheckboxDescription: function(text) {
          return this.getDescription(text);
        },
        getFormInputDescription: function(text) {
          return this.getDescription(text);
        },
        getHeaderButtonHolder: function() {
          return this.getButtonHolder();
        },
        getButtonHolder: function() {
          return document.createElement('div');
        },
        getButton: function(text, icon, title) {
          var el = document.createElement('button');
          el.type = 'button';
          this.setButtonText(el, text, icon, title);
          return el;
        },
        setButtonText: function(button, text, icon, title) {
          button.innerHTML = '';
          if (icon) {
            button.appendChild(icon);
            button.innerHTML += ' ';
          }
          button.appendChild(document.createTextNode(text));
          if (title)
            button.setAttribute('title', title);
        },
        getTable: function() {
          return document.createElement('table');
        },
        getTableRow: function() {
          return document.createElement('tr');
        },
        getTableHead: function() {
          return document.createElement('thead');
        },
        getTableBody: function() {
          return document.createElement('tbody');
        },
        getTableHeaderCell: function(text) {
          var el = document.createElement('th');
          el.textContent = text;
          return el;
        },
        getTableCell: function() {
          var el = document.createElement('td');
          return el;
        },
        getErrorMessage: function(text) {
          var el = document.createElement('p');
          el.style = el.style || {};
          el.style.color = 'red';
          el.appendChild(document.createTextNode(text));
          return el;
        },
        addInputError: function(input, text) {},
        removeInputError: function(input) {},
        addTableRowError: function(row) {},
        removeTableRowError: function(row) {},
        getTabHolder: function() {
          var el = document.createElement('div');
          el.innerHTML = "<div style='float: left; width: 130px;' class='tabs'></div><div class='content' style='margin-left: 130px;'></div><div style='clear:both;'></div>";
          return el;
        },
        applyStyles: function(el, styles) {
          el.style = el.style || {};
          for (var i in styles) {
            if (!styles.hasOwnProperty(i))
              continue;
            el.style[i] = styles[i];
          }
        },
        closest: function(elem, selector) {
          while (elem && elem !== document) {
            if (matchKey) {
              if (elem[matchKey](selector)) {
                return elem;
              } else {
                elem = elem.parentNode;
              }
            } else {
              return false;
            }
          }
          return false;
        },
        getTab: function(span) {
          var el = document.createElement('div');
          el.appendChild(span);
          el.style = el.style || {};
          this.applyStyles(el, {
            border: '1px solid #ccc',
            borderWidth: '1px 0 1px 1px',
            textAlign: 'center',
            lineHeight: '30px',
            borderRadius: '5px',
            borderBottomRightRadius: 0,
            borderTopRightRadius: 0,
            fontWeight: 'bold',
            cursor: 'pointer'
          });
          return el;
        },
        getTabContentHolder: function(tab_holder) {
          return tab_holder.children[1];
        },
        getTabContent: function() {
          return this.getIndentedPanel();
        },
        markTabActive: function(tab) {
          this.applyStyles(tab, {
            opacity: 1,
            background: 'white'
          });
        },
        markTabInactive: function(tab) {
          this.applyStyles(tab, {
            opacity: 0.5,
            background: ''
          });
        },
        addTab: function(holder, tab) {
          holder.children[0].appendChild(tab);
        },
        getBlockLink: function() {
          var link = document.createElement('a');
          link.style.display = 'block';
          return link;
        },
        getBlockLinkHolder: function() {
          var el = document.createElement('div');
          return el;
        },
        getLinksHolder: function() {
          var el = document.createElement('div');
          return el;
        },
        createMediaLink: function(holder, link, media) {
          holder.appendChild(link);
          media.style.width = '100%';
          holder.appendChild(media);
        },
        createImageLink: function(holder, link, image) {
          holder.appendChild(link);
          link.appendChild(image);
        }
      });
      JSONEditor.defaults.themes.bootstrap2 = JSONEditor.AbstractTheme.extend({
        getRangeInput: function(min, max, step) {
          return this._super(min, max, step);
        },
        getGridContainer: function() {
          var el = document.createElement('div');
          el.className = 'container-fluid';
          return el;
        },
        getGridRow: function() {
          var el = document.createElement('div');
          el.className = 'row-fluid';
          return el;
        },
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.display = 'inline-block';
          el.style.fontWeight = 'bold';
          return el;
        },
        setGridColumnSize: function(el, size) {
          el.className = 'span' + size;
        },
        getSelectInput: function(options) {
          var input = this._super(options);
          input.style.width = 'auto';
          input.style.maxWidth = '98%';
          return input;
        },
        getFormInputField: function(type) {
          var el = this._super(type);
          el.style.width = '98%';
          return el;
        },
        afterInputReady: function(input) {
          if (input.controlgroup)
            return;
          input.controlgroup = this.closest(input, '.control-group');
          input.controls = this.closest(input, '.controls');
          if (this.closest(input, '.compact')) {
            input.controlgroup.className = input.controlgroup.className.replace(/control-group/g, '').replace(/[ ]{2,}/g, ' ');
            input.controls.className = input.controlgroup.className.replace(/controls/g, '').replace(/[ ]{2,}/g, ' ');
            input.style.marginBottom = 0;
          }
        },
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.className = 'well well-small';
          el.style.paddingBottom = 0;
          return el;
        },
        getFormInputDescription: function(text) {
          var el = document.createElement('p');
          el.className = 'help-inline';
          el.textContent = text;
          return el;
        },
        getFormControl: function(label, input, description) {
          var ret = document.createElement('div');
          ret.className = 'control-group';
          var controls = document.createElement('div');
          controls.className = 'controls';
          if (label && input.getAttribute('type') === 'checkbox') {
            ret.appendChild(controls);
            label.className += ' checkbox';
            label.appendChild(input);
            controls.appendChild(label);
            controls.style.height = '30px';
          } else {
            if (label) {
              label.className += ' control-label';
              ret.appendChild(label);
            }
            controls.appendChild(input);
            ret.appendChild(controls);
          }
          if (description)
            controls.appendChild(description);
          return ret;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          el.style.marginLeft = '10px';
          return el;
        },
        getButtonHolder: function() {
          var el = document.createElement('div');
          el.className = 'btn-group';
          return el;
        },
        getButton: function(text, icon, title) {
          var el = this._super(text, icon, title);
          el.className += ' btn btn-default';
          return el;
        },
        getTable: function() {
          var el = document.createElement('table');
          el.className = 'table table-bordered';
          el.style.width = 'auto';
          el.style.maxWidth = 'none';
          return el;
        },
        addInputError: function(input, text) {
          if (!input.controlgroup || !input.controls)
            return;
          input.controlgroup.className += ' error';
          if (!input.errmsg) {
            input.errmsg = document.createElement('p');
            input.errmsg.className = 'help-block errormsg';
            input.controls.appendChild(input.errmsg);
          } else {
            input.errmsg.style.display = '';
          }
          input.errmsg.textContent = text;
        },
        removeInputError: function(input) {
          if (!input.errmsg)
            return;
          input.errmsg.style.display = 'none';
          input.controlgroup.className = input.controlgroup.className.replace(/\s?error/g, '');
        },
        getTabHolder: function() {
          var el = document.createElement('div');
          el.className = 'tabbable tabs-left';
          el.innerHTML = "<ul class='nav nav-tabs span2' style='margin-right: 0;'></ul><div class='tab-content span10' style='overflow:visible;'></div>";
          return el;
        },
        getTab: function(text) {
          var el = document.createElement('li');
          var a = document.createElement('a');
          a.setAttribute('href', '#');
          a.appendChild(text);
          el.appendChild(a);
          return el;
        },
        getTabContentHolder: function(tab_holder) {
          return tab_holder.children[1];
        },
        getTabContent: function() {
          var el = document.createElement('div');
          el.className = 'tab-pane active';
          return el;
        },
        markTabActive: function(tab) {
          tab.className += ' active';
        },
        markTabInactive: function(tab) {
          tab.className = tab.className.replace(/\s?active/g, '');
        },
        addTab: function(holder, tab) {
          holder.children[0].appendChild(tab);
        },
        getProgressBar: function() {
          var container = document.createElement('div');
          container.className = 'progress';
          var bar = document.createElement('div');
          bar.className = 'bar';
          bar.style.width = '0%';
          container.appendChild(bar);
          return container;
        },
        updateProgressBar: function(progressBar, progress) {
          if (!progressBar)
            return;
          progressBar.firstChild.style.width = progress + "%";
        },
        updateProgressBarUnknown: function(progressBar) {
          if (!progressBar)
            return;
          progressBar.className = 'progress progress-striped active';
          progressBar.firstChild.style.width = '100%';
        }
      });
      JSONEditor.defaults.themes.bootstrap3 = JSONEditor.AbstractTheme.extend({
        getSelectInput: function(options) {
          var el = this._super(options);
          el.className += 'form-control';
          return el;
        },
        setGridColumnSize: function(el, size) {
          el.className = 'col-md-' + size;
        },
        afterInputReady: function(input) {
          if (input.controlgroup)
            return;
          input.controlgroup = this.closest(input, '.form-group');
          if (this.closest(input, '.compact')) {
            input.controlgroup.style.marginBottom = 0;
          }
        },
        getTextareaInput: function() {
          var el = document.createElement('textarea');
          el.className = 'form-control';
          return el;
        },
        getRangeInput: function(min, max, step) {
          return this._super(min, max, step);
        },
        getFormInputField: function(type) {
          var el = this._super(type);
          if (type !== 'checkbox') {
            el.className += 'form-control';
          }
          return el;
        },
        getFormControl: function(label, input, description) {
          var group = document.createElement('div');
          if (label && input.type === 'checkbox') {
            group.className += ' checkbox';
            label.appendChild(input);
            label.style.fontSize = '14px';
            group.style.marginTop = '0';
            group.appendChild(label);
            input.style.position = 'relative';
            input.style.cssFloat = 'left';
          } else {
            group.className += ' form-group';
            if (label) {
              label.className += ' control-label';
              group.appendChild(label);
            }
            group.appendChild(input);
          }
          if (description)
            group.appendChild(description);
          return group;
        },
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.className = 'well well-sm';
          el.style.paddingBottom = 0;
          return el;
        },
        getFormInputDescription: function(text) {
          var el = document.createElement('p');
          el.className = 'help-block';
          el.innerHTML = text;
          return el;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          el.style.marginLeft = '10px';
          return el;
        },
        getButtonHolder: function() {
          var el = document.createElement('div');
          el.className = 'btn-group';
          return el;
        },
        getButton: function(text, icon, title) {
          var el = this._super(text, icon, title);
          el.className += 'btn btn-default';
          return el;
        },
        getTable: function() {
          var el = document.createElement('table');
          el.className = 'table table-bordered';
          el.style.width = 'auto';
          el.style.maxWidth = 'none';
          return el;
        },
        addInputError: function(input, text) {
          if (!input.controlgroup)
            return;
          input.controlgroup.className += ' has-error';
          if (!input.errmsg) {
            input.errmsg = document.createElement('p');
            input.errmsg.className = 'help-block errormsg';
            input.controlgroup.appendChild(input.errmsg);
          } else {
            input.errmsg.style.display = '';
          }
          input.errmsg.textContent = text;
        },
        removeInputError: function(input) {
          if (!input.errmsg)
            return;
          input.errmsg.style.display = 'none';
          input.controlgroup.className = input.controlgroup.className.replace(/\s?has-error/g, '');
        },
        getTabHolder: function() {
          var el = document.createElement('div');
          el.innerHTML = "<div class='tabs list-group col-md-2'></div><div class='col-md-10'></div>";
          el.className = 'rows';
          return el;
        },
        getTab: function(text) {
          var el = document.createElement('a');
          el.className = 'list-group-item';
          el.setAttribute('href', '#');
          el.appendChild(text);
          return el;
        },
        markTabActive: function(tab) {
          tab.className += ' active';
        },
        markTabInactive: function(tab) {
          tab.className = tab.className.replace(/\s?active/g, '');
        },
        getProgressBar: function() {
          var min = 0,
              max = 100,
              start = 0;
          var container = document.createElement('div');
          container.className = 'progress';
          var bar = document.createElement('div');
          bar.className = 'progress-bar';
          bar.setAttribute('role', 'progressbar');
          bar.setAttribute('aria-valuenow', start);
          bar.setAttribute('aria-valuemin', min);
          bar.setAttribute('aria-valuenax', max);
          bar.innerHTML = start + "%";
          container.appendChild(bar);
          return container;
        },
        updateProgressBar: function(progressBar, progress) {
          if (!progressBar)
            return;
          var bar = progressBar.firstChild;
          var percentage = progress + "%";
          bar.setAttribute('aria-valuenow', progress);
          bar.style.width = percentage;
          bar.innerHTML = percentage;
        },
        updateProgressBarUnknown: function(progressBar) {
          if (!progressBar)
            return;
          var bar = progressBar.firstChild;
          progressBar.className = 'progress progress-striped active';
          bar.removeAttribute('aria-valuenow');
          bar.style.width = '100%';
          bar.innerHTML = '';
        }
      });
      JSONEditor.defaults.themes.foundation = JSONEditor.AbstractTheme.extend({
        getChildEditorHolder: function() {
          var el = document.createElement('div');
          el.style.marginBottom = '15px';
          return el;
        },
        getSelectInput: function(options) {
          var el = this._super(options);
          el.style.minWidth = 'none';
          el.style.padding = '5px';
          el.style.marginTop = '3px';
          return el;
        },
        getSwitcher: function(options) {
          var el = this._super(options);
          el.style.paddingRight = '8px';
          return el;
        },
        afterInputReady: function(input) {
          if (this.closest(input, '.compact')) {
            input.style.marginBottom = 0;
          }
          input.group = this.closest(input, '.form-control');
        },
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.display = 'inline-block';
          return el;
        },
        getFormInputField: function(type) {
          var el = this._super(type);
          el.style.width = '100%';
          el.style.marginBottom = type === 'checkbox' ? '0' : '12px';
          return el;
        },
        getFormInputDescription: function(text) {
          var el = document.createElement('p');
          el.textContent = text;
          el.style.marginTop = '-10px';
          el.style.fontStyle = 'italic';
          return el;
        },
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.className = 'panel';
          el.style.paddingBottom = 0;
          return el;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          el.style.display = 'inline-block';
          el.style.marginLeft = '10px';
          el.style.verticalAlign = 'middle';
          return el;
        },
        getButtonHolder: function() {
          var el = document.createElement('div');
          el.className = 'button-group';
          return el;
        },
        getButton: function(text, icon, title) {
          var el = this._super(text, icon, title);
          el.className += ' small button';
          return el;
        },
        addInputError: function(input, text) {
          if (!input.group)
            return;
          input.group.className += ' error';
          if (!input.errmsg) {
            input.insertAdjacentHTML('afterend', '<small class="error"></small>');
            input.errmsg = input.parentNode.getElementsByClassName('error')[0];
          } else {
            input.errmsg.style.display = '';
          }
          input.errmsg.textContent = text;
        },
        removeInputError: function(input) {
          if (!input.errmsg)
            return;
          input.group.className = input.group.className.replace(/ error/g, '');
          input.errmsg.style.display = 'none';
        },
        getProgressBar: function() {
          var progressBar = document.createElement('div');
          progressBar.className = 'progress';
          var meter = document.createElement('span');
          meter.className = 'meter';
          meter.style.width = '0%';
          progressBar.appendChild(meter);
          return progressBar;
        },
        updateProgressBar: function(progressBar, progress) {
          if (!progressBar)
            return;
          progressBar.firstChild.style.width = progress + '%';
        },
        updateProgressBarUnknown: function(progressBar) {
          if (!progressBar)
            return;
          progressBar.firstChild.style.width = '100%';
        }
      });
      JSONEditor.defaults.themes.foundation3 = JSONEditor.defaults.themes.foundation.extend({
        getHeaderButtonHolder: function() {
          var el = this._super();
          el.style.fontSize = '.6em';
          return el;
        },
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.fontWeight = 'bold';
          return el;
        },
        getTabHolder: function() {
          var el = document.createElement('div');
          el.className = 'row';
          el.innerHTML = "<dl class='tabs vertical two columns'></dl><div class='tabs-content ten columns'></div>";
          return el;
        },
        setGridColumnSize: function(el, size) {
          var sizes = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine', 'ten', 'eleven', 'twelve'];
          el.className = 'columns ' + sizes[size];
        },
        getTab: function(text) {
          var el = document.createElement('dd');
          var a = document.createElement('a');
          a.setAttribute('href', '#');
          a.appendChild(text);
          el.appendChild(a);
          return el;
        },
        getTabContentHolder: function(tab_holder) {
          return tab_holder.children[1];
        },
        getTabContent: function() {
          var el = document.createElement('div');
          el.className = 'content active';
          el.style.paddingLeft = '5px';
          return el;
        },
        markTabActive: function(tab) {
          tab.className += ' active';
        },
        markTabInactive: function(tab) {
          tab.className = tab.className.replace(/\s*active/g, '');
        },
        addTab: function(holder, tab) {
          holder.children[0].appendChild(tab);
        }
      });
      JSONEditor.defaults.themes.foundation4 = JSONEditor.defaults.themes.foundation.extend({
        getHeaderButtonHolder: function() {
          var el = this._super();
          el.style.fontSize = '.6em';
          return el;
        },
        setGridColumnSize: function(el, size) {
          el.className = 'columns large-' + size;
        },
        getFormInputDescription: function(text) {
          var el = this._super(text);
          el.style.fontSize = '.8rem';
          return el;
        },
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.fontWeight = 'bold';
          return el;
        }
      });
      JSONEditor.defaults.themes.foundation5 = JSONEditor.defaults.themes.foundation.extend({
        getFormInputDescription: function(text) {
          var el = this._super(text);
          el.style.fontSize = '.8rem';
          return el;
        },
        setGridColumnSize: function(el, size) {
          el.className = 'columns medium-' + size;
        },
        getButton: function(text, icon, title) {
          var el = this._super(text, icon, title);
          el.className = el.className.replace(/\s*small/g, '') + ' tiny';
          return el;
        },
        getTabHolder: function() {
          var el = document.createElement('div');
          el.innerHTML = "<dl class='tabs vertical'></dl><div class='tabs-content vertical'></div>";
          return el;
        },
        getTab: function(text) {
          var el = document.createElement('dd');
          var a = document.createElement('a');
          a.setAttribute('href', '#');
          a.appendChild(text);
          el.appendChild(a);
          return el;
        },
        getTabContentHolder: function(tab_holder) {
          return tab_holder.children[1];
        },
        getTabContent: function() {
          var el = document.createElement('div');
          el.className = 'content active';
          el.style.paddingLeft = '5px';
          return el;
        },
        markTabActive: function(tab) {
          tab.className += ' active';
        },
        markTabInactive: function(tab) {
          tab.className = tab.className.replace(/\s*active/g, '');
        },
        addTab: function(holder, tab) {
          holder.children[0].appendChild(tab);
        }
      });
      JSONEditor.defaults.themes.foundation6 = JSONEditor.defaults.themes.foundation5.extend({
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.className = 'callout secondary';
          return el;
        },
        getButtonHolder: function() {
          var el = document.createElement('div');
          el.className = 'button-group tiny';
          el.style.marginBottom = 0;
          return el;
        },
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.display = 'block';
          return el;
        },
        getFormControl: function(label, input, description) {
          var el = document.createElement('div');
          el.className = 'form-control';
          if (label)
            el.appendChild(label);
          if (input.type === 'checkbox') {
            label.insertBefore(input, label.firstChild);
          } else if (label) {
            label.appendChild(input);
          } else {
            el.appendChild(input);
          }
          if (description)
            label.appendChild(description);
          return el;
        },
        addInputError: function(input, text) {
          if (!input.group)
            return;
          input.group.className += ' error';
          if (!input.errmsg) {
            var errorEl = document.createElement('span');
            errorEl.className = 'form-error is-visible';
            input.group.getElementsByTagName('label')[0].appendChild(errorEl);
            input.className = input.className + ' is-invalid-input';
            input.errmsg = errorEl;
          } else {
            input.errmsg.style.display = '';
            input.className = '';
          }
          input.errmsg.textContent = text;
        },
        removeInputError: function(input) {
          if (!input.errmsg)
            return;
          input.className = input.className.replace(/ is-invalid-input/g, '');
          if (input.errmsg.parentNode) {
            input.errmsg.parentNode.removeChild(input.errmsg);
          }
        }
      });
      JSONEditor.defaults.themes.html = JSONEditor.AbstractTheme.extend({
        getFormInputLabel: function(text) {
          var el = this._super(text);
          el.style.display = 'block';
          el.style.marginBottom = '3px';
          el.style.fontWeight = 'bold';
          return el;
        },
        getFormInputDescription: function(text) {
          var el = this._super(text);
          el.style.fontSize = '.8em';
          el.style.margin = 0;
          el.style.display = 'inline-block';
          el.style.fontStyle = 'italic';
          return el;
        },
        getIndentedPanel: function() {
          var el = this._super();
          el.style.border = '1px solid #ddd';
          el.style.padding = '5px';
          el.style.margin = '5px';
          el.style.borderRadius = '3px';
          return el;
        },
        getChildEditorHolder: function() {
          var el = this._super();
          el.style.marginBottom = '8px';
          return el;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          el.style.display = 'inline-block';
          el.style.marginLeft = '10px';
          el.style.fontSize = '.8em';
          el.style.verticalAlign = 'middle';
          return el;
        },
        getTable: function() {
          var el = this._super();
          el.style.borderBottom = '1px solid #ccc';
          el.style.marginBottom = '5px';
          return el;
        },
        addInputError: function(input, text) {
          input.style.borderColor = 'red';
          if (!input.errmsg) {
            var group = this.closest(input, '.form-control');
            input.errmsg = document.createElement('div');
            input.errmsg.setAttribute('class', 'errmsg');
            input.errmsg.style = input.errmsg.style || {};
            input.errmsg.style.color = 'red';
            group.appendChild(input.errmsg);
          } else {
            input.errmsg.style.display = 'block';
          }
          input.errmsg.innerHTML = '';
          input.errmsg.appendChild(document.createTextNode(text));
        },
        removeInputError: function(input) {
          input.style.borderColor = '';
          if (input.errmsg)
            input.errmsg.style.display = 'none';
        },
        getProgressBar: function() {
          var max = 100,
              start = 0;
          var progressBar = document.createElement('progress');
          progressBar.setAttribute('max', max);
          progressBar.setAttribute('value', start);
          return progressBar;
        },
        updateProgressBar: function(progressBar, progress) {
          if (!progressBar)
            return;
          progressBar.setAttribute('value', progress);
        },
        updateProgressBarUnknown: function(progressBar) {
          if (!progressBar)
            return;
          progressBar.removeAttribute('value');
        }
      });
      JSONEditor.defaults.themes.jqueryui = JSONEditor.AbstractTheme.extend({
        getTable: function() {
          var el = this._super();
          el.setAttribute('cellpadding', 5);
          el.setAttribute('cellspacing', 0);
          return el;
        },
        getTableHeaderCell: function(text) {
          var el = this._super(text);
          el.className = 'ui-state-active';
          el.style.fontWeight = 'bold';
          return el;
        },
        getTableCell: function() {
          var el = this._super();
          el.className = 'ui-widget-content';
          return el;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          el.style.marginLeft = '10px';
          el.style.fontSize = '.6em';
          el.style.display = 'inline-block';
          return el;
        },
        getFormInputDescription: function(text) {
          var el = this.getDescription(text);
          el.style.marginLeft = '10px';
          el.style.display = 'inline-block';
          return el;
        },
        getFormControl: function(label, input, description) {
          var el = this._super(label, input, description);
          if (input.type === 'checkbox') {
            el.style.lineHeight = '25px';
            el.style.padding = '3px 0';
          } else {
            el.style.padding = '4px 0 8px 0';
          }
          return el;
        },
        getDescription: function(text) {
          var el = document.createElement('span');
          el.style.fontSize = '.8em';
          el.style.fontStyle = 'italic';
          el.textContent = text;
          return el;
        },
        getButtonHolder: function() {
          var el = document.createElement('div');
          el.className = 'ui-buttonset';
          el.style.fontSize = '.7em';
          return el;
        },
        getFormInputLabel: function(text) {
          var el = document.createElement('label');
          el.style.fontWeight = 'bold';
          el.style.display = 'block';
          el.textContent = text;
          return el;
        },
        getButton: function(text, icon, title) {
          var button = document.createElement("button");
          button.className = 'ui-button ui-widget ui-state-default ui-corner-all';
          if (icon && !text) {
            button.className += ' ui-button-icon-only';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          } else if (icon) {
            button.className += ' ui-button-text-icon-primary';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          } else {
            button.className += ' ui-button-text-only';
          }
          var el = document.createElement('span');
          el.className = 'ui-button-text';
          el.textContent = text || title || ".";
          button.appendChild(el);
          button.setAttribute('title', title);
          return button;
        },
        setButtonText: function(button, text, icon, title) {
          button.innerHTML = '';
          button.className = 'ui-button ui-widget ui-state-default ui-corner-all';
          if (icon && !text) {
            button.className += ' ui-button-icon-only';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          } else if (icon) {
            button.className += ' ui-button-text-icon-primary';
            icon.className += ' ui-button-icon-primary ui-icon-primary';
            button.appendChild(icon);
          } else {
            button.className += ' ui-button-text-only';
          }
          var el = document.createElement('span');
          el.className = 'ui-button-text';
          el.textContent = text || title || ".";
          button.appendChild(el);
          button.setAttribute('title', title);
        },
        getIndentedPanel: function() {
          var el = document.createElement('div');
          el.className = 'ui-widget-content ui-corner-all';
          el.style.padding = '1em 1.4em';
          el.style.marginBottom = '20px';
          return el;
        },
        afterInputReady: function(input) {
          if (input.controls)
            return;
          input.controls = this.closest(input, '.form-control');
        },
        addInputError: function(input, text) {
          if (!input.controls)
            return;
          if (!input.errmsg) {
            input.errmsg = document.createElement('div');
            input.errmsg.className = 'ui-state-error';
            input.controls.appendChild(input.errmsg);
          } else {
            input.errmsg.style.display = '';
          }
          input.errmsg.textContent = text;
        },
        removeInputError: function(input) {
          if (!input.errmsg)
            return;
          input.errmsg.style.display = 'none';
        },
        markTabActive: function(tab) {
          tab.className = tab.className.replace(/\s*ui-widget-header/g, '') + ' ui-state-active';
        },
        markTabInactive: function(tab) {
          tab.className = tab.className.replace(/\s*ui-state-active/g, '') + ' ui-widget-header';
        }
      });
      JSONEditor.defaults.themes.barebones = JSONEditor.AbstractTheme.extend({
        getFormInputLabel: function(text) {
          var el = this._super(text);
          return el;
        },
        getFormInputDescription: function(text) {
          var el = this._super(text);
          return el;
        },
        getIndentedPanel: function() {
          var el = this._super();
          return el;
        },
        getChildEditorHolder: function() {
          var el = this._super();
          return el;
        },
        getHeaderButtonHolder: function() {
          var el = this.getButtonHolder();
          return el;
        },
        getTable: function() {
          var el = this._super();
          return el;
        },
        addInputError: function(input, text) {
          if (!input.errmsg) {
            var group = this.closest(input, '.form-control');
            input.errmsg = document.createElement('div');
            input.errmsg.setAttribute('class', 'errmsg');
            group.appendChild(input.errmsg);
          } else {
            input.errmsg.style.display = 'block';
          }
          input.errmsg.innerHTML = '';
          input.errmsg.appendChild(document.createTextNode(text));
        },
        removeInputError: function(input) {
          input.style.borderColor = '';
          if (input.errmsg)
            input.errmsg.style.display = 'none';
        },
        getProgressBar: function() {
          var max = 100,
              start = 0;
          var progressBar = document.createElement('progress');
          progressBar.setAttribute('max', max);
          progressBar.setAttribute('value', start);
          return progressBar;
        },
        updateProgressBar: function(progressBar, progress) {
          if (!progressBar)
            return;
          progressBar.setAttribute('value', progress);
        },
        updateProgressBarUnknown: function(progressBar) {
          if (!progressBar)
            return;
          progressBar.removeAttribute('value');
        }
      });
      JSONEditor.AbstractIconLib = Class.extend({
        mapping: {
          collapse: '',
          expand: '',
          "delete": '',
          edit: '',
          add: '',
          cancel: '',
          save: '',
          moveup: '',
          movedown: ''
        },
        icon_prefix: '',
        getIconClass: function(key) {
          if (this.mapping[key])
            return this.icon_prefix + this.mapping[key];
          else
            return null;
        },
        getIcon: function(key) {
          var iconclass = this.getIconClass(key);
          if (!iconclass)
            return null;
          var i = document.createElement('i');
          i.className = iconclass;
          return i;
        }
      });
      JSONEditor.defaults.iconlibs.bootstrap2 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'chevron-down',
          expand: 'chevron-up',
          "delete": 'trash',
          edit: 'pencil',
          add: 'plus',
          cancel: 'ban-circle',
          save: 'ok',
          moveup: 'arrow-up',
          movedown: 'arrow-down'
        },
        icon_prefix: 'icon-'
      });
      JSONEditor.defaults.iconlibs.bootstrap3 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'chevron-down',
          expand: 'chevron-right',
          "delete": 'remove',
          edit: 'pencil',
          add: 'plus',
          cancel: 'floppy-remove',
          save: 'floppy-saved',
          moveup: 'arrow-up',
          movedown: 'arrow-down'
        },
        icon_prefix: 'glyphicon glyphicon-'
      });
      JSONEditor.defaults.iconlibs.fontawesome3 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'chevron-down',
          expand: 'chevron-right',
          "delete": 'remove',
          edit: 'pencil',
          add: 'plus',
          cancel: 'ban-circle',
          save: 'save',
          moveup: 'arrow-up',
          movedown: 'arrow-down'
        },
        icon_prefix: 'icon-'
      });
      JSONEditor.defaults.iconlibs.fontawesome4 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'caret-square-o-down',
          expand: 'caret-square-o-right',
          "delete": 'times',
          edit: 'pencil',
          add: 'plus',
          cancel: 'ban',
          save: 'save',
          moveup: 'arrow-up',
          movedown: 'arrow-down'
        },
        icon_prefix: 'fa fa-'
      });
      JSONEditor.defaults.iconlibs.foundation2 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'minus',
          expand: 'plus',
          "delete": 'remove',
          edit: 'edit',
          add: 'add-doc',
          cancel: 'error',
          save: 'checkmark',
          moveup: 'up-arrow',
          movedown: 'down-arrow'
        },
        icon_prefix: 'foundicon-'
      });
      JSONEditor.defaults.iconlibs.foundation3 = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'minus',
          expand: 'plus',
          "delete": 'x',
          edit: 'pencil',
          add: 'page-add',
          cancel: 'x-circle',
          save: 'save',
          moveup: 'arrow-up',
          movedown: 'arrow-down'
        },
        icon_prefix: 'fi-'
      });
      JSONEditor.defaults.iconlibs.jqueryui = JSONEditor.AbstractIconLib.extend({
        mapping: {
          collapse: 'triangle-1-s',
          expand: 'triangle-1-e',
          "delete": 'trash',
          edit: 'pencil',
          add: 'plusthick',
          cancel: 'closethick',
          save: 'disk',
          moveup: 'arrowthick-1-n',
          movedown: 'arrowthick-1-s'
        },
        icon_prefix: 'ui-icon ui-icon-'
      });
      JSONEditor.defaults.templates["default"] = function() {
        return {compile: function(template) {
            var matches = template.match(/{{\s*([a-zA-Z0-9\-_ \.]+)\s*}}/g);
            var l = matches && matches.length;
            if (!l)
              return function() {
                return template;
              };
            var replacements = [];
            var get_replacement = function(i) {
              var p = matches[i].replace(/[{}]+/g, '').trim().split('.');
              var n = p.length;
              var func;
              if (n > 1) {
                var cur;
                func = function(vars) {
                  cur = vars;
                  for (i = 0; i < n; i++) {
                    cur = cur[p[i]];
                    if (!cur)
                      break;
                  }
                  return cur;
                };
              } else {
                p = p[0];
                func = function(vars) {
                  return vars[p];
                };
              }
              replacements.push({
                s: matches[i],
                r: func
              });
            };
            for (var i = 0; i < l; i++) {
              get_replacement(i);
            }
            return function(vars) {
              var ret = template + "";
              var r;
              for (i = 0; i < l; i++) {
                r = replacements[i];
                ret = ret.replace(r.s, r.r(vars));
              }
              return ret;
            };
          }};
      };
      JSONEditor.defaults.templates.ejs = function() {
        if (!window.EJS)
          return false;
        return {compile: function(template) {
            var compiled = new window.EJS({text: template});
            return function(context) {
              return compiled.render(context);
            };
          }};
      };
      JSONEditor.defaults.templates.handlebars = function() {
        return window.Handlebars;
      };
      JSONEditor.defaults.templates.hogan = function() {
        if (!window.Hogan)
          return false;
        return {compile: function(template) {
            var compiled = window.Hogan.compile(template);
            return function(context) {
              return compiled.render(context);
            };
          }};
      };
      JSONEditor.defaults.templates.markup = function() {
        if (!window.Mark || !window.Mark.up)
          return false;
        return {compile: function(template) {
            return function(context) {
              return window.Mark.up(template, context);
            };
          }};
      };
      JSONEditor.defaults.templates.mustache = function() {
        if (!window.Mustache)
          return false;
        return {compile: function(template) {
            return function(view) {
              return window.Mustache.render(template, view);
            };
          }};
      };
      JSONEditor.defaults.templates.swig = function() {
        return window.swig;
      };
      JSONEditor.defaults.templates.underscore = function() {
        if (!window._)
          return false;
        return {compile: function(template) {
            return function(context) {
              return window._.template(template, context);
            };
          }};
      };
      JSONEditor.defaults.theme = 'html';
      JSONEditor.defaults.template = 'default';
      JSONEditor.defaults.options = {};
      JSONEditor.defaults.translate = function(key, variables) {
        var lang = JSONEditor.defaults.languages[JSONEditor.defaults.language];
        if (!lang)
          throw "Unknown language " + JSONEditor.defaults.language;
        var string = lang[key] || JSONEditor.defaults.languages[JSONEditor.defaults.default_language][key];
        if (typeof string === "undefined")
          throw "Unknown translate string " + key;
        if (variables) {
          for (var i = 0; i < variables.length; i++) {
            string = string.replace(new RegExp('\\{\\{' + i + '}}', 'g'), variables[i]);
          }
        }
        return string;
      };
      JSONEditor.defaults.default_language = 'en';
      JSONEditor.defaults.language = JSONEditor.defaults.default_language;
      JSONEditor.defaults.languages.en = {
        error_notset: "Property must be set",
        error_notempty: "Value required",
        error_enum: "Value must be one of the enumerated values",
        error_anyOf: "Value must validate against at least one of the provided schemas",
        error_oneOf: 'Value must validate against exactly one of the provided schemas. It currently validates against {{0}} of the schemas.',
        error_not: "Value must not validate against the provided schema",
        error_type_union: "Value must be one of the provided types",
        error_type: "Value must be of type {{0}}",
        error_disallow_union: "Value must not be one of the provided disallowed types",
        error_disallow: "Value must not be of type {{0}}",
        error_multipleOf: "Value must be a multiple of {{0}}",
        error_maximum_excl: "Value must be less than {{0}}",
        error_maximum_incl: "Value must be at most {{0}}",
        error_minimum_excl: "Value must be greater than {{0}}",
        error_minimum_incl: "Value must be at least {{0}}",
        error_maxLength: "Value must be at most {{0}} characters long",
        error_minLength: "Value must be at least {{0}} characters long",
        error_pattern: "Value must match the pattern {{0}}",
        error_additionalItems: "No additional items allowed in this array",
        error_maxItems: "Value must have at most {{0}} items",
        error_minItems: "Value must have at least {{0}} items",
        error_uniqueItems: "Array must have unique items",
        error_maxProperties: "Object must have at most {{0}} properties",
        error_minProperties: "Object must have at least {{0}} properties",
        error_required: "Object is missing the required property '{{0}}'",
        error_additional_properties: "No additional properties allowed, but property {{0}} is set",
        error_dependency: "Must have property {{0}}",
        button_delete_all: "All",
        button_delete_all_title: "Delete All",
        button_delete_last: "Last {{0}}",
        button_delete_last_title: "Delete Last {{0}}",
        button_add_row_title: "Add {{0}}",
        button_move_down_title: "Move down",
        button_move_up_title: "Move up",
        button_delete_row_title: "Delete {{0}}",
        button_delete_row_title_short: "Delete",
        button_collapse: "Collapse"
      };
      JSONEditor.plugins = {
        ace: {theme: ''},
        epiceditor: {},
        sceditor: {},
        select2: {},
        selectize: {}
      };
      for (var i in JSONEditor.defaults.editors) {
        if (!JSONEditor.defaults.editors.hasOwnProperty(i))
          continue;
        JSONEditor.defaults.editors[i].options = JSONEditor.defaults.editors.options || {};
      }
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (typeof schema.type !== "string")
          return "multiple";
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (!schema.type && schema.properties)
          return "object";
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (typeof schema.type === "string")
          return schema.type;
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type === 'boolean') {
          if (schema.format === "checkbox" || (schema.options && schema.options.checkbox)) {
            return "checkbox";
          }
          return (JSONEditor.plugins.selectize.enable) ? 'selectize' : 'select';
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type === "any")
          return "multiple";
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type === "string" && schema.media && schema.media.binaryEncoding === "base64") {
          return "base64";
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type === "string" && schema.format === "url" && schema.options && schema.options.upload === true) {
          if (window.FileReader)
            return "upload";
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type == "array" && schema.format == "table") {
          return "table";
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.enumSource)
          return (JSONEditor.plugins.selectize.enable) ? 'selectize' : 'select';
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema["enum"]) {
          if (schema.type === "array" || schema.type === "object") {
            return "enum";
          } else if (schema.type === "number" || schema.type === "integer" || schema.type === "string") {
            return (JSONEditor.plugins.selectize.enable) ? 'selectize' : 'select';
          }
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.type === "array" && schema.items && !(Array.isArray(schema.items)) && schema.uniqueItems && ['string', 'number', 'integer'].indexOf(schema.items.type) >= 0) {
          if (schema.items.enum) {
            return 'multiselect';
          } else if (JSONEditor.plugins.selectize.enable && schema.items.type === "string") {
            return 'arraySelectize';
          }
        }
      });
      JSONEditor.defaults.resolvers.unshift(function(schema) {
        if (schema.oneOf)
          return "multiple";
      });
      (function() {
        if (window.jQuery || window.Zepto) {
          var $ = window.jQuery || window.Zepto;
          $.jsoneditor = JSONEditor.defaults;
          $.fn.jsoneditor = function(options) {
            var self = this;
            var editor = this.data('jsoneditor');
            if (options === 'value') {
              if (!editor)
                throw "Must initialize jsoneditor before getting/setting the value";
              if (arguments.length > 1) {
                editor.setValue(arguments[1]);
              } else {
                return editor.getValue();
              }
            } else if (options === 'validate') {
              if (!editor)
                throw "Must initialize jsoneditor before validating";
              if (arguments.length > 1) {
                return editor.validate(arguments[1]);
              } else {
                return editor.validate();
              }
            } else if (options === 'destroy') {
              if (editor) {
                editor.destroy();
                this.data('jsoneditor', null);
              }
            } else {
              if (editor) {
                editor.destroy();
              }
              editor = new JSONEditor(this.get(0), options);
              this.data('jsoneditor', editor);
              editor.on('change', function() {
                self.trigger('change');
              });
              editor.on('ready', function() {
                self.trigger('ready');
              });
            }
            return this;
          };
        }
      })();
      window.JSONEditor = JSONEditor;
    })();
  })();
  return _retrieveGlobal();
});

$__System.registerDynamic("75", ["74"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('74');
  return module.exports;
});

$__System.register('76', ['11', '14', '15', '16', '17', '20', '27', '75'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, JSONEditor, ViewSettings;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_7) {
            Marionette = _7['default'];
        }, function (_6) {
            JSONEditor = _6['default'];
        }],
        execute: function () {

            /**
             * Settings view for WorkflowJob.
             */
            'use strict';

            ViewSettings = (function (_Marionette$ItemView) {
                _inherits(ViewSettings, _Marionette$ItemView);

                function ViewSettings() {
                    _classCallCheck(this, ViewSettings);

                    _get(Object.getPrototypeOf(ViewSettings.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewSettings, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.workflow' (Workflow) must also be provided
                     */
                    value: function initialize(options) {
                        this._workflow = options.workflow;
                    }

                    /**
                     * Initialize the settings after render.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        this._initializeSettingsDisplay();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Save settings.
                     */
                }, {
                    key: '_handleButtonSave',
                    value: function _handleButtonSave() {
                        var element = this._getJQueryElement();
                        if ($(element).is(':visible')) {
                            this.model.set('job_settings', this._editor.getValue());
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOB_SAVE, { workflowjob: this.model, workflow: this._workflow });
                        }
                    }

                    /**
                     * Initializes settings display.
                     */
                }, {
                    key: '_initializeSettingsDisplay',
                    value: function _initializeSettingsDisplay() {
                        // Initially hide.
                        var element = this._getJQueryElement();
                        $(element).hide();

                        // Create settings.
                        var startValues = this.model.get('job_settings');
                        startValues = $.isEmptyObject(startValues) ? null : startValues;
                        $(element).show();
                        var jobUuid = this.model.getJobUuid();
                        var collection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION);
                        var job = collection.get(jobUuid);
                        var settingsSchema = {
                            schema: job.get('settings'),
                            theme: 'bootstrap3',
                            disable_collapse: true,
                            disable_edit_json: true,
                            disable_properties: true,
                            no_additional_properties: true,
                            show_errors: 'always',
                            startval: startValues,
                            form_name_root: ' '
                        };
                        this._editor = new JSONEditor.JSONEditor(element, settingsSchema);
                    }

                    /**
                     * Get HTML element as jQuery object.
                     */
                }, {
                    key: '_getJQueryElement',
                    value: function _getJQueryElement() {
                        return $(this.$el.find('#workflowjob-settings')[0])[0];
                    }
                }]);

                return ViewSettings;
            })(Marionette.ItemView);

            _export('default', ViewSettings);

            ViewSettings.prototype.modelEvents = {
                'all': 'render'
            };
            ViewSettings.prototype.ui = {
                buttonSave: '#button-save_workflowjob_settings'
            };
            ViewSettings.prototype.events = {
                'click @ui.buttonSave': '_handleButtonSave'
            };
            ViewSettings.prototype.template = '#template-main_workflowjob_settings';
        }
    };
});

$__System.register('77', ['10', '11', '14', '15', '16', '17', '20', '32', '33', '37', '47', '48', '54', '55', '57', '58', '59', '63', '64', '65', '67', '68', '73', '76', '78', '79', '6d', '6a', '6c'], function (_export) {
    var Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, _, BaseCollection, BaseController, Resource, ResourceCollection, ViewWorkflow, ViewWorkflowList, WorkflowCollection, ViewControlWorkflowJob, JobCollection, LayoutViewControlPorts, LayoutViewResourceAssignment, ResourceList, ViewJobList, ViewResourceListAssigned, ViewWorkflowJobGroup, ViewSettings, InputPort, OutputPort, Connection, ViewResourceListAvailable, ViewWorkflowListImportItem, ControllerWorkflowBuilder;

    return {
        setters: [function (_9) {
            Configuration = _9['default'];
        }, function (_10) {
            RODAN_EVENTS = _10['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_17) {
            Radio = _17['default'];
        }, function (_6) {
            _ = _6['default'];
        }, function (_7) {
            BaseCollection = _7['default'];
        }, function (_8) {
            BaseController = _8['default'];
        }, function (_18) {
            Resource = _18['default'];
        }, function (_19) {
            ResourceCollection = _19['default'];
        }, function (_23) {
            ViewWorkflow = _23['default'];
        }, function (_24) {
            ViewWorkflowList = _24['default'];
        }, function (_25) {
            WorkflowCollection = _25['default'];
        }, function (_12) {
            ViewControlWorkflowJob = _12['default'];
        }, function (_13) {
            JobCollection = _13['default'];
        }, function (_14) {
            LayoutViewControlPorts = _14['default'];
        }, function (_15) {
            LayoutViewResourceAssignment = _15['default'];
        }, function (_20) {
            ResourceList = _20['default'];
        }, function (_21) {
            ViewJobList = _21['default'];
        }, function (_22) {
            ViewResourceListAssigned = _22['default'];
        }, function (_26) {
            ViewWorkflowJobGroup = _26['default'];
        }, function (_27) {
            ViewSettings = _27['default'];
        }, function (_11) {
            InputPort = _11['default'];
        }, function (_16) {
            OutputPort = _16['default'];
        }, function (_d) {
            Connection = _d['default'];
        }, function (_a) {
            ViewResourceListAvailable = _a['default'];
        }, function (_c) {
            ViewWorkflowListImportItem = _c['default'];
        }],
        execute: function () {

            /**
             * Controller for the WorkflowBuilder.
             */
            'use strict';

            ControllerWorkflowBuilder = (function (_BaseController) {
                _inherits(ControllerWorkflowBuilder, _BaseController);

                function ControllerWorkflowBuilder() {
                    _classCallCheck(this, ControllerWorkflowBuilder);

                    _get(Object.getPrototypeOf(ControllerWorkflowBuilder.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerWorkflowBuilder, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializer.
                     */
                    value: function initialize() {
                        this._resourceAssignments = []; // this helps manage the list of resource assignments while building the resource
                        this._resourcesAvailable = []; // this is just a cache for resources that will work with a given input port
                        this._workflowRunOptions = {};
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_SELECTED, function (options) {
                            return _this._handleEventBuilderSelected(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SET_ADDPORTS, function (options) {
                            return _this._handleRequestSetAddPorts(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_CONNECTION, function (options) {
                            return _this._handleCommandAddConnection(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_INPUTPORT, function (options) {
                            return _this._handleCommandAddInputPort(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_OUTPUTPORT, function (options) {
                            return _this._handleCommandAddOutputPort(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOB, function (options) {
                            return _this._handleRequestAddWorkflowJob(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOBGROUP, function (options) {
                            return _this._handleRequestAddWorkflowJobGroup(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ASSIGN_RESOURCE, function (options) {
                            return _this._handleRequestAssignResource(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_CREATE_WORKFLOWRUN, function (options) {
                            return _this._handleRequestCreateWorkflowRun(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_DISTRIBUTOR, function (options) {
                            return _this._handleRequestCreateDistributor(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_CONNECTION, function (options) {
                            return _this._handleRequestDeleteConnection(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_INPUTPORT, function (options) {
                            return _this._handleCommandDeleteInputPort(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_OUTPUTPORT, function (options) {
                            return _this._handleCommandDeleteOutputPort(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB, function (options) {
                            return _this._handleRequestDeleteWorkflowJob(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOBGROUP, function (options) {
                            return _this._handleRequestDeleteWorkflowJobGroup(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_GET_RESOURCEASSIGNMENTS, function (options) {
                            return _this._handleRequestGetResourceAssignments(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_IMPORT_WORKFLOW, function (options) {
                            return _this._handleRequestImportWorkflow(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW, function (options) {
                            return _this._handleEventLoadWorkflow(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_JOBCOLLECTION_VIEW, function (options) {
                            return _this._handleRequestShowJobListView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_RESOURCEASSIGNMENT_VIEW, function (options) {
                            return _this._handleRequestShowResourceAssignmentView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWCOLLECTION_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowListView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOW_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowJobView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_PORTS_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowJobPortsView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_SETTINGS_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowJobSettingsView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOBGROUP_VIEW, function (options) {
                            return _this._handleRequestShowWorkflowJobGroupView(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_UNASSIGN_RESOURCE, function (options) {
                            return _this._handleRequestUnassignResource(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_UNGROUP_WORKFLOWJOBGROUP, function (options) {
                            return _this._handleRequestWorkflowJobGroupUngroup(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, function (options) {
                            return _this._handleRequestValidateWorkflow(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_GET_SATISFYING_INPUTPORTS, function (options) {
                            return _this._handleRequestGetSatisfyingInputPorts(options);
                        }, this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle selection.
                     */
                }, {
                    key: '_handleEventBuilderSelected',
                    value: function _handleEventBuilderSelected(options) {
                        this._resourceAssignments = [];
                        this._resourcesAvailable = [];
                        this._addPorts = true;
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW, { 'workflow': options.workflow });
                    }

                    /**
                     * Handle request set add ports.
                     */
                }, {
                    key: '_handleRequestSetAddPorts',
                    value: function _handleRequestSetAddPorts(options) {
                        this._addPorts = options.addports;
                    }

                    /**
                     * Handle request create WorkflowRun.
                     */
                }, {
                    key: '_handleRequestCreateWorkflowRun',
                    value: function _handleRequestCreateWorkflowRun(options) {
                        this._workflowRunOptions = { workflow: options.workflow, assignments: {} };
                        var inputPortTypes = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION);
                        var knownInputPorts = this._workflowRunOptions.workflow.get('workflow_input_ports').clone();
                        for (var inputPortUrl in this._resourceAssignments) {
                            // If our assignments for an InputPort are not needed, we just skip it.
                            var inputPort = knownInputPorts.findWhere({ url: inputPortUrl });
                            if (!inputPort) {
                                continue;
                            }

                            // If there is nothing for a given InputPort, error.
                            this._workflowRunOptions.assignments[inputPortUrl] = [];
                            var collection = this._getResourceAssignments(inputPortUrl);
                            if (collection.length === 0) {
                                alert('There are still unsatisfied Input Ports.');
                                return;
                            }

                            // Get URLs.
                            var resourceUrls = [];
                            for (var i = 0; i < collection.length; i++) {
                                var resource = collection.at(i);
                                resourceUrls.push(resource.get('url'));
                            }

                            // If the InputPort requires a ResourceList, we'll have to create one.
                            // Else, just get the Resource URLs.
                            var inputPortType = inputPortTypes.findWhere({ url: inputPort.get('input_port_type') });
                            if (inputPortType.get('is_list')) {
                                var resource = collection.at(0);
                                var resourceType = resource.get('resource_type');
                                var resourceList = new ResourceList();
                                resourceList.set({ resources: resourceUrls, resource_type: resourceType });
                                this._workflowRunOptions.assignments[inputPortUrl] = resourceList;
                            } else {
                                this._workflowRunOptions.assignments[inputPortUrl] = resourceUrls;
                            }

                            // Finally, remove the InputPort from the cloned Collection.
                            knownInputPorts.remove(inputPort);
                        }

                        // If we have anything left oveer in our cloned Collection, something is wrong.
                        if (knownInputPorts.length > 0) {
                            alert('There are still unsatisfied Input Ports.');
                        } else {
                            this._attemptWorkflowRunCreation();
                        }
                    }

                    /**
                     * Handle request show Resource assignment view.
                     */
                }, {
                    key: '_handleRequestShowResourceAssignmentView',
                    value: function _handleRequestShowResourceAssignmentView(options) {
                        // Create views.
                        var inputPort = options.inputport;
                        var assignedResources = this._getResourceAssignments(inputPort.get('url'));
                        var availableResources = this._getResourcesAvailable(inputPort);
                        var assignedResourceView = new ViewResourceListAssigned({ collection: assignedResources,
                            childViewOptions: { inputport: inputPort, assigned: true, workflow: options.workflow } });
                        var resourceListView = new ViewResourceListAvailable({ collection: availableResources,
                            childViewOptions: { inputport: inputPort, assigned: false, workflow: options.workflow } });

                        // Show the layout view.
                        var view = new LayoutViewResourceAssignment({ viewavailableresources: resourceListView, viewassignedresources: assignedResourceView });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'InputPort' });
                    }

                    /**
                     * Handles success of workflow fetch.
                     */
                }, {
                    key: '_handleWorkflowLoadSuccess',
                    value: function _handleWorkflowLoadSuccess(workflow) {
                        this._processWorkflow(workflow);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_LOADED_WORKFLOW, { workflow: workflow });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle request add workflow job.
                     */
                }, {
                    key: '_handleRequestAddWorkflowJob',
                    value: function _handleRequestAddWorkflowJob(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOB_CREATE, { job: options.job, workflow: options.workflow, addports: this._addPorts });
                        Radio.channel('rodan').once(RODAN_EVENTS.EVENT__WORKFLOWJOB_CREATED, function () {
                            return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: options.workflow });
                        });
                    }

                    /**
                     * Handle command delete WorkflowJob.
                     */
                }, {
                    key: '_handleRequestDeleteWorkflowJob',
                    value: function _handleRequestDeleteWorkflowJob(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOB_DELETE, { workflowjob: options.workflowjob, workflow: options.workflow });
                        Radio.channel('rodan').once(RODAN_EVENTS.EVENT__WORKFLOWJOB_DELETED, function () {
                            return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: options.workflow });
                        });
                    }

                    /**
                     * Handle command delete WorkflowJobGroup.
                     */
                }, {
                    key: '_handleRequestDeleteWorkflowJobGroup',
                    value: function _handleRequestDeleteWorkflowJobGroup(options) {
                        var _this2 = this;

                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_DELETE, { workflowjobgroup: options.workflowjobgroup, workflow: options.workflow });
                        Radio.channel('rodan').once(RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_DELETED, function () {
                            return _this2._handleEventWorkflowJobGroupDelete(options.workflowjobgroup, options.workflow);
                        });
                    }

                    /**
                     * Handle request delete Connection.
                     */
                }, {
                    key: '_handleRequestDeleteConnection',
                    value: function _handleRequestDeleteConnection(options) {
                        var _this3 = this;

                        options.connection.destroy({ success: function success(model) {
                                return _this3._handleConnectionDeletionSuccess(options.connection, options.workflow);
                            } });
                    }

                    /**
                     * Handle request import Workflow.
                     */
                }, {
                    key: '_handleRequestImportWorkflow',
                    value: function _handleRequestImportWorkflow(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_IMPORT, { origin: options.origin, target: options.target });
                        Radio.channel('rodan').once(RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_IMPORTED, function () {
                            return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW, { workflow: options.target });
                        });
                    }

                    /**
                     * Handle add connection.
                     */
                }, {
                    key: '_handleCommandAddConnection',
                    value: function _handleCommandAddConnection(options) {
                        this._createConnection(options.outputport, options.inputport, options.workflow);
                    }

                    /**
                     * Create input port
                     */
                }, {
                    key: '_handleCommandAddInputPort',
                    value: function _handleCommandAddInputPort(options) {
                        var _this4 = this;

                        var port = new InputPort({ input_port_type: options.inputporttype.get('url'), workflow_job: options.workflowjob.get('url') });
                        port.save({}, { success: function success(model) {
                                return _this4._handleInputPortCreationSuccess(port, options.workflow, options.workflowjob);
                            } });
                    }

                    /**
                     * Create output port
                     */
                }, {
                    key: '_handleCommandAddOutputPort',
                    value: function _handleCommandAddOutputPort(options) {
                        var _this5 = this;

                        var port = new OutputPort({ output_port_type: options.outputporttype.get('url'), workflow_job: options.workflowjob.get('url') });
                        port.save({}, { success: function success(model) {
                                return _this5._handleOutputPortCreationSuccess(port, options.workflow, options.workflowjob, options.targetinputports);
                            } });
                    }

                    /**
                     * Delete input port
                     */
                }, {
                    key: '_handleCommandDeleteInputPort',
                    value: function _handleCommandDeleteInputPort(options) {
                        var _this6 = this;

                        options.inputport.destroy({ success: function success(model) {
                                return _this6._handleInputPortDeletionSuccess(model, options.workflow, options.workflowjob);
                            } });
                    }

                    /**
                     * Delete output port
                     */
                }, {
                    key: '_handleCommandDeleteOutputPort',
                    value: function _handleCommandDeleteOutputPort(options) {
                        var _this7 = this;

                        options.outputport.destroy({ success: function success(model) {
                                return _this7._handleOutputPortDeletionSuccess(model, options.workflow, options.workflowjob);
                            } });
                    }

                    /**
                     * Handle request load Workflow.
                     */
                }, {
                    key: '_handleEventLoadWorkflow',
                    value: function _handleEventLoadWorkflow(options) {
                        var _this8 = this;

                        options.workflow.fetch({ 'success': function success(workflow) {
                                return _this8._handleWorkflowLoadSuccess(workflow);
                            } });
                    }

                    /**
                     * Handle request validate Workflow.
                     */
                }, {
                    key: '_handleRequestValidateWorkflow',
                    value: function _handleRequestValidateWorkflow(options) {
                        this._validateWorkflow(options.workflow);
                    }

                    /**
                     * Handle request create distributor.
                     */
                }, {
                    key: '_handleRequestCreateDistributor',
                    value: function _handleRequestCreateDistributor(options) {
                        var requiredResourceTypes = this._getCompatibleResourceTypeURLs(options.inputports);
                        if (requiredResourceTypes.length > 0) {
                            var jobs = this._getCandidateResourceDistributorJobs(requiredResourceTypes);
                            if (jobs.length > 0) {
                                // TODO - offer list
                                var targetInputPorts = [];
                                for (var index in options.inputports) {
                                    var inputPort = options.inputports[index];
                                    targetInputPorts.push(options.workflow.get('workflow_input_ports').get(inputPort.id));
                                }
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOB_CREATE, { job: jobs[0],
                                    workflow: options.workflow,
                                    addports: true,
                                    targetinputports: targetInputPorts });
                            }
                        }
                    }

                    /**
                     * Handle request WorkflowJobGroup ungroup.
                     */
                }, {
                    key: '_handleRequestWorkflowJobGroupUngroup',
                    value: function _handleRequestWorkflowJobGroupUngroup(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_DELETE, { workflowjobgroup: options.workflowjobgroup, workflow: options.workflow });
                    }

                    /**
                     * Handle request add WorkflowJobGroup.
                     */
                }, {
                    key: '_handleRequestAddWorkflowJobGroup',
                    value: function _handleRequestAddWorkflowJobGroup(options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_CREATE, { workflowjobs: options.workflowjobs, workflow: options.workflow });
                    }

                    /**
                     * Handle request assign Resource to InputPort.
                     */
                }, {
                    key: '_handleRequestAssignResource',
                    value: function _handleRequestAssignResource(options) {
                        var url = options.inputport.get('url');
                        var resourcesAssigned = this._getResourceAssignments(url);
                        var multipleUrl = this._getInputPortURLWithMultipleAssignments();
                        if (multipleUrl && resourcesAssigned.length > 0 && multipleUrl !== url) {
                            alert('Only one InputPort may have multiple Resources assigned to it.');
                            return;
                        }
                        resourcesAssigned.add(options.resource);
                    }

                    /**
                     * Handle request unassigne Resource from InputPort.
                     */
                }, {
                    key: '_handleRequestUnassignResource',
                    value: function _handleRequestUnassignResource(options) {
                        var resourcesAssigned = this._getResourceAssignments(options.inputport.get('url'));
                        resourcesAssigned.remove(options.resource);
                    }

                    /**
                     * Handle request get Resource assignments.
                     */
                }, {
                    key: '_handleRequestGetResourceAssignments',
                    value: function _handleRequestGetResourceAssignments(options) {
                        return this._getResourceAssignments(options.inputport.get('url'));
                    }

                    /**
                     * Handle request get Workflow view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowView',
                    value: function _handleRequestShowWorkflowView(options) {
                        var view = new ViewWorkflow({ template: '#template-main_workflow_individual_edit', model: options.workflow });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'Workflow' });
                    }

                    /**
                     * Handle request get WorkflowJob view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowJobView',
                    value: function _handleRequestShowWorkflowJobView(options) {
                        var view = new ViewControlWorkflowJob({ model: options.workflowjob, workflow: options.workflow });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: options.workflowjob.get('name') });
                    }

                    /**
                     * Handle request show Job list view.
                     */
                }, {
                    key: '_handleRequestShowJobListView',
                    value: function _handleRequestShowJobListView(options) {
                        var collection = new JobCollection();
                        collection.fetch();
                        var view = new ViewJobList({ collection: collection, childViewOptions: { workflow: options.workflow } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'Jobs' });
                    }

                    /**
                     * Handle request show Workflow list view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowListView',
                    value: function _handleRequestShowWorkflowListView(options) {
                        var collection = new WorkflowCollection();
                        collection.fetch({ data: { /*project: project.id, */valid: 'True' } });
                        var project = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE);
                        var view = new ViewWorkflowList({ collection: collection,
                            childView: ViewWorkflowListImportItem,
                            template: '#template-main_workflow_list_import',
                            childViewOptions: { workflow: options.workflow } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'Workflows' });
                    }

                    /**
                     * Handle request show WorkflowJobGroup view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowJobGroupView',
                    value: function _handleRequestShowWorkflowJobGroupView(options) {
                        var view = new ViewWorkflowJobGroup({ workflow: options.workflow, workflowjobgroup: options.workflowjobgroup });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'Workflow Job Group' });
                    }

                    /**
                     * Handle request show WorkflowJob ports view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowJobPortsView',
                    value: function _handleRequestShowWorkflowJobPortsView(options) {
                        var view = new LayoutViewControlPorts(options);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'WorkflowJob Ports' });
                    }

                    /**
                     * Handle request show WorkflowJob settings view.
                     */
                }, {
                    key: '_handleRequestShowWorkflowJobSettingsView',
                    value: function _handleRequestShowWorkflowJobSettingsView(options) {
                        var view = new ViewSettings({ workflow: options.workflow, model: options.workflowjob });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW, { view: view, title: 'WorkflowJob Settings' });
                    }

                    /**
                     * Handle WorkflowJobGroup delete success. This will remove associated WorkflowJobs.
                     */
                }, {
                    key: '_handleEventWorkflowJobGroupDelete',
                    value: function _handleEventWorkflowJobGroupDelete(workflowJobGroup, workflow) {
                        var workflowJobs = workflowJobGroup.get('workflow_jobs');
                        for (var index in workflowJobs) {
                            var workflowJob = workflow.get('workflow_jobs').findWhere({ url: workflowJobs[index] });
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB, { workflowjob: workflowJob, workflow: workflow });
                        }
                    }

                    /**
                     * Handle request get satisfying InputPorts.
                     */
                }, {
                    key: '_handleRequestGetSatisfyingInputPorts',
                    value: function _handleRequestGetSatisfyingInputPorts(options) {
                        var outputPort = options.outputport;
                        var workflow = options.workflow;
                        return this._getSatisfiableInputPorts(outputPort, workflow);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - REST response handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle ResourceList creation success.
                     */
                }, {
                    key: '_handleResourceListCreationSuccess',
                    value: function _handleResourceListCreationSuccess(model, inputPortUrl) {
                        this._workflowRunOptions.assignments[inputPortUrl] = [model.get('url')];
                        this._attemptWorkflowRunCreation();
                    }

                    /**
                     * Handle ResourceList creation error.
                     */
                }, {
                    key: '_handleResourceListCreationError',
                    value: function _handleResourceListCreationError() {}
                    // todo - need something here

                    /**
                     * Handle InputPort creation success.
                     */

                }, {
                    key: '_handleInputPortCreationSuccess',
                    value: function _handleInputPortCreationSuccess(model, workflow, workflowJob) {
                        workflow.get('workflow_input_ports').add(model);
                        workflowJob.get('input_ports').add(model);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle OutputPort creation success.
                     */
                }, {
                    key: '_handleOutputPortCreationSuccess',
                    value: function _handleOutputPortCreationSuccess(model, workflow, workflowJob, targetInputPorts) {
                        workflow.get('workflow_output_ports').add(model);
                        workflowJob.get('output_ports').add(model);
                        for (var index in targetInputPorts) {
                            this._createConnection(model, targetInputPorts[index], workflow);
                        }
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handles success of Connection creation.
                     */
                }, {
                    key: '_handleConnectionCreationSuccess',
                    value: function _handleConnectionCreationSuccess(model, workflow, inputPort, outputPort) {
                        workflow.get('connections').add(model);
                        inputPort.fetch(); // to get populated Connection array
                        outputPort.fetch(); // to get populated Connection array
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle InputPort deletion success.
                     */
                }, {
                    key: '_handleInputPortDeletionSuccess',
                    value: function _handleInputPortDeletionSuccess(model, workflow, workflowJob) {
                        workflowJob.get('input_ports').remove(model);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle OutputPort deletion success.
                     */
                }, {
                    key: '_handleOutputPortDeletionSuccess',
                    value: function _handleOutputPortDeletionSuccess(model, workflow, workflowJob) {
                        workflowJob.get('output_ports').remove(model);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle Connection deletion success.
                     */
                }, {
                    key: '_handleConnectionDeletionSuccess',
                    value: function _handleConnectionDeletionSuccess(model, workflow) {
                        workflow.get('connections').remove(model);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                    }

                    /**
                     * Handle validation failure.
                     */
                }, {
                    key: '_handleValidationFailure',
                    value: function _handleValidationFailure(model, response, options) {
                        model.set({ 'valid': false });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_VALIDATED_WORKFLOW, { workflow: model });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Create connection.
                     */
                }, {
                    key: '_createConnection',
                    value: function _createConnection(outputPort, inputPort, workflow) {
                        var _this9 = this;

                        var connection = new Connection({ input_port: inputPort.get('url'), output_port: outputPort.get('url') });
                        connection.save({}, { success: function success(model) {
                                return _this9._handleConnectionCreationSuccess(model, workflow, inputPort, outputPort);
                            } });
                    }

                    /**
                     * Process workflow for GUI.
                     */
                }, {
                    key: '_processWorkflow',
                    value: function _processWorkflow(workflow) {
                        // Process all WorkflowJobs and their associated ports.
                        var connections = {};
                        var workflowJobs = workflow.get('workflow_jobs');
                        if (workflowJobs !== undefined) {
                            for (var i = 0; i < workflowJobs.length; i++) {
                                // Create WorkflowJob item then process connections.
                                var workflowJob = workflowJobs.at(i);
                                var tempConnections = this._processWorkflowJob(workflowJob);

                                // For the connections returned, merge them into our master list.
                                for (var connectionUrl in tempConnections) {
                                    var connection = tempConnections[connectionUrl];
                                    if (connections.hasOwnProperty(connectionUrl)) {
                                        connections[connectionUrl].inputPort = connections[connectionUrl].inputPort === null ? connection.inputPort : connections[connectionUrl].inputPort;
                                        connections[connectionUrl].outputPort = connections[connectionUrl].outputPort === null ? connection.outputPort : connections[connectionUrl].outputPort;
                                    } else {
                                        connections[connectionUrl] = connection;
                                    }
                                }
                            }
                        }

                        // Process connections.
                        for (var connectionUrl in connections) {
                            var connection = connections[connectionUrl];
                            var connectionModel = new Connection({ input_port: connection.inputPort.get('url'),
                                output_port: connection.outputPort.get('url'),
                                url: connectionUrl });

                            // TODO - better way to get connections?
                            var connectionId = connectionModel.parseIdFromUrl(connectionUrl);
                            connectionModel.set({ uuid: connectionId });
                            connectionModel.fetch();
                            workflow.get('connections').add(connectionModel);
                        }

                        // Finally inport the WorkflowJobGroups.
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_LOAD_COLLECTION, { workflow: workflow });
                    }

                    /**
                     * Process workflow job for GUI.
                     */
                }, {
                    key: '_processWorkflowJob',
                    value: function _processWorkflowJob(model) {
                        // We want to keep track of what connections need to be made and return those.
                        var connections = {};

                        // Process input ports.
                        var inputPorts = model.get('input_ports');
                        if (inputPorts !== undefined) {
                            for (var i = 0; i < inputPorts.length; i++) {
                                var inputPort = inputPorts.at(i);

                                // Get connections.
                                var inputPortConnections = inputPort.get('connections');
                                for (var k = 0; k < inputPortConnections.length; k++) {
                                    var connection = inputPortConnections[k];
                                    connections[connection] = { 'inputPort': inputPort, 'outputPort': null };
                                }
                            }
                        }

                        // Process output ports.
                        var outputPorts = model.get('output_ports');
                        if (outputPorts !== undefined) {
                            for (var j = 0; j < outputPorts.length; j++) {
                                var outputPort = outputPorts.at(j);

                                // Get connections.
                                var outputPortConnections = outputPort.get('connections');
                                for (var k = 0; k < outputPortConnections.length; k++) {
                                    var connection = outputPortConnections[k];
                                    connections[connection] = { 'inputPort': null, 'outputPort': outputPort };
                                }
                            }
                        }

                        return connections;
                    }

                    /**
                     * Attempts to validate Workflow.
                     */
                }, {
                    key: '_validateWorkflow',
                    value: function _validateWorkflow(workflow) {
                        var _this10 = this;

                        workflow.save({ valid: true }, { patch: true,
                            success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWBUILDER_VALIDATED_WORKFLOW, { workflow: model });
                            },
                            error: function error(model, response, options) {
                                return _this10._handleValidationFailure(model, response, options);
                            } });
                    }

                    /**
                     * Given an array of InputPorts, returns an array of ResourceType URLs that
                     * would satisfy the InputPorts.
                     */
                }, {
                    key: '_getCompatibleResourceTypeURLs',
                    value: function _getCompatibleResourceTypeURLs(inputPorts) {
                        var resourceTypes = [];
                        var inputPortTypes = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION);
                        for (var index in inputPorts) {
                            // Get the available resource types.
                            var inputPort = inputPorts[index];
                            var inputPortTypeURL = inputPort.get('input_port_type');
                            var inputPortType = inputPortTypes.findWhere({ url: inputPortTypeURL });
                            var inputPortResourceTypes = inputPortType.get('resource_types');

                            // If this is the first iteration, set the array. Else, do an intersection.
                            if (resourceTypes.length === 0) {
                                resourceTypes = inputPortResourceTypes;
                            }
                            resourceTypes = _.intersection(resourceTypes, inputPortResourceTypes);
                        }
                        return resourceTypes;
                    }

                    /**
                     * Given an OutputPort, returns an array of ResourceType URLs that would satisfy it.
                     */
                }, {
                    key: '_getOutputPortResourceTypeURLs',
                    value: function _getOutputPortResourceTypeURLs(outputPort) {
                        var resourceTypes = [];
                        var outputPortTypes = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_OUTPUTPORTTYPE_COLLECTION);
                        var outputPortTypeURL = outputPort.get('output_port_type');
                        var outputPortType = outputPortTypes.findWhere({ url: outputPortTypeURL });
                        var outputPortResourceTypes = outputPortType.get('resource_types');
                        return outputPortResourceTypes;
                    }

                    /**
                     * Given an array of ResourceType URLs, finds jobs that both give at least one and take at least
                     * one of the ResourceTypes. The returned array {job: Job, inputporttypes: URL strings, outputporttypes: URL string}.
                     * The port types are those ports of the associated Job that will satisfy the resource requirements.
                     */
                }, {
                    key: '_getCandidateResourceDistributorJobs',
                    value: function _getCandidateResourceDistributorJobs(resourceTypes) {
                        var jobs = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION).where({ category: Configuration.RESOURCE_DISTRIBUTOR_CATEGORY });
                        var satisfiableJobs = [];
                        for (var i = 0; i < jobs.length; i++) {
                            var job = jobs[i];
                            var inputPortType = job.get('input_port_types').at(0);
                            var outputPortType = job.get('output_port_types').at(0);

                            // Intersect against InputPortType ResourceTypes.
                            var intersect = _.intersection(resourceTypes, inputPortType.get('resource_types'));
                            if (intersect.length === 0) {
                                continue;
                            }

                            intersect = _.intersection(resourceTypes, outputPortType.get('resource_types'));
                            if (intersect.length === 0) {
                                continue;
                            }

                            // We want to keep this job.
                            satisfiableJobs.push(job);
                        }
                        return satisfiableJobs;
                    }

                    /**
                     * Return InputPort URL that has multiple assignments.
                     * Returns null if DNE.
                     */
                }, {
                    key: '_getInputPortURLWithMultipleAssignments',
                    value: function _getInputPortURLWithMultipleAssignments() {
                        for (var inputPortUrl in this._resourceAssignments) {
                            var resourceAssignments = this._getResourceAssignments(inputPortUrl);
                            if (resourceAssignments.length > 1) {
                                return inputPortUrl;
                            }
                        }
                        return null;
                    }

                    /**
                     * Returns resource assignment for given InputPort url.
                     */
                }, {
                    key: '_getResourceAssignments',
                    value: function _getResourceAssignments(inputPortUrl) {
                        if (!this._resourceAssignments[inputPortUrl]) {
                            this._resourceAssignments[inputPortUrl] = new BaseCollection(null, { model: Resource });
                        }
                        return this._resourceAssignments[inputPortUrl];
                    }

                    /**
                     * Returns resources available for given InputPort.
                     */
                }, {
                    key: '_getResourcesAvailable',
                    value: function _getResourcesAvailable(inputPort) {
                        if (!this._resourcesAvailable[inputPort.get('url')]) {
                            var project = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE);
                            var resourceTypeURLs = this._getCompatibleResourceTypeURLs([inputPort]);
                            var data = { project: project.id, resource_type__in: '' };
                            var globalResourceTypes = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION);
                            var first = true;
                            for (var index in resourceTypeURLs) {
                                var idString = null;
                                if (first) {
                                    first = false;
                                    idString = globalResourceTypes.findWhere({ url: resourceTypeURLs[index] }).id;
                                } else {
                                    idString = ',' + globalResourceTypes.findWhere({ url: resourceTypeURLs[index] }).id;
                                }
                                data.resource_type__in = data.resource_type__in + idString;
                            }
                            this._resourcesAvailable[inputPort.get('url')] = new ResourceCollection();
                            this._resourcesAvailable[inputPort.get('url')].fetch({ data: data });
                        }
                        this._resourcesAvailable[inputPort.get('url')].syncList();
                        return this._resourcesAvailable[inputPort.get('url')];
                    }

                    /**
                     * Check WorkflowRun Resource assignments.
                     *
                     * This method checks if any Resource assignments are ResourceLists.
                     * If there are and the ResourceList has no ID, it saves the list and waits for a response.
                     * If it has an ID, it replaces the object with the URL for that ResourceList.
                     * If a reference is just to an array of REsource refs, it is ignored.
                     *
                     * If everything checks out create the WorkflowRun and return true. Else return false.
                     */
                }, {
                    key: '_attemptWorkflowRunCreation',
                    value: function _attemptWorkflowRunCreation() {
                        var _this11 = this;

                        for (var inputPortUrl in this._workflowRunOptions.assignments) {
                            var assignments = this._workflowRunOptions.assignments[inputPortUrl];
                            if (assignments instanceof ResourceList && !assignments.id) {
                                // TODO - shitty way to do this; once I do a "save", I don't do another; this ensures that 'inputPortUrl'
                                // doesn't get set to the last one in the loop
                                assignments.save({}, { success: function success(model) {
                                        return _this11._handleResourceListCreationSuccess(model, inputPortUrl);
                                    },
                                    error: function error() {
                                        return _this11._handleResourceListCreationError();
                                    } });
                                return false;
                            }
                        }
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWRUN_CREATE, this._workflowRunOptions);
                        return true;
                    }

                    /**
                     * Given a WorkflowJob, returns array of all InputPorts.
                     */
                }, {
                    key: '_getInputPorts',
                    value: function _getInputPorts(workflowJobs) {
                        var inputPorts = [];
                        for (var i = 0; i < workflowJobs.length; i++) {
                            var workflowJob = workflowJobs[i];
                            inputPorts.push(workflowJob.get('input_ports').models());
                        }
                        return inputPorts;
                    }

                    /**
                     * Given an OutputPort, return an array of those InputPort URLs that would be satisfied by the OutputPort.
                     */
                }, {
                    key: '_getSatisfiableInputPorts',
                    value: function _getSatisfiableInputPorts(outputPort, workflow) {
                        var outputPortResourceTypes = this._getOutputPortResourceTypeURLs(outputPort);
                        var inputPortTypes = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION);
                        var inputPorts = [];
                        var workflowJobs = workflow.get('workflow_jobs').models;
                        for (var i = 0; i < workflowJobs.length; i++) {
                            // Get WorkflowJob.
                            var workflowJob = workflowJobs[i];
                            if (workflowJob.get('url') === outputPort.get('workflow_job')) {
                                continue;
                            }

                            // For each InputPort, get ResourceType URL.
                            var possibleInputPorts = workflowJob.get('input_ports').models;
                            for (var j = 0; j < possibleInputPorts.length; j++) {
                                var inputPort = possibleInputPorts[j];
                                var inputPortType = inputPortTypes.findWhere({ url: inputPort.get('input_port_type') });
                                var inputPortResourceTypes = inputPortType.get('resource_types');
                                var resourceTypes = _.intersection(outputPortResourceTypes, inputPortResourceTypes);
                                if (resourceTypes.length > 0) {
                                    inputPorts.push(inputPort.get('url'));
                                }
                            }
                        }
                        return inputPorts;
                    }
                }]);

                return ControllerWorkflowBuilder;
            })(BaseController);

            _export('default', ControllerWorkflowBuilder);
        }
    };
});

$__System.register('78', ['14', '15', '16', '17', '1d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseModel, InputPort;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * InputPort.
       */
      'use strict';

      InputPort = (function (_BaseModel) {
        _inherits(InputPort, _BaseModel);

        function InputPort() {
          _classCallCheck(this, InputPort);

          _get(Object.getPrototypeOf(InputPort.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(InputPort, [{
          key: 'defaults',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Override of Backbone.Model.defaults. Sets default label to null.
           *
           * @return {object} defaults
           */
          value: function defaults() {
            return { label: null };
          }

          /**
           * Returns human-readable descriptive text.
           *
           * @return {string} 'label' property
           */
        }, {
          key: 'getDescription',
          value: function getDescription() {
            return this.get('label');
          }
        }]);

        return InputPort;
      })(BaseModel);

      _export('default', InputPort);

      InputPort.prototype.routeName = 'inputports';
    }
  };
});

$__System.register('71', ['14', '15', '16', '17', '33', '78'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, InputPort, InputPortCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      InputPort = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of InputPort models.
       */
      'use strict';

      InputPortCollection = (function (_BaseCollection) {
        _inherits(InputPortCollection, _BaseCollection);

        function InputPortCollection() {
          _classCallCheck(this, InputPortCollection);

          _get(Object.getPrototypeOf(InputPortCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(InputPortCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = InputPort;
            this._route = 'inputports';
          }
        }]);

        return InputPortCollection;
      })(BaseCollection);

      _export('default', InputPortCollection);
    }
  };
});

$__System.register('79', ['14', '15', '16', '17', '1d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseModel, OutputPort;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * InputPort.
       */
      'use strict';

      OutputPort = (function (_BaseModel) {
        _inherits(OutputPort, _BaseModel);

        function OutputPort() {
          _classCallCheck(this, OutputPort);

          _get(Object.getPrototypeOf(OutputPort.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(OutputPort, [{
          key: 'defaults',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Override of Backbone.Model.defaults. Sets default label to null.
           *
           * @return {object} default properties
           */
          value: function defaults() {
            return { label: null };
          }

          /**
           * Returns human-readable descriptive text.
           *
           * @return {string} 'label' property
           */
        }, {
          key: 'getDescription',
          value: function getDescription() {
            return this.get('label');
          }
        }]);

        return OutputPort;
      })(BaseModel);

      _export('default', OutputPort);

      OutputPort.prototype.routeName = 'outputports';
    }
  };
});

$__System.register('72', ['14', '15', '16', '17', '33', '79'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, OutputPort, OutputPortCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      OutputPort = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of OutputPort models.
       */
      'use strict';

      OutputPortCollection = (function (_BaseCollection) {
        _inherits(OutputPortCollection, _BaseCollection);

        function OutputPortCollection() {
          _classCallCheck(this, OutputPortCollection);

          _get(Object.getPrototypeOf(OutputPortCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(OutputPortCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = OutputPort;
            this._route = 'outputports';
          }
        }]);

        return OutputPortCollection;
      })(BaseCollection);

      _export('default', OutputPortCollection);
    }
  };
});

$__System.register('70', ['14', '15', '16', '17', '71', '72', '1d'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, InputPortCollection, OutputPortCollection, BaseModel, WorkflowJob;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            InputPortCollection = _5['default'];
        }, function (_6) {
            OutputPortCollection = _6['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * WorkflowJob.
             */
            'use strict';

            WorkflowJob = (function (_BaseModel) {
                _inherits(WorkflowJob, _BaseModel);

                function WorkflowJob() {
                    _classCallCheck(this, WorkflowJob);

                    _get(Object.getPrototypeOf(WorkflowJob.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(WorkflowJob, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Backbone.Model options object; 'options.input_ports' (InputPortCollection or associated Backbone.Collection raw-object representation) and 'options.output_ports' (OutputPortCollection or associated Backbone.Collection raw-object representation) must also be provided
                     */
                    value: function initialize(options) {
                        var inputPortCollection = new InputPortCollection();
                        var outputPortCollection = new OutputPortCollection();
                        inputPortCollection.set(options.input_ports);
                        outputPortCollection.set(options.output_ports);
                        this.set('input_ports', inputPortCollection);
                        this.set('output_ports', outputPortCollection);
                    }

                    /**
                     * Returns defaults.
                     *
                     * @return {object} object holding default values
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return { input_ports: null, output_ports: null, job_name: null, job_description: null };
                    }

                    /**
                     * Override of Backbone.Model.parse. This will populate 'input_ports' and 'output_ports' with associated models.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        for (var i in response.input_ports) {
                            var ModelClass = this.get('input_ports').model;
                            var model = new ModelClass(response.input_ports[i]);
                            this.get('input_ports').add(model, { merge: true });
                        }
                        response.input_ports = this.get('input_ports');

                        for (i in response.output_ports) {
                            var ModelClass = this.get('output_ports').model;
                            var model = new ModelClass(response.output_ports[i]);
                            this.get('output_ports').add(model, { merge: true });
                        }
                        response.output_ports = this.get('output_ports');

                        return response;
                    }

                    /**
                     * Returns UUID of associated Job.
                     *
                     * @return {string} UUID of associated Job
                     */
                }, {
                    key: 'getJobUuid',
                    value: function getJobUuid() {
                        var lastSlash = this.get('job').lastIndexOf('/');
                        var subString = this.get('job').substring(0, lastSlash);
                        var secondLastSlash = subString.lastIndexOf('/');
                        return this.get('job').substring(secondLastSlash + 1, lastSlash);
                    }

                    /**
                     * Returns human-readable descriptive text.
                     *
                     * @return {string} 'name' and 'job_description' (from associated Job)
                     */
                }, {
                    key: 'getDescription',
                    value: function getDescription() {
                        var string = this.get('name') + ': ' + this.get('job_description');
                        return string;
                    }
                }]);

                return WorkflowJob;
            })(BaseModel);

            _export('default', WorkflowJob);

            WorkflowJob.prototype.routeName = 'workflowjobs';
        }
    };
});

$__System.register('7a', ['11', '14', '15', '16', '17', '20', '37', '70'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, WorkflowJob, ControllerWorkflowJob;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_8) {
            WorkflowJob = _8['default'];
        }],
        execute: function () {

            /**
             * Controller for WorkflowJobs.
             */
            'use strict';

            ControllerWorkflowJob = (function (_BaseController) {
                _inherits(ControllerWorkflowJob, _BaseController);

                function ControllerWorkflowJob() {
                    _classCallCheck(this, ControllerWorkflowJob);

                    _get(Object.getPrototypeOf(ControllerWorkflowJob.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerWorkflowJob, [{
                    key: '_initializeRadio',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Initialization
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOB_CREATE, function (options) {
                            return _this._handleRequestCreateWorkflowJob(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOB_DELETE, function (options) {
                            return _this._handleRequestDeleteWorkflowJob(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOB_SAVE, function (options) {
                            return _this._handleRequestSaveWorkflowJob(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Create WorkflowJob.
                     *
                     * If ports are to be automatically generated, we add a success function that adds them.
                     */
                }, {
                    key: '_handleRequestCreateWorkflowJob',
                    value: function _handleRequestCreateWorkflowJob(options) {
                        var _this2 = this;

                        var workflowJob = new WorkflowJob({ job: options.job.get('url'), workflow: options.workflow.get('url') });
                        var addPorts = options.addports ? options.addports : false;
                        var targetInputPorts = options.targetinputports ? options.targetinputports : [];
                        workflowJob.save({}, { success: function success(model) {
                                return _this2._handleWorkflowJobCreationSuccess(model, options.workflow, addPorts, targetInputPorts);
                            } });
                    }

                    /**
                     * Delete WorkflowJob
                     */
                }, {
                    key: '_handleRequestDeleteWorkflowJob',
                    value: function _handleRequestDeleteWorkflowJob(options) {
                        options.workflowjob.destroy({ success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOB_DELETED, { workflowjob: model });
                            } });
                    }

                    /**
                     * Handle save WorkflowJob.
                     */
                }, {
                    key: '_handleRequestSaveWorkflowJob',
                    value: function _handleRequestSaveWorkflowJob(options) {
                        var _this3 = this;

                        options.workflowjob.save(options.workflowjob.changed, { patch: true, success: function success(model) {
                                return _this3._handleWorkflowJobSaveSuccess(model, options.workflow);
                            } });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - REST handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle WorkflowJob creation success.
                     */
                }, {
                    key: '_handleWorkflowJobCreationSuccess',
                    value: function _handleWorkflowJobCreationSuccess(model, workflow, addPorts, targetInputPorts) {
                        workflow.get('workflow_jobs').add(model);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOB_CREATED, { workflowjob: model });
                        if (addPorts) {
                            this._addRequiredPorts(model, targetInputPorts, workflow);
                        }
                    }

                    /**
                     * Handle save success.
                     */
                }, {
                    key: '_handleWorkflowJobSaveSuccess',
                    value: function _handleWorkflowJobSaveSuccess(workflowJob, workflow) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOB_SAVED, { workflowjob: workflowJob });
                        if (workflow) {
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW, { workflow: workflow });
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Given a WorkflowJob, adds ports that must be present.
                     * This method assumes that the WorkflowJob has NO ports to begin with.
                     * The InputPorts in targetInputPorts will be automatically connected to IFF the resulting
                     * WorkflowJob has one OutputPort.
                     */
                }, {
                    key: '_addRequiredPorts',
                    value: function _addRequiredPorts(workflowJob, targetInputPorts, workflow) {
                        var jobCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION);
                        var job = jobCollection.get(workflowJob.getJobUuid());
                        var outputPortTypes = job.get('output_port_types');
                        var inputPortTypes = job.get('input_port_types');

                        this._addInputPorts(workflowJob, inputPortTypes, workflow);
                        this._addOutputPorts(workflowJob, outputPortTypes, targetInputPorts, workflow);
                    }

                    /**
                     * Adds InputPorts.
                     */
                }, {
                    key: '_addInputPorts',
                    value: function _addInputPorts(workflowJob, inputPortTypes, workflow) {
                        inputPortTypes.forEach(function (inputPortType) {
                            for (var i = 0; i < inputPortType.get('minimum'); i++) {
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_INPUTPORT, { inputporttype: inputPortType, workflowjob: workflowJob, workflow: workflow });
                            }
                        });
                    }

                    /**
                     * Adds OutputPorts.
                     */
                }, {
                    key: '_addOutputPorts',
                    value: function _addOutputPorts(workflowJob, outputPortTypes, targetInputPorts, workflow) {
                        var sendTargetInputPorts = outputPortTypes.length === 1 && outputPortTypes.at(0).get('minimum') === 1 ? targetInputPorts : [];
                        outputPortTypes.forEach(function (outputPortType) {
                            for (var i = 0; i < outputPortType.get('minimum'); i++) {
                                Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_ADD_OUTPUTPORT, { outputporttype: outputPortType, workflowjob: workflowJob, targetinputports: targetInputPorts, workflow: workflow });
                            }
                        });
                    }
                }]);

                return ControllerWorkflowJob;
            })(BaseController);

            _export('default', ControllerWorkflowJob);
        }
    };
});

$__System.register('7b', ['14', '15', '16', '17', '1d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseModel, WorkflowJobGroup;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * WorkflowJobGroup.
       */
      'use strict';

      WorkflowJobGroup = (function (_BaseModel) {
        _inherits(WorkflowJobGroup, _BaseModel);

        function WorkflowJobGroup() {
          _classCallCheck(this, WorkflowJobGroup);

          _get(Object.getPrototypeOf(WorkflowJobGroup.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(WorkflowJobGroup, [{
          key: 'defaults',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Returns defaults.
           *
           * @return {object} object holding default values
           */
          value: function defaults() {
            return { name: 'untitled' };
          }
        }]);

        return WorkflowJobGroup;
      })(BaseModel);

      _export('default', WorkflowJobGroup);

      WorkflowJobGroup.prototype.routeName = 'workflowjobgroups';
    }
  };
});

$__System.register('7c', ['14', '15', '16', '17', '33', '7b'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, WorkflowJobGroup, WorkflowJobGroupCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_b) {
      WorkflowJobGroup = _b['default'];
    }],
    execute: function () {

      /**
       * Collection of WorkflowJobGroup models.
       */
      'use strict';

      WorkflowJobGroupCollection = (function (_BaseCollection) {
        _inherits(WorkflowJobGroupCollection, _BaseCollection);

        function WorkflowJobGroupCollection() {
          _classCallCheck(this, WorkflowJobGroupCollection);

          _get(Object.getPrototypeOf(WorkflowJobGroupCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(WorkflowJobGroupCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           * @todo doing a fetch on a collection isn't firing events, so I need to do this. See https://github.com/DDMAL/rodan-client/issues/77
           */
          value: function initialize() {
            var _this = this;

            /** @ignore */
            this.model = WorkflowJobGroup;
            this._route = 'workflowjobgroups';
            this.on('sync', function (collection, response, options) {
              return _this._onSync(collection, response, options);
            });
          }

          ///////////////////////////////////////////////////////////////////////////////////////
          // PRIVATE METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Every sync, just save each model.
           */
        }, {
          key: '_onSync',
          value: function _onSync(collection, response, options) {
            for (var i = 0; i < collection.length; i++) {
              var model = collection.at(i);
              model.save({}, { patch: true });
            }
          }
        }]);

        return WorkflowJobGroupCollection;
      })(BaseCollection);

      _export('default', WorkflowJobGroupCollection);
    }
  };
});

$__System.register('7d', ['11', '14', '15', '16', '17', '20', '37', '7b', '7c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, WorkflowJobGroup, WorkflowJobGroupCollection, ControllerWorkflowJobGroup;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_b) {
            WorkflowJobGroup = _b['default'];
        }, function (_c) {
            WorkflowJobGroupCollection = _c['default'];
        }],
        execute: function () {

            /**
             * Controller for WorkflowJobGroups.
             */
            'use strict';

            ControllerWorkflowJobGroup = (function (_BaseController) {
                _inherits(ControllerWorkflowJobGroup, _BaseController);

                function ControllerWorkflowJobGroup() {
                    _classCallCheck(this, ControllerWorkflowJobGroup);

                    _get(Object.getPrototypeOf(ControllerWorkflowJobGroup.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerWorkflowJobGroup, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        this._collection = new WorkflowJobGroupCollection();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        // Requests.
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_CREATE, function (options) {
                            return _this._handleRequestCreateWorkflowJobGroup(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_DELETE, function (options) {
                            return _this._handleRequestDeleteWorkflowJobGroup(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_GET_PORTS, function (options) {
                            return _this._handleRequestGetPorts(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_IMPORT, function (options) {
                            return _this._handleRequestImportWorkflowJobGroup(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_LOAD_COLLECTION, function (options) {
                            return _this._handleRequestWorkflowJobGroupLoadCollection(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_SAVE, function (options) {
                            return _this._handleRequestSaveWorkflowJobGroup(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle WorkflowJobGroup creation.
                     */
                }, {
                    key: '_handleRequestCreateWorkflowJobGroup',
                    value: function _handleRequestCreateWorkflowJobGroup(options) {
                        var _this2 = this;

                        var urls = [];
                        var workflowJobs = options.workflowjobs;
                        var workflow = options.workflow;
                        for (var index in workflowJobs) {
                            urls.push(workflowJobs[index].get('url'));
                        }
                        var workflowJobGroup = new WorkflowJobGroup({ workflow_jobs: urls, workflow: workflow });
                        workflowJobGroup.save({}, { success: function success(model) {
                                return _this2._handleWorkflowJobGroupCreationSuccess(model);
                            } });
                    }

                    /**
                     * Handle WorkflowJobGroup save.
                     */
                }, {
                    key: '_handleRequestSaveWorkflowJobGroup',
                    value: function _handleRequestSaveWorkflowJobGroup(options) {
                        options.workflowjobgroup.save(options.workflowjobgroup.changed, { patch: true, success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_SAVED, { workflowjobgroup: model });
                            } });
                    }

                    /**
                     * Handle WorkflowJobGroup load.
                     */
                }, {
                    key: '_handleRequestWorkflowJobGroupLoadCollection',
                    value: function _handleRequestWorkflowJobGroupLoadCollection(options) {
                        this._collection.fetch({ data: { 'workflow': options.workflow.get('uuid') } });
                    }

                    /**
                     * Handle WorkflowJobGroup delete.
                     */
                }, {
                    key: '_handleRequestDeleteWorkflowJobGroup',
                    value: function _handleRequestDeleteWorkflowJobGroup(options) {
                        var _this3 = this;

                        options.workflowjobgroup.destroy({ success: function success(model) {
                                return _this3._handleWorkflowJobGroupDeleteSuccess(options.workflowjobgroup);
                            } });
                    }

                    /**
                     * Handle request import Workflow.
                     */
                }, {
                    key: '_handleRequestImportWorkflowJobGroup',
                    value: function _handleRequestImportWorkflowJobGroup(options) {
                        var _this4 = this;

                        var workflow = options.target;
                        var originWorkflow = options.origin;
                        var newGroup = new WorkflowJobGroup({ 'workflow': workflow.get('url'), 'origin': originWorkflow.get('url') });
                        newGroup.save({}, { success: function success(model) {
                                return _this4._handleWorkflowJobGroupCreationSuccess(model);
                            } });
                    }

                    /**
                     * Handle request get ports.
                     */
                }, {
                    key: '_handleRequestGetPorts',
                    value: function _handleRequestGetPorts(options) {
                        var workflowJobGroup = this._collection.findWhere({ url: options.url });
                        return this._getExposedPorts(workflowJobGroup, options.workflow);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - REST handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle import success.
                     */
                }, {
                    key: '_handleWorkflowJobGroupCreationSuccess',
                    value: function _handleWorkflowJobGroupCreationSuccess(model) {
                        this._collection.set(model, { remove: false });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_IMPORTED, { workflowjobgroup: model });
                    }

                    /**
                     * Handle ungroup success.
                     */
                }, {
                    key: '_handleWorkflowJobGroupDeleteSuccess',
                    value: function _handleWorkflowJobGroupDeleteSuccess(workflowJobGroup) {
                        this._collection.remove(workflowJobGroup);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_DELETED, { workflowjobgroup: workflowJobGroup });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Determine which ports should be kept exposed for the provided WorkflowJobs.
                     *
                     * It should be exposed if:
                     * - it does not have an associated Connection
                     * - it is connected to a port outside of the WorkflowJobs
                     */
                }, {
                    key: '_getExposedPorts',
                    value: function _getExposedPorts(workflowJobGroup, workflow) {
                        var object = { inputports: {}, outputports: {} };
                        var connections = {};
                        var workflowJobUrls = workflowJobGroup.get('workflow_jobs');

                        // Go through the WorkflowJobs. For each InputPort:
                        // - add it to the return list
                        // - if it has Connections, add that Connection and the associated InputPort to the Connections list
                        for (var index in workflowJobUrls) {
                            var workflowJobUrl = workflowJobUrls[index];
                            var workflowJob = workflow.get('workflow_jobs').findWhere({ url: workflowJobUrl });
                            if (!workflowJob) {
                                return null;
                            }

                            var inputPorts = workflowJob.get('input_ports');
                            for (var i = 0; i < inputPorts.length; i++) {
                                var inputPort = inputPorts.at(i);
                                object.inputports[inputPort.get('url')] = inputPort;
                                if (inputPort.get('connections').length !== 0) {
                                    var connection = inputPort.get('connections')[0];
                                    connections[connection] = { inputPort: inputPort };
                                }
                            }
                        }

                        // Go through the WorkflowJobs. For each OutputPort:
                        // - if it doesn't have Connections, add it to the return list
                        // - if it has Connections:
                        // -- if the Connection exists in the Connection list, remove the InputPort from reeturn list and
                        //    remove the Connection from the Connection list
                        // -- else, the OutputPort is added to the return list
                        for (var index in workflowJobUrls) {
                            var workflowJobUrl = workflowJobUrls[index];
                            var workflowJob = workflow.get('workflow_jobs').findWhere({ url: workflowJobUrl });

                            // Get unsatisfied OutputPorts and also collect OutputPorts with Connections.
                            var outputPorts = workflowJob.get('output_ports');
                            for (var i = 0; i < outputPorts.length; i++) {
                                var outputPort = outputPorts.at(i);
                                if (outputPort.get('connections').length === 0) {
                                    object.outputports[outputPort.get('url')] = outputPort;
                                    continue;
                                } else {
                                    for (var j = 0; j < outputPort.get('connections').length; j++) {
                                        var connection = outputPort.get('connections')[j];
                                        if (connection in connections) {
                                            delete object.inputports[connections[connection].inputPort.get('url')];
                                            delete connections[connection];
                                        } else {
                                            object.outputports[outputPort.get('url')] = outputPort;
                                        }
                                    }
                                }
                            }
                        }
                        return object;
                    }
                }]);

                return ControllerWorkflowJobGroup;
            })(BaseController);

            _export('default', ControllerWorkflowJobGroup);
        }
    };
});

$__System.register('37', ['14', '15', '16', '17', '27'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, Marionette, BaseController;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      Marionette = _5['default'];
    }],
    execute: function () {

      /**
       * Base controller.
       */
      'use strict';

      BaseController = (function (_Marionette$Object) {
        _inherits(BaseController, _Marionette$Object);

        ///////////////////////////////////////////////////////////////////////////////////////
        // PUBLIC METHODS
        ///////////////////////////////////////////////////////////////////////////////////////
        /**
         * Constructor.
         *
         * @param {object} options Marionette.Object options object
         */

        function BaseController(options) {
          _classCallCheck(this, BaseController);

          _get(Object.getPrototypeOf(BaseController.prototype), 'constructor', this).call(this, options);
          this._initializeViews();
          this._initializeRadio();
        }

        ///////////////////////////////////////////////////////////////////////////////////////
        // PRIVATE METHODS
        ///////////////////////////////////////////////////////////////////////////////////////
        /**
         * Initialize Radio.
         */

        _createClass(BaseController, [{
          key: '_initializeRadio',
          value: function _initializeRadio() {}

          /**
           * Initialize views.
           */
        }, {
          key: '_initializeViews',
          value: function _initializeViews() {}
        }]);

        return BaseController;
      })(Marionette.Object);

      _export('default', BaseController);
    }
  };
});

$__System.register('40', ['14', '15', '16', '17', '27'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Marionette, LayoutViewModel;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }],
        execute: function () {

            /**
             * This is a layout to help render a Collection and a single item.
             * We're using a LayoutView as opposed to a CompositeView because the single model
             * that would be associated with the CompositveView is not initially known, so it can't
             * rerender.
             */
            'use strict';

            LayoutViewModel = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewModel, _Marionette$LayoutView);

                function LayoutViewModel() {
                    _classCallCheck(this, LayoutViewModel);

                    _get(Object.getPrototypeOf(LayoutViewModel.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewModel, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        this.addRegions({
                            regionList: '#region-main_layoutview_model_list',
                            regionItem: '#region-main_layoutview_model_item'
                        });
                    }

                    /**
                     * Show a list view.
                     *
                     * @param {Marionette.View} view list view to show
                     */
                }, {
                    key: 'showList',
                    value: function showList(view) {
                        this.regionList.show(view);
                    }

                    /**
                     * Show an item view.
                     *
                     * @param {Marionette.View} view item view to show
                     */
                }, {
                    key: 'showItem',
                    value: function showItem(view) {
                        this.regionItem.show(view);
                    }

                    /**
                     * Clears item view.
                     */
                }, {
                    key: 'clearItemView',
                    value: function clearItemView() {
                        this.regionItem.empty();
                    }
                }]);

                return LayoutViewModel;
            })(Marionette.LayoutView);

            _export('default', LayoutViewModel);

            LayoutViewModel.prototype.template = '#template-main_layoutview_model';
        }
    };
});

$__System.register('49', ['11', '14', '15', '16', '17', '20', '32', '3e'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, _, BaseViewList, ViewResourceList;

    return {
        setters: [function (_7) {
            RODAN_EVENTS = _7['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_6) {
            _ = _6['default'];
        }, function (_e) {
            BaseViewList = _e['default'];
        }],
        execute: function () {

            /**
             * View for Resource list.
             */
            'use strict';

            ViewResourceList = (function (_BaseViewList) {
                _inherits(ViewResourceList, _BaseViewList);

                function ViewResourceList() {
                    _classCallCheck(this, ViewResourceList);

                    _get(Object.getPrototypeOf(ViewResourceList.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewResourceList, [{
                    key: '_handleClickButtonFile',

                    /**
                     * Handle file button.
                     */
                    value: function _handleClickButtonFile() {
                        var type = this.$el.find('#select-resourcetype').val();
                        for (var i = 0; i < this.ui.fileInput[0].files.length; i++) {
                            var file = this.ui.fileInput[0].files[i];
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_CREATE, { project: this.model, file: file, resourcetype: type });
                        }
                        this.ui.fileInput.replaceWith(this.ui.fileInput = this.ui.fileInput.clone(true));
                    }

                    /**
                     * On render populate the ResourceTypeList dropdown.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        var templateResourceType = _.template($('#template-main_resource_list_resourcetype_list_item').html());
                        var resourceTypeCollection = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION);
                        var html = templateResourceType({ url: null, mimetype: 'Auto-detect', extension: 'Rodan will attempt to determine the file type based on the file itself' });
                        this.$el.find('#select-resourcetype').append(html);
                        for (var i = 0; i < resourceTypeCollection.length; i++) {
                            var resourceType = resourceTypeCollection.at(i);
                            html = templateResourceType(resourceType.attributes);
                            this.$el.find('#select-resourcetype').append(html);
                        }
                    }
                }]);

                return ViewResourceList;
            })(BaseViewList);

            _export('default', ViewResourceList);

            ViewResourceList.prototype.behaviors = { Table: { 'table': '#table-resources' } };
            ViewResourceList.prototype.ui = {
                fileInput: '#file-main_resource_file'
            };
            ViewResourceList.prototype.events = {
                'change @ui.fileInput': '_handleClickButtonFile'
            };
        }
    };
});

$__System.register('4a', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewResourceListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * Item view for Resource list.
             */
            'use strict';

            ViewResourceListItem = (function (_BaseViewListItem) {
                _inherits(ViewResourceListItem, _BaseViewListItem);

                function ViewResourceListItem() {
                    _classCallCheck(this, ViewResourceListItem);

                    _get(Object.getPrototypeOf(ViewResourceListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewResourceListItem, [{
                    key: '_handleClick',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles click.
                     */
                    value: function _handleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_SELECTED, { resource: this.model });
                    }

                    /**
                     * Handles double click.
                     */
                }, {
                    key: '_handleDblClick',
                    value: function _handleDblClick() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_DOWNLOAD, { resource: this.model });
                    }
                }]);

                return ViewResourceListItem;
            })(BaseViewListItem);

            _export('default', ViewResourceListItem);

            ViewResourceListItem.prototype.template = '#template-main_resource_list_item';
            ViewResourceListItem.prototype.tagName = 'tr';
            ViewResourceListItem.prototype.events = {
                'click': '_handleClick',
                'dblclick': '_handleDblClick'
            };
        }
    };
});

$__System.register('4f', ['14', '15', '17', '3e'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseViewList, ViewRunJobList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_e) {
      BaseViewList = _e['default'];
    }],
    execute: function () {

      /**
       * RunJob list view.
       */
      'use strict';

      ViewRunJobList = (function (_BaseViewList) {
        _inherits(ViewRunJobList, _BaseViewList);

        function ViewRunJobList() {
          _classCallCheck(this, ViewRunJobList);

          _get(Object.getPrototypeOf(ViewRunJobList.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewRunJobList;
      })(BaseViewList);

      _export('default', ViewRunJobList);

      ViewRunJobList.prototype.behaviors = { Table: { 'table': '#table-runjobs' } };
    }
  };
});

$__System.register('50', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewRunJobListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * RunJob list item view.
             */
            'use strict';

            ViewRunJobListItem = (function (_BaseViewListItem) {
                _inherits(ViewRunJobListItem, _BaseViewListItem);

                function ViewRunJobListItem() {
                    _classCallCheck(this, ViewRunJobListItem);

                    _get(Object.getPrototypeOf(ViewRunJobListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewRunJobListItem, [{
                    key: 'onBeforeRender',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Set availability  property before render.
                     *
                     * @todo this is a hack to make sure the client shows what runjobs are manual and available
                     */
                    value: function onBeforeRender() {
                        this.model.set('available', this.model.available());
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles click.
                     */
                }, {
                    key: '_handleClick',
                    value: function _handleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RUNJOB_SELECTED, { runjob: this.model });
                    }

                    /**
                     * Handle double-click.
                     */
                }, {
                    key: '_handleDoubleClick',
                    value: function _handleDoubleClick() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RUNJOB_ACQUIRE, { runjob: this.model });
                    }
                }]);

                return ViewRunJobListItem;
            })(BaseViewListItem);

            _export('default', ViewRunJobListItem);

            ViewRunJobListItem.prototype.template = '#template-main_runjob_list_item';
            ViewRunJobListItem.prototype.tagName = 'tr';
            ViewRunJobListItem.prototype.events = {
                'click': '_handleClick',
                'dblclick': '_handleDoubleClick'
            };
        }
    };
});

$__System.register('7e', ['11', '14', '15', '16', '17', '20', '27', '40', '49', '50', '4a', '4f'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, LayoutViewModel, ViewResourceList, ViewRunJobListItem, ViewResourceListItem, ViewRunJobList, LayoutViewIndividualWorkflowRun;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_7) {
            Marionette = _7['default'];
        }, function (_6) {
            LayoutViewModel = _6['default'];
        }, function (_9) {
            ViewResourceList = _9['default'];
        }, function (_10) {
            ViewRunJobListItem = _10['default'];
        }, function (_a) {
            ViewResourceListItem = _a['default'];
        }, function (_f) {
            ViewRunJobList = _f['default'];
        }],
        execute: function () {

            /**
             * WorkflowRun view.
             */
            'use strict';

            LayoutViewIndividualWorkflowRun = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewIndividualWorkflowRun, _Marionette$LayoutView);

                function LayoutViewIndividualWorkflowRun() {
                    _classCallCheck(this, LayoutViewIndividualWorkflowRun);

                    _get(Object.getPrototypeOf(LayoutViewIndividualWorkflowRun.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewIndividualWorkflowRun, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options Marionette.View options object; 'options.runjobs' (RunJobCollection) and 'options.resources' (ResourceCollection) must also be provided
                     */
                    value: function initialize(options) {
                        this._runJobs = options.runjobs;
                        this._resources = options.resources;
                        this.addRegions({
                            regionRunJobList: '#region-main_workflowrun_individual_runjobs',
                            regionResourceList: '#region-main_workflowrun_individual_resources'
                        });
                    }

                    /**
                     * Insert subviews after render.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        // Empty regions.
                        this.regionRunJobList.empty();
                        this.regionResourceList.empty();

                        // Create Resource list view.
                        this._layoutViewResources = new LayoutViewModel();
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCE_SHOWLAYOUTVIEW, { layoutView: this._layoutViewResources });
                        this.regionResourceList.show(this._layoutViewResources);
                        this._viewResourceList = new ViewResourceList({ collection: this._resources,
                            template: '#template-main_workflowrun_individual_resources_list',
                            childView: ViewResourceListItem });
                        this._layoutViewResources.showList(this._viewResourceList);

                        // Create RunJob list view.
                        this._layoutViewRunJobs = new LayoutViewModel();
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RUNJOB_SHOWLAYOUTVIEW, { layoutView: this._layoutViewRunJobs });
                        this.regionRunJobList.show(this._layoutViewRunJobs);
                        this._viewRunJobList = new ViewRunJobList({ collection: this._runJobs,
                            template: '#template-main_runjob_list_notitle',
                            childView: ViewRunJobListItem });
                        this._layoutViewRunJobs.showList(this._viewRunJobList);

                        // Show Resources on default.
                        this._showResources();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle button show Resources.
                     */
                }, {
                    key: '_showResources',
                    value: function _showResources() {
                        this.regionRunJobList.$el.hide();
                        this.ui.buttonShowResources.css('text-decoration', 'underline');
                        this.ui.buttonShowRunJobs.css('text-decoration', 'none');
                        if (!this.regionResourceList.$el.is(':visible')) {
                            this.regionResourceList.$el.toggle('fast');
                        }
                    }

                    /**
                     * Handle button show RunJobs.
                     */
                }, {
                    key: '_showRunJobs',
                    value: function _showRunJobs() {
                        this.regionResourceList.$el.hide();
                        this.ui.buttonShowResources.css('text-decoration', 'none');
                        this.ui.buttonShowRunJobs.css('text-decoration', 'underline');
                        if (!this.regionRunJobList.$el.is(':visible')) {
                            this.regionRunJobList.$el.toggle('fast');
                        }
                    }

                    /**
                     * Handle save button.
                     */
                }, {
                    key: '_handleButtonSave',
                    value: function _handleButtonSave() {
                        this.model.set({ name: this.ui.textName.val(), description: this.ui.textDescription.val() });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__WORKFLOWRUN_SAVE, { workflowrun: this.model });
                    }
                }]);

                return LayoutViewIndividualWorkflowRun;
            })(Marionette.LayoutView);

            _export('default', LayoutViewIndividualWorkflowRun);

            LayoutViewIndividualWorkflowRun.prototype.modelEvents = {
                'all': 'render'
            };
            LayoutViewIndividualWorkflowRun.prototype.ui = {
                buttonShowResources: '#button-resources_show',
                buttonShowRunJobs: '#button-runjobs_show',
                buttonSave: '#button-save_workflowrun',
                textName: '#text-workflowrun_name',
                textDescription: '#text-workflowrun_description'
            };
            LayoutViewIndividualWorkflowRun.prototype.events = {
                'click @ui.buttonShowResources': '_showResources',
                'click @ui.buttonShowRunJobs': '_showRunJobs',
                'click @ui.buttonSave': '_handleButtonSave'

            };
            LayoutViewIndividualWorkflowRun.prototype.template = '#template-main_workflowrun_individual';
        }
    };
});

$__System.register('3e', ['14', '15', '17', '27'], function (_export) {
  var _get, _inherits, _classCallCheck, Marionette, BaseViewList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_4) {
      Marionette = _4['default'];
    }],
    execute: function () {

      /**
       * Base View for lists.
       */
      'use strict';

      BaseViewList = (function (_Marionette$CompositeView) {
        _inherits(BaseViewList, _Marionette$CompositeView);

        function BaseViewList() {
          _classCallCheck(this, BaseViewList);

          _get(Object.getPrototypeOf(BaseViewList.prototype), 'constructor', this).apply(this, arguments);
        }

        return BaseViewList;
      })(Marionette.CompositeView);

      _export('default', BaseViewList);

      BaseViewList.prototype.modelEvents = { 'all': 'render' };
      BaseViewList.prototype.childViewContainer = 'tbody';
      BaseViewList.prototype.allowMultipleSelection = false;
    }
  };
});

$__System.register('3c', ['14', '15', '16', '17', '27'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Marionette, BaseViewListItem;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }],
        execute: function () {

            /**
             * Base List Item view.
             */
            'use strict';

            BaseViewListItem = (function (_Marionette$ItemView) {
                _inherits(BaseViewListItem, _Marionette$ItemView);

                function BaseViewListItem() {
                    _classCallCheck(this, BaseViewListItem);

                    _get(Object.getPrototypeOf(BaseViewListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(BaseViewListItem, [{
                    key: 'onRender',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Set description after render.
                     */
                    value: function onRender() {
                        var description = 'no description available';
                        if (this.model.has('description') && this.model.get('description') !== '') {
                            description = this.model.get('description');
                        }
                        this.$el.attr('title', description);
                    }
                }]);

                return BaseViewListItem;
            })(Marionette.ItemView);

            _export('default', BaseViewListItem);

            BaseViewListItem.prototype.modelEvents = {
                'change': 'render'
            };
        }
    };
});

$__System.register('7f', ['11', '14', '15', '16', '17', '20', '3c'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseViewListItem, ViewWorkflowRunListItem;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_c) {
            BaseViewListItem = _c['default'];
        }],
        execute: function () {

            /**
             * WorkflowRun list item view.
             */
            'use strict';

            ViewWorkflowRunListItem = (function (_BaseViewListItem) {
                _inherits(ViewWorkflowRunListItem, _BaseViewListItem);

                function ViewWorkflowRunListItem() {
                    _classCallCheck(this, ViewWorkflowRunListItem);

                    _get(Object.getPrototypeOf(ViewWorkflowRunListItem.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewWorkflowRunListItem, [{
                    key: '_handleDoubleClick',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handles double click.
                     */
                    value: function _handleDoubleClick() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED, { workflowrun: this.model });
                    }
                }]);

                return ViewWorkflowRunListItem;
            })(BaseViewListItem);

            _export('default', ViewWorkflowRunListItem);

            ViewWorkflowRunListItem.prototype.template = '#template-main_workflowrun_list_item';
            ViewWorkflowRunListItem.prototype.tagName = 'tr';
            ViewWorkflowRunListItem.prototype.events = {
                'dblclick': '_handleDoubleClick'
            };
        }
    };
});

$__System.register('42', ['14', '15', '17', '3e', '7f'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseViewList, ViewWorkflowRunListItem, ViewWorkflowRunList;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_e) {
      BaseViewList = _e['default'];
    }, function (_f) {
      ViewWorkflowRunListItem = _f['default'];
    }],
    execute: function () {

      /**
       * WorkflowRun list view.
       */
      'use strict';

      ViewWorkflowRunList = (function (_BaseViewList) {
        _inherits(ViewWorkflowRunList, _BaseViewList);

        function ViewWorkflowRunList() {
          _classCallCheck(this, ViewWorkflowRunList);

          _get(Object.getPrototypeOf(ViewWorkflowRunList.prototype), 'constructor', this).apply(this, arguments);
        }

        return ViewWorkflowRunList;
      })(BaseViewList);

      _export('default', ViewWorkflowRunList);

      ViewWorkflowRunList.prototype.template = '#template-main_workflowrun_list';
      ViewWorkflowRunList.prototype.childView = ViewWorkflowRunListItem;
      ViewWorkflowRunList.prototype.behaviors = { Table: { 'table': '#table-workflowruns' } };
    }
  };
});

$__System.register('80', ['14', '15', '16', '17', '1d'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseModel, WorkflowRun;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * WorkflowRun.
             */
            'use strict';

            WorkflowRun = (function (_BaseModel) {
                _inherits(WorkflowRun, _BaseModel);

                function WorkflowRun() {
                    _classCallCheck(this, WorkflowRun);

                    _get(Object.getPrototypeOf(WorkflowRun.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(WorkflowRun, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this.set('statusText', this._getStatusText(this.get('status')));
                    }

                    /**
                     * Returns defaults.
                     *
                     * @return {object} object holding default values
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return { created: null, updated: null };
                    }

                    /**
                     * Override of Backbone.Model.parse. This will populate 'statusText' from the existing status.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        this.set('statusText', this._getStatusText(response.status));
                        return response;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Return text based on status.
                     */
                }, {
                    key: '_getStatusText',
                    value: function _getStatusText(status) {
                        switch (status) {
                            case -1:
                                {
                                    return 'Failed';
                                }

                            case 0:
                                {
                                    return 'Scheduled';
                                }

                            case 1:
                                {
                                    return 'Processing';
                                }

                            case 2:
                                {
                                    return 'Waiting for input';
                                }

                            case 4:
                                {
                                    return 'Finished';
                                }

                            case 8:
                                {
                                    return 'Expired';
                                }

                            case 9:
                                {
                                    return 'Cancelled';
                                }

                            case 11:
                                {
                                    return 'Retrying';
                                }

                            default:
                                {
                                    return 'Unknown status';
                                }
                        }
                    }
                }]);

                return WorkflowRun;
            })(BaseModel);

            _export('default', WorkflowRun);

            WorkflowRun.prototype.routeName = 'workflowruns';
        }
    };
});

$__System.register('43', ['14', '15', '16', '17', '33', '80'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, WorkflowRun, WorkflowRunCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      WorkflowRun = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of WorkflowRun models.
       */
      'use strict';

      WorkflowRunCollection = (function (_BaseCollection) {
        _inherits(WorkflowRunCollection, _BaseCollection);

        function WorkflowRunCollection() {
          _classCallCheck(this, WorkflowRunCollection);

          _get(Object.getPrototypeOf(WorkflowRunCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(WorkflowRunCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = WorkflowRun;
            this._route = 'workflowruns';
          }
        }]);

        return WorkflowRunCollection;
      })(BaseCollection);

      _export('default', WorkflowRunCollection);
    }
  };
});

$__System.register('81', ['11', '14', '15', '16', '17', '20', '37', '42', '43', '80', '7e'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseController, ViewWorkflowRunList, WorkflowRunCollection, WorkflowRun, LayoutViewIndividualWorkflowRun, ControllerWorkflowRun;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            BaseController = _5['default'];
        }, function (_8) {
            ViewWorkflowRunList = _8['default'];
        }, function (_10) {
            WorkflowRunCollection = _10['default'];
        }, function (_9) {
            WorkflowRun = _9['default'];
        }, function (_e) {
            LayoutViewIndividualWorkflowRun = _e['default'];
        }],
        execute: function () {

            /**
             * Controller for WorkflowRun.
             */
            'use strict';

            ControllerWorkflowRun = (function (_BaseController) {
                _inherits(ControllerWorkflowRun, _BaseController);

                function ControllerWorkflowRun() {
                    _classCallCheck(this, ControllerWorkflowRun);

                    _get(Object.getPrototypeOf(ControllerWorkflowRun.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ControllerWorkflowRun, [{
                    key: '_initializeRadio',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Initialize
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                    value: function _initializeRadio() {
                        var _this = this;

                        // Events.
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWRUN_CREATED, function (options) {
                            return _this._handleEventWorkflowRunCreationResponse(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWRUN_SAVED, function (options) {
                            return _this._handleEventWorkflowRunSaveResponse(options);
                        });

                        // Requests.
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventListSelected(options);
                        }, this);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED, function (options) {
                            return _this._handleEventItemSelected(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWRUN_CREATE, function (options) {
                            return _this._handleRequestWorkflowRunCreate(options);
                        }, this);
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__WORKFLOWRUN_SAVE, function (options) {
                            return _this._handleRequestWorkflowRunSave(options);
                        }, this);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS - Radio handlers
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle event Project generic response.
                     */
                }, {
                    key: '_handleEventWorkflowRunCreationResponse',
                    value: function _handleEventWorkflowRunCreationResponse(options) {
                        var project = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED_COLLECTION, { project: project });
                    }

                    /**
                     * Handle event Project save response.
                     */
                }, {
                    key: '_handleEventWorkflowRunSaveResponse',
                    value: function _handleEventWorkflowRunSaveResponse(options) {
                        var project = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_GET_ACTIVE);
                    }

                    /**
                     * Handle item selection.
                     */
                }, {
                    key: '_handleEventItemSelected',
                    value: function _handleEventItemSelected(options) {
                        // Get required collections.
                        var runJobs = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RUNJOBS_LOAD, { data: { workflow_run: options.workflowrun.id } });
                        var resources = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__RESOURCES_LOAD, { data: { result_of_workflow_run: options.workflowrun.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [runJobs, resources] });

                        // Create view and show.
                        this._viewItem = new LayoutViewIndividualWorkflowRun({ runjobs: runJobs, resources: resources, model: options.workflowrun });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: this._viewItem });
                    }

                    /**
                     * Handle list selection.
                     */
                }, {
                    key: '_handleEventListSelected',
                    value: function _handleEventListSelected(options) {
                        var collection = new WorkflowRunCollection();
                        collection.fetchSort(false, 'created', { data: { project: options.project.id } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, { collections: [collection] });
                        var view = new ViewWorkflowRunList({ collection: collection });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: view });
                    }

                    /**
                     * Handle request create WorkflowRun.
                     */
                }, {
                    key: '_handleRequestWorkflowRunCreate',
                    value: function _handleRequestWorkflowRunCreate(options) {
                        var name = options.workflow.get('name');
                        var description = 'Run of Workflow "' + name + '"\n\n' + this._getResourceAssignmentDescription(options.assignments);
                        var workflowRun = new WorkflowRun({ workflow: options.workflow.get('url'),
                            resource_assignments: options.assignments,
                            name: name,
                            description: description });
                        workflowRun.save({}, { success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWRUN_CREATED, { workflowrun: model });
                            } });
                    }

                    /**
                     * Handle request save WorkflowRun.
                     */
                }, {
                    key: '_handleRequestWorkflowRunSave',
                    value: function _handleRequestWorkflowRunSave(options) {
                        options.workflowrun.save(options.workflowrun.changed, { patch: true, success: function success(model) {
                                return Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWRUN_SAVED, { workflowrun: model });
                            } });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Given resource assignments, provides descriptive info.
                     */
                }, {
                    key: '_getResourceAssignmentDescription',
                    value: function _getResourceAssignmentDescription(assignments) {
                        var text = '';
                        for (var inputPortUrl in assignments) {
                            var resourceUrls = assignments[inputPortUrl];
                            for (var index in resourceUrls) {
                                text += '- ' + resourceUrls[index] + '\n';
                            }
                            text += '\n';
                        }
                        return text;
                    }

                    /**
                     * Handle sync of WorkflowRun elements.
                     */
                }, {
                    key: '_handleSyncWorkflowRun',
                    value: function _handleSyncWorkflowRun(runJobs, resources) {
                        runJobs.syncList();
                        resources.syncList();
                    }
                }]);

                return ControllerWorkflowRun;
            })(BaseController);

            _export('default', ControllerWorkflowRun);
        }
    };
});

$__System.register('82', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ErrorHandler;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }],
        execute: function () {

            /**
             * General error handler.
             */
            'use strict';

            ErrorHandler = (function (_Marionette$Object) {
                _inherits(ErrorHandler, _Marionette$Object);

                function ErrorHandler() {
                    _classCallCheck(this, ErrorHandler);

                    _get(Object.getPrototypeOf(ErrorHandler.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ErrorHandler, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        var _this = this;

                        this._initializeRadio();
                        window.onerror = function (errorText, url, lineNumber, columnNumber, error) {
                            return _this._handleJavaScriptError(errorText, url, lineNumber, columnNumber, error);
                        };
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this2 = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, function (options) {
                            return _this2._handleError(options);
                        });
                    }

                    /**
                     * Handles Javscript error.
                     */
                }, {
                    key: '_handleJavaScriptError',
                    value: function _handleJavaScriptError(errorText, url, lineNumber, columnNumber, error) {
                        var text = 'text: ' + errorText + '\n';
                        text += 'url: ' + url + '\n';
                        text += 'line: ' + lineNumber + '\n';
                        text += 'column: ' + columnNumber;
                        console.log(error);
                    }

                    /**
                     * Handle error.
                     */
                }, {
                    key: '_handleError',
                    value: function _handleError(options) {
                        var response = options.response;
                        var responseTextObject = response.responseText !== '' ? JSON.parse(response.responseText) : null;
                        if (responseTextObject !== null) {
                            if (responseTextObject.hasOwnProperty('error_code')) {
                                this._processRodanError(options); // custom Rodan error code present
                            } else {
                                    this._processHTTPError(options); // HTTP error
                                }
                        } else {
                                alert(response.statusText);
                            }
                    }

                    /**
                     * Processes HTTP errors.
                     */
                }, {
                    key: '_processHTTPError',
                    value: function _processHTTPError(options) {
                        var response = options.response;
                        var responseTextObject = JSON.parse(response.responseText);
                        var message = 'An unknown error occured.';

                        // Look for message in options first.
                        if (options.hasOwnProperty('message')) {
                            message = options.message;
                        }

                        // Go through the response text.
                        var first = true;
                        for (var property in responseTextObject) {
                            if (responseTextObject.hasOwnProperty(property)) {
                                message += '\n';
                                if (first) {
                                    message += '\n';
                                    first = false;
                                }
                                message += responseTextObject[property];
                            }
                        }
                        alert(message);
                    }

                    /**
                     * Processes Rodan-generated error response.
                     */
                }, {
                    key: '_processRodanError',
                    value: function _processRodanError(options) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__SERVER_ERROR, { json: options.response.responseJSON });
                    }
                }]);

                return ErrorHandler;
            })(Marionette.Object);

            _export('default', ErrorHandler);
        }
    };
});

$__System.register('83', ['11', '14', '15', '16', '17', '84', '85'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, GlobalCollection, InputPortType, _instance, GlobalInputPortTypeCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            GlobalCollection = _5['default'];
        }, function (_7) {
            InputPortType = _7['default'];
        }],
        execute: function () {
            'use strict';

            _instance = null;

            /**
             * Global Collection of InputPortType models. This uses a pseudo-singleton model so we can inherit from BaseCollection.
             */

            GlobalInputPortTypeCollection = (function (_GlobalCollection) {
                _inherits(GlobalInputPortTypeCollection, _GlobalCollection);

                function GlobalInputPortTypeCollection() {
                    _classCallCheck(this, GlobalInputPortTypeCollection);

                    _get(Object.getPrototypeOf(GlobalInputPortTypeCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalInputPortTypeCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance. As this class is a singleton, an Error will be thrown if called more than once.
                     *
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize() {
                        if (_instance) {
                            throw new Error('only one instance of this class may exist');
                        }
                        _instance = this;
                        /** @ignore */
                        this.model = InputPortType;
                        this._route = 'inputporttypes';
                        this._loadCommand = RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPES_LOAD;
                        this._requestCommand = RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION;
                    }
                }]);

                return GlobalInputPortTypeCollection;
            })(GlobalCollection);

            _export('default', GlobalInputPortTypeCollection);
        }
    };
});

$__System.register('85', ['14', '15', '17', '1d'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseModel, InputPortType;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * InputPortType.
       */
      'use strict';

      InputPortType = (function (_BaseModel) {
        _inherits(InputPortType, _BaseModel);

        function InputPortType() {
          _classCallCheck(this, InputPortType);

          _get(Object.getPrototypeOf(InputPortType.prototype), 'constructor', this).apply(this, arguments);
        }

        return InputPortType;
      })(BaseModel);

      _export('default', InputPortType);

      InputPortType.prototype.routeName = 'inputporttypes';
    }
  };
});

$__System.register('86', ['14', '15', '16', '17', '33', '85'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, InputPortType, InputPortTypeCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      InputPortType = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of InputPortType models.
       */
      'use strict';

      InputPortTypeCollection = (function (_BaseCollection) {
        _inherits(InputPortTypeCollection, _BaseCollection);

        function InputPortTypeCollection() {
          _classCallCheck(this, InputPortTypeCollection);

          _get(Object.getPrototypeOf(InputPortTypeCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(InputPortTypeCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = InputPortType;
            this._route = 'inputporttypes';
          }
        }]);

        return InputPortTypeCollection;
      })(BaseCollection);

      _export('default', InputPortTypeCollection);
    }
  };
});

$__System.register('87', ['14', '15', '16', '17', '33', '88'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseCollection, OutputPortType, OutputPortTypeCollection;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      BaseCollection = _5['default'];
    }, function (_6) {
      OutputPortType = _6['default'];
    }],
    execute: function () {

      /**
       * Collection of OutputPortType models.
       */
      'use strict';

      OutputPortTypeCollection = (function (_BaseCollection) {
        _inherits(OutputPortTypeCollection, _BaseCollection);

        function OutputPortTypeCollection() {
          _classCallCheck(this, OutputPortTypeCollection);

          _get(Object.getPrototypeOf(OutputPortTypeCollection.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(OutputPortTypeCollection, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the instance.
           */
          value: function initialize() {
            /** @ignore */
            this.model = OutputPortType;
            this._route = 'outputporttypes';
          }
        }]);

        return OutputPortTypeCollection;
      })(BaseCollection);

      _export('default', OutputPortTypeCollection);
    }
  };
});

$__System.register('5a', ['14', '15', '16', '17', '86', '87', '1d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, InputPortTypeCollection, OutputPortTypeCollection, BaseModel, Job;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_5) {
      InputPortTypeCollection = _5['default'];
    }, function (_6) {
      OutputPortTypeCollection = _6['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * Job.
       */
      'use strict';

      Job = (function (_BaseModel) {
        _inherits(Job, _BaseModel);

        function Job() {
          _classCallCheck(this, Job);

          _get(Object.getPrototypeOf(Job.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(Job, [{
          key: 'initialize',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Initializes the model. Upon initialization the 'input_port_types' and 'output_port_types' will be set as Backbone.Collections.
           *
           * @param {object} options Backbone.Model options object; 'options.input_port_types' and 'options.output_port_types' may be given
           */
          value: function initialize(options) {
            this.set('input_port_types', new InputPortTypeCollection(options.input_port_types));
            this.set('output_port_types', new OutputPortTypeCollection(options.output_port_types));
          }

          /**
           * Override of Backbone.Model.defaults. Sets 'input_port_types' and 'output_port_types' to null.
           *
           * @todo is this needed?
           * @return {object} default properties
           */
        }, {
          key: 'defaults',
          value: function defaults() {
            return { input_port_types: null, output_port_types: null };
          }

          /**
           * Override of Backbone.Model.parse. The 'input_port_types' and 'output_port_types' will be set as Backbone.Collections.
           *
           * @param {object} response JSON response from server
           * @return {object} response object
           */
        }, {
          key: 'parse',
          value: function parse(response) {
            response.input_port_types = new InputPortTypeCollection(response.input_port_types);
            response.output_port_types = new OutputPortTypeCollection(response.output_port_types);
            return response;
          }
        }]);

        return Job;
      })(BaseModel);

      _export('default', Job);

      Job.prototype.routeName = 'jobs';
    }
  };
});

$__System.register('89', ['11', '14', '15', '16', '17', '84', '5a'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, GlobalCollection, Job, _instance, GlobalJobCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            GlobalCollection = _5['default'];
        }, function (_a) {
            Job = _a['default'];
        }],
        execute: function () {
            'use strict';

            _instance = null;

            /**
             * Global Collection of Job models.
             * This uses a pseudo-singleton model so we can inherit from BaseCollection.
             */

            GlobalJobCollection = (function (_GlobalCollection) {
                _inherits(GlobalJobCollection, _GlobalCollection);

                function GlobalJobCollection() {
                    _classCallCheck(this, GlobalJobCollection);

                    _get(Object.getPrototypeOf(GlobalJobCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalJobCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize() {
                        if (_instance) {
                            throw new Error('only one instance of this class may exist');
                        }
                        _instance = this;
                        /** @ignore */
                        this.model = Job;
                        this._route = 'jobs';
                        this._loadCommand = RODAN_EVENTS.REQUEST__GLOBAL_JOBS_LOAD;
                        this._requestCommand = RODAN_EVENTS.REQUEST__GLOBAL_JOB_COLLECTION;
                        this._enumerations = [{ field: 'category', label: 'Category' }, { field: 'interactive', label: 'Interactive', values: [{ value: 'True', label: 'True' }, { value: 'False', label: 'False' }] }];
                    }
                }]);

                return GlobalJobCollection;
            })(GlobalCollection);

            _export('default', GlobalJobCollection);
        }
    };
});

$__System.register('88', ['14', '15', '17', '1d'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseModel, OutputPortType;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * OutputPortType.
       */
      'use strict';

      OutputPortType = (function (_BaseModel) {
        _inherits(OutputPortType, _BaseModel);

        function OutputPortType() {
          _classCallCheck(this, OutputPortType);

          _get(Object.getPrototypeOf(OutputPortType.prototype), 'constructor', this).apply(this, arguments);
        }

        return OutputPortType;
      })(BaseModel);

      _export('default', OutputPortType);

      OutputPortType.prototype.routeName = 'outputporttypes';
    }
  };
});

$__System.register('8a', ['11', '14', '15', '16', '17', '84', '88'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, GlobalCollection, OutputPortType, _instance, GlobalOutputPortTypeCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            GlobalCollection = _5['default'];
        }, function (_7) {
            OutputPortType = _7['default'];
        }],
        execute: function () {
            'use strict';

            _instance = null;

            /**
             * Global Collection of OutputPortType models.
             * This uses a pseudo-singleton model so we can inherit from BaseCollection.
             */

            GlobalOutputPortTypeCollection = (function (_GlobalCollection) {
                _inherits(GlobalOutputPortTypeCollection, _GlobalCollection);

                function GlobalOutputPortTypeCollection() {
                    _classCallCheck(this, GlobalOutputPortTypeCollection);

                    _get(Object.getPrototypeOf(GlobalOutputPortTypeCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalOutputPortTypeCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize() {
                        if (_instance) {
                            throw new Error('only one instance of this class may exist');
                        }
                        _instance = this;
                        /** @ignore */
                        this.model = OutputPortType;
                        this._route = 'outputporttypes';
                        this._loadCommand = RODAN_EVENTS.REQUEST__GLOBAL_OUTPUTPORTTYPES_LOAD;
                        this._requestCommand = RODAN_EVENTS.REQUEST__GLOBAL_OUTPUTPORTTYPE_COLLECTION;
                    }
                }]);

                return GlobalOutputPortTypeCollection;
            })(GlobalCollection);

            _export('default', GlobalOutputPortTypeCollection);
        }
    };
});

$__System.register('41', ['14', '15', '16', '17', '1d'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, BaseModel, Project;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_d) {
            BaseModel = _d['default'];
        }],
        execute: function () {

            /**
             * Project model.
             */
            'use strict';

            Project = (function (_BaseModel) {
                _inherits(Project, _BaseModel);

                function Project() {
                    _classCallCheck(this, Project);

                    _get(Object.getPrototypeOf(Project.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(Project, [{
                    key: 'parse',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Override of Backbone.Model.parse. This sets the 'workflow_count' if not provided by the server.
                     *
                     * @param {object} response JSON response from server
                     * @return {object} response object
                     * @todo why is it not being provided by the server?
                     */
                    value: function parse(response) {
                        response = _get(Object.getPrototypeOf(Project.prototype), 'parse', this).call(this, response);
                        if (!response.hasOwnProperty('workflow_count')) {
                            response.workflow_count = response.workflows.length;
                        }
                        return response;
                    }

                    /**
                     * Return defaults.
                     *
                     * @return {object} default properties
                     */
                }, {
                    key: 'defaults',
                    value: function defaults() {
                        return { creator: { username: null },
                            created: null,
                            updated: null,
                            workflow_count: null,
                            resource_count: null,
                            name: 'untitled' };
                    }
                }]);

                return Project;
            })(BaseModel);

            _export('default', Project);

            Project.prototype.routeName = 'projects';
        }
    };
});

$__System.register('8b', ['11', '14', '15', '16', '17', '41', '84'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Project, GlobalCollection, _instance, GlobalProjectCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Project = _7['default'];
        }, function (_5) {
            GlobalCollection = _5['default'];
        }],
        execute: function () {
            'use strict';

            _instance = null;

            /**
             * Global Collection of Project models.
             * This uses a pseudo-singleton model so we can inherit from BaseCollection.
             */

            GlobalProjectCollection = (function (_GlobalCollection) {
                _inherits(GlobalProjectCollection, _GlobalCollection);

                function GlobalProjectCollection() {
                    _classCallCheck(this, GlobalProjectCollection);

                    _get(Object.getPrototypeOf(GlobalProjectCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalProjectCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize() {
                        if (_instance) {
                            throw new Error('only one instance of this class may exist');
                        }
                        _instance = this;
                        /** @ignore */
                        this.model = Project;
                        this._route = 'projects';
                        this._allowPagination = true;
                        this._loadCommand = RODAN_EVENTS.REQUEST__GLOBAL_PROJECTS_LOAD;
                        this._requestCommand = RODAN_EVENTS.REQUEST__GLOBAL_PROJECT_COLLECTION;
                    }
                }]);

                return GlobalProjectCollection;
            })(GlobalCollection);

            _export('default', GlobalProjectCollection);
        }
    };
});

$__System.register('8c', ['14', '15', '16', '17', '1d'], function (_export) {
  var _get, _inherits, _createClass, _classCallCheck, BaseModel, Pagination;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _createClass = _3['default'];
    }, function (_4) {
      _classCallCheck = _4['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * Pagination. Note that this has no 'routeName' since pagination is stored within a Collection. This model is simply here for convenience.
       */
      'use strict';

      Pagination = (function (_BaseModel) {
        _inherits(Pagination, _BaseModel);

        function Pagination() {
          _classCallCheck(this, Pagination);

          _get(Object.getPrototypeOf(Pagination.prototype), 'constructor', this).apply(this, arguments);
        }

        _createClass(Pagination, [{
          key: 'defaults',

          ///////////////////////////////////////////////////////////////////////////////////////
          // PUBLIC METHODS
          ///////////////////////////////////////////////////////////////////////////////////////
          /**
           * Set defaults.
           *
           * @return {object} default properties
           */
          value: function defaults() {
            return { count: 0, next: '#', previous: '#', current: 1, total: 1 };
          }
        }]);

        return Pagination;
      })(BaseModel);

      _export('default', Pagination);

      Pagination.prototype.routeName = null;
    }
  };
});

$__System.register('33', ['3', '11', '14', '15', '16', '17', '20', '32', '52', '8c'], function (_export) {
    var $, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, _, Backbone, Pagination, BaseCollection;

    return {
        setters: [function (_6) {
            $ = _6['default'];
        }, function (_9) {
            RODAN_EVENTS = _9['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_10) {
            Radio = _10['default'];
        }, function (_7) {
            _ = _7['default'];
        }, function (_8) {
            Backbone = _8['default'];
        }, function (_c) {
            Pagination = _c['default'];
        }],
        execute: function () {

            /**
             * Subclass of Backbone.Collection.
             *
             * Some functionality of Backbone.Collection is overridden to facilitate server-based pagination, filtering, and sorting.
             */
            'use strict';

            BaseCollection = (function (_Backbone$Collection) {
                _inherits(BaseCollection, _Backbone$Collection);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 *
                 * @param {object} options initialization parameters for Backbone.Collection
                 */

                function BaseCollection(options) {
                    var _this = this;

                    _classCallCheck(this, BaseCollection);

                    _get(Object.getPrototypeOf(BaseCollection.prototype), 'constructor', this).call(this, options);
                    this._pagination = new Pagination();
                    this._lastData = {};
                    this._initializeRadio();
                    this._filters = {};
                    this._sort = {}; //{ordering: '-created'};
                    this._page = {};
                    this._enumerations = this._enumerations ? this._enumerations : [];
                    this.on('add', function (model, collection, options) {
                        return _this._onAdd(model, collection, options);
                    });
                }

                /**
                 * Returns route.
                 *
                 * @return {string} route
                 */

                _createClass(BaseCollection, [{
                    key: 'getEnumerations',

                    /**
                     * Returns enumerations of this Collection. These are custom-defined in the subclasses.
                     *
                     * Enumerations should be defined in subclasses as follows:
                     * - [{field: string, label: string, values: [{value: primitive type, label: string}] (optional)}]
                     *
                     * In the above:
                     * - "field" is a property of the associated Model in the Collection
                     * - "label" is a string that will appear in the table header
                     * - "values" is optional; populate this array with explicit "value"/"label"s if desired, else BaseCollection will determine the values for enumeration based on the contents of the Collection
                     * 
                     * @todo Rodan server should provide explicit enumerations
                     *
                     * @return {array} enumerations
                     */
                    value: function getEnumerations() {
                        return this._enumerations;
                    }

                    /**
                     * Parse results.
                     *
                     * @param {object} response JSON object
                     * @return {object} JSON object
                     */
                }, {
                    key: 'parse',
                    value: function parse(response) {
                        if (response.count) {
                            this._parsePagination(response);
                        }

                        if (this._enumerations && this._enumerations.length > 0) {
                            this._populateEnumerations(response);
                        }

                        if (response.hasOwnProperty('results')) {
                            return response.results;
                        }
                        return response;
                    }

                    /**
                     * Parses ID out of URL.
                     *
                     * @param {string} url URL
                     * @return {string} string representing UUID of Collection
                     * @todo this should be moved to a utility class
                     */
                }, {
                    key: 'parseIdFromUrl',
                    value: function parseIdFromUrl(url) {
                        var lastSlash = url.lastIndexOf('/');
                        var subString = url.substring(0, lastSlash);
                        var secondLastSlash = subString.lastIndexOf('/');
                        return url.substring(secondLastSlash + 1, lastSlash);
                    }

                    /**
                     * Override of fetch to allow for generic handling.
                     *
                     * Note that we save the data options. This is in case we do a create
                     * and have to reload/fetch the previous collection. We need to preserve
                     * the fetch parameters.
                     *
                     * @param {object} options Backbone.Collection.fetch options object
                     */
                }, {
                    key: 'fetch',
                    value: function fetch(options) {
                        if (!options) {
                            options = {};
                        }

                        // Set task.
                        options.task = 'fetch';

                        // Save last data.
                        this._lastData = options.data ? options.data : {};

                        // Build final options.
                        var finalOptions = {};
                        if (options.error) {
                            finalOptions.error = options.error;
                        }
                        if (options.success) {
                            finalOptions.success = options.success;
                        }
                        finalOptions.reset = options.reset ? options.reset : false;
                        finalOptions.data = {};
                        $.extend(finalOptions.data, this._filters);
                        $.extend(finalOptions.data, this._sort);
                        $.extend(finalOptions.data, this._page);
                        $.extend(finalOptions.data, options.data);

                        // Fech.
                        _get(Object.getPrototypeOf(BaseCollection.prototype), 'fetch', this).call(this, finalOptions);
                    }

                    /**
                     * Override of create.
                     *
                     * This override exists because we do NOT want to add it to the collection
                     * by default (as there's a limit to what the server returns for collections,
                     * and we need to respect that). However, if the save worked, we do want to do a fetch
                     * to update the Collection. The fetch is called in the custom success handler for creation.
                     *
                     * There's also the case if this Collection is local and not associated with a DB Collection.
                     *
                     * @param {object} options Backbone.Collection.create options object
                     * @return {Backbone.Model} instance of Backbone.Model or subclass of Backbone.Model
                     */
                }, {
                    key: 'create',
                    value: function create(options) {
                        var _this2 = this;

                        var instance = new this.model(options);
                        if (this.hasOwnProperty('url')) {
                            instance.save({}, { success: function success() {
                                    return _this2._handleCreateSuccess();
                                } });
                        } else {
                            instance.save({}, { success: function success(model) {
                                    return _this2.add(model);
                                } });
                        }
                        return instance;
                    }

                    /**
                     * Requests a sorted fetch. This is not called "sort" because backbone already has
                     * a sort method for the Collection.
                     *
                     * If no options.data is passed, the options.data from the last fetch are used.
                     *
                     * @param {boolean} ascending results will return in ascending order iff true
                     * @param {string} field name of field to sort by
                     * @param {object} options Backbone.Collection.fetch options object
                     */
                }, {
                    key: 'fetchSort',
                    value: function fetchSort(ascending, field, options) {
                        if (options && options.data) {
                            this._lastData = options.data;
                        }
                        this._sort.ordering = field;
                        if (!ascending) {
                            this._sort.ordering = '-' + field;
                        }
                        this.fetch({ data: this._lastData, reset: true });
                    }

                    /**
                     * Requests a filtered fetch.
                     *
                     * If no options.data is passed, the options.data from the last fetch are used.
                     *
                     * @param {array} filters array of objects; {name: string, value: primitive}; what filters can be used is defined in Rodan
                     * @param {object} options Backbone.Collection.fetch options object
                     * @todo give more info on filters
                     */
                }, {
                    key: 'fetchFilter',
                    value: function fetchFilter(filters, options) {
                        if (options && options.data) {
                            this._lastData = options.data;
                        }
                        this._filters = filters;
                        this._page = {};
                        this.fetch({ data: this._lastData, reset: true });
                    }

                    /**
                     * Requests a page to be fetched.
                     *
                     * If no options.data is passed, the options.data from the last fetch are used.
                     *
                     * @param {integer} page non-negative page number to retrieve from server
                     * @param {object} options Backbone.Collection.fetch options object
                     */
                }, {
                    key: 'fetchPage',
                    value: function fetchPage(page, options) {
                        if (options && options.data) {
                            this._lastData = options.data;
                        }
                        this._page = page;
                        this.fetch({ data: this._lastData, reset: true });
                    }

                    /**
                     * Returns pagination object for this Collection.
                     *
                     * @return {object} pagination object
                     * @todo point to pagination info on Rodan server
                     */
                }, {
                    key: 'getPagination',
                    value: function getPagination() {
                        return this._pagination;
                    }

                    /**
                     * Returns the URL associated with this Collection.
                     *
                     * @return {string} URL associated with this Collection
                     */
                }, {
                    key: 'url',
                    value: function url() {
                        return Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, this._route);
                    }

                    /**
                     * Syncs the Collection while preserving the last used fetch options.data.
                     */
                }, {
                    key: 'syncList',
                    value: function syncList() {
                        this.fetch({ data: this._lastData });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {}
                    // dummy

                    /**
                     * Handles a succesful creation. All this does is "properly" reload the collection.
                     */

                }, {
                    key: '_handleCreateSuccess',
                    value: function _handleCreateSuccess() {
                        this.syncList({});
                    }

                    /**
                     * Parses pagination parameters from response.
                     */
                }, {
                    key: '_parsePagination',
                    value: function _parsePagination(options) {
                        this._pagination.set({ 'count': options.count,
                            'next': options.next !== null ? options.next : '#',
                            'previous': options.previous !== null ? options.previous : '#',
                            'current': options.current_page,
                            'total': options.total_pages });
                    }

                    /**
                     * Populates enumerations.
                     */
                }, {
                    key: '_populateEnumerations',
                    value: function _populateEnumerations(response) {
                        var items = response.results ? response.results : response;
                        for (var j in this._enumerations) {
                            var field = this._enumerations[j].field;
                            if (!this._enumerations[j].values || this._enumerations[j].values.length === 0) {
                                this._enumerations[j].values = [];
                                for (var i in items) {
                                    var result = items[i];
                                    this._enumerations[j].values.push({ value: result[field], label: result[field] });
                                }
                                this._enumerations[j].values = _.uniq(this._enumerations[j].values, false, function (item) {
                                    return item.value;
                                });
                            }
                        }
                    }

                    /**
                     * Handle backbone add event.
                     */
                }, {
                    key: '_onAdd',
                    value: function _onAdd(model, collection, options) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__COLLECTION_ADD, { model: model, collection: collection, options: options });
                    }
                }, {
                    key: 'route',
                    get: function get() {
                        return this._route;
                    }
                }]);

                return BaseCollection;
            })(Backbone.Collection);

            _export('default', BaseCollection);
        }
    };
});

$__System.register('84', ['11', '14', '15', '16', '17', '20', '33'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, BaseCollection, GlobalCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            BaseCollection = _5['default'];
        }],
        execute: function () {

            /**
             * Global Collections that should be loaded on startup. These are not expected to change during the lifetime of a session. They are also customized to get non-paginated results.
             */
            'use strict';

            GlobalCollection = (function (_BaseCollection) {
                _inherits(GlobalCollection, _BaseCollection);

                function GlobalCollection() {
                    _classCallCheck(this, GlobalCollection);

                    _get(Object.getPrototypeOf(GlobalCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @param {object} options initialization parameters for Backbone.Collection
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize(options) {
                        _get(Object.getPrototypeOf(GlobalCollection.prototype), 'initialize', this).call(this, options);
                        this._allowPagination = false;
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(this._loadCommand, function (options) {
                            return _this._retrieveList(options);
                        });
                        Radio.channel('rodan').reply(this._requestCommand, function () {
                            return _this._handleRequestInstance();
                        });
                    }

                    /**
                     * Returns this instance.
                     *
                     * @return {GlobalCollection} this instance
                     */
                }, {
                    key: '_handleRequestInstance',
                    value: function _handleRequestInstance() {
                        return this;
                    }

                    /**
                     * Retrieves list.
                     */
                }, {
                    key: '_retrieveList',
                    value: function _retrieveList(options) {
                        options = options ? options : {};
                        this.reset();
                        var data = options.hasOwnProperty('data') ? options.data : {};
                        if (!this._allowPagination) {
                            data.disable_pagination = true;
                        }
                        options.data = data;
                        /** @ignore */
                        this.url = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, this._route);
                        this.fetch(options);
                    }
                }]);

                return GlobalCollection;
            })(BaseCollection);

            _export('default', GlobalCollection);
        }
    };
});

$__System.register('1d', ['11', '14', '15', '16', '17', '20', '52'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Backbone, BaseModel;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            Backbone = _5['default'];
        }],
        execute: function () {

            /**
             * Base model.
             */
            'use strict';

            BaseModel = (function (_Backbone$Model) {
                _inherits(BaseModel, _Backbone$Model);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 *
                 * @param {object} options initialization parameters for Backbone.Model
                 */

                function BaseModel(options) {
                    var _this = this;

                    _classCallCheck(this, BaseModel);

                    _get(Object.getPrototypeOf(BaseModel.prototype), 'constructor', this).call(this, options);
                    this.on('change', function (model, options) {
                        return _this._onChange(model, options);
                    });
                    this.on('sync', function (model, response, options) {
                        return _this._onSync(model, response, options);
                    });
                }

                /**
                 * URL override to add trailing slash. Also, the URL will depend if this model instance has been saved or not. 
                 * If not saved, we have to use the plural route for the model to save it.
                 * That's the way Rodan works. :)
                 *
                 * @return {string} URL of Resource with trailing slash
                 */

                _createClass(BaseModel, [{
                    key: 'url',
                    value: function url() {
                        var original_url = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_ROUTE, this.routeName);
                        if (typeof this.get('uuid') !== 'undefined') {
                            original_url = this.get('url');
                        }
                        var parsed_url = original_url + (original_url.charAt(original_url.length - 1) === '/' ? '' : '/');
                        return parsed_url;
                    }

                    /**
                     * Override of destroy to allow for generic handling.
                     *
                     * @param {object} options Backbone.Model.destroy options object
                     */
                }, {
                    key: 'destroy',
                    value: function destroy(options) {
                        options = this._applyResponseHandlers(options);
                        options.task = 'destroy';
                        _get(Object.getPrototypeOf(BaseModel.prototype), 'destroy', this).call(this, options);
                    }

                    /**
                     * Override of save to allow for generic handling.
                     *
                     * @param {object} attributes attributes to change in model
                     * @param {object} options Backbone.Model.save options object
                     */
                }, {
                    key: 'save',
                    value: function save(attributes, options) {
                        options = this._applyResponseHandlers(options);
                        options.task = 'save';
                        return _get(Object.getPrototypeOf(BaseModel.prototype), 'save', this).call(this, attributes, options);
                    }

                    /**
                     * Override of fetch to allow for generic handling.
                     *
                     * @param {object} options Backbone.Model.fetch options object
                     */
                }, {
                    key: 'fetch',
                    value: function fetch(options) {
                        options = this._applyResponseHandlers(options);
                        options.task = 'fetch';
                        _get(Object.getPrototypeOf(BaseModel.prototype), 'fetch', this).call(this, options);
                    }

                    /**
                     * Returns descriptive string for model. This should be overridden by sub-classes.
                     *
                     * @return {string} returns 'no description available' unless overridden by subclass
                     */
                }, {
                    key: 'getDescription',
                    value: function getDescription() {
                        return 'no description available';
                    }

                    /**
                     * Parses ID out of resource type URL.
                     *
                     * @param {string} url URL with UUID at end
                     * @return {string} UUID
                     * @todo this should be in a utility file
                     */
                }, {
                    key: 'parseIdFromUrl',
                    value: function parseIdFromUrl(url) {
                        var lastSlash = url.lastIndexOf('/');
                        var subString = url.substring(0, lastSlash);
                        var secondLastSlash = subString.lastIndexOf('/');
                        return url.substring(secondLastSlash + 1, lastSlash);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * On change handler.
                     */
                }, {
                    key: '_onChange',
                    value: function _onChange(model, response, options) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__MODEL_CHANGE, { model: model, options: options });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__MODEL_CHANGE + model.get('url'), { model: model, options: options });
                    }

                    /**
                     * On sync handler.
                     */
                }, {
                    key: '_onSync',
                    value: function _onSync(model, response, options) {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__MODEL_SYNC, { model: model, response: response, options: options });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__MODEL_SYNC + model.get('url'), { model: model, response: response, options: options });
                    }

                    /**
                     * Applies response handlers.
                     */
                }, {
                    key: '_applyResponseHandlers',
                    value: function _applyResponseHandlers(options) {
                        var _this2 = this;

                        // Check if options are defined.
                        if (options === undefined) {
                            options = {};
                        }

                        // Success.
                        var genericSuccessFunction = function genericSuccessFunction(model, response, options) {
                            return _this2._handleSuccessResponse(model, response, options);
                        };
                        if (!options.hasOwnProperty('success')) {
                            options.success = function (model, response, options) {
                                return _this2._handleSuccessResponse(model, response, options);
                            };
                        } else {
                            var customSuccessFunction = options.success;
                            options.success = function (model, response, options) {
                                customSuccessFunction(model, response, options);
                                genericSuccessFunction(model, response, options);
                            };
                        }

                        // Error.
                        var genericErrorFunction = function genericErrorFunction(model, response, options) {
                            return _this2._handleErrorResponse(model, response, options);
                        };
                        if (!options.hasOwnProperty('error')) {
                            options.error = function (model, response, options) {
                                return _this2._handleErrorResponse(model, response, options);
                            };
                        } else {
                            var customErrorFunction = options.error;
                            options.error = function (model, response, options) {
                                customErrorFunction(model, response, options);
                                genericErrorFunction(model, response, options);
                            };
                        }

                        return options;
                    }

                    /**
                     * Handle success response.
                     */
                }, {
                    key: '_handleSuccessResponse',
                    value: function _handleSuccessResponse(model, response, options) {}

                    /**
                     * Handle error response.
                     */
                }, {
                    key: '_handleErrorResponse',
                    value: function _handleErrorResponse(model, response, options) {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SYSTEM_HANDLE_ERROR, { model: model,
                            response: response,
                            options: options });
                    }
                }]);

                return BaseModel;
            })(Backbone.Model);

            _export('default', BaseModel);

            BaseModel.prototype.idAttribute = 'uuid';
        }
    };
});

$__System.register('8d', ['14', '15', '17', '1d'], function (_export) {
  var _get, _inherits, _classCallCheck, BaseModel, ResourceType;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_d) {
      BaseModel = _d['default'];
    }],
    execute: function () {

      /**
       * ResourceType
       */
      'use strict';

      ResourceType = (function (_BaseModel) {
        _inherits(ResourceType, _BaseModel);

        function ResourceType() {
          _classCallCheck(this, ResourceType);

          _get(Object.getPrototypeOf(ResourceType.prototype), 'constructor', this).apply(this, arguments);
        }

        return ResourceType;
      })(BaseModel);

      _export('default', ResourceType);

      ResourceType.prototype.routeName = 'resourcetypes';
    }
  };
});

$__System.register('8e', ['11', '14', '15', '16', '17', '84', '8d'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, GlobalCollection, ResourceType, _instance, GlobalResourceTypeCollection;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_5) {
            GlobalCollection = _5['default'];
        }, function (_d) {
            ResourceType = _d['default'];
        }],
        execute: function () {
            'use strict';

            _instance = null;

            /**
             * Global Collection of ResourceType models.
             * This uses a pseudo-singleton model so we can inherit from BaseCollection.
             */

            GlobalResourceTypeCollection = (function (_GlobalCollection) {
                _inherits(GlobalResourceTypeCollection, _GlobalCollection);

                function GlobalResourceTypeCollection() {
                    _classCallCheck(this, GlobalResourceTypeCollection);

                    _get(Object.getPrototypeOf(GlobalResourceTypeCollection.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(GlobalResourceTypeCollection, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     *
                     * @throws {Error} thrown iff called more than once
                     */
                    value: function initialize() {
                        if (_instance) {
                            throw new Error('only one instance of this class may exist');
                        }
                        _instance = this;
                        /** @ignore */
                        this.model = ResourceType;
                        this._route = 'resourcetypes';
                        this._loadCommand = RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPES_LOAD;
                        this._requestCommand = RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION;
                    }
                }]);

                return GlobalResourceTypeCollection;
            })(GlobalCollection);

            _export('default', GlobalResourceTypeCollection);
        }
    };
});

$__System.register('8f', ['11', '14', '15', '16', '17', '20', '27'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewLogin;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }],
        execute: function () {

            /**
             * Login view.
             */
            'use strict';

            ViewLogin = (function (_Marionette$ItemView) {
                _inherits(ViewLogin, _Marionette$ItemView);

                function ViewLogin() {
                    _classCallCheck(this, ViewLogin);

                    _get(Object.getPrototypeOf(ViewLogin.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewLogin, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__UPDATER_CLEAR);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Handle login button.
                     */
                }, {
                    key: '_handleButton',
                    value: function _handleButton() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_LOGIN, { username: this.ui.textUsername.val(), password: this.ui.textPassword.val() });
                    }
                }]);

                return ViewLogin;
            })(Marionette.ItemView);

            _export('default', ViewLogin);

            ViewLogin.prototype.modelEvents = {
                'all': 'render'
            };
            ViewLogin.prototype.ui = {
                textUsername: '#text-login_username',
                textPassword: '#text-login_password',
                buttonLogin: '#button-login'
            };
            ViewLogin.prototype.events = {
                'click @ui.buttonLogin': '_handleButton'
            };
            ViewLogin.prototype.template = '#template-main_login';
        }
    };
});

$__System.register('90', ['11', '14', '15', '16', '17', '20', '27', '8f'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, ViewLogin, LayoutViewMain;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_5) {
            Marionette = _5['default'];
        }, function (_f) {
            ViewLogin = _f['default'];
        }],
        execute: function () {

            /**
             * Layout view for main work area. This is responsible for loading views within the main region.
             */
            'use strict';

            LayoutViewMain = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewMain, _Marionette$LayoutView);

                function LayoutViewMain() {
                    _classCallCheck(this, LayoutViewMain);

                    _get(Object.getPrototypeOf(LayoutViewMain.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewMain, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the instance.
                     */
                    value: function initialize() {
                        this.addRegions({
                            region: 'div'
                        });
                        this._initializeRadio();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, function (options) {
                            return _this._handleCommandShow(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGOUT_SUCCESS, function () {
                            return _this._handleDeauthenticationSuccess();
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGINREQUIRED, function () {
                            return _this._handleAuthenticationLoginRequired();
                        });
                    }

                    /**
                     * Handles request for login.
                     */
                }, {
                    key: '_handleAuthenticationLoginRequired',
                    value: function _handleAuthenticationLoginRequired() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: new ViewLogin() });
                    }

                    /**
                     * Handle show.
                     */
                }, {
                    key: '_handleCommandShow',
                    value: function _handleCommandShow(options) {
                        /** @ignore */
                        this.region.show(options.view);
                    }

                    /**
                     * Handle deauthentication success.
                     */
                }, {
                    key: '_handleDeauthenticationSuccess',
                    value: function _handleDeauthenticationSuccess() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MAINREGION_SHOW_VIEW, { view: new ViewLogin() });
                    }
                }]);

                return LayoutViewMain;
            })(Marionette.LayoutView);

            _export('default', LayoutViewMain);

            LayoutViewMain.prototype.template = '#template-empty';
        }
    };
});

$__System.register('91', ['11', '14', '15', '16', '17', '20', '92', '93'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, NAV_EVENTS, ViewNavigationNode, ViewNavigationNodeRunJobs;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            NAV_EVENTS = _6['default'];
        }, function (_8) {
            ViewNavigationNode = _8['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node for RunJobs.
             */
            'use strict';

            ViewNavigationNodeRunJobs = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeRunJobs, _ViewNavigationNode);

                function ViewNavigationNodeRunJobs() {
                    _classCallCheck(this, ViewNavigationNodeRunJobs);

                    _get(Object.getPrototypeOf(ViewNavigationNodeRunJobs.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeRunJobs, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Marionette.View options object
                     */
                    value: function initialize(options) {
                        var _this = this;

                        _get(Object.getPrototypeOf(ViewNavigationNodeRunJobs.prototype), 'initialize', this).call(this, options);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RUNJOB_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventCollectionSelected(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_SET_ACTIVE, { project: this.model.get('project') });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RUNJOB_SELECTED_COLLECTION, { project: this.model.get('project') });
                    }

                    /**
                     * Handle highlighting.
                     */
                }, {
                    key: '_handleEventCollectionSelected',
                    value: function _handleEventCollectionSelected(options) {
                        if (options.project === this.model.get('project')) {
                            Radio.channel('rodan-navigation').trigger(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, { node: this });
                        }
                    }
                }]);

                return ViewNavigationNodeRunJobs;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeRunJobs);

            ViewNavigationNodeRunJobs.prototype.template = '#template-navigation_runjobs';
        }
    };
});

$__System.register('94', ['11', '14', '15', '16', '17', '20', '92', '93'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, NAV_EVENTS, ViewNavigationNode, ViewNavigationNodeResources;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            NAV_EVENTS = _6['default'];
        }, function (_8) {
            ViewNavigationNode = _8['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node for a project.
             */
            'use strict';

            ViewNavigationNodeResources = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeResources, _ViewNavigationNode);

                function ViewNavigationNodeResources() {
                    _classCallCheck(this, ViewNavigationNodeResources);

                    _get(Object.getPrototypeOf(ViewNavigationNodeResources.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeResources, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Marionette.View options object
                     */
                    value: function initialize(options) {
                        var _this = this;

                        _get(Object.getPrototypeOf(ViewNavigationNodeResources.prototype), 'initialize', this).call(this, options);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__RESOURCE_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventResourcesSelected(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_SET_ACTIVE, { project: this.model.get('project') });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__RESOURCE_SELECTED_COLLECTION, { project: this.model.get('project') });
                    }

                    /**
                     * Handle highlighting.
                     */
                }, {
                    key: '_handleEventResourcesSelected',
                    value: function _handleEventResourcesSelected(options) {
                        if (options.project === this.model.get('project')) {
                            Radio.channel('rodan-navigation').trigger(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, { node: this });
                        }
                    }
                }]);

                return ViewNavigationNodeResources;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeResources);

            ViewNavigationNodeResources.prototype.template = '#template-navigation_resources';
        }
    };
});

$__System.register('95', ['11', '14', '15', '16', '17', '20', '92', '93'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, NAV_EVENTS, ViewNavigationNode, ViewNavigationNodeWorkflowRuns;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            NAV_EVENTS = _6['default'];
        }, function (_8) {
            ViewNavigationNode = _8['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node for a WorkflowRun list.
             */
            'use strict';

            ViewNavigationNodeWorkflowRuns = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeWorkflowRuns, _ViewNavigationNode);

                function ViewNavigationNodeWorkflowRuns() {
                    _classCallCheck(this, ViewNavigationNodeWorkflowRuns);

                    _get(Object.getPrototypeOf(ViewNavigationNodeWorkflowRuns.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeWorkflowRuns, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Marionette.View options object
                     */
                    value: function initialize(options) {
                        var _this = this;

                        _get(Object.getPrototypeOf(ViewNavigationNodeWorkflowRuns.prototype), 'initialize', this).call(this, options);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED_COLLECTION, function (event) {
                            return _this._handleEventWorkflowRunsSelected(event);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_SET_ACTIVE, { project: this.model.get('project') });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOWRUN_SELECTED_COLLECTION, { project: this.model.get('project') });
                    }

                    /**
                     * Handle highlighting.
                     */
                }, {
                    key: '_handleEventWorkflowRunsSelected',
                    value: function _handleEventWorkflowRunsSelected(event) {
                        if (event.project === this.model.get('project')) {
                            Radio.channel('rodan-navigation').trigger(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, { node: this });
                        }
                    }
                }]);

                return ViewNavigationNodeWorkflowRuns;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeWorkflowRuns);

            ViewNavigationNodeWorkflowRuns.prototype.template = '#template-navigation_workflowruns';
        }
    };
});

$__System.register('96', ['11', '14', '15', '16', '17', '20', '92', '93'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, NAV_EVENTS, ViewNavigationNode, ViewNavigationNodeWorkflows;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Radio = _7['default'];
        }, function (_6) {
            NAV_EVENTS = _6['default'];
        }, function (_8) {
            ViewNavigationNode = _8['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node for a Workflow list.
             */
            'use strict';

            ViewNavigationNodeWorkflows = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeWorkflows, _ViewNavigationNode);

                function ViewNavigationNodeWorkflows() {
                    _classCallCheck(this, ViewNavigationNodeWorkflows);

                    _get(Object.getPrototypeOf(ViewNavigationNodeWorkflows.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeWorkflows, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Marionette.View options object
                     */
                    value: function initialize(options) {
                        var _this = this;

                        _get(Object.getPrototypeOf(ViewNavigationNodeWorkflows.prototype), 'initialize', this).call(this, options);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED_COLLECTION, function (options) {
                            return _this._handleEventWorkflowsSelected(options);
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__PROJECT_SET_ACTIVE, { project: this.model.get('project') });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__WORKFLOW_SELECTED_COLLECTION, { project: this.model.get('project') });
                    }

                    /**
                     * Handle highlighting.
                     */
                }, {
                    key: '_handleEventWorkflowsSelected',
                    value: function _handleEventWorkflowsSelected(options) {
                        if (options.project === this.model.get('project')) {
                            Radio.channel('rodan-navigation').trigger(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, { node: this });
                        }
                    }
                }]);

                return ViewNavigationNodeWorkflows;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeWorkflows);

            ViewNavigationNodeWorkflows.prototype.template = '#template-navigation_workflows';
        }
    };
});

$__System.register('92', [], function (_export) {
  /**
   * Backbone.Radio events for navigation "module".
   */
  'use strict';

  var NAV_EVENTS;
  return {
    setters: [],
    execute: function () {
      NAV_EVENTS = {
        EVENT__NAVIGATION_SELECTED_NODE: 'EVENT__NAVIGATION_SELECTED_NODE'
      };

      _export('default', NAV_EVENTS);
    }
  };
});

$__System.register('93', ['3', '14', '15', '16', '17', '20', '27', '92'], function (_export) {
    var $, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, NAV_EVENTS, ViewNavigationNode;

    return {
        setters: [function (_5) {
            $ = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_6) {
            Marionette = _6['default'];
        }, function (_7) {
            NAV_EVENTS = _7['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node.
             */
            'use strict';

            ViewNavigationNode = (function (_Marionette$CompositeView) {
                _inherits(ViewNavigationNode, _Marionette$CompositeView);

                function ViewNavigationNode() {
                    _classCallCheck(this, ViewNavigationNode);

                    _get(Object.getPrototypeOf(ViewNavigationNode.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNode, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        var _this = this;

                        Radio.channel('rodan-navigation').on(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, function (event) {
                            return _this._handleEventNodeSelected(event);
                        });
                    }

                    /**
                     * Hide subviews on render (initially).
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        this._hideSubviews();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Sets highlight of this menu entry.
                     */
                }, {
                    key: '_setHighlight',
                    value: function _setHighlight(highlight) {
                        var node = $(this.$el.find('.node_text')[0]);
                        if (highlight) {
                            // TODO magic number
                            node.css('background-color', '#444444');
                        } else {
                            node.css('background-color', '');
                        }
                    }

                    /**
                     * Handle click.
                     */
                }, {
                    key: '_handleClick',
                    value: function _handleClick(event) {
                        this._toggleSubviews();
                        event.stopPropagation();
                        this._sendClickEvents();
                    }

                    /**
                     * Toggle subview show.
                     */
                }, {
                    key: '_toggleSubviews',
                    value: function _toggleSubviews() {
                        var firstUl = $(this.$el.find(this.childViewContainer)[0]);
                        if (firstUl !== undefined && firstUl.find('div').length > 0) {
                            firstUl.toggle('fast');
                        }
                    }

                    /**
                     * Hide subvies.
                     */
                }, {
                    key: '_hideSubviews',
                    value: function _hideSubviews() {
                        var firstUl = $(this.$el.find(this.childViewContainer)[0]);
                        if (firstUl !== undefined) {
                            firstUl.hide();
                        }
                    }

                    /**
                     * Show subviews.
                     */
                }, {
                    key: '_showSubviews',
                    value: function _showSubviews() {
                        // Show subviews.
                        var firstUl = $(this.$el.find(this.childViewContainer)[0]);
                        if (firstUl !== undefined) {
                            firstUl.show();
                        }
                    }

                    /**
                     * Expand parent.
                     */
                }, {
                    key: '_expandParent',
                    value: function _expandParent() {
                        // Show parents.
                        if (this._parent !== null && this._parent !== undefined && this._parent instanceof ViewNavigationNode) {
                            this._parent._showSubviews();
                            this._parent._expandParent();
                        }
                    }

                    /**
                     * Does highlighting.
                     */
                }, {
                    key: '_handleEventNodeSelected',
                    value: function _handleEventNodeSelected(event) {
                        if (this === event.node) {
                            this._setHighlight(true);
                            this._expandParent();
                        } else {
                            this._setHighlight(false);
                        }
                    }
                }]);

                return ViewNavigationNode;
            })(Marionette.CompositeView);

            _export('default', ViewNavigationNode);

            ViewNavigationNode.prototype.ui = {
                text: '.node_text'
            };
            ViewNavigationNode.prototype.events = {
                'click @ui.text': '_handleClick'
            };
            ViewNavigationNode.prototype.template = '#template-navigation_node';
            ViewNavigationNode.prototype.childViewContainer = 'ul';
        }
    };
});

$__System.register('97', ['11', '14', '15', '16', '17', '20', '52', '91', '92', '93', '94', '95', '96'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Backbone, ViewNavigationNodeRunJobs, NAV_EVENTS, ViewNavigationNode, ViewNavigationNodeResources, ViewNavigationNodeWorkflowRuns, ViewNavigationNodeWorkflows, ViewNavigationNodeProject;

    return {
        setters: [function (_6) {
            RODAN_EVENTS = _6['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_8) {
            Radio = _8['default'];
        }, function (_5) {
            Backbone = _5['default'];
        }, function (_9) {
            ViewNavigationNodeRunJobs = _9['default'];
        }, function (_7) {
            NAV_EVENTS = _7['default'];
        }, function (_13) {
            ViewNavigationNode = _13['default'];
        }, function (_10) {
            ViewNavigationNodeResources = _10['default'];
        }, function (_11) {
            ViewNavigationNodeWorkflowRuns = _11['default'];
        }, function (_12) {
            ViewNavigationNodeWorkflows = _12['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node for a project.
             */
            'use strict';

            ViewNavigationNodeProject = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeProject, _ViewNavigationNode);

                function ViewNavigationNodeProject() {
                    _classCallCheck(this, ViewNavigationNodeProject);

                    _get(Object.getPrototypeOf(ViewNavigationNodeProject.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeProject, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     *
                     * @param {object} options Marionette.View options object
                     */
                    value: function initialize(options) {
                        var _this = this;

                        _get(Object.getPrototypeOf(ViewNavigationNodeProject.prototype), 'initialize', this).call(this, options);
                        /** @ignore */
                        this.collection = new Backbone.Collection();
                        var resourcesNodeModel = new Backbone.Model({ name: 'Resources', project: this.model });
                        var workflowBuilderNodeModel = new Backbone.Model({ name: 'Workflows', project: this.model });
                        var workflowRunsNodeModel = new Backbone.Model({ name: 'Workflow Runs', project: this.model });
                        var runJobsNodeModel = new Backbone.Model({ name: 'Run Jobs', project: this.model });
                        this.collection.add(resourcesNodeModel);
                        this.collection.add(workflowBuilderNodeModel);
                        this.collection.add(workflowRunsNodeModel);
                        this.collection.add(runJobsNodeModel);
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__PROJECT_SELECTED, function (event) {
                            return _this._handleEventProjectSelected(event);
                        });
                    }

                    /**
                     * Determine child view based on name.
                     *
                     * @param {BaseModel} model instance of 'Resource', 'Workflow', 'WorkflowRun', or 'RunJob'
                     * @return {ViewNavigationNode} a subclass of ViewNavigationNode; only returns class, not instance; will return ViewNavigationNode if the BaseModel provided is not one of the above
                     */
                }, {
                    key: 'getChildView',
                    value: function getChildView(model) {
                        switch (model.get('name')) {
                            case 'Resources':
                                {
                                    return ViewNavigationNodeResources;
                                }

                            case 'Workflows':
                                {
                                    return ViewNavigationNodeWorkflows;
                                }

                            case 'Workflow Runs':
                                {
                                    return ViewNavigationNodeWorkflowRuns;
                                }

                            case 'Run Jobs':
                                {
                                    return ViewNavigationNodeRunJobs;
                                }

                            default:
                                {
                                    return ViewNavigationNode;
                                }
                        }
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SELECTED, { project: this.model });
                    }

                    /**
                     * Handle highlighting.
                     */
                }, {
                    key: '_handleEventProjectSelected',
                    value: function _handleEventProjectSelected(event) {
                        if (event.project === this.model) {
                            Radio.channel('rodan-navigation').trigger(NAV_EVENTS.EVENT__NAVIGATION_SELECTED_NODE, { node: this });
                        }
                    }
                }]);

                return ViewNavigationNodeProject;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeProject);
        }
    };
});

$__System.register('98', ['11', '14', '15', '16', '17', '20', '93', '97'], function (_export) {
    var RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, ViewNavigationNode, ViewNavigationNodeProject, ViewNavigationNodeRoot;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_6) {
            Radio = _6['default'];
        }, function (_7) {
            ViewNavigationNode = _7['default'];
        }, function (_8) {
            ViewNavigationNodeProject = _8['default'];
        }],
        execute: function () {

            /**
             * This class represents a navigation menu node.
             */
            'use strict';

            ViewNavigationNodeRoot = (function (_ViewNavigationNode) {
                _inherits(ViewNavigationNodeRoot, _ViewNavigationNode);

                function ViewNavigationNodeRoot() {
                    _classCallCheck(this, ViewNavigationNodeRoot);

                    _get(Object.getPrototypeOf(ViewNavigationNodeRoot.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(ViewNavigationNodeRoot, [{
                    key: 'onRender',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * This hides all subviews on render (initially).
                     */
                    value: function onRender() {
                        this._showSubviews();
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Send click events.
                     */
                }, {
                    key: '_sendClickEvents',
                    value: function _sendClickEvents() {
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SELECTED_COLLECTION);
                    }
                }]);

                return ViewNavigationNodeRoot;
            })(ViewNavigationNode);

            _export('default', ViewNavigationNodeRoot);

            ViewNavigationNodeRoot.prototype.ui = {
                text: '.node_text'
            };
            ViewNavigationNodeRoot.prototype.events = {
                'click @ui.text': '_handleClick'
            };
            ViewNavigationNodeRoot.prototype.template = '#template-navigation_root';
            ViewNavigationNodeRoot.prototype.childView = ViewNavigationNodeProject;
        }
    };
});

$__System.register('99', ['10', '11', '14', '15', '16', '17', '20', '27', '32', '52', '98'], function (_export) {
    var Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, _, Backbone, ViewNavigationNodeRoot, LayoutViewNavigation;

    return {
        setters: [function (_8) {
            Configuration = _8['default'];
        }, function (_9) {
            RODAN_EVENTS = _9['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_11) {
            Radio = _11['default'];
        }, function (_10) {
            Marionette = _10['default'];
        }, function (_6) {
            _ = _6['default'];
        }, function (_7) {
            Backbone = _7['default'];
        }, function (_12) {
            ViewNavigationNodeRoot = _12['default'];
        }],
        execute: function () {

            /**
             * Layout view for main work area. This is responsible for loading views within the main region.
             */
            'use strict';

            LayoutViewNavigation = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewNavigation, _Marionette$LayoutView);

                function LayoutViewNavigation() {
                    _classCallCheck(this, LayoutViewNavigation);

                    _get(Object.getPrototypeOf(LayoutViewNavigation.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewNavigation, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize.
                     */
                    value: function initialize() {
                        this._initializeRadio();
                        this.addRegions({
                            regionNavigationTree: '#region-navigation_tree'
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize Radio.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGIN_SUCCESS, function (options) {
                            return _this._handleAuthenticationSuccess(options);
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGOUT_SUCCESS, function () {
                            return _this._handleDeauthenticationSuccess();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SHOW_ABOUT, function () {
                            return _this._handleRequestShowAbout();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__SHOW_HELP, function () {
                            return _this._handleRequestShowHelp();
                        });
                    }

                    /**
                     * Handle authentication.
                     */
                }, {
                    key: '_handleAuthenticationSuccess',
                    value: function _handleAuthenticationSuccess() {
                        var model = new Backbone.Model({ name: 'Projects' });
                        var object = { model: model, collection: Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_PROJECT_COLLECTION) };
                        this.regionNavigationTree.show(new ViewNavigationNodeRoot(object));
                        this.$el.find('#button-navigation_logout').prop('disabled', false);
                    }

                    /**
                     * Handle deauthentication.
                     */
                }, {
                    key: '_handleDeauthenticationSuccess',
                    value: function _handleDeauthenticationSuccess() {
                        this.regionNavigationTree.reset();
                        this.$el.find('#button-navigation_logout').prop('disabled', true);
                    }

                    /**
                     * Handle button logout.
                     */
                }, {
                    key: '_handleButtonLogout',
                    value: function _handleButtonLogout() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_LOGOUT);
                    }

                    /**
                     * Handle button about.
                     */
                }, {
                    key: '_handleButtonAbout',
                    value: function _handleButtonAbout() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SHOW_ABOUT);
                    }

                    /**
                     * Handle button help.
                     */
                }, {
                    key: '_handleButtonHelp',
                    value: function _handleButtonHelp() {
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SHOW_HELP);
                    }

                    /**
                     * Handle request show about.
                     */
                }, {
                    key: '_handleRequestShowAbout',
                    value: function _handleRequestShowAbout() {
                        var user = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER);
                        var serverConfig = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_CONFIGURATION);
                        var hostname = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_HOSTNAME);
                        var version = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_GET_VERSION);
                        var serverDate = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_DATE);
                        serverDate = serverDate.toString();
                        var username = user ? user.get('username') : 'no user';
                        var name = user ? user.get('first_name') + ' ' + user.get('last_name') : 'no user';
                        var html = _.template($('#template-misc_about').html())({ hostname: hostname,
                            version: version,
                            username: username,
                            name: name,
                            serverConfiguration: serverConfig,
                            date: serverDate,
                            client: Configuration.CLIENT });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW_SIMPLE, { title: 'About', text: html });
                    }

                    /**
                     * Handle request show help.
                     */
                }, {
                    key: '_handleRequestShowHelp',
                    value: function _handleRequestShowHelp() {
                        var html = _.template($('#template-misc_help').html())({ email: Configuration.ADMIN_CLIENT.EMAIL, name: Configuration.ADMIN_CLIENT.NAME, url: Configuration.WEBSITE_URL });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW_SIMPLE, { title: 'Help', text: html });
                    }
                }]);

                return LayoutViewNavigation;
            })(Marionette.LayoutView);

            _export('default', LayoutViewNavigation);

            LayoutViewNavigation.prototype.template = '#template-navigation';
            LayoutViewNavigation.prototype.ui = {
                buttonLogout: '#button-navigation_logout',
                buttonAbout: '#button-navigation_about',
                buttonHelp: '#button-navigation_help'
            };
            LayoutViewNavigation.prototype.events = {
                'click @ui.buttonLogout': '_handleButtonLogout',
                'click @ui.buttonAbout': '_handleButtonAbout',
                'click @ui.buttonHelp': '_handleButtonHelp'
            };
        }
    };
});

$__System.registerDynamic("9a", ["9b", "32", "22"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function(root, factory) {
      if (typeof define === 'function' && define.amd) {
        define(['backbone', 'underscore'], function(Backbone, _) {
          return factory(Backbone, _);
        });
      } else if (typeof exports !== 'undefined') {
        var Backbone = $__require('9b');
        var _ = $__require('32');
        module.exports = factory(Backbone, _);
      } else {
        factory(root.Backbone, root._);
      }
    }(this, function(Backbone, _) {
      "use strict";
      var previousWreqr = Backbone.Wreqr;
      var Wreqr = Backbone.Wreqr = {};
      Backbone.Wreqr.VERSION = '1.3.6';
      Backbone.Wreqr.noConflict = function() {
        Backbone.Wreqr = previousWreqr;
        return this;
      };
      Wreqr.Handlers = (function(Backbone, _) {
        "use strict";
        var Handlers = function(options) {
          this.options = options;
          this._wreqrHandlers = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        Handlers.extend = Backbone.Model.extend;
        _.extend(Handlers.prototype, Backbone.Events, {
          setHandlers: function(handlers) {
            _.each(handlers, function(handler, name) {
              var context = null;
              if (_.isObject(handler) && !_.isFunction(handler)) {
                context = handler.context;
                handler = handler.callback;
              }
              this.setHandler(name, handler, context);
            }, this);
          },
          setHandler: function(name, handler, context) {
            var config = {
              callback: handler,
              context: context
            };
            this._wreqrHandlers[name] = config;
            this.trigger("handler:add", name, handler, context);
          },
          hasHandler: function(name) {
            return !!this._wreqrHandlers[name];
          },
          getHandler: function(name) {
            var config = this._wreqrHandlers[name];
            if (!config) {
              return;
            }
            return function() {
              return config.callback.apply(config.context, arguments);
            };
          },
          removeHandler: function(name) {
            delete this._wreqrHandlers[name];
          },
          removeAllHandlers: function() {
            this._wreqrHandlers = {};
          }
        });
        return Handlers;
      })(Backbone, _);
      Wreqr.CommandStorage = (function() {
        "use strict";
        var CommandStorage = function(options) {
          this.options = options;
          this._commands = {};
          if (_.isFunction(this.initialize)) {
            this.initialize(options);
          }
        };
        _.extend(CommandStorage.prototype, Backbone.Events, {
          getCommands: function(commandName) {
            var commands = this._commands[commandName];
            if (!commands) {
              commands = {
                command: commandName,
                instances: []
              };
              this._commands[commandName] = commands;
            }
            return commands;
          },
          addCommand: function(commandName, args) {
            var command = this.getCommands(commandName);
            command.instances.push(args);
          },
          clearCommands: function(commandName) {
            var command = this.getCommands(commandName);
            command.instances = [];
          }
        });
        return CommandStorage;
      })();
      Wreqr.Commands = (function(Wreqr, _) {
        "use strict";
        return Wreqr.Handlers.extend({
          storageType: Wreqr.CommandStorage,
          constructor: function(options) {
            this.options = options || {};
            this._initializeStorage(this.options);
            this.on("handler:add", this._executeCommands, this);
            Wreqr.Handlers.prototype.constructor.apply(this, arguments);
          },
          execute: function(name) {
            name = arguments[0];
            var args = _.rest(arguments);
            if (this.hasHandler(name)) {
              this.getHandler(name).apply(this, args);
            } else {
              this.storage.addCommand(name, args);
            }
          },
          _executeCommands: function(name, handler, context) {
            var command = this.storage.getCommands(name);
            _.each(command.instances, function(args) {
              handler.apply(context, args);
            });
            this.storage.clearCommands(name);
          },
          _initializeStorage: function(options) {
            var storage;
            var StorageType = options.storageType || this.storageType;
            if (_.isFunction(StorageType)) {
              storage = new StorageType();
            } else {
              storage = StorageType;
            }
            this.storage = storage;
          }
        });
      })(Wreqr, _);
      Wreqr.RequestResponse = (function(Wreqr, _) {
        "use strict";
        return Wreqr.Handlers.extend({request: function(name) {
            if (this.hasHandler(name)) {
              return this.getHandler(name).apply(this, _.rest(arguments));
            }
          }});
      })(Wreqr, _);
      Wreqr.EventAggregator = (function(Backbone, _) {
        "use strict";
        var EA = function() {};
        EA.extend = Backbone.Model.extend;
        _.extend(EA.prototype, Backbone.Events);
        return EA;
      })(Backbone, _);
      Wreqr.Channel = (function(Wreqr) {
        "use strict";
        var Channel = function(channelName) {
          this.vent = new Backbone.Wreqr.EventAggregator();
          this.reqres = new Backbone.Wreqr.RequestResponse();
          this.commands = new Backbone.Wreqr.Commands();
          this.channelName = channelName;
        };
        _.extend(Channel.prototype, {
          reset: function() {
            this.vent.off();
            this.vent.stopListening();
            this.reqres.removeAllHandlers();
            this.commands.removeAllHandlers();
            return this;
          },
          connectEvents: function(hash, context) {
            this._connect('vent', hash, context);
            return this;
          },
          connectCommands: function(hash, context) {
            this._connect('commands', hash, context);
            return this;
          },
          connectRequests: function(hash, context) {
            this._connect('reqres', hash, context);
            return this;
          },
          _connect: function(type, hash, context) {
            if (!hash) {
              return;
            }
            context = context || this;
            var method = (type === 'vent') ? 'on' : 'setHandler';
            _.each(hash, function(fn, eventName) {
              this[type][method](eventName, _.bind(fn, context));
            }, this);
          }
        });
        return Channel;
      })(Wreqr);
      Wreqr.radio = (function(Wreqr, _) {
        "use strict";
        var Radio = function() {
          this._channels = {};
          this.vent = {};
          this.commands = {};
          this.reqres = {};
          this._proxyMethods();
        };
        _.extend(Radio.prototype, {
          channel: function(channelName) {
            if (!channelName) {
              throw new Error('Channel must receive a name');
            }
            return this._getChannel(channelName);
          },
          _getChannel: function(channelName) {
            var channel = this._channels[channelName];
            if (!channel) {
              channel = new Wreqr.Channel(channelName);
              this._channels[channelName] = channel;
            }
            return channel;
          },
          _proxyMethods: function() {
            _.each(['vent', 'commands', 'reqres'], function(system) {
              _.each(messageSystems[system], function(method) {
                this[system][method] = proxyMethod(this, system, method);
              }, this);
            }, this);
          }
        });
        var messageSystems = {
          vent: ['on', 'off', 'trigger', 'once', 'stopListening', 'listenTo', 'listenToOnce'],
          commands: ['execute', 'setHandler', 'setHandlers', 'removeHandler', 'removeAllHandlers'],
          reqres: ['request', 'setHandler', 'setHandlers', 'removeHandler', 'removeAllHandlers']
        };
        var proxyMethod = function(radio, system, method) {
          return function(channelName) {
            var messageSystem = radio._getChannel(channelName)[system];
            return messageSystem[method].apply(messageSystem, _.rest(arguments));
          };
        };
        return new Radio();
      })(Wreqr, _);
      return Backbone.Wreqr;
    }));
  })($__require('22'));
  return module.exports;
});

$__System.registerDynamic("9c", ["9a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('9a');
  return module.exports;
});

$__System.registerDynamic("9d", ["9b", "32"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(root, factory) {
    if (typeof define === 'function' && define.amd) {
      define(['backbone', 'underscore'], function(Backbone, _) {
        return factory(Backbone, _);
      });
    } else if (typeof exports !== 'undefined') {
      var Backbone = $__require('9b');
      var _ = $__require('32');
      module.exports = factory(Backbone, _);
    } else {
      factory(root.Backbone, root._);
    }
  }(this, function(Backbone, _) {
    'use strict';
    var previousChildViewContainer = Backbone.ChildViewContainer;
    Backbone.ChildViewContainer = (function(Backbone, _) {
      var Container = function(views) {
        this._views = {};
        this._indexByModel = {};
        this._indexByCustom = {};
        this._updateLength();
        _.each(views, this.add, this);
      };
      _.extend(Container.prototype, {
        add: function(view, customIndex) {
          var viewCid = view.cid;
          this._views[viewCid] = view;
          if (view.model) {
            this._indexByModel[view.model.cid] = viewCid;
          }
          if (customIndex) {
            this._indexByCustom[customIndex] = viewCid;
          }
          this._updateLength();
          return this;
        },
        findByModel: function(model) {
          return this.findByModelCid(model.cid);
        },
        findByModelCid: function(modelCid) {
          var viewCid = this._indexByModel[modelCid];
          return this.findByCid(viewCid);
        },
        findByCustom: function(index) {
          var viewCid = this._indexByCustom[index];
          return this.findByCid(viewCid);
        },
        findByIndex: function(index) {
          return _.values(this._views)[index];
        },
        findByCid: function(cid) {
          return this._views[cid];
        },
        remove: function(view) {
          var viewCid = view.cid;
          if (view.model) {
            delete this._indexByModel[view.model.cid];
          }
          _.any(this._indexByCustom, function(cid, key) {
            if (cid === viewCid) {
              delete this._indexByCustom[key];
              return true;
            }
          }, this);
          delete this._views[viewCid];
          this._updateLength();
          return this;
        },
        call: function(method) {
          this.apply(method, _.tail(arguments));
        },
        apply: function(method, args) {
          _.each(this._views, function(view) {
            if (_.isFunction(view[method])) {
              view[method].apply(view, args || []);
            }
          });
        },
        _updateLength: function() {
          this.length = _.size(this._views);
        }
      });
      var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'toArray', 'first', 'initial', 'rest', 'last', 'without', 'isEmpty', 'pluck', 'reduce'];
      _.each(methods, function(method) {
        Container.prototype[method] = function() {
          var views = _.values(this._views);
          var args = [views].concat(_.toArray(arguments));
          return _[method].apply(_, args);
        };
      });
      return Container;
    })(Backbone, _);
    Backbone.ChildViewContainer.VERSION = '0.1.11';
    Backbone.ChildViewContainer.noConflict = function() {
      Backbone.ChildViewContainer = previousChildViewContainer;
      return this;
    };
    return Backbone.ChildViewContainer;
  }));
  return module.exports;
});

$__System.registerDynamic("9e", ["9d"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('9d');
  return module.exports;
});

$__System.registerDynamic("9f", ["9b", "32", "9c", "9e", "22"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function(root, factory) {
      if (typeof define === 'function' && define.amd) {
        define(['backbone', 'underscore', 'backbone.wreqr', 'backbone.babysitter'], function(Backbone, _) {
          return (root.Marionette = root.Mn = factory(root, Backbone, _));
        });
      } else if (typeof exports !== 'undefined') {
        var Backbone = $__require('9b');
        var _ = $__require('32');
        var Wreqr = $__require('9c');
        var BabySitter = $__require('9e');
        module.exports = factory(root, Backbone, _);
      } else {
        root.Marionette = root.Mn = factory(root, root.Backbone, root._);
      }
    }(this, function(root, Backbone, _) {
      'use strict';
      var previousMarionette = root.Marionette;
      var previousMn = root.Mn;
      var Marionette = Backbone.Marionette = {};
      Marionette.VERSION = '2.4.5';
      Marionette.noConflict = function() {
        root.Marionette = previousMarionette;
        root.Mn = previousMn;
        return this;
      };
      Marionette.Deferred = Backbone.$.Deferred;
      Marionette.FEATURES = {};
      Marionette.isEnabled = function(name) {
        return !!Marionette.FEATURES[name];
      };
      Marionette.extend = Backbone.Model.extend;
      Marionette.isNodeAttached = function(el) {
        return Backbone.$.contains(document.documentElement, el);
      };
      Marionette.mergeOptions = function(options, keys) {
        if (!options) {
          return;
        }
        _.extend(this, _.pick(options, keys));
      };
      Marionette.getOption = function(target, optionName) {
        if (!target || !optionName) {
          return;
        }
        if (target.options && (target.options[optionName] !== undefined)) {
          return target.options[optionName];
        } else {
          return target[optionName];
        }
      };
      Marionette.proxyGetOption = function(optionName) {
        return Marionette.getOption(this, optionName);
      };
      Marionette._getValue = function(value, context, params) {
        if (_.isFunction(value)) {
          value = params ? value.apply(context, params) : value.call(context);
        }
        return value;
      };
      Marionette.normalizeMethods = function(hash) {
        return _.reduce(hash, function(normalizedHash, method, name) {
          if (!_.isFunction(method)) {
            method = this[method];
          }
          if (method) {
            normalizedHash[name] = method;
          }
          return normalizedHash;
        }, {}, this);
      };
      Marionette.normalizeUIString = function(uiString, ui) {
        return uiString.replace(/@ui\.[a-zA-Z-_$0-9]*/g, function(r) {
          return ui[r.slice(4)];
        });
      };
      Marionette.normalizeUIKeys = function(hash, ui) {
        return _.reduce(hash, function(memo, val, key) {
          var normalizedKey = Marionette.normalizeUIString(key, ui);
          memo[normalizedKey] = val;
          return memo;
        }, {});
      };
      Marionette.normalizeUIValues = function(hash, ui, properties) {
        _.each(hash, function(val, key) {
          if (_.isString(val)) {
            hash[key] = Marionette.normalizeUIString(val, ui);
          } else if (_.isObject(val) && _.isArray(properties)) {
            _.extend(val, Marionette.normalizeUIValues(_.pick(val, properties), ui));
            _.each(properties, function(property) {
              var propertyVal = val[property];
              if (_.isString(propertyVal)) {
                val[property] = Marionette.normalizeUIString(propertyVal, ui);
              }
            });
          }
        });
        return hash;
      };
      Marionette.actAsCollection = function(object, listProperty) {
        var methods = ['forEach', 'each', 'map', 'find', 'detect', 'filter', 'select', 'reject', 'every', 'all', 'some', 'any', 'include', 'contains', 'invoke', 'toArray', 'first', 'initial', 'rest', 'last', 'without', 'isEmpty', 'pluck'];
        _.each(methods, function(method) {
          object[method] = function() {
            var list = _.values(_.result(this, listProperty));
            var args = [list].concat(_.toArray(arguments));
            return _[method].apply(_, args);
          };
        });
      };
      var deprecate = Marionette.deprecate = function(message, test) {
        if (_.isObject(message)) {
          message = (message.prev + ' is going to be removed in the future. ' + 'Please use ' + message.next + ' instead.' + (message.url ? ' See: ' + message.url : ''));
        }
        if ((test === undefined || !test) && !deprecate._cache[message]) {
          deprecate._warn('Deprecation warning: ' + message);
          deprecate._cache[message] = true;
        }
      };
      deprecate._console = typeof console !== 'undefined' ? console : {};
      deprecate._warn = function() {
        var warn = deprecate._console.warn || deprecate._console.log || function() {};
        return warn.apply(deprecate._console, arguments);
      };
      deprecate._cache = {};
      Marionette._triggerMethod = (function() {
        var splitter = /(^|:)(\w)/gi;
        function getEventName(match, prefix, eventName) {
          return eventName.toUpperCase();
        }
        return function(context, event, args) {
          var noEventArg = arguments.length < 3;
          if (noEventArg) {
            args = event;
            event = args[0];
          }
          var methodName = 'on' + event.replace(splitter, getEventName);
          var method = context[methodName];
          var result;
          if (_.isFunction(method)) {
            result = method.apply(context, noEventArg ? _.rest(args) : args);
          }
          if (_.isFunction(context.trigger)) {
            if (noEventArg + args.length > 1) {
              context.trigger.apply(context, noEventArg ? args : [event].concat(_.drop(args, 0)));
            } else {
              context.trigger(event);
            }
          }
          return result;
        };
      })();
      Marionette.triggerMethod = function(event) {
        return Marionette._triggerMethod(this, arguments);
      };
      Marionette.triggerMethodOn = function(context) {
        var fnc = _.isFunction(context.triggerMethod) ? context.triggerMethod : Marionette.triggerMethod;
        return fnc.apply(context, _.rest(arguments));
      };
      Marionette.MonitorDOMRefresh = function(view) {
        if (view._isDomRefreshMonitored) {
          return;
        }
        view._isDomRefreshMonitored = true;
        function handleShow() {
          view._isShown = true;
          triggerDOMRefresh();
        }
        function handleRender() {
          view._isRendered = true;
          triggerDOMRefresh();
        }
        function triggerDOMRefresh() {
          if (view._isShown && view._isRendered && Marionette.isNodeAttached(view.el)) {
            Marionette.triggerMethodOn(view, 'dom:refresh', view);
          }
        }
        view.on({
          show: handleShow,
          render: handleRender
        });
      };
      (function(Marionette) {
        'use strict';
        function bindFromStrings(target, entity, evt, methods) {
          var methodNames = methods.split(/\s+/);
          _.each(methodNames, function(methodName) {
            var method = target[methodName];
            if (!method) {
              throw new Marionette.Error('Method "' + methodName + '" was configured as an event handler, but does not exist.');
            }
            target.listenTo(entity, evt, method);
          });
        }
        function bindToFunction(target, entity, evt, method) {
          target.listenTo(entity, evt, method);
        }
        function unbindFromStrings(target, entity, evt, methods) {
          var methodNames = methods.split(/\s+/);
          _.each(methodNames, function(methodName) {
            var method = target[methodName];
            target.stopListening(entity, evt, method);
          });
        }
        function unbindToFunction(target, entity, evt, method) {
          target.stopListening(entity, evt, method);
        }
        function iterateEvents(target, entity, bindings, functionCallback, stringCallback) {
          if (!entity || !bindings) {
            return;
          }
          if (!_.isObject(bindings)) {
            throw new Marionette.Error({
              message: 'Bindings must be an object or function.',
              url: 'marionette.functions.html#marionettebindentityevents'
            });
          }
          bindings = Marionette._getValue(bindings, target);
          _.each(bindings, function(methods, evt) {
            if (_.isFunction(methods)) {
              functionCallback(target, entity, evt, methods);
            } else {
              stringCallback(target, entity, evt, methods);
            }
          });
        }
        Marionette.bindEntityEvents = function(target, entity, bindings) {
          iterateEvents(target, entity, bindings, bindToFunction, bindFromStrings);
        };
        Marionette.unbindEntityEvents = function(target, entity, bindings) {
          iterateEvents(target, entity, bindings, unbindToFunction, unbindFromStrings);
        };
        Marionette.proxyBindEntityEvents = function(entity, bindings) {
          return Marionette.bindEntityEvents(this, entity, bindings);
        };
        Marionette.proxyUnbindEntityEvents = function(entity, bindings) {
          return Marionette.unbindEntityEvents(this, entity, bindings);
        };
      })(Marionette);
      var errorProps = ['description', 'fileName', 'lineNumber', 'name', 'message', 'number'];
      Marionette.Error = Marionette.extend.call(Error, {
        urlRoot: 'http://marionettejs.com/docs/v' + Marionette.VERSION + '/',
        constructor: function(message, options) {
          if (_.isObject(message)) {
            options = message;
            message = options.message;
          } else if (!options) {
            options = {};
          }
          var error = Error.call(this, message);
          _.extend(this, _.pick(error, errorProps), _.pick(options, errorProps));
          this.captureStackTrace();
          if (options.url) {
            this.url = this.urlRoot + options.url;
          }
        },
        captureStackTrace: function() {
          if (Error.captureStackTrace) {
            Error.captureStackTrace(this, Marionette.Error);
          }
        },
        toString: function() {
          return this.name + ': ' + this.message + (this.url ? ' See: ' + this.url : '');
        }
      });
      Marionette.Error.extend = Marionette.extend;
      Marionette.Callbacks = function() {
        this._deferred = Marionette.Deferred();
        this._callbacks = [];
      };
      _.extend(Marionette.Callbacks.prototype, {
        add: function(callback, contextOverride) {
          var promise = _.result(this._deferred, 'promise');
          this._callbacks.push({
            cb: callback,
            ctx: contextOverride
          });
          promise.then(function(args) {
            if (contextOverride) {
              args.context = contextOverride;
            }
            callback.call(args.context, args.options);
          });
        },
        run: function(options, context) {
          this._deferred.resolve({
            options: options,
            context: context
          });
        },
        reset: function() {
          var callbacks = this._callbacks;
          this._deferred = Marionette.Deferred();
          this._callbacks = [];
          _.each(callbacks, function(cb) {
            this.add(cb.cb, cb.ctx);
          }, this);
        }
      });
      Marionette.Controller = function(options) {
        this.options = options || {};
        if (_.isFunction(this.initialize)) {
          this.initialize(this.options);
        }
      };
      Marionette.Controller.extend = Marionette.extend;
      _.extend(Marionette.Controller.prototype, Backbone.Events, {
        destroy: function() {
          Marionette._triggerMethod(this, 'before:destroy', arguments);
          Marionette._triggerMethod(this, 'destroy', arguments);
          this.stopListening();
          this.off();
          return this;
        },
        triggerMethod: Marionette.triggerMethod,
        mergeOptions: Marionette.mergeOptions,
        getOption: Marionette.proxyGetOption
      });
      Marionette.Object = function(options) {
        this.options = _.extend({}, _.result(this, 'options'), options);
        this.initialize.apply(this, arguments);
      };
      Marionette.Object.extend = Marionette.extend;
      _.extend(Marionette.Object.prototype, Backbone.Events, {
        initialize: function() {},
        destroy: function(options) {
          options = options || {};
          this.triggerMethod('before:destroy', options);
          this.triggerMethod('destroy', options);
          this.stopListening();
          return this;
        },
        triggerMethod: Marionette.triggerMethod,
        mergeOptions: Marionette.mergeOptions,
        getOption: Marionette.proxyGetOption,
        bindEntityEvents: Marionette.proxyBindEntityEvents,
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });
      Marionette.Region = Marionette.Object.extend({
        constructor: function(options) {
          this.options = options || {};
          this.el = this.getOption('el');
          this.el = this.el instanceof Backbone.$ ? this.el[0] : this.el;
          if (!this.el) {
            throw new Marionette.Error({
              name: 'NoElError',
              message: 'An "el" must be specified for a region.'
            });
          }
          this.$el = this.getEl(this.el);
          Marionette.Object.call(this, options);
        },
        show: function(view, options) {
          if (!this._ensureElement()) {
            return;
          }
          this._ensureViewIsIntact(view);
          Marionette.MonitorDOMRefresh(view);
          var showOptions = options || {};
          var isDifferentView = view !== this.currentView;
          var preventDestroy = !!showOptions.preventDestroy;
          var forceShow = !!showOptions.forceShow;
          var isChangingView = !!this.currentView;
          var _shouldDestroyView = isDifferentView && !preventDestroy;
          var _shouldShowView = isDifferentView || forceShow;
          if (isChangingView) {
            this.triggerMethod('before:swapOut', this.currentView, this, options);
          }
          if (this.currentView && isDifferentView) {
            delete this.currentView._parent;
          }
          if (_shouldDestroyView) {
            this.empty();
          } else if (isChangingView && _shouldShowView) {
            this.currentView.off('destroy', this.empty, this);
          }
          if (_shouldShowView) {
            view.once('destroy', this.empty, this);
            view._parent = this;
            this._renderView(view);
            if (isChangingView) {
              this.triggerMethod('before:swap', view, this, options);
            }
            this.triggerMethod('before:show', view, this, options);
            Marionette.triggerMethodOn(view, 'before:show', view, this, options);
            if (isChangingView) {
              this.triggerMethod('swapOut', this.currentView, this, options);
            }
            var attachedRegion = Marionette.isNodeAttached(this.el);
            var displayedViews = [];
            var attachOptions = _.extend({
              triggerBeforeAttach: this.triggerBeforeAttach,
              triggerAttach: this.triggerAttach
            }, showOptions);
            if (attachedRegion && attachOptions.triggerBeforeAttach) {
              displayedViews = this._displayedViews(view);
              this._triggerAttach(displayedViews, 'before:');
            }
            this.attachHtml(view);
            this.currentView = view;
            if (attachedRegion && attachOptions.triggerAttach) {
              displayedViews = this._displayedViews(view);
              this._triggerAttach(displayedViews);
            }
            if (isChangingView) {
              this.triggerMethod('swap', view, this, options);
            }
            this.triggerMethod('show', view, this, options);
            Marionette.triggerMethodOn(view, 'show', view, this, options);
            return this;
          }
          return this;
        },
        triggerBeforeAttach: true,
        triggerAttach: true,
        _triggerAttach: function(views, prefix) {
          var eventName = (prefix || '') + 'attach';
          _.each(views, function(view) {
            Marionette.triggerMethodOn(view, eventName, view, this);
          }, this);
        },
        _displayedViews: function(view) {
          return _.union([view], _.result(view, '_getNestedViews') || []);
        },
        _renderView: function(view) {
          if (!view.supportsRenderLifecycle) {
            Marionette.triggerMethodOn(view, 'before:render', view);
          }
          view.render();
          if (!view.supportsRenderLifecycle) {
            Marionette.triggerMethodOn(view, 'render', view);
          }
        },
        _ensureElement: function() {
          if (!_.isObject(this.el)) {
            this.$el = this.getEl(this.el);
            this.el = this.$el[0];
          }
          if (!this.$el || this.$el.length === 0) {
            if (this.getOption('allowMissingEl')) {
              return false;
            } else {
              throw new Marionette.Error('An "el" ' + this.$el.selector + ' must exist in DOM');
            }
          }
          return true;
        },
        _ensureViewIsIntact: function(view) {
          if (!view) {
            throw new Marionette.Error({
              name: 'ViewNotValid',
              message: 'The view passed is undefined and therefore invalid. You must pass a view instance to show.'
            });
          }
          if (view.isDestroyed) {
            throw new Marionette.Error({
              name: 'ViewDestroyedError',
              message: 'View (cid: "' + view.cid + '") has already been destroyed and cannot be used.'
            });
          }
        },
        getEl: function(el) {
          return Backbone.$(el, Marionette._getValue(this.options.parentEl, this));
        },
        attachHtml: function(view) {
          this.$el.contents().detach();
          this.el.appendChild(view.el);
        },
        empty: function(options) {
          var view = this.currentView;
          var emptyOptions = options || {};
          var preventDestroy = !!emptyOptions.preventDestroy;
          if (!view) {
            return this;
          }
          view.off('destroy', this.empty, this);
          this.triggerMethod('before:empty', view);
          if (!preventDestroy) {
            this._destroyView();
          }
          this.triggerMethod('empty', view);
          delete this.currentView;
          if (preventDestroy) {
            this.$el.contents().detach();
          }
          return this;
        },
        _destroyView: function() {
          var view = this.currentView;
          if (view.isDestroyed) {
            return;
          }
          if (!view.supportsDestroyLifecycle) {
            Marionette.triggerMethodOn(view, 'before:destroy', view);
          }
          if (view.destroy) {
            view.destroy();
          } else {
            view.remove();
            view.isDestroyed = true;
          }
          if (!view.supportsDestroyLifecycle) {
            Marionette.triggerMethodOn(view, 'destroy', view);
          }
        },
        attachView: function(view) {
          if (this.currentView) {
            delete this.currentView._parent;
          }
          view._parent = this;
          this.currentView = view;
          return this;
        },
        hasView: function() {
          return !!this.currentView;
        },
        reset: function() {
          this.empty();
          if (this.$el) {
            this.el = this.$el.selector;
          }
          delete this.$el;
          return this;
        }
      }, {
        buildRegion: function(regionConfig, DefaultRegionClass) {
          if (_.isString(regionConfig)) {
            return this._buildRegionFromSelector(regionConfig, DefaultRegionClass);
          }
          if (regionConfig.selector || regionConfig.el || regionConfig.regionClass) {
            return this._buildRegionFromObject(regionConfig, DefaultRegionClass);
          }
          if (_.isFunction(regionConfig)) {
            return this._buildRegionFromRegionClass(regionConfig);
          }
          throw new Marionette.Error({
            message: 'Improper region configuration type.',
            url: 'marionette.region.html#region-configuration-types'
          });
        },
        _buildRegionFromSelector: function(selector, DefaultRegionClass) {
          return new DefaultRegionClass({el: selector});
        },
        _buildRegionFromObject: function(regionConfig, DefaultRegionClass) {
          var RegionClass = regionConfig.regionClass || DefaultRegionClass;
          var options = _.omit(regionConfig, 'selector', 'regionClass');
          if (regionConfig.selector && !options.el) {
            options.el = regionConfig.selector;
          }
          return new RegionClass(options);
        },
        _buildRegionFromRegionClass: function(RegionClass) {
          return new RegionClass();
        }
      });
      Marionette.RegionManager = Marionette.Controller.extend({
        constructor: function(options) {
          this._regions = {};
          this.length = 0;
          Marionette.Controller.call(this, options);
          this.addRegions(this.getOption('regions'));
        },
        addRegions: function(regionDefinitions, defaults) {
          regionDefinitions = Marionette._getValue(regionDefinitions, this, arguments);
          return _.reduce(regionDefinitions, function(regions, definition, name) {
            if (_.isString(definition)) {
              definition = {selector: definition};
            }
            if (definition.selector) {
              definition = _.defaults({}, definition, defaults);
            }
            regions[name] = this.addRegion(name, definition);
            return regions;
          }, {}, this);
        },
        addRegion: function(name, definition) {
          var region;
          if (definition instanceof Marionette.Region) {
            region = definition;
          } else {
            region = Marionette.Region.buildRegion(definition, Marionette.Region);
          }
          this.triggerMethod('before:add:region', name, region);
          region._parent = this;
          this._store(name, region);
          this.triggerMethod('add:region', name, region);
          return region;
        },
        get: function(name) {
          return this._regions[name];
        },
        getRegions: function() {
          return _.clone(this._regions);
        },
        removeRegion: function(name) {
          var region = this._regions[name];
          this._remove(name, region);
          return region;
        },
        removeRegions: function() {
          var regions = this.getRegions();
          _.each(this._regions, function(region, name) {
            this._remove(name, region);
          }, this);
          return regions;
        },
        emptyRegions: function() {
          var regions = this.getRegions();
          _.invoke(regions, 'empty');
          return regions;
        },
        destroy: function() {
          this.removeRegions();
          return Marionette.Controller.prototype.destroy.apply(this, arguments);
        },
        _store: function(name, region) {
          if (!this._regions[name]) {
            this.length++;
          }
          this._regions[name] = region;
        },
        _remove: function(name, region) {
          this.triggerMethod('before:remove:region', name, region);
          region.empty();
          region.stopListening();
          delete region._parent;
          delete this._regions[name];
          this.length--;
          this.triggerMethod('remove:region', name, region);
        }
      });
      Marionette.actAsCollection(Marionette.RegionManager.prototype, '_regions');
      Marionette.TemplateCache = function(templateId) {
        this.templateId = templateId;
      };
      _.extend(Marionette.TemplateCache, {
        templateCaches: {},
        get: function(templateId, options) {
          var cachedTemplate = this.templateCaches[templateId];
          if (!cachedTemplate) {
            cachedTemplate = new Marionette.TemplateCache(templateId);
            this.templateCaches[templateId] = cachedTemplate;
          }
          return cachedTemplate.load(options);
        },
        clear: function() {
          var i;
          var args = _.toArray(arguments);
          var length = args.length;
          if (length > 0) {
            for (i = 0; i < length; i++) {
              delete this.templateCaches[args[i]];
            }
          } else {
            this.templateCaches = {};
          }
        }
      });
      _.extend(Marionette.TemplateCache.prototype, {
        load: function(options) {
          if (this.compiledTemplate) {
            return this.compiledTemplate;
          }
          var template = this.loadTemplate(this.templateId, options);
          this.compiledTemplate = this.compileTemplate(template, options);
          return this.compiledTemplate;
        },
        loadTemplate: function(templateId, options) {
          var $template = Backbone.$(templateId);
          if (!$template.length) {
            throw new Marionette.Error({
              name: 'NoTemplateError',
              message: 'Could not find template: "' + templateId + '"'
            });
          }
          return $template.html();
        },
        compileTemplate: function(rawTemplate, options) {
          return _.template(rawTemplate, options);
        }
      });
      Marionette.Renderer = {render: function(template, data) {
          if (!template) {
            throw new Marionette.Error({
              name: 'TemplateNotFoundError',
              message: 'Cannot render the template since its false, null or undefined.'
            });
          }
          var templateFunc = _.isFunction(template) ? template : Marionette.TemplateCache.get(template);
          return templateFunc(data);
        }};
      Marionette.View = Backbone.View.extend({
        isDestroyed: false,
        supportsRenderLifecycle: true,
        supportsDestroyLifecycle: true,
        constructor: function(options) {
          this.render = _.bind(this.render, this);
          options = Marionette._getValue(options, this);
          this.options = _.extend({}, _.result(this, 'options'), options);
          this._behaviors = Marionette.Behaviors(this);
          Backbone.View.call(this, this.options);
          Marionette.MonitorDOMRefresh(this);
        },
        getTemplate: function() {
          return this.getOption('template');
        },
        serializeModel: function(model) {
          return model.toJSON.apply(model, _.rest(arguments));
        },
        mixinTemplateHelpers: function(target) {
          target = target || {};
          var templateHelpers = this.getOption('templateHelpers');
          templateHelpers = Marionette._getValue(templateHelpers, this);
          return _.extend(target, templateHelpers);
        },
        normalizeUIKeys: function(hash) {
          var uiBindings = _.result(this, '_uiBindings');
          return Marionette.normalizeUIKeys(hash, uiBindings || _.result(this, 'ui'));
        },
        normalizeUIValues: function(hash, properties) {
          var ui = _.result(this, 'ui');
          var uiBindings = _.result(this, '_uiBindings');
          return Marionette.normalizeUIValues(hash, uiBindings || ui, properties);
        },
        configureTriggers: function() {
          if (!this.triggers) {
            return;
          }
          var triggers = this.normalizeUIKeys(_.result(this, 'triggers'));
          return _.reduce(triggers, function(events, value, key) {
            events[key] = this._buildViewTrigger(value);
            return events;
          }, {}, this);
        },
        delegateEvents: function(events) {
          this._delegateDOMEvents(events);
          this.bindEntityEvents(this.model, this.getOption('modelEvents'));
          this.bindEntityEvents(this.collection, this.getOption('collectionEvents'));
          _.each(this._behaviors, function(behavior) {
            behavior.bindEntityEvents(this.model, behavior.getOption('modelEvents'));
            behavior.bindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
          }, this);
          return this;
        },
        _delegateDOMEvents: function(eventsArg) {
          var events = Marionette._getValue(eventsArg || this.events, this);
          events = this.normalizeUIKeys(events);
          if (_.isUndefined(eventsArg)) {
            this.events = events;
          }
          var combinedEvents = {};
          var behaviorEvents = _.result(this, 'behaviorEvents') || {};
          var triggers = this.configureTriggers();
          var behaviorTriggers = _.result(this, 'behaviorTriggers') || {};
          _.extend(combinedEvents, behaviorEvents, events, triggers, behaviorTriggers);
          Backbone.View.prototype.delegateEvents.call(this, combinedEvents);
        },
        undelegateEvents: function() {
          Backbone.View.prototype.undelegateEvents.apply(this, arguments);
          this.unbindEntityEvents(this.model, this.getOption('modelEvents'));
          this.unbindEntityEvents(this.collection, this.getOption('collectionEvents'));
          _.each(this._behaviors, function(behavior) {
            behavior.unbindEntityEvents(this.model, behavior.getOption('modelEvents'));
            behavior.unbindEntityEvents(this.collection, behavior.getOption('collectionEvents'));
          }, this);
          return this;
        },
        _ensureViewIsIntact: function() {
          if (this.isDestroyed) {
            throw new Marionette.Error({
              name: 'ViewDestroyedError',
              message: 'View (cid: "' + this.cid + '") has already been destroyed and cannot be used.'
            });
          }
        },
        destroy: function() {
          if (this.isDestroyed) {
            return this;
          }
          var args = _.toArray(arguments);
          this.triggerMethod.apply(this, ['before:destroy'].concat(args));
          this.isDestroyed = true;
          this.triggerMethod.apply(this, ['destroy'].concat(args));
          this.unbindUIElements();
          this.isRendered = false;
          this.remove();
          _.invoke(this._behaviors, 'destroy', args);
          return this;
        },
        bindUIElements: function() {
          this._bindUIElements();
          _.invoke(this._behaviors, this._bindUIElements);
        },
        _bindUIElements: function() {
          if (!this.ui) {
            return;
          }
          if (!this._uiBindings) {
            this._uiBindings = this.ui;
          }
          var bindings = _.result(this, '_uiBindings');
          this.ui = {};
          _.each(bindings, function(selector, key) {
            this.ui[key] = this.$(selector);
          }, this);
        },
        unbindUIElements: function() {
          this._unbindUIElements();
          _.invoke(this._behaviors, this._unbindUIElements);
        },
        _unbindUIElements: function() {
          if (!this.ui || !this._uiBindings) {
            return;
          }
          _.each(this.ui, function($el, name) {
            delete this.ui[name];
          }, this);
          this.ui = this._uiBindings;
          delete this._uiBindings;
        },
        _buildViewTrigger: function(triggerDef) {
          var options = _.defaults({}, triggerDef, {
            preventDefault: true,
            stopPropagation: true
          });
          var eventName = _.isObject(triggerDef) ? options.event : triggerDef;
          return function(e) {
            if (e) {
              if (e.preventDefault && options.preventDefault) {
                e.preventDefault();
              }
              if (e.stopPropagation && options.stopPropagation) {
                e.stopPropagation();
              }
            }
            var args = {
              view: this,
              model: this.model,
              collection: this.collection
            };
            this.triggerMethod(eventName, args);
          };
        },
        setElement: function() {
          var ret = Backbone.View.prototype.setElement.apply(this, arguments);
          _.invoke(this._behaviors, 'proxyViewProperties', this);
          return ret;
        },
        triggerMethod: function() {
          var ret = Marionette._triggerMethod(this, arguments);
          this._triggerEventOnBehaviors(arguments);
          this._triggerEventOnParentLayout(arguments[0], _.rest(arguments));
          return ret;
        },
        _triggerEventOnBehaviors: function(args) {
          var triggerMethod = Marionette._triggerMethod;
          var behaviors = this._behaviors;
          for (var i = 0,
              length = behaviors && behaviors.length; i < length; i++) {
            triggerMethod(behaviors[i], args);
          }
        },
        _triggerEventOnParentLayout: function(eventName, args) {
          var layoutView = this._parentLayoutView();
          if (!layoutView) {
            return;
          }
          var eventPrefix = Marionette.getOption(layoutView, 'childViewEventPrefix');
          var prefixedEventName = eventPrefix + ':' + eventName;
          var callArgs = [this].concat(args);
          Marionette._triggerMethod(layoutView, prefixedEventName, callArgs);
          var childEvents = Marionette.getOption(layoutView, 'childEvents');
          childEvents = Marionette._getValue(childEvents, layoutView);
          var normalizedChildEvents = layoutView.normalizeMethods(childEvents);
          if (normalizedChildEvents && _.isFunction(normalizedChildEvents[eventName])) {
            normalizedChildEvents[eventName].apply(layoutView, callArgs);
          }
        },
        _getImmediateChildren: function() {
          return [];
        },
        _getNestedViews: function() {
          var children = this._getImmediateChildren();
          if (!children.length) {
            return children;
          }
          return _.reduce(children, function(memo, view) {
            if (!view._getNestedViews) {
              return memo;
            }
            return memo.concat(view._getNestedViews());
          }, children);
        },
        _parentLayoutView: function() {
          var parent = this._parent;
          while (parent) {
            if (parent instanceof Marionette.LayoutView) {
              return parent;
            }
            parent = parent._parent;
          }
        },
        normalizeMethods: Marionette.normalizeMethods,
        mergeOptions: Marionette.mergeOptions,
        getOption: Marionette.proxyGetOption,
        bindEntityEvents: Marionette.proxyBindEntityEvents,
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });
      Marionette.ItemView = Marionette.View.extend({
        constructor: function() {
          Marionette.View.apply(this, arguments);
        },
        serializeData: function() {
          if (!this.model && !this.collection) {
            return {};
          }
          var args = [this.model || this.collection];
          if (arguments.length) {
            args.push.apply(args, arguments);
          }
          if (this.model) {
            return this.serializeModel.apply(this, args);
          } else {
            return {items: this.serializeCollection.apply(this, args)};
          }
        },
        serializeCollection: function(collection) {
          return collection.toJSON.apply(collection, _.rest(arguments));
        },
        render: function() {
          this._ensureViewIsIntact();
          this.triggerMethod('before:render', this);
          this._renderTemplate();
          this.isRendered = true;
          this.bindUIElements();
          this.triggerMethod('render', this);
          return this;
        },
        _renderTemplate: function() {
          var template = this.getTemplate();
          if (template === false) {
            return;
          }
          if (!template) {
            throw new Marionette.Error({
              name: 'UndefinedTemplateError',
              message: 'Cannot render the template since it is null or undefined.'
            });
          }
          var data = this.mixinTemplateHelpers(this.serializeData());
          var html = Marionette.Renderer.render(template, data, this);
          this.attachElContent(html);
          return this;
        },
        attachElContent: function(html) {
          this.$el.html(html);
          return this;
        }
      });
      Marionette.CollectionView = Marionette.View.extend({
        childViewEventPrefix: 'childview',
        sort: true,
        constructor: function(options) {
          this.once('render', this._initialEvents);
          this._initChildViewStorage();
          Marionette.View.apply(this, arguments);
          this.on({
            'before:show': this._onBeforeShowCalled,
            'show': this._onShowCalled,
            'before:attach': this._onBeforeAttachCalled,
            'attach': this._onAttachCalled
          });
          this.initRenderBuffer();
        },
        initRenderBuffer: function() {
          this._bufferedChildren = [];
        },
        startBuffering: function() {
          this.initRenderBuffer();
          this.isBuffering = true;
        },
        endBuffering: function() {
          var canTriggerAttach = this._isShown && Marionette.isNodeAttached(this.el);
          var nestedViews;
          this.isBuffering = false;
          if (this._isShown) {
            this._triggerMethodMany(this._bufferedChildren, this, 'before:show');
          }
          if (canTriggerAttach && this._triggerBeforeAttach) {
            nestedViews = this._getNestedViews();
            this._triggerMethodMany(nestedViews, this, 'before:attach');
          }
          this.attachBuffer(this, this._createBuffer());
          if (canTriggerAttach && this._triggerAttach) {
            nestedViews = this._getNestedViews();
            this._triggerMethodMany(nestedViews, this, 'attach');
          }
          if (this._isShown) {
            this._triggerMethodMany(this._bufferedChildren, this, 'show');
          }
          this.initRenderBuffer();
        },
        _triggerMethodMany: function(targets, source, eventName) {
          var args = _.drop(arguments, 3);
          _.each(targets, function(target) {
            Marionette.triggerMethodOn.apply(target, [target, eventName, target, source].concat(args));
          });
        },
        _initialEvents: function() {
          if (this.collection) {
            this.listenTo(this.collection, 'add', this._onCollectionAdd);
            this.listenTo(this.collection, 'remove', this._onCollectionRemove);
            this.listenTo(this.collection, 'reset', this.render);
            if (this.getOption('sort')) {
              this.listenTo(this.collection, 'sort', this._sortViews);
            }
          }
        },
        _onCollectionAdd: function(child, collection, opts) {
          var index = opts.at !== undefined && (opts.index || collection.indexOf(child));
          if (this.getOption('filter') || index === false) {
            index = _.indexOf(this._filteredSortedModels(index), child);
          }
          if (this._shouldAddChild(child, index)) {
            this.destroyEmptyView();
            var ChildView = this.getChildView(child);
            this.addChild(child, ChildView, index);
          }
        },
        _onCollectionRemove: function(model) {
          var view = this.children.findByModel(model);
          this.removeChildView(view);
          this.checkEmpty();
        },
        _onBeforeShowCalled: function() {
          this._triggerBeforeAttach = this._triggerAttach = false;
          this.children.each(function(childView) {
            Marionette.triggerMethodOn(childView, 'before:show', childView);
          });
        },
        _onShowCalled: function() {
          this.children.each(function(childView) {
            Marionette.triggerMethodOn(childView, 'show', childView);
          });
        },
        _onBeforeAttachCalled: function() {
          this._triggerBeforeAttach = true;
        },
        _onAttachCalled: function() {
          this._triggerAttach = true;
        },
        render: function() {
          this._ensureViewIsIntact();
          this.triggerMethod('before:render', this);
          this._renderChildren();
          this.isRendered = true;
          this.triggerMethod('render', this);
          return this;
        },
        reorder: function() {
          var children = this.children;
          var models = this._filteredSortedModels();
          var anyModelsAdded = _.some(models, function(model) {
            return !children.findByModel(model);
          });
          if (anyModelsAdded) {
            this.render();
          } else {
            var elsToReorder = _.map(models, function(model, index) {
              var view = children.findByModel(model);
              view._index = index;
              return view.el;
            });
            var filteredOutViews = children.filter(function(view) {
              return !_.contains(elsToReorder, view.el);
            });
            this.triggerMethod('before:reorder');
            this._appendReorderedChildren(elsToReorder);
            _.each(filteredOutViews, this.removeChildView, this);
            this.checkEmpty();
            this.triggerMethod('reorder');
          }
        },
        resortView: function() {
          if (Marionette.getOption(this, 'reorderOnSort')) {
            this.reorder();
          } else {
            this.render();
          }
        },
        _sortViews: function() {
          var models = this._filteredSortedModels();
          var orderChanged = _.find(models, function(item, index) {
            var view = this.children.findByModel(item);
            return !view || view._index !== index;
          }, this);
          if (orderChanged) {
            this.resortView();
          }
        },
        _emptyViewIndex: -1,
        _appendReorderedChildren: function(children) {
          this.$el.append(children);
        },
        _renderChildren: function() {
          this.destroyEmptyView();
          this.destroyChildren({checkEmpty: false});
          if (this.isEmpty(this.collection)) {
            this.showEmptyView();
          } else {
            this.triggerMethod('before:render:collection', this);
            this.startBuffering();
            this.showCollection();
            this.endBuffering();
            this.triggerMethod('render:collection', this);
            if (this.children.isEmpty() && this.getOption('filter')) {
              this.showEmptyView();
            }
          }
        },
        showCollection: function() {
          var ChildView;
          var models = this._filteredSortedModels();
          _.each(models, function(child, index) {
            ChildView = this.getChildView(child);
            this.addChild(child, ChildView, index);
          }, this);
        },
        _filteredSortedModels: function(addedAt) {
          var viewComparator = this.getViewComparator();
          var models = this.collection.models;
          addedAt = Math.min(Math.max(addedAt, 0), models.length - 1);
          if (viewComparator) {
            var addedModel;
            if (addedAt) {
              addedModel = models[addedAt];
              models = models.slice(0, addedAt).concat(models.slice(addedAt + 1));
            }
            models = this._sortModelsBy(models, viewComparator);
            if (addedModel) {
              models.splice(addedAt, 0, addedModel);
            }
          }
          if (this.getOption('filter')) {
            models = _.filter(models, function(model, index) {
              return this._shouldAddChild(model, index);
            }, this);
          }
          return models;
        },
        _sortModelsBy: function(models, comparator) {
          if (typeof comparator === 'string') {
            return _.sortBy(models, function(model) {
              return model.get(comparator);
            }, this);
          } else if (comparator.length === 1) {
            return _.sortBy(models, comparator, this);
          } else {
            return models.sort(_.bind(comparator, this));
          }
        },
        showEmptyView: function() {
          var EmptyView = this.getEmptyView();
          if (EmptyView && !this._showingEmptyView) {
            this.triggerMethod('before:render:empty');
            this._showingEmptyView = true;
            var model = new Backbone.Model();
            this.addEmptyView(model, EmptyView);
            this.triggerMethod('render:empty');
          }
        },
        destroyEmptyView: function() {
          if (this._showingEmptyView) {
            this.triggerMethod('before:remove:empty');
            this.destroyChildren();
            delete this._showingEmptyView;
            this.triggerMethod('remove:empty');
          }
        },
        getEmptyView: function() {
          return this.getOption('emptyView');
        },
        addEmptyView: function(child, EmptyView) {
          var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
          var nestedViews;
          var emptyViewOptions = this.getOption('emptyViewOptions') || this.getOption('childViewOptions');
          if (_.isFunction(emptyViewOptions)) {
            emptyViewOptions = emptyViewOptions.call(this, child, this._emptyViewIndex);
          }
          var view = this.buildChildView(child, EmptyView, emptyViewOptions);
          view._parent = this;
          this.proxyChildEvents(view);
          view.once('render', function() {
            if (this._isShown) {
              Marionette.triggerMethodOn(view, 'before:show', view);
            }
            if (canTriggerAttach && this._triggerBeforeAttach) {
              nestedViews = this._getViewAndNested(view);
              this._triggerMethodMany(nestedViews, this, 'before:attach');
            }
          }, this);
          this.children.add(view);
          this.renderChildView(view, this._emptyViewIndex);
          if (canTriggerAttach && this._triggerAttach) {
            nestedViews = this._getViewAndNested(view);
            this._triggerMethodMany(nestedViews, this, 'attach');
          }
          if (this._isShown) {
            Marionette.triggerMethodOn(view, 'show', view);
          }
        },
        getChildView: function(child) {
          var childView = this.getOption('childView');
          if (!childView) {
            throw new Marionette.Error({
              name: 'NoChildViewError',
              message: 'A "childView" must be specified'
            });
          }
          return childView;
        },
        addChild: function(child, ChildView, index) {
          var childViewOptions = this.getOption('childViewOptions');
          childViewOptions = Marionette._getValue(childViewOptions, this, [child, index]);
          var view = this.buildChildView(child, ChildView, childViewOptions);
          this._updateIndices(view, true, index);
          this.triggerMethod('before:add:child', view);
          this._addChildView(view, index);
          this.triggerMethod('add:child', view);
          view._parent = this;
          return view;
        },
        _updateIndices: function(view, increment, index) {
          if (!this.getOption('sort')) {
            return;
          }
          if (increment) {
            view._index = index;
          }
          this.children.each(function(laterView) {
            if (laterView._index >= view._index) {
              laterView._index += increment ? 1 : -1;
            }
          });
        },
        _addChildView: function(view, index) {
          var canTriggerAttach = this._isShown && !this.isBuffering && Marionette.isNodeAttached(this.el);
          var nestedViews;
          this.proxyChildEvents(view);
          view.once('render', function() {
            if (this._isShown && !this.isBuffering) {
              Marionette.triggerMethodOn(view, 'before:show', view);
            }
            if (canTriggerAttach && this._triggerBeforeAttach) {
              nestedViews = this._getViewAndNested(view);
              this._triggerMethodMany(nestedViews, this, 'before:attach');
            }
          }, this);
          this.children.add(view);
          this.renderChildView(view, index);
          if (canTriggerAttach && this._triggerAttach) {
            nestedViews = this._getViewAndNested(view);
            this._triggerMethodMany(nestedViews, this, 'attach');
          }
          if (this._isShown && !this.isBuffering) {
            Marionette.triggerMethodOn(view, 'show', view);
          }
        },
        renderChildView: function(view, index) {
          if (!view.supportsRenderLifecycle) {
            Marionette.triggerMethodOn(view, 'before:render', view);
          }
          view.render();
          if (!view.supportsRenderLifecycle) {
            Marionette.triggerMethodOn(view, 'render', view);
          }
          this.attachHtml(this, view, index);
          return view;
        },
        buildChildView: function(child, ChildViewClass, childViewOptions) {
          var options = _.extend({model: child}, childViewOptions);
          var childView = new ChildViewClass(options);
          Marionette.MonitorDOMRefresh(childView);
          return childView;
        },
        removeChildView: function(view) {
          if (!view) {
            return view;
          }
          this.triggerMethod('before:remove:child', view);
          if (!view.supportsDestroyLifecycle) {
            Marionette.triggerMethodOn(view, 'before:destroy', view);
          }
          if (view.destroy) {
            view.destroy();
          } else {
            view.remove();
          }
          if (!view.supportsDestroyLifecycle) {
            Marionette.triggerMethodOn(view, 'destroy', view);
          }
          delete view._parent;
          this.stopListening(view);
          this.children.remove(view);
          this.triggerMethod('remove:child', view);
          this._updateIndices(view, false);
          return view;
        },
        isEmpty: function() {
          return !this.collection || this.collection.length === 0;
        },
        checkEmpty: function() {
          if (this.isEmpty(this.collection)) {
            this.showEmptyView();
          }
        },
        attachBuffer: function(collectionView, buffer) {
          collectionView.$el.append(buffer);
        },
        _createBuffer: function() {
          var elBuffer = document.createDocumentFragment();
          _.each(this._bufferedChildren, function(b) {
            elBuffer.appendChild(b.el);
          });
          return elBuffer;
        },
        attachHtml: function(collectionView, childView, index) {
          if (collectionView.isBuffering) {
            collectionView._bufferedChildren.splice(index, 0, childView);
          } else {
            if (!collectionView._insertBefore(childView, index)) {
              collectionView._insertAfter(childView);
            }
          }
        },
        _insertBefore: function(childView, index) {
          var currentView;
          var findPosition = this.getOption('sort') && (index < this.children.length - 1);
          if (findPosition) {
            currentView = this.children.find(function(view) {
              return view._index === index + 1;
            });
          }
          if (currentView) {
            currentView.$el.before(childView.el);
            return true;
          }
          return false;
        },
        _insertAfter: function(childView) {
          this.$el.append(childView.el);
        },
        _initChildViewStorage: function() {
          this.children = new Backbone.ChildViewContainer();
        },
        destroy: function() {
          if (this.isDestroyed) {
            return this;
          }
          this.triggerMethod('before:destroy:collection');
          this.destroyChildren({checkEmpty: false});
          this.triggerMethod('destroy:collection');
          return Marionette.View.prototype.destroy.apply(this, arguments);
        },
        destroyChildren: function(options) {
          var destroyOptions = options || {};
          var shouldCheckEmpty = true;
          var childViews = this.children.map(_.identity);
          if (!_.isUndefined(destroyOptions.checkEmpty)) {
            shouldCheckEmpty = destroyOptions.checkEmpty;
          }
          this.children.each(this.removeChildView, this);
          if (shouldCheckEmpty) {
            this.checkEmpty();
          }
          return childViews;
        },
        _shouldAddChild: function(child, index) {
          var filter = this.getOption('filter');
          return !_.isFunction(filter) || filter.call(this, child, index, this.collection);
        },
        proxyChildEvents: function(view) {
          var prefix = this.getOption('childViewEventPrefix');
          this.listenTo(view, 'all', function() {
            var args = _.toArray(arguments);
            var rootEvent = args[0];
            var childEvents = this.normalizeMethods(_.result(this, 'childEvents'));
            args[0] = prefix + ':' + rootEvent;
            args.splice(1, 0, view);
            if (typeof childEvents !== 'undefined' && _.isFunction(childEvents[rootEvent])) {
              childEvents[rootEvent].apply(this, args.slice(1));
            }
            this.triggerMethod.apply(this, args);
          });
        },
        _getImmediateChildren: function() {
          return _.values(this.children._views);
        },
        _getViewAndNested: function(view) {
          return [view].concat(_.result(view, '_getNestedViews') || []);
        },
        getViewComparator: function() {
          return this.getOption('viewComparator');
        }
      });
      Marionette.CompositeView = Marionette.CollectionView.extend({
        constructor: function() {
          Marionette.CollectionView.apply(this, arguments);
        },
        _initialEvents: function() {
          if (this.collection) {
            this.listenTo(this.collection, 'add', this._onCollectionAdd);
            this.listenTo(this.collection, 'remove', this._onCollectionRemove);
            this.listenTo(this.collection, 'reset', this._renderChildren);
            if (this.getOption('sort')) {
              this.listenTo(this.collection, 'sort', this._sortViews);
            }
          }
        },
        getChildView: function(child) {
          var childView = this.getOption('childView') || this.constructor;
          return childView;
        },
        serializeData: function() {
          var data = {};
          if (this.model) {
            data = _.partial(this.serializeModel, this.model).apply(this, arguments);
          }
          return data;
        },
        render: function() {
          this._ensureViewIsIntact();
          this._isRendering = true;
          this.resetChildViewContainer();
          this.triggerMethod('before:render', this);
          this._renderTemplate();
          this._renderChildren();
          this._isRendering = false;
          this.isRendered = true;
          this.triggerMethod('render', this);
          return this;
        },
        _renderChildren: function() {
          if (this.isRendered || this._isRendering) {
            Marionette.CollectionView.prototype._renderChildren.call(this);
          }
        },
        _renderTemplate: function() {
          var data = {};
          data = this.serializeData();
          data = this.mixinTemplateHelpers(data);
          this.triggerMethod('before:render:template');
          var template = this.getTemplate();
          var html = Marionette.Renderer.render(template, data, this);
          this.attachElContent(html);
          this.bindUIElements();
          this.triggerMethod('render:template');
        },
        attachElContent: function(html) {
          this.$el.html(html);
          return this;
        },
        attachBuffer: function(compositeView, buffer) {
          var $container = this.getChildViewContainer(compositeView);
          $container.append(buffer);
        },
        _insertAfter: function(childView) {
          var $container = this.getChildViewContainer(this, childView);
          $container.append(childView.el);
        },
        _appendReorderedChildren: function(children) {
          var $container = this.getChildViewContainer(this);
          $container.append(children);
        },
        getChildViewContainer: function(containerView, childView) {
          if (!!containerView.$childViewContainer) {
            return containerView.$childViewContainer;
          }
          var container;
          var childViewContainer = Marionette.getOption(containerView, 'childViewContainer');
          if (childViewContainer) {
            var selector = Marionette._getValue(childViewContainer, containerView);
            if (selector.charAt(0) === '@' && containerView.ui) {
              container = containerView.ui[selector.substr(4)];
            } else {
              container = containerView.$(selector);
            }
            if (container.length <= 0) {
              throw new Marionette.Error({
                name: 'ChildViewContainerMissingError',
                message: 'The specified "childViewContainer" was not found: ' + containerView.childViewContainer
              });
            }
          } else {
            container = containerView.$el;
          }
          containerView.$childViewContainer = container;
          return container;
        },
        resetChildViewContainer: function() {
          if (this.$childViewContainer) {
            this.$childViewContainer = undefined;
          }
        }
      });
      Marionette.LayoutView = Marionette.ItemView.extend({
        regionClass: Marionette.Region,
        options: {destroyImmediate: false},
        childViewEventPrefix: 'childview',
        constructor: function(options) {
          options = options || {};
          this._firstRender = true;
          this._initializeRegions(options);
          Marionette.ItemView.call(this, options);
        },
        render: function() {
          this._ensureViewIsIntact();
          if (this._firstRender) {
            this._firstRender = false;
          } else {
            this._reInitializeRegions();
          }
          return Marionette.ItemView.prototype.render.apply(this, arguments);
        },
        destroy: function() {
          if (this.isDestroyed) {
            return this;
          }
          if (this.getOption('destroyImmediate') === true) {
            this.$el.remove();
          }
          this.regionManager.destroy();
          return Marionette.ItemView.prototype.destroy.apply(this, arguments);
        },
        showChildView: function(regionName, view, options) {
          var region = this.getRegion(regionName);
          return region.show.apply(region, _.rest(arguments));
        },
        getChildView: function(regionName) {
          return this.getRegion(regionName).currentView;
        },
        addRegion: function(name, definition) {
          var regions = {};
          regions[name] = definition;
          return this._buildRegions(regions)[name];
        },
        addRegions: function(regions) {
          this.regions = _.extend({}, this.regions, regions);
          return this._buildRegions(regions);
        },
        removeRegion: function(name) {
          delete this.regions[name];
          return this.regionManager.removeRegion(name);
        },
        getRegion: function(region) {
          return this.regionManager.get(region);
        },
        getRegions: function() {
          return this.regionManager.getRegions();
        },
        _buildRegions: function(regions) {
          var defaults = {
            regionClass: this.getOption('regionClass'),
            parentEl: _.partial(_.result, this, 'el')
          };
          return this.regionManager.addRegions(regions, defaults);
        },
        _initializeRegions: function(options) {
          var regions;
          this._initRegionManager();
          regions = Marionette._getValue(this.regions, this, [options]) || {};
          var regionOptions = this.getOption.call(options, 'regions');
          regionOptions = Marionette._getValue(regionOptions, this, [options]);
          _.extend(regions, regionOptions);
          regions = this.normalizeUIValues(regions, ['selector', 'el']);
          this.addRegions(regions);
        },
        _reInitializeRegions: function() {
          this.regionManager.invoke('reset');
        },
        getRegionManager: function() {
          return new Marionette.RegionManager();
        },
        _initRegionManager: function() {
          this.regionManager = this.getRegionManager();
          this.regionManager._parent = this;
          this.listenTo(this.regionManager, 'before:add:region', function(name) {
            this.triggerMethod('before:add:region', name);
          });
          this.listenTo(this.regionManager, 'add:region', function(name, region) {
            this[name] = region;
            this.triggerMethod('add:region', name, region);
          });
          this.listenTo(this.regionManager, 'before:remove:region', function(name) {
            this.triggerMethod('before:remove:region', name);
          });
          this.listenTo(this.regionManager, 'remove:region', function(name, region) {
            delete this[name];
            this.triggerMethod('remove:region', name, region);
          });
        },
        _getImmediateChildren: function() {
          return _.chain(this.regionManager.getRegions()).pluck('currentView').compact().value();
        }
      });
      Marionette.Behavior = Marionette.Object.extend({
        constructor: function(options, view) {
          this.view = view;
          this.defaults = _.result(this, 'defaults') || {};
          this.options = _.extend({}, this.defaults, options);
          this.ui = _.extend({}, _.result(view, 'ui'), _.result(this, 'ui'));
          Marionette.Object.apply(this, arguments);
        },
        $: function() {
          return this.view.$.apply(this.view, arguments);
        },
        destroy: function() {
          this.stopListening();
          return this;
        },
        proxyViewProperties: function(view) {
          this.$el = view.$el;
          this.el = view.el;
        }
      });
      Marionette.Behaviors = (function(Marionette, _) {
        var delegateEventSplitter = /^(\S+)\s*(.*)$/;
        function Behaviors(view, behaviors) {
          if (!_.isObject(view.behaviors)) {
            return {};
          }
          behaviors = Behaviors.parseBehaviors(view, behaviors || _.result(view, 'behaviors'));
          Behaviors.wrap(view, behaviors, _.keys(methods));
          return behaviors;
        }
        var methods = {
          behaviorTriggers: function(behaviorTriggers, behaviors) {
            var triggerBuilder = new BehaviorTriggersBuilder(this, behaviors);
            return triggerBuilder.buildBehaviorTriggers();
          },
          behaviorEvents: function(behaviorEvents, behaviors) {
            var _behaviorsEvents = {};
            _.each(behaviors, function(b, i) {
              var _events = {};
              var behaviorEvents = _.clone(_.result(b, 'events')) || {};
              behaviorEvents = Marionette.normalizeUIKeys(behaviorEvents, getBehaviorsUI(b));
              var j = 0;
              _.each(behaviorEvents, function(behaviour, key) {
                var match = key.match(delegateEventSplitter);
                var eventName = match[1] + '.' + [this.cid, i, j++, ' '].join('');
                var selector = match[2];
                var eventKey = eventName + selector;
                var handler = _.isFunction(behaviour) ? behaviour : b[behaviour];
                if (!handler) {
                  return;
                }
                _events[eventKey] = _.bind(handler, b);
              }, this);
              _behaviorsEvents = _.extend(_behaviorsEvents, _events);
            }, this);
            return _behaviorsEvents;
          }
        };
        _.extend(Behaviors, {
          behaviorsLookup: function() {
            throw new Marionette.Error({
              message: 'You must define where your behaviors are stored.',
              url: 'marionette.behaviors.html#behaviorslookup'
            });
          },
          getBehaviorClass: function(options, key) {
            if (options.behaviorClass) {
              return options.behaviorClass;
            }
            return Marionette._getValue(Behaviors.behaviorsLookup, this, [options, key])[key];
          },
          parseBehaviors: function(view, behaviors) {
            return _.chain(behaviors).map(function(options, key) {
              var BehaviorClass = Behaviors.getBehaviorClass(options, key);
              var behavior = new BehaviorClass(options, view);
              var nestedBehaviors = Behaviors.parseBehaviors(view, _.result(behavior, 'behaviors'));
              return [behavior].concat(nestedBehaviors);
            }).flatten().value();
          },
          wrap: function(view, behaviors, methodNames) {
            _.each(methodNames, function(methodName) {
              view[methodName] = _.partial(methods[methodName], view[methodName], behaviors);
            });
          }
        });
        function BehaviorTriggersBuilder(view, behaviors) {
          this._view = view;
          this._behaviors = behaviors;
          this._triggers = {};
        }
        _.extend(BehaviorTriggersBuilder.prototype, {
          buildBehaviorTriggers: function() {
            _.each(this._behaviors, this._buildTriggerHandlersForBehavior, this);
            return this._triggers;
          },
          _buildTriggerHandlersForBehavior: function(behavior, i) {
            var triggersHash = _.clone(_.result(behavior, 'triggers')) || {};
            triggersHash = Marionette.normalizeUIKeys(triggersHash, getBehaviorsUI(behavior));
            _.each(triggersHash, _.bind(this._setHandlerForBehavior, this, behavior, i));
          },
          _setHandlerForBehavior: function(behavior, i, eventName, trigger) {
            var triggerKey = trigger.replace(/^\S+/, function(triggerName) {
              return triggerName + '.' + 'behaviortriggers' + i;
            });
            this._triggers[triggerKey] = this._view._buildViewTrigger(eventName);
          }
        });
        function getBehaviorsUI(behavior) {
          return behavior._uiBindings || behavior.ui;
        }
        return Behaviors;
      })(Marionette, _);
      Marionette.AppRouter = Backbone.Router.extend({
        constructor: function(options) {
          this.options = options || {};
          Backbone.Router.apply(this, arguments);
          var appRoutes = this.getOption('appRoutes');
          var controller = this._getController();
          this.processAppRoutes(controller, appRoutes);
          this.on('route', this._processOnRoute, this);
        },
        appRoute: function(route, methodName) {
          var controller = this._getController();
          this._addAppRoute(controller, route, methodName);
        },
        _processOnRoute: function(routeName, routeArgs) {
          if (_.isFunction(this.onRoute)) {
            var routePath = _.invert(this.getOption('appRoutes'))[routeName];
            this.onRoute(routeName, routePath, routeArgs);
          }
        },
        processAppRoutes: function(controller, appRoutes) {
          if (!appRoutes) {
            return;
          }
          var routeNames = _.keys(appRoutes).reverse();
          _.each(routeNames, function(route) {
            this._addAppRoute(controller, route, appRoutes[route]);
          }, this);
        },
        _getController: function() {
          return this.getOption('controller');
        },
        _addAppRoute: function(controller, route, methodName) {
          var method = controller[methodName];
          if (!method) {
            throw new Marionette.Error('Method "' + methodName + '" was not found on the controller');
          }
          this.route(route, methodName, _.bind(method, controller));
        },
        mergeOptions: Marionette.mergeOptions,
        getOption: Marionette.proxyGetOption,
        triggerMethod: Marionette.triggerMethod,
        bindEntityEvents: Marionette.proxyBindEntityEvents,
        unbindEntityEvents: Marionette.proxyUnbindEntityEvents
      });
      Marionette.Application = Marionette.Object.extend({
        constructor: function(options) {
          this._initializeRegions(options);
          this._initCallbacks = new Marionette.Callbacks();
          this.submodules = {};
          _.extend(this, options);
          this._initChannel();
          Marionette.Object.apply(this, arguments);
        },
        execute: function() {
          this.commands.execute.apply(this.commands, arguments);
        },
        request: function() {
          return this.reqres.request.apply(this.reqres, arguments);
        },
        addInitializer: function(initializer) {
          this._initCallbacks.add(initializer);
        },
        start: function(options) {
          this.triggerMethod('before:start', options);
          this._initCallbacks.run(options, this);
          this.triggerMethod('start', options);
        },
        addRegions: function(regions) {
          return this._regionManager.addRegions(regions);
        },
        emptyRegions: function() {
          return this._regionManager.emptyRegions();
        },
        removeRegion: function(region) {
          return this._regionManager.removeRegion(region);
        },
        getRegion: function(region) {
          return this._regionManager.get(region);
        },
        getRegions: function() {
          return this._regionManager.getRegions();
        },
        module: function(moduleNames, moduleDefinition) {
          var ModuleClass = Marionette.Module.getClass(moduleDefinition);
          var args = _.toArray(arguments);
          args.unshift(this);
          return ModuleClass.create.apply(ModuleClass, args);
        },
        getRegionManager: function() {
          return new Marionette.RegionManager();
        },
        _initializeRegions: function(options) {
          var regions = _.isFunction(this.regions) ? this.regions(options) : this.regions || {};
          this._initRegionManager();
          var optionRegions = Marionette.getOption(options, 'regions');
          if (_.isFunction(optionRegions)) {
            optionRegions = optionRegions.call(this, options);
          }
          _.extend(regions, optionRegions);
          this.addRegions(regions);
          return this;
        },
        _initRegionManager: function() {
          this._regionManager = this.getRegionManager();
          this._regionManager._parent = this;
          this.listenTo(this._regionManager, 'before:add:region', function() {
            Marionette._triggerMethod(this, 'before:add:region', arguments);
          });
          this.listenTo(this._regionManager, 'add:region', function(name, region) {
            this[name] = region;
            Marionette._triggerMethod(this, 'add:region', arguments);
          });
          this.listenTo(this._regionManager, 'before:remove:region', function() {
            Marionette._triggerMethod(this, 'before:remove:region', arguments);
          });
          this.listenTo(this._regionManager, 'remove:region', function(name) {
            delete this[name];
            Marionette._triggerMethod(this, 'remove:region', arguments);
          });
        },
        _initChannel: function() {
          this.channelName = _.result(this, 'channelName') || 'global';
          this.channel = _.result(this, 'channel') || Backbone.Wreqr.radio.channel(this.channelName);
          this.vent = _.result(this, 'vent') || this.channel.vent;
          this.commands = _.result(this, 'commands') || this.channel.commands;
          this.reqres = _.result(this, 'reqres') || this.channel.reqres;
        }
      });
      Marionette.Module = function(moduleName, app, options) {
        this.moduleName = moduleName;
        this.options = _.extend({}, this.options, options);
        this.initialize = options.initialize || this.initialize;
        this.submodules = {};
        this._setupInitializersAndFinalizers();
        this.app = app;
        if (_.isFunction(this.initialize)) {
          this.initialize(moduleName, app, this.options);
        }
      };
      Marionette.Module.extend = Marionette.extend;
      _.extend(Marionette.Module.prototype, Backbone.Events, {
        startWithParent: true,
        initialize: function() {},
        addInitializer: function(callback) {
          this._initializerCallbacks.add(callback);
        },
        addFinalizer: function(callback) {
          this._finalizerCallbacks.add(callback);
        },
        start: function(options) {
          if (this._isInitialized) {
            return;
          }
          _.each(this.submodules, function(mod) {
            if (mod.startWithParent) {
              mod.start(options);
            }
          });
          this.triggerMethod('before:start', options);
          this._initializerCallbacks.run(options, this);
          this._isInitialized = true;
          this.triggerMethod('start', options);
        },
        stop: function() {
          if (!this._isInitialized) {
            return;
          }
          this._isInitialized = false;
          this.triggerMethod('before:stop');
          _.invoke(this.submodules, 'stop');
          this._finalizerCallbacks.run(undefined, this);
          this._initializerCallbacks.reset();
          this._finalizerCallbacks.reset();
          this.triggerMethod('stop');
        },
        addDefinition: function(moduleDefinition, customArgs) {
          this._runModuleDefinition(moduleDefinition, customArgs);
        },
        _runModuleDefinition: function(definition, customArgs) {
          if (!definition) {
            return;
          }
          var args = _.flatten([this, this.app, Backbone, Marionette, Backbone.$, _, customArgs]);
          definition.apply(this, args);
        },
        _setupInitializersAndFinalizers: function() {
          this._initializerCallbacks = new Marionette.Callbacks();
          this._finalizerCallbacks = new Marionette.Callbacks();
        },
        triggerMethod: Marionette.triggerMethod
      });
      _.extend(Marionette.Module, {
        create: function(app, moduleNames, moduleDefinition) {
          var module = app;
          var customArgs = _.drop(arguments, 3);
          moduleNames = moduleNames.split('.');
          var length = moduleNames.length;
          var moduleDefinitions = [];
          moduleDefinitions[length - 1] = moduleDefinition;
          _.each(moduleNames, function(moduleName, i) {
            var parentModule = module;
            module = this._getModule(parentModule, moduleName, app, moduleDefinition);
            this._addModuleDefinition(parentModule, module, moduleDefinitions[i], customArgs);
          }, this);
          return module;
        },
        _getModule: function(parentModule, moduleName, app, def, args) {
          var options = _.extend({}, def);
          var ModuleClass = this.getClass(def);
          var module = parentModule[moduleName];
          if (!module) {
            module = new ModuleClass(moduleName, app, options);
            parentModule[moduleName] = module;
            parentModule.submodules[moduleName] = module;
          }
          return module;
        },
        getClass: function(moduleDefinition) {
          var ModuleClass = Marionette.Module;
          if (!moduleDefinition) {
            return ModuleClass;
          }
          if (moduleDefinition.prototype instanceof ModuleClass) {
            return moduleDefinition;
          }
          return moduleDefinition.moduleClass || ModuleClass;
        },
        _addModuleDefinition: function(parentModule, module, def, args) {
          var fn = this._getDefine(def);
          var startWithParent = this._getStartWithParent(def, module);
          if (fn) {
            module.addDefinition(fn, args);
          }
          this._addStartWithParent(parentModule, module, startWithParent);
        },
        _getStartWithParent: function(def, module) {
          var swp;
          if (_.isFunction(def) && (def.prototype instanceof Marionette.Module)) {
            swp = module.constructor.prototype.startWithParent;
            return _.isUndefined(swp) ? true : swp;
          }
          if (_.isObject(def)) {
            swp = def.startWithParent;
            return _.isUndefined(swp) ? true : swp;
          }
          return true;
        },
        _getDefine: function(def) {
          if (_.isFunction(def) && !(def.prototype instanceof Marionette.Module)) {
            return def;
          }
          if (_.isObject(def)) {
            return def.define;
          }
          return null;
        },
        _addStartWithParent: function(parentModule, module, startWithParent) {
          module.startWithParent = module.startWithParent && startWithParent;
          if (!module.startWithParent || !!module.startWithParentIsConfigured) {
            return;
          }
          module.startWithParentIsConfigured = true;
          parentModule.addInitializer(function(options) {
            if (module.startWithParent) {
              module.start(options);
            }
          });
        }
      });
      return Marionette;
    }));
  })($__require('22'));
  return module.exports;
});

$__System.registerDynamic("27", ["9f"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('9f');
  return module.exports;
});

$__System.register('a0', ['14', '15', '16', '17', '27', '90', '99'], function (_export) {
    var _get, _inherits, _createClass, _classCallCheck, Marionette, LayoutViewMain, LayoutViewNavigation, LayoutViewMaster;

    return {
        setters: [function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_7) {
            Marionette = _7['default'];
        }, function (_5) {
            LayoutViewMain = _5['default'];
        }, function (_6) {
            LayoutViewNavigation = _6['default'];
        }],
        execute: function () {

            /**
             * Layout view for master work area.
             */
            'use strict';

            LayoutViewMaster = (function (_Marionette$LayoutView) {
                _inherits(LayoutViewMaster, _Marionette$LayoutView);

                function LayoutViewMaster() {
                    _classCallCheck(this, LayoutViewMaster);

                    _get(Object.getPrototypeOf(LayoutViewMaster.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(LayoutViewMaster, [{
                    key: 'initialize',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initializes the view.
                     */
                    value: function initialize() {
                        this.addRegions({
                            regionMain: '#region-main',
                            regionNavigation: '#region-navigation'
                        });
                        this._initializeViews();
                    }

                    /**
                     * Shows the main and navigation views.
                     */
                }, {
                    key: 'onRender',
                    value: function onRender() {
                        this.regionMain.show(this._layoutViewMain);
                        this.regionNavigation.show(this._layoutViewNavigation);
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Initialize all the views so they can respond to events.
                     */
                }, {
                    key: '_initializeViews',
                    value: function _initializeViews() {
                        this._layoutViewNavigation = new LayoutViewNavigation();
                        this._layoutViewMain = new LayoutViewMain();
                    }
                }]);

                return LayoutViewMaster;
            })(Marionette.LayoutView);

            _export('default', LayoutViewMaster);

            LayoutViewMaster.prototype.template = '#template-master';
        }
    };
});

$__System.register('a1', ['11', '16', '17', '20'], function (_export) {
    var RODAN_EVENTS, _createClass, _classCallCheck, Radio, RadioManager;

    return {
        setters: [function (_4) {
            RODAN_EVENTS = _4['default'];
        }, function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_3) {
            Radio = _3['default'];
        }],
        execute: function () {

            /**
             * Radio manager.
             */
            'use strict';

            RadioManager = (function () {
                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function RadioManager() {
                    var _this = this;

                    _classCallCheck(this, RadioManager);

                    Radio.tuneIn('rodan');
                    this._originalRadioLog = Radio.log;
                    Radio.log = function (channelName, eventName, options) {
                        return _this._handleRadioRequest(channelName, eventName, options);
                    };

                    this._pendingResponses = [];
                    this._radioRequestResponseMap = [];

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__PROJECT_CREATE] = { event: RODAN_EVENTS.EVENT__PROJECT_CREATED, modalTitle: 'Creating Project' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__PROJECT_DELETE] = { event: RODAN_EVENTS.EVENT__PROJECT_DELETED, modalTitle: 'Deleting Project' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__PROJECT_SAVE] = { event: RODAN_EVENTS.EVENT__PROJECT_SAVED, modalTitle: 'Saving Project' };

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__RESOURCE_CREATE] = { event: RODAN_EVENTS.EVENT__RESOURCE_CREATED, modalTitle: 'Creating Resource' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__RESOURCE_DELETE] = { event: RODAN_EVENTS.EVENT__RESOURCE_DELETED, modalTitle: 'Deleting Resource' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__RESOURCE_SAVE] = { event: RODAN_EVENTS.EVENT__RESOURCE_SAVED, modalTitle: 'Saving Resource' };

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOW_CREATE] = { event: RODAN_EVENTS.EVENT__WORKFLOW_CREATED, modalTitle: 'Creating Workflow' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOW_DELETE] = { event: RODAN_EVENTS.EVENT__WORKFLOW_DELETED, modalTitle: 'Deleting Workflow' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOW_SAVE] = { event: RODAN_EVENTS.EVENT__WORKFLOW_SAVED, modalTitle: 'Saving Workflow' };

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW] = { event: RODAN_EVENTS.EVENT__WORKFLOWBUILDER_LOADED_WORKFLOW, modalTitle: 'Loading Workflow' };
                    //    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW] = {event: RODAN_EVENTS.EVENT__WORKFLOWBUILDER_VALIDATED_WORKFLOW, modalTitle: 'Validating Workflow'};

                    //    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOB_CREATE] = {event: RODAN_EVENTS.EVENT__WORKFLOWJOB_CREATED, modalTitle: 'Creating Workflow Job'};
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOB_DELETE] = { event: RODAN_EVENTS.EVENT__WORKFLOWJOB_DELETED, modalTitle: 'Deleting Workflow Job' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOB_SAVE] = { event: RODAN_EVENTS.EVENT__WORKFLOWJOB_SAVED, modalTitle: 'Saving Workflow Job' };

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_IMPORT] = { event: RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_IMPORTED, modalTitle: 'Importing Workflow' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_DELETE] = { event: RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_DELETED, modalTitle: 'Deleting Workflow Job Group' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWJOBGROUP_SAVE] = { event: RODAN_EVENTS.EVENT__WORKFLOWJOBGROUP_SAVED, modalTitle: 'Saving Workflow Job Group' };

                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWRUN_CREATE] = { event: RODAN_EVENTS.EVENT__WORKFLOWRUN_CREATED, modalTitle: 'Creating Workflow Run' };
                    this._radioRequestResponseMap[RODAN_EVENTS.REQUEST__WORKFLOWRUN_SAVE] = { event: RODAN_EVENTS.EVENT__WORKFLOWRUN_SAVED, modalTitle: 'Saving Workflow Run' };
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PRIVATE METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Handle Radio request.
                 */

                _createClass(RadioManager, [{
                    key: '_handleRadioRequest',
                    value: function _handleRadioRequest(channelName, eventName, options) {
                        var _this2 = this;

                        var response = this._radioRequestResponseMap[eventName];
                        if (response) {
                            if (!this._pendingResponses[response.event]) {
                                this._pendingResponses[response.event] = 0;
                            }
                            this._pendingResponses[response.event] += 1;
                            Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_SHOW_SIMPLE, { title: response.modalTitle, text: 'Please wait...' });
                            Radio.channel('rodan').once(response.event, function () {
                                return _this2._handleRadioEvent(response.event);
                            });
                        }
                    }

                    /**
                     * Handle Radio event.
                     */
                }, {
                    key: '_handleRadioEvent',
                    value: function _handleRadioEvent(eventName) {
                        var _this3 = this;

                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__MODAL_HIDE);
                        this._pendingResponses[eventName] -= 1;
                        if (this._pendingResponses[eventName] > 0) {
                            Radio.channel('rodan').once(eventName, function () {
                                return _this3._handleRadioEvent(eventName);
                            });
                        }
                    }
                }]);

                return RadioManager;
            })();

            _export('default', RadioManager);
        }
    };
});

$__System.register('a2', ['14', '15', '17', 'a3'], function (_export) {
  var _get, _inherits, _classCallCheck, AbstractUpdater, PollUpdater;

  return {
    setters: [function (_) {
      _get = _['default'];
    }, function (_2) {
      _inherits = _2['default'];
    }, function (_3) {
      _classCallCheck = _3['default'];
    }, function (_a3) {
      AbstractUpdater = _a3['default'];
    }],
    execute: function () {

      /**
       * Updater that syncs collections by a timer.
       */
      'use strict';

      PollUpdater = (function (_AbstractUpdater) {
        _inherits(PollUpdater, _AbstractUpdater);

        ///////////////////////////////////////////////////////////////////////////////////////
        // PUBLIC METHODS
        ///////////////////////////////////////////////////////////////////////////////////////
        /**
         * Constructor
         *
         * @param {options} options options.frequency is the update interval in milliseconds
         */

        function PollUpdater(options) {
          var _this = this;

          _classCallCheck(this, PollUpdater);

          _get(Object.getPrototypeOf(PollUpdater.prototype), 'constructor', this).call(this, options);
          this._timer = setInterval(function () {
            return _this.update();
          }, options.frequency);
        }

        return PollUpdater;
      })(AbstractUpdater);

      _export('default', PollUpdater);
    }
  };
});

$__System.registerDynamic("a4", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toString = {}.toString;
  module.exports = function(it) {
    return toString.call(it).slice(8, -1);
  };
  return module.exports;
});

$__System.registerDynamic("a5", ["a4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var cof = $__require('a4');
  module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it) {
    return cof(it) == 'String' ? it.split('') : Object(it);
  };
  return module.exports;
});

$__System.registerDynamic("8", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (it == undefined)
      throw TypeError("Can't call method on  " + it);
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("a6", ["a5", "8"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var IObject = $__require('a5'),
      defined = $__require('8');
  module.exports = function(it) {
    return IObject(defined(it));
  };
  return module.exports;
});

$__System.registerDynamic("a7", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(exec) {
    try {
      return !!exec();
    } catch (e) {
      return true;
    }
  };
  return module.exports;
});

$__System.registerDynamic("a", ["a8", "c", "a7"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('a8'),
      core = $__require('c'),
      fails = $__require('a7');
  module.exports = function(KEY, exec) {
    var fn = (core.Object || {})[KEY] || Object[KEY],
        exp = {};
    exp[KEY] = exec(fn);
    $export($export.S + $export.F * fails(function() {
      fn(1);
    }), 'Object', exp);
  };
  return module.exports;
});

$__System.registerDynamic("a9", ["a6", "a"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var toIObject = $__require('a6');
  $__require('a')('getOwnPropertyDescriptor', function($getOwnPropertyDescriptor) {
    return function getOwnPropertyDescriptor(it, key) {
      return $getOwnPropertyDescriptor(toIObject(it), key);
    };
  });
  return module.exports;
});

$__System.registerDynamic("aa", ["ab", "a9"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('ab');
  $__require('a9');
  module.exports = function getOwnPropertyDescriptor(it, key) {
    return $.getDesc(it, key);
  };
  return module.exports;
});

$__System.registerDynamic("ac", ["aa"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('aa'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("14", ["ac"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$getOwnPropertyDescriptor = $__require('ac')["default"];
  exports["default"] = function get(_x, _x2, _x3) {
    var _again = true;
    _function: while (_again) {
      var object = _x,
          property = _x2,
          receiver = _x3;
      _again = false;
      if (object === null)
        object = Function.prototype;
      var desc = _Object$getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) {
          return undefined;
        } else {
          _x = parent;
          _x2 = property;
          _x3 = receiver;
          _again = true;
          desc = parent = undefined;
          continue _function;
        }
      } else if ("value" in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) {
          return undefined;
        }
        return getter.call(receiver);
      }
    }
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("ad", ["ab"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('ab');
  module.exports = function create(P, D) {
    return $.create(P, D);
  };
  return module.exports;
});

$__System.registerDynamic("ae", ["ad"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('ad'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("af", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
  if (typeof __g == 'number')
    __g = global;
  return module.exports;
});

$__System.registerDynamic("a8", ["af", "c", "b0"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var global = $__require('af'),
      core = $__require('c'),
      ctx = $__require('b0'),
      PROTOTYPE = 'prototype';
  var $export = function(type, name, source) {
    var IS_FORCED = type & $export.F,
        IS_GLOBAL = type & $export.G,
        IS_STATIC = type & $export.S,
        IS_PROTO = type & $export.P,
        IS_BIND = type & $export.B,
        IS_WRAP = type & $export.W,
        exports = IS_GLOBAL ? core : core[name] || (core[name] = {}),
        target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE],
        key,
        own,
        out;
    if (IS_GLOBAL)
      source = name;
    for (key in source) {
      own = !IS_FORCED && target && key in target;
      if (own && key in exports)
        continue;
      out = own ? target[key] : source[key];
      exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] : IS_BIND && own ? ctx(out, global) : IS_WRAP && target[key] == out ? (function(C) {
        var F = function(param) {
          return this instanceof C ? new C(param) : C(param);
        };
        F[PROTOTYPE] = C[PROTOTYPE];
        return F;
      })(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
      if (IS_PROTO)
        (exports[PROTOTYPE] || (exports[PROTOTYPE] = {}))[key] = out;
    }
  };
  $export.F = 1;
  $export.G = 2;
  $export.S = 4;
  $export.P = 8;
  $export.B = 16;
  $export.W = 32;
  module.exports = $export;
  return module.exports;
});

$__System.registerDynamic("b1", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
  };
  return module.exports;
});

$__System.registerDynamic("b2", ["b1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var isObject = $__require('b1');
  module.exports = function(it) {
    if (!isObject(it))
      throw TypeError(it + ' is not an object!');
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("b3", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = function(it) {
    if (typeof it != 'function')
      throw TypeError(it + ' is not a function!');
    return it;
  };
  return module.exports;
});

$__System.registerDynamic("b0", ["b3"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var aFunction = $__require('b3');
  module.exports = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined)
      return fn;
    switch (length) {
      case 1:
        return function(a) {
          return fn.call(that, a);
        };
      case 2:
        return function(a, b) {
          return fn.call(that, a, b);
        };
      case 3:
        return function(a, b, c) {
          return fn.call(that, a, b, c);
        };
    }
    return function() {
      return fn.apply(that, arguments);
    };
  };
  return module.exports;
});

$__System.registerDynamic("b4", ["ab", "b1", "b2", "b0"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var getDesc = $__require('ab').getDesc,
      isObject = $__require('b1'),
      anObject = $__require('b2');
  var check = function(O, proto) {
    anObject(O);
    if (!isObject(proto) && proto !== null)
      throw TypeError(proto + ": can't set as prototype!");
  };
  module.exports = {
    set: Object.setPrototypeOf || ('__proto__' in {} ? function(test, buggy, set) {
      try {
        set = $__require('b0')(Function.call, getDesc(Object.prototype, '__proto__').set, 2);
        set(test, []);
        buggy = !(test instanceof Array);
      } catch (e) {
        buggy = true;
      }
      return function setPrototypeOf(O, proto) {
        check(O, proto);
        if (buggy)
          O.__proto__ = proto;
        else
          set(O, proto);
        return O;
      };
    }({}, false) : undefined),
    check: check
  };
  return module.exports;
});

$__System.registerDynamic("b5", ["a8", "b4"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $export = $__require('a8');
  $export($export.S, 'Object', {setPrototypeOf: $__require('b4').set});
  return module.exports;
});

$__System.registerDynamic("c", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var core = module.exports = {version: '1.2.6'};
  if (typeof __e == 'number')
    __e = core;
  return module.exports;
});

$__System.registerDynamic("b6", ["b5", "c"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  $__require('b5');
  module.exports = $__require('c').Object.setPrototypeOf;
  return module.exports;
});

$__System.registerDynamic("b7", ["b6"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('b6'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("15", ["ae", "b7"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$create = $__require('ae')["default"];
  var _Object$setPrototypeOf = $__require('b7')["default"];
  exports["default"] = function(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }
    subClass.prototype = _Object$create(superClass && superClass.prototype, {constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }});
    if (superClass)
      _Object$setPrototypeOf ? _Object$setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.register("a3", ["16", "17"], function (_export) {
	var _createClass, _classCallCheck, AbstractUpdater;

	return {
		setters: [function (_) {
			_createClass = _["default"];
		}, function (_2) {
			_classCallCheck = _2["default"];
		}],
		execute: function () {
			/**
    * Base class for updaters.
    */
			"use strict";

			AbstractUpdater = (function () {
				function AbstractUpdater() {
					_classCallCheck(this, AbstractUpdater);
				}

				_createClass(AbstractUpdater, [{
					key: "setCollections",

					///////////////////////////////////////////////////////////////////////////////////////
					// PUBLIC METHODS
					///////////////////////////////////////////////////////////////////////////////////////
					/**
      * Sets the collections that are to be updated.
      *
      * @param {[BaseCollection]} collections collections to be updated.
      */
					value: function setCollections(collections) {
						this.clear();
						this._collections = collections;
					}

					/**
      * Updates registered collections.
      */
				}, {
					key: "update",
					value: function update() {
						if (this._collections) {
							for (var i = 0; i < this._collections.length; i++) {
								this._collections[i].syncList();
							}
						}
					}

					/**
      * Clears registered collections.
      */
				}, {
					key: "clear",
					value: function clear() {
						this._collection = null;
					}
				}]);

				return AbstractUpdater;
			})();

			_export("default", AbstractUpdater);
		}
	};
});

$__System.register('10', ['11', '20'], function (_export) {

    /**
     * Client configuration object.
     */
    'use strict';

    var RODAN_EVENTS, Radio, Configuration;
    return {
        setters: [function (_2) {
            RODAN_EVENTS = _2['default'];
        }, function (_) {
            Radio = _['default'];
        }],
        execute: function () {
            Configuration = {
                ///////////////////////////////////////////////////////////////////////////////////////
                // Server parameters
                ///////////////////////////////////////////////////////////////////////////////////////
                // Host of server (e.g. 123.456.789.0 or mydomain.com).
                SERVER_HOST: '',

                // Server port.
                SERVER_PORT: '',

                // Set to true iff using HTTPS (else HTTP). Default is true.
                SERVER_HTTPS: true,

                // Set to true iff the server allows socket connections. Default is false.
                SERVER_SOCKET_AVAILABLE: false,

                // Authentication type. Either 'session' or 'token'.
                SERVER_AUTHENTICATION_TYPE: '',

                // This determines the method to use for loading updates from the server.
                // Either 'POLL' (default) or 'SOCKET'.
                SERVER_UPDATE_METHOD: 'SOCKET',

                // Interval after which the client will get the server time (ms).
                // Generally, the client extracts the server time from all responses from the server.
                // However, if the client has not received a response from the server after this
                // amount of time, the client will fire an HTTP HEAD request and get the server
                // time. This means that the server MUST exposde the 'Date' response header. As
                // such, it is recommended that this value be greater than the
                // EVENT_TIMER_FREQUENCY to reduce traffic.
                SERVER_REQUEST_TIME_INTERVAL: 60000,

                // Milliseconds to wait before the client goes into a 'wait' mode. This is used in the WorkflowBuilder when heavy lifting is going on, such as a Workflow import.
                SERVER_WAIT_TIMER: 1000,

                // Milliseconds to wait before the client 'panics' mode. This is used in the WorkflowBuilder when heavy lifting is going on, such as a Workflow import.
                // This should be bigger than SERVER_WAIT_TIMER.
                SERVER_PANIC_TIMER: 8000,

                ///////////////////////////////////////////////////////////////////////////////////////
                // General behavior parameters
                ///////////////////////////////////////////////////////////////////////////////////////
                // URL for website.
                WEBSITE_URL: 'http://ddmal.github.io/rodan-client/',

                // Date/time format. See http://momentjs.com/docs/#/displaying/format/
                DATETIME_FORMAT: 'YYYY-MM-DD HH:mm:ss',

                // Event timer frequency (ms).
                EVENT_TIMER_FREQUENCY: 3000,

                // If you have a Job package meant solely for distributing Resources (i.e. takes in a single Resource and outputs that Resource) you have the option to use a
                // feature that will automatically create a WorkflowJob of the correct Job that satisfies selected InputPorts. If this is the case, those Jobs must have
                // their category set to the value of RESOURCE_DISTRIBUTOR_CATEGORY.
                RESOURCE_DISTRIBUTOR_CATEGORY: 'Resource Distributor',

                ///////////////////////////////////////////////////////////////////////////////////////
                // Interactive RunJob parameters
                ///////////////////////////////////////////////////////////////////////////////////////
                // Time (in milliseconds) that the CLIENT will attempt to hold a job.
                RUNJOB_ACQUIRE_DURATION: 3600000,

                // Interval (in milliseconds) that the RunJob controller will use to reacquire interactive locks.
                RUNJOB_ACQUIRE_INTERVAL: 5000,

                ///////////////////////////////////////////////////////////////////////////////////////
                // DON'T EDIT BELOW THIS LINE (unless you know what you're doing)
                ///////////////////////////////////////////////////////////////////////////////////////
                // Routes without OPTIONS. if the route name is in here, the client won't try to grab them.
                ROUTES_WITHOUT_OPTIONS: ['auth-reset-token', 'taskqueue-status', 'auth-change-password', 'auth-register', 'taskqueue-scheduled', 'taskqueue-active', 'auth-token'],

                // Client admin info. Leave fields empty if you don't want to be bothered. ;)
                ADMIN_CLIENT: {
                    NAME: '',
                    EMAIL: ''
                }
            };

            ///////////////////////////////////////////////////////////////////////////////////////
            // Loader methods
            ///////////////////////////////////////////////////////////////////////////////////////
            /**
             * Convenience method to return the URL (I.e. '<http or https>://SERVER_HOST:SERVER_PORT'.)
             *
             * @return {string} <http or https>://SERVER_HOST:SERVER_PORT
             */
            Configuration.getServerURL = function () {
                var url = this.SERVER_HOST + ':' + this.SERVER_PORT;
                return this.SERVER_HTTPS ? 'https://' + url : 'http://' + url;
            };

            /**
             * Requests filename from the client host. Whatever it gets from the host
             * it will merge with the default configuration.
             *
             * When finished it will fire the provided callback.
             */
            Configuration.load = function (filename, callback) {
                'use strict';

                var _this = this;

                var request = new XMLHttpRequest();
                request.open('GET', filename, true);
                request.onreadystatechange = function (event) {
                    return _this._handleStateChange(event, filename, callback);
                };
                request.send();
            };

            /**
             * Handle state change of request.
             */
            Configuration._handleStateChange = function (event, filename, callback) {
                'use strict';
                var request = event.currentTarget;
                switch (request.readyState) {
                    case 0:
                        //UNSENT
                        {
                            break;
                        }

                    case 1:
                        //OPENED
                        {
                            break;
                        }

                    case 2:
                        //HEADERS_RECEIVED
                        {
                            break;
                        }

                    case 3:
                        //LOADING
                        {
                            break;
                        }

                    case 4:
                        {
                            var configuration = JSON.parse(request.response);
                            $.extend(this, configuration);
                            Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__CONFIGURATION_LOADED);
                            if (callback) {
                                callback();
                            }
                            break;
                        }

                    default:
                        {
                            // TODO error
                            console.error('failed to load file ' + filename);
                            break;
                        }
                }
            };

            _export('default', Configuration);
        }
    };
});

$__System.register('b8', ['10', '14', '15', '16', '17', 'a3'], function (_export) {
    var Configuration, _get, _inherits, _createClass, _classCallCheck, AbstractUpdater, SocketUpdater;

    return {
        setters: [function (_5) {
            Configuration = _5['default'];
        }, function (_) {
            _get = _['default'];
        }, function (_2) {
            _inherits = _2['default'];
        }, function (_3) {
            _createClass = _3['default'];
        }, function (_4) {
            _classCallCheck = _4['default'];
        }, function (_a3) {
            AbstractUpdater = _a3['default'];
        }],
        execute: function () {

            /**
             * Updater that uses sockets to trigger collection updates.
             */
            'use strict';

            SocketUpdater = (function (_AbstractUpdater) {
                _inherits(SocketUpdater, _AbstractUpdater);

                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function SocketUpdater() {
                    var _this = this;

                    _classCallCheck(this, SocketUpdater);

                    _get(Object.getPrototypeOf(SocketUpdater.prototype), 'constructor', this).call(this);
                    this._webSocket = new WebSocket('ws://' + Configuration.SERVER_HOST + ':' + Configuration.SERVER_PORT + '/ws/rodan?subscribe-broadcast&publish-broadcast&echo');
                    this._webSocket.onmessage = function (event) {
                        return _this._handleSocketMessage(event);
                    };
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PRIVATE METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Handle login success.
                 */

                _createClass(SocketUpdater, [{
                    key: '_handleEventLogoutSuccess',
                    value: function _handleEventLogoutSuccess() {
                        this._webSocket.close();
                    }

                    /**
                     * Handle socket message.
                     */
                }, {
                    key: '_handleSocketMessage',
                    value: function _handleSocketMessage(event) {
                        if (event.data === '--heartbeat--') {
                            //  this._processHeartbeat(event);
                        } else {
                                this.update();
                            }
                    }
                }]);

                return SocketUpdater;
            })(AbstractUpdater);

            _export('default', SocketUpdater);
        }
    };
});

$__System.register('b9', ['10', '11', '16', '17', '20', 'a2', 'b8'], function (_export) {
    var Configuration, RODAN_EVENTS, _createClass, _classCallCheck, Radio, PollUpdater, SocketUpdater, UpdateManager;

    return {
        setters: [function (_3) {
            Configuration = _3['default'];
        }, function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_4) {
            Radio = _4['default'];
        }, function (_a2) {
            PollUpdater = _a2['default'];
        }, function (_b8) {
            SocketUpdater = _b8['default'];
        }],
        execute: function () {

            /**
             * This manages how updates are handled.
             */
            'use strict';

            UpdateManager = (function () {
                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function UpdateManager() {
                    var _this = this;

                    _classCallCheck(this, UpdateManager);

                    this._updater = null;
                    Radio.channel('rodan').on(RODAN_EVENTS.EVENT__CONFIGURATION_LOADED, function () {
                        return _this._handleEventConfigurationLoaded();
                    });
                    Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__UPDATER_SET_COLLECTIONS, function (options) {
                        return _this._handleRequestUpdateSetFunction(options);
                    });
                    Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__UPDATER_CLEAR, function () {
                        return _this._handleRequestUpdateClear();
                    });
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PRIVATE METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Handle config load. Reads the configuration and check for socket setting.
                 */

                _createClass(UpdateManager, [{
                    key: '_handleEventConfigurationLoaded',
                    value: function _handleEventConfigurationLoaded() {
                        if (Configuration.SERVER_SOCKET_AVAILABLE) {
                            this._updater = new SocketUpdater();
                        } else {
                            this._updater = new PollUpdater({ frequency: Configuration.EVENT_TIMER_FREQUENCY });
                        }
                    }

                    /**
                     * Handle request Update set function.
                     */
                }, {
                    key: '_handleRequestUpdateSetFunction',
                    value: function _handleRequestUpdateSetFunction(options) {
                        this._updater.setCollections(options.collections);
                    }

                    /**
                     * Handle request Update clear.
                     */
                }, {
                    key: '_handleRequestUpdateClear',
                    value: function _handleRequestUpdateClear(options) {
                        this._updater.clear();
                    }
                }]);

                return UpdateManager;
            })();

            _export('default', UpdateManager);
        }
    };
});

$__System.registerDynamic("ab", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $Object = Object;
  module.exports = {
    create: $Object.create,
    getProto: $Object.getPrototypeOf,
    isEnum: {}.propertyIsEnumerable,
    getDesc: $Object.getOwnPropertyDescriptor,
    setDesc: $Object.defineProperty,
    setDescs: $Object.defineProperties,
    getKeys: $Object.keys,
    getNames: $Object.getOwnPropertyNames,
    getSymbols: $Object.getOwnPropertySymbols,
    each: [].forEach
  };
  return module.exports;
});

$__System.registerDynamic("ba", ["ab"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var $ = $__require('ab');
  module.exports = function defineProperty(it, key, desc) {
    return $.setDesc(it, key, desc);
  };
  return module.exports;
});

$__System.registerDynamic("bb", ["ba"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = {
    "default": $__require('ba'),
    __esModule: true
  };
  return module.exports;
});

$__System.registerDynamic("16", ["bb"], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  var _Object$defineProperty = $__require('bb')["default"];
  exports["default"] = (function() {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor)
          descriptor.writable = true;
        _Object$defineProperty(target, descriptor.key, descriptor);
      }
    }
    return function(Constructor, protoProps, staticProps) {
      if (protoProps)
        defineProperties(Constructor.prototype, protoProps);
      if (staticProps)
        defineProperties(Constructor, staticProps);
      return Constructor;
    };
  })();
  exports.__esModule = true;
  return module.exports;
});

$__System.registerDynamic("bc", ["32", "3", "22"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function(factory) {
      var root = (typeof self == 'object' && self.self === self && self) || (typeof global == 'object' && global.global === global && global);
      if (typeof define === 'function' && define.amd) {
        define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
          root.Backbone = factory(root, exports, _, $);
        });
      } else if (typeof exports !== 'undefined') {
        var _ = $__require('32'),
            $;
        try {
          $ = $__require('3');
        } catch (e) {}
        factory(root, exports, _, $);
      } else {
        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
      }
    })(function(root, Backbone, _, $) {
      var previousBackbone = root.Backbone;
      var slice = Array.prototype.slice;
      Backbone.VERSION = '1.3.3';
      Backbone.$ = $;
      Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
      };
      Backbone.emulateHTTP = false;
      Backbone.emulateJSON = false;
      var addMethod = function(length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
              return _[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return _[method](this[attribute], value);
            };
          case 3:
            return function(iteratee, context) {
              return _[method](this[attribute], cb(iteratee, this), context);
            };
          case 4:
            return function(iteratee, defaultVal, context) {
              return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };
          default:
            return function() {
              var args = slice.call(arguments);
              args.unshift(this[attribute]);
              return _[method].apply(_, args);
            };
        }
      };
      var addUnderscoreMethods = function(Class, methods, attribute) {
        _.each(methods, function(length, method) {
          if (_[method])
            Class.prototype[method] = addMethod(length, method, attribute);
        });
      };
      var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee))
          return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee))
          return modelMatcher(iteratee);
        if (_.isString(iteratee))
          return function(model) {
            return model.get(iteratee);
          };
        return iteratee;
      };
      var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
          return matcher(model.attributes);
        };
      };
      var Events = Backbone.Events = {};
      var eventSplitter = /\s+/;
      var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0,
            names;
        if (name && typeof name === 'object') {
          if (callback !== void 0 && 'context' in opts && opts.context === void 0)
            opts.context = callback;
          for (names = _.keys(name); i < names.length; i++) {
            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
          }
        } else if (name && eventSplitter.test(name)) {
          for (names = name.split(eventSplitter); i < names.length; i++) {
            events = iteratee(events, names[i], callback, opts);
          }
        } else {
          events = iteratee(events, name, callback, opts);
        }
        return events;
      };
      Events.on = function(name, callback, context) {
        return internalOn(this, name, callback, context);
      };
      var internalOn = function(obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
          context: context,
          ctx: obj,
          listening: listening
        });
        if (listening) {
          var listeners = obj._listeners || (obj._listeners = {});
          listeners[listening.id] = listening;
        }
        return obj;
      };
      Events.listenTo = function(obj, name, callback) {
        if (!obj)
          return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];
        if (!listening) {
          var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
          listening = listeningTo[id] = {
            obj: obj,
            objId: id,
            id: thisId,
            listeningTo: listeningTo,
            count: 0
          };
        }
        internalOn(obj, name, callback, this, listening);
        return this;
      };
      var onApi = function(events, name, callback, options) {
        if (callback) {
          var handlers = events[name] || (events[name] = []);
          var context = options.context,
              ctx = options.ctx,
              listening = options.listening;
          if (listening)
            listening.count++;
          handlers.push({
            callback: callback,
            context: context,
            ctx: context || ctx,
            listening: listening
          });
        }
        return events;
      };
      Events.off = function(name, callback, context) {
        if (!this._events)
          return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
          context: context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
          return this;
        var ids = obj ? [obj._listenId] : _.keys(listeningTo);
        for (var i = 0; i < ids.length; i++) {
          var listening = listeningTo[ids[i]];
          if (!listening)
            break;
          listening.obj.off(name, callback, this);
        }
        return this;
      };
      var offApi = function(events, name, callback, options) {
        if (!events)
          return;
        var i = 0,
            listening;
        var context = options.context,
            listeners = options.listeners;
        if (!name && !callback && !context) {
          var ids = _.keys(listeners);
          for (; i < ids.length; i++) {
            listening = listeners[ids[i]];
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
          return;
        }
        var names = name ? [name] : _.keys(events);
        for (; i < names.length; i++) {
          name = names[i];
          var handlers = events[name];
          if (!handlers)
            break;
          var remaining = [];
          for (var j = 0; j < handlers.length; j++) {
            var handler = handlers[j];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              listening = handler.listening;
              if (listening && --listening.count === 0) {
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
              }
            }
          }
          if (remaining.length) {
            events[name] = remaining;
          } else {
            delete events[name];
          }
        }
        return events;
      };
      Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === 'string' && context == null)
          callback = void 0;
        return this.on(events, callback, context);
      };
      Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
      };
      var onceMap = function(map, name, callback, offer) {
        if (callback) {
          var once = map[name] = _.once(function() {
            offer(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map;
      };
      Events.trigger = function(name) {
        if (!this._events)
          return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++)
          args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
          var events = objEvents[name];
          var allEvents = objEvents.all;
          if (events && allEvents)
            allEvents = allEvents.slice();
          if (events)
            triggerEvents(events, args);
          if (allEvents)
            triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events, args) {
        var ev,
            i = -1,
            l = events.length,
            a1 = args[0],
            a2 = args[1],
            a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;
          case 3:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;
          default:
            while (++i < l)
              (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _.extend(Backbone, Events);
      var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection)
          this.collection = options.collection;
        if (options.parse)
          attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, 'defaults');
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: 'id',
        cidPrefix: 'c',
        initialize: function() {},
        toJSON: function(options) {
          return _.clone(this.attributes);
        },
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
        get: function(attr) {
          return this.attributes[attr];
        },
        escape: function(attr) {
          return _.escape(this.get(attr));
        },
        has: function(attr) {
          return this.get(attr) != null;
        },
        matches: function(attrs) {
          return !!_.iteratee(attrs, this)(this.attributes);
        },
        set: function(key, val, options) {
          if (key == null)
            return this;
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          var unset = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val))
              changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        unset: function(attr, options) {
          return this.set(attr, void 0, _.extend({}, options, {unset: true}));
        },
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {unset: true}));
        },
        hasChanged: function(attr) {
          if (attr == null)
            return !_.isEmpty(this.changed);
          return _.has(this.changed, attr);
        },
        changedAttributes: function(diff) {
          if (!diff)
            return this.hasChanged() ? _.clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (_.isEqual(old[attr], val))
              continue;
            changed[attr] = val;
          }
          return _.size(changed) ? changed : false;
        },
        previous: function(attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        previousAttributes: function() {
          return _.clone(this._previousAttributes);
        },
        fetch: function(options) {
          options = _.extend({parse: true}, options);
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (!model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        save: function(key, val, options) {
          var attrs;
          if (key == null || typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _.extend({
            validate: true,
            parse: true
          }, options);
          var wait = options.wait;
          if (attrs && !wait) {
            if (!this.set(attrs, options))
              return false;
          } else if (!this._validate(attrs, options)) {
            return false;
          }
          var model = this;
          var success = options.success;
          var attributes = this.attributes;
          options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (wait)
              serverAttrs = _.extend({}, attrs, serverAttrs);
            if (serverAttrs && !model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          if (attrs && wait)
            this.attributes = _.extend({}, attributes, attrs);
          var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
          if (method === 'patch' && !options.attrs)
            options.attrs = attrs;
          var xhr = this.sync(method, this, options);
          this.attributes = attributes;
          return xhr;
        },
        destroy: function(options) {
          options = options ? _.clone(options) : {};
          var model = this;
          var success = options.success;
          var wait = options.wait;
          var destroy = function() {
            model.stopListening();
            model.trigger('destroy', model, model.collection, options);
          };
          options.success = function(resp) {
            if (wait)
              destroy();
            if (success)
              success.call(options.context, model, resp, options);
            if (!model.isNew())
              model.trigger('sync', model, resp, options);
          };
          var xhr = false;
          if (this.isNew()) {
            _.defer(options.success);
          } else {
            wrapError(this, options);
            xhr = this.sync('delete', this, options);
          }
          if (!wait)
            destroy();
          return xhr;
        },
        url: function() {
          var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
          if (this.isNew())
            return base;
          var id = this.get(this.idAttribute);
          return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
        },
        parse: function(resp, options) {
          return resp;
        },
        clone: function() {
          return new this.constructor(this.attributes);
        },
        isNew: function() {
          return !this.has(this.idAttribute);
        },
        isValid: function(options) {
          return this._validate({}, _.extend({}, options, {validate: true}));
        },
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
          return false;
        }
      });
      var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
      };
      addUnderscoreMethods(Model, modelMethods, 'attributes');
      var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model)
          this.model = options.model;
        if (options.comparator !== void 0)
          this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
          this.reset(models, _.extend({silent: true}, options));
      };
      var setOptions = {
        add: true,
        remove: true,
        merge: true
      };
      var addOptions = {
        add: true,
        remove: false
      };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for (i = 0; i < tail.length; i++)
          tail[i] = array[i + at];
        for (i = 0; i < length; i++)
          array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++)
          array[i + length + at] = tail[i];
      };
      _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function() {},
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
        add: function(models, options) {
          return this.set(models, _.extend({merge: false}, options, addOptions));
        },
        remove: function(models, options) {
          options = _.extend({}, options);
          var singular = !_.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = {
              added: [],
              merged: [],
              removed: removed
            };
            this.trigger('update', this, options);
          }
          return singular ? removed[0] : removed;
        },
        set: function(models, options) {
          if (models == null)
            return;
          options = _.extend({}, setOptions, options);
          if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
          }
          var singular = !_.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null)
            at = +at;
          if (at > this.length)
            at = this.length;
          if (at < 0)
            at += this.length + 1;
          var set = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge = options.merge;
          var remove = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _.isString(this.comparator) ? this.comparator : null;
          var model,
              i;
          for (i = 0; i < models.length; i++) {
            model = models[i];
            var existing = this.get(model);
            if (existing) {
              if (merge && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort)
                  sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set.push(existing);
              }
              models[i] = existing;
            } else if (add) {
              model = models[i] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set.push(model);
              }
            }
          }
          if (remove) {
            for (i = 0; i < this.length; i++) {
              model = this.models[i];
              if (!modelMap[model.cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove;
          if (set.length && replace) {
            orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
              return m !== set[index];
            });
            this.models.length = 0;
            splice(this.models, set, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable)
              sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort)
            this.sort({silent: true});
          if (!options.silent) {
            for (i = 0; i < toAdd.length; i++) {
              if (at != null)
                options.index = at + i;
              model = toAdd[i];
              model.trigger('add', model, this, options);
            }
            if (sort || orderChanged)
              this.trigger('sort', this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger('update', this, options);
            }
          }
          return singular ? models[0] : models;
        },
        reset: function(models, options) {
          options = options ? _.clone(options) : {};
          for (var i = 0; i < this.models.length; i++) {
            this._removeReference(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _.extend({silent: true}, options));
          if (!options.silent)
            this.trigger('reset', this, options);
          return models;
        },
        push: function(model, options) {
          return this.add(model, _.extend({at: this.length}, options));
        },
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        unshift: function(model, options) {
          return this.add(model, _.extend({at: 0}, options));
        },
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        slice: function() {
          return slice.apply(this.models, arguments);
        },
        get: function(obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
        },
        has: function(obj) {
          return this.get(obj) != null;
        },
        at: function(index) {
          if (index < 0)
            index += this.length;
          return this.models[index];
        },
        where: function(attrs, first) {
          return this[first ? 'find' : 'filter'](attrs);
        },
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator)
            throw new Error('Cannot sort a set without a comparator');
          options || (options = {});
          var length = comparator.length;
          if (_.isFunction(comparator))
            comparator = _.bind(comparator, this);
          if (length === 1 || _.isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent)
            this.trigger('sort', this, options);
          return this;
        },
        pluck: function(attr) {
          return this.map(attr + '');
        },
        fetch: function(options) {
          options = _.extend({parse: true}, options);
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? 'reset' : 'set';
            collection[method](resp, options);
            if (success)
              success.call(options.context, collection, resp, options);
            collection.trigger('sync', collection, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        create: function(model, options) {
          options = options ? _.clone(options) : {};
          var wait = options.wait;
          model = this._prepareModel(model, options);
          if (!model)
            return false;
          if (!wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(m, resp, callbackOpts) {
            if (wait)
              collection.add(m, callbackOpts);
            if (success)
              success.call(callbackOpts.context, m, resp, callbackOpts);
          };
          model.save(null, options);
          return model;
        },
        parse: function(resp, options) {
          return resp;
        },
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        modelId: function(attrs) {
          return attrs[this.model.prototype.idAttribute || 'id'];
        },
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!attrs.collection)
              attrs.collection = this;
            return attrs;
          }
          options = options ? _.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger('invalid', this, model.validationError, options);
          return false;
        },
        _removeModels: function(models, options) {
          var removed = [];
          for (var i = 0; i < models.length; i++) {
            var model = this.get(models[i]);
            if (!model)
              continue;
            var index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null)
              delete this._byId[id];
            if (!options.silent) {
              options.index = index;
              model.trigger('remove', model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          return removed;
        },
        _isModel: function(model) {
          return model instanceof Model;
        },
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          var id = this.modelId(model.attributes);
          if (id != null)
            this._byId[id] = model;
          model.on('all', this._onModelEvent, this);
        },
        _removeReference: function(model, options) {
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (this === model.collection)
            delete model.collection;
          model.off('all', this._onModelEvent, this);
        },
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === 'add' || event === 'remove') && collection !== this)
              return;
            if (event === 'destroy')
              this.remove(model, options);
            if (event === 'change') {
              var prevId = this.modelId(model.previousAttributes());
              var id = this.modelId(model.attributes);
              if (prevId !== id) {
                if (prevId != null)
                  delete this._byId[prevId];
                if (id != null)
                  this._byId[id] = model;
              }
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
      };
      addUnderscoreMethods(Collection, collectionMethods, 'models');
      var View = Backbone.View = function(options) {
        this.cid = _.uniqueId('view');
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
      _.extend(View.prototype, Events, {
        tagName: 'div',
        $: function(selector) {
          return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
          return this;
        },
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        _removeElement: function() {
          this.$el.remove();
        },
        setElement: function(element) {
          this.undelegateEvents();
          this._setElement(element);
          this.delegateEvents();
          return this;
        },
        _setElement: function(el) {
          this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
          this.el = this.$el[0];
        },
        delegateEvents: function(events) {
          events || (events = _.result(this, 'events'));
          if (!events)
            return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method))
              method = this[method];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], _.bind(method, this));
          }
          return this;
        },
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
          return this;
        },
        undelegateEvents: function() {
          if (this.$el)
            this.$el.off('.delegateEvents' + this.cid);
          return this;
        },
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
          return this;
        },
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _.extend({}, _.result(this, 'attributes'));
            if (this.id)
              attrs.id = _.result(this, 'id');
            if (this.className)
              attrs['class'] = _.result(this, 'className');
            this.setElement(this._createElement(_.result(this, 'tagName')));
            this._setAttributes(attrs);
          } else {
            this.setElement(_.result(this, 'el'));
          }
        },
        _setAttributes: function(attributes) {
          this.$el.attr(attributes);
        }
      });
      Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
          emulateHTTP: Backbone.emulateHTTP,
          emulateJSON: Backbone.emulateJSON
        });
        var params = {
          type: type,
          dataType: 'json'
        };
        if (!options.url) {
          params.url = _.result(model, 'url') || urlError();
        }
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
          params.contentType = 'application/json';
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = 'application/x-www-form-urlencoded';
          params.data = params.data ? {model: params.data} : {};
        }
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
          params.type = 'POST';
          if (options.emulateJSON)
            params.data._method = type;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr) {
            xhr.setRequestHeader('X-HTTP-Method-Override', type);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== 'GET' && !options.emulateJSON) {
          params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error)
            error.call(options.context, xhr, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
      };
      var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
      };
      Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
      };
      var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes)
          this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _.extend(Router.prototype, Events, {
        initialize: function() {},
        route: function(route, name, callback) {
          if (!_.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_.isFunction(name)) {
            callback = name;
            name = '';
          }
          if (!callback)
            callback = this[name];
          var router = this;
          Backbone.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name) !== false) {
              router.trigger.apply(router, ['route:' + name].concat(args));
              router.trigger('route', name, args);
              Backbone.history.trigger('route', router, name, args);
            }
          });
          return this;
        },
        execute: function(callback, args, name) {
          if (callback)
            callback.apply(this, args);
        },
        navigate: function(fragment, options) {
          Backbone.history.navigate(fragment, options);
          return this;
        },
        _bindRoutes: function() {
          if (!this.routes)
            return;
          this.routes = _.result(this, 'routes');
          var route,
              routes = _.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function(match, optional) {
            return optional ? match : '([^/?]+)';
          }).replace(splatParam, '([^?]*?)');
          return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _.map(params, function(param, i) {
            if (i === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);
        if (typeof window !== 'undefined') {
          this.location = window.location;
          this.history = window.history;
        }
      };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var pathStripper = /#.*$/;
      History.started = false;
      _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function() {
          var path = this.location.pathname.replace(/[^\/]$/, '$&/');
          return path === this.root && !this.getSearch();
        },
        matchRoot: function() {
          var path = this.decodeFragment(this.location.pathname);
          var rootPath = path.slice(0, this.root.length - 1) + '/';
          return rootPath === this.root;
        },
        decodeFragment: function(fragment) {
          return decodeURI(fragment.replace(/%25/g, '%2525'));
        },
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
          return match ? match[0] : '';
        },
        getHash: function(window) {
          var match = (window || this).location.href.match(/#(.*)$/);
          return match ? match[1] : '';
        },
        getPath: function() {
          var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
          return path.charAt(0) === '/' ? path.slice(1) : path;
        },
        getFragment: function(fragment) {
          if (fragment == null) {
            if (this._usePushState || !this._wantsHashChange) {
              fragment = this.getPath();
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, '');
        },
        start: function(options) {
          if (History.started)
            throw new Error('Backbone.history has already been started');
          History.started = true;
          this.options = _.extend({root: '/'}, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
          this._useHashChange = this._wantsHashChange && this._hasHashChange;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.history && this.history.pushState);
          this._usePushState = this._wantsPushState && this._hasPushState;
          this.fragment = this.getFragment();
          this.root = ('/' + this.root + '/').replace(rootStripper, '/');
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              var rootPath = this.root.slice(0, -1) || '/';
              this.location.replace(rootPath + '#' + this.getPath());
              return true;
            } else if (this._hasPushState && this.atRoot()) {
              this.navigate(this.getHash(), {replace: true});
            }
          }
          if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
            this.iframe = document.createElement('iframe');
            this.iframe.src = 'javascript:0';
            this.iframe.style.display = 'none';
            this.iframe.tabIndex = -1;
            var body = document.body;
            var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
            iWindow.document.open();
            iWindow.document.close();
            iWindow.location.hash = '#' + this.fragment;
          }
          var addEventListener = window.addEventListener || function(eventName, listener) {
            return attachEvent('on' + eventName, listener);
          };
          if (this._usePushState) {
            addEventListener('popstate', this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            addEventListener('hashchange', this.checkUrl, false);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        stop: function() {
          var removeEventListener = window.removeEventListener || function(eventName, listener) {
            return detachEvent('on' + eventName, listener);
          };
          if (this._usePushState) {
            removeEventListener('popstate', this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            removeEventListener('hashchange', this.checkUrl, false);
          }
          if (this.iframe) {
            document.body.removeChild(this.iframe);
            this.iframe = null;
          }
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        route: function(route, callback) {
          this.handlers.unshift({
            route: route,
            callback: callback
          });
        },
        checkUrl: function(e) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe.contentWindow);
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        loadUrl: function(fragment) {
          if (!this.matchRoot())
            return false;
          fragment = this.fragment = this.getFragment(fragment);
          return _.some(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        navigate: function(fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = {trigger: !!options};
          fragment = this.getFragment(fragment || '');
          var rootPath = this.root;
          if (fragment === '' || fragment.charAt(0) === '?') {
            rootPath = rootPath.slice(0, -1) || '/';
          }
          var url = rootPath + fragment;
          fragment = this.decodeFragment(fragment.replace(pathStripper, ''));
          if (this.fragment === fragment)
            return;
          this.fragment = fragment;
          if (this._usePushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
              var iWindow = this.iframe.contentWindow;
              if (!options.replace) {
                iWindow.document.open();
                iWindow.document.close();
              }
              this._updateHash(iWindow.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
          if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, '');
            location.replace(href + '#' + fragment);
          } else {
            location.hash = '#' + fragment;
          }
        }
      });
      Backbone.history = new History;
      var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, 'constructor')) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        _.extend(child, parent, staticProps);
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
      };
      Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error)
            error.call(options.context, model, resp, options);
          model.trigger('error', model, resp, options);
        };
      };
      return Backbone;
    });
  })($__require('22'));
  return module.exports;
});

$__System.registerDynamic("52", ["bc"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('bc');
  return module.exports;
});

$__System.registerDynamic("bd", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function() {
    var root = this;
    var previousUnderscore = root._;
    var ArrayProto = Array.prototype,
        ObjProto = Object.prototype,
        FuncProto = Function.prototype;
    var push = ArrayProto.push,
        slice = ArrayProto.slice,
        toString = ObjProto.toString,
        hasOwnProperty = ObjProto.hasOwnProperty;
    var nativeIsArray = Array.isArray,
        nativeKeys = Object.keys,
        nativeBind = FuncProto.bind,
        nativeCreate = Object.create;
    var Ctor = function() {};
    var _ = function(obj) {
      if (obj instanceof _)
        return obj;
      if (!(this instanceof _))
        return new _(obj);
      this._wrapped = obj;
    };
    if (typeof exports !== 'undefined') {
      if (typeof module !== 'undefined' && module.exports) {
        exports = module.exports = _;
      }
      exports._ = _;
    } else {
      root._ = _;
    }
    _.VERSION = '1.8.3';
    var optimizeCb = function(func, context, argCount) {
      if (context === void 0)
        return func;
      switch (argCount == null ? 3 : argCount) {
        case 1:
          return function(value) {
            return func.call(context, value);
          };
        case 2:
          return function(value, other) {
            return func.call(context, value, other);
          };
        case 3:
          return function(value, index, collection) {
            return func.call(context, value, index, collection);
          };
        case 4:
          return function(accumulator, value, index, collection) {
            return func.call(context, accumulator, value, index, collection);
          };
      }
      return function() {
        return func.apply(context, arguments);
      };
    };
    var cb = function(value, context, argCount) {
      if (value == null)
        return _.identity;
      if (_.isFunction(value))
        return optimizeCb(value, context, argCount);
      if (_.isObject(value))
        return _.matcher(value);
      return _.property(value);
    };
    _.iteratee = function(value, context) {
      return cb(value, context, Infinity);
    };
    var createAssigner = function(keysFunc, undefinedOnly) {
      return function(obj) {
        var length = arguments.length;
        if (length < 2 || obj == null)
          return obj;
        for (var index = 1; index < length; index++) {
          var source = arguments[index],
              keys = keysFunc(source),
              l = keys.length;
          for (var i = 0; i < l; i++) {
            var key = keys[i];
            if (!undefinedOnly || obj[key] === void 0)
              obj[key] = source[key];
          }
        }
        return obj;
      };
    };
    var baseCreate = function(prototype) {
      if (!_.isObject(prototype))
        return {};
      if (nativeCreate)
        return nativeCreate(prototype);
      Ctor.prototype = prototype;
      var result = new Ctor;
      Ctor.prototype = null;
      return result;
    };
    var property = function(key) {
      return function(obj) {
        return obj == null ? void 0 : obj[key];
      };
    };
    var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
    var getLength = property('length');
    var isArrayLike = function(collection) {
      var length = getLength(collection);
      return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
    };
    _.each = _.forEach = function(obj, iteratee, context) {
      iteratee = optimizeCb(iteratee, context);
      var i,
          length;
      if (isArrayLike(obj)) {
        for (i = 0, length = obj.length; i < length; i++) {
          iteratee(obj[i], i, obj);
        }
      } else {
        var keys = _.keys(obj);
        for (i = 0, length = keys.length; i < length; i++) {
          iteratee(obj[keys[i]], keys[i], obj);
        }
      }
      return obj;
    };
    _.map = _.collect = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          results = Array(length);
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        results[index] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };
    function createReduce(dir) {
      function iterator(obj, iteratee, memo, keys, index, length) {
        for (; index >= 0 && index < length; index += dir) {
          var currentKey = keys ? keys[index] : index;
          memo = iteratee(memo, obj[currentKey], currentKey, obj);
        }
        return memo;
      }
      return function(obj, iteratee, memo, context) {
        iteratee = optimizeCb(iteratee, context, 4);
        var keys = !isArrayLike(obj) && _.keys(obj),
            length = (keys || obj).length,
            index = dir > 0 ? 0 : length - 1;
        if (arguments.length < 3) {
          memo = obj[keys ? keys[index] : index];
          index += dir;
        }
        return iterator(obj, iteratee, memo, keys, index, length);
      };
    }
    _.reduce = _.foldl = _.inject = createReduce(1);
    _.reduceRight = _.foldr = createReduce(-1);
    _.find = _.detect = function(obj, predicate, context) {
      var key;
      if (isArrayLike(obj)) {
        key = _.findIndex(obj, predicate, context);
      } else {
        key = _.findKey(obj, predicate, context);
      }
      if (key !== void 0 && key !== -1)
        return obj[key];
    };
    _.filter = _.select = function(obj, predicate, context) {
      var results = [];
      predicate = cb(predicate, context);
      _.each(obj, function(value, index, list) {
        if (predicate(value, index, list))
          results.push(value);
      });
      return results;
    };
    _.reject = function(obj, predicate, context) {
      return _.filter(obj, _.negate(cb(predicate)), context);
    };
    _.every = _.all = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (!predicate(obj[currentKey], currentKey, obj))
          return false;
      }
      return true;
    };
    _.some = _.any = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length;
      for (var index = 0; index < length; index++) {
        var currentKey = keys ? keys[index] : index;
        if (predicate(obj[currentKey], currentKey, obj))
          return true;
      }
      return false;
    };
    _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
      if (!isArrayLike(obj))
        obj = _.values(obj);
      if (typeof fromIndex != 'number' || guard)
        fromIndex = 0;
      return _.indexOf(obj, item, fromIndex) >= 0;
    };
    _.invoke = function(obj, method) {
      var args = slice.call(arguments, 2);
      var isFunc = _.isFunction(method);
      return _.map(obj, function(value) {
        var func = isFunc ? method : value[method];
        return func == null ? func : func.apply(value, args);
      });
    };
    _.pluck = function(obj, key) {
      return _.map(obj, _.property(key));
    };
    _.where = function(obj, attrs) {
      return _.filter(obj, _.matcher(attrs));
    };
    _.findWhere = function(obj, attrs) {
      return _.find(obj, _.matcher(attrs));
    };
    _.max = function(obj, iteratee, context) {
      var result = -Infinity,
          lastComputed = -Infinity,
          value,
          computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0,
            length = obj.length; i < length; i++) {
          value = obj[i];
          if (value > result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };
    _.min = function(obj, iteratee, context) {
      var result = Infinity,
          lastComputed = Infinity,
          value,
          computed;
      if (iteratee == null && obj != null) {
        obj = isArrayLike(obj) ? obj : _.values(obj);
        for (var i = 0,
            length = obj.length; i < length; i++) {
          value = obj[i];
          if (value < result) {
            result = value;
          }
        }
      } else {
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index, list) {
          computed = iteratee(value, index, list);
          if (computed < lastComputed || computed === Infinity && result === Infinity) {
            result = value;
            lastComputed = computed;
          }
        });
      }
      return result;
    };
    _.shuffle = function(obj) {
      var set = isArrayLike(obj) ? obj : _.values(obj);
      var length = set.length;
      var shuffled = Array(length);
      for (var index = 0,
          rand; index < length; index++) {
        rand = _.random(0, index);
        if (rand !== index)
          shuffled[index] = shuffled[rand];
        shuffled[rand] = set[index];
      }
      return shuffled;
    };
    _.sample = function(obj, n, guard) {
      if (n == null || guard) {
        if (!isArrayLike(obj))
          obj = _.values(obj);
        return obj[_.random(obj.length - 1)];
      }
      return _.shuffle(obj).slice(0, Math.max(0, n));
    };
    _.sortBy = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      return _.pluck(_.map(obj, function(value, index, list) {
        return {
          value: value,
          index: index,
          criteria: iteratee(value, index, list)
        };
      }).sort(function(left, right) {
        var a = left.criteria;
        var b = right.criteria;
        if (a !== b) {
          if (a > b || a === void 0)
            return 1;
          if (a < b || b === void 0)
            return -1;
        }
        return left.index - right.index;
      }), 'value');
    };
    var group = function(behavior) {
      return function(obj, iteratee, context) {
        var result = {};
        iteratee = cb(iteratee, context);
        _.each(obj, function(value, index) {
          var key = iteratee(value, index, obj);
          behavior(result, value, key);
        });
        return result;
      };
    };
    _.groupBy = group(function(result, value, key) {
      if (_.has(result, key))
        result[key].push(value);
      else
        result[key] = [value];
    });
    _.indexBy = group(function(result, value, key) {
      result[key] = value;
    });
    _.countBy = group(function(result, value, key) {
      if (_.has(result, key))
        result[key]++;
      else
        result[key] = 1;
    });
    _.toArray = function(obj) {
      if (!obj)
        return [];
      if (_.isArray(obj))
        return slice.call(obj);
      if (isArrayLike(obj))
        return _.map(obj, _.identity);
      return _.values(obj);
    };
    _.size = function(obj) {
      if (obj == null)
        return 0;
      return isArrayLike(obj) ? obj.length : _.keys(obj).length;
    };
    _.partition = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var pass = [],
          fail = [];
      _.each(obj, function(value, key, obj) {
        (predicate(value, key, obj) ? pass : fail).push(value);
      });
      return [pass, fail];
    };
    _.first = _.head = _.take = function(array, n, guard) {
      if (array == null)
        return void 0;
      if (n == null || guard)
        return array[0];
      return _.initial(array, array.length - n);
    };
    _.initial = function(array, n, guard) {
      return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
    };
    _.last = function(array, n, guard) {
      if (array == null)
        return void 0;
      if (n == null || guard)
        return array[array.length - 1];
      return _.rest(array, Math.max(0, array.length - n));
    };
    _.rest = _.tail = _.drop = function(array, n, guard) {
      return slice.call(array, n == null || guard ? 1 : n);
    };
    _.compact = function(array) {
      return _.filter(array, _.identity);
    };
    var flatten = function(input, shallow, strict, startIndex) {
      var output = [],
          idx = 0;
      for (var i = startIndex || 0,
          length = getLength(input); i < length; i++) {
        var value = input[i];
        if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
          if (!shallow)
            value = flatten(value, shallow, strict);
          var j = 0,
              len = value.length;
          output.length += len;
          while (j < len) {
            output[idx++] = value[j++];
          }
        } else if (!strict) {
          output[idx++] = value;
        }
      }
      return output;
    };
    _.flatten = function(array, shallow) {
      return flatten(array, shallow, false);
    };
    _.without = function(array) {
      return _.difference(array, slice.call(arguments, 1));
    };
    _.uniq = _.unique = function(array, isSorted, iteratee, context) {
      if (!_.isBoolean(isSorted)) {
        context = iteratee;
        iteratee = isSorted;
        isSorted = false;
      }
      if (iteratee != null)
        iteratee = cb(iteratee, context);
      var result = [];
      var seen = [];
      for (var i = 0,
          length = getLength(array); i < length; i++) {
        var value = array[i],
            computed = iteratee ? iteratee(value, i, array) : value;
        if (isSorted) {
          if (!i || seen !== computed)
            result.push(value);
          seen = computed;
        } else if (iteratee) {
          if (!_.contains(seen, computed)) {
            seen.push(computed);
            result.push(value);
          }
        } else if (!_.contains(result, value)) {
          result.push(value);
        }
      }
      return result;
    };
    _.union = function() {
      return _.uniq(flatten(arguments, true, true));
    };
    _.intersection = function(array) {
      var result = [];
      var argsLength = arguments.length;
      for (var i = 0,
          length = getLength(array); i < length; i++) {
        var item = array[i];
        if (_.contains(result, item))
          continue;
        for (var j = 1; j < argsLength; j++) {
          if (!_.contains(arguments[j], item))
            break;
        }
        if (j === argsLength)
          result.push(item);
      }
      return result;
    };
    _.difference = function(array) {
      var rest = flatten(arguments, true, true, 1);
      return _.filter(array, function(value) {
        return !_.contains(rest, value);
      });
    };
    _.zip = function() {
      return _.unzip(arguments);
    };
    _.unzip = function(array) {
      var length = array && _.max(array, getLength).length || 0;
      var result = Array(length);
      for (var index = 0; index < length; index++) {
        result[index] = _.pluck(array, index);
      }
      return result;
    };
    _.object = function(list, values) {
      var result = {};
      for (var i = 0,
          length = getLength(list); i < length; i++) {
        if (values) {
          result[list[i]] = values[i];
        } else {
          result[list[i][0]] = list[i][1];
        }
      }
      return result;
    };
    function createPredicateIndexFinder(dir) {
      return function(array, predicate, context) {
        predicate = cb(predicate, context);
        var length = getLength(array);
        var index = dir > 0 ? 0 : length - 1;
        for (; index >= 0 && index < length; index += dir) {
          if (predicate(array[index], index, array))
            return index;
        }
        return -1;
      };
    }
    _.findIndex = createPredicateIndexFinder(1);
    _.findLastIndex = createPredicateIndexFinder(-1);
    _.sortedIndex = function(array, obj, iteratee, context) {
      iteratee = cb(iteratee, context, 1);
      var value = iteratee(obj);
      var low = 0,
          high = getLength(array);
      while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (iteratee(array[mid]) < value)
          low = mid + 1;
        else
          high = mid;
      }
      return low;
    };
    function createIndexFinder(dir, predicateFind, sortedIndex) {
      return function(array, item, idx) {
        var i = 0,
            length = getLength(array);
        if (typeof idx == 'number') {
          if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
          } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
          }
        } else if (sortedIndex && idx && length) {
          idx = sortedIndex(array, item);
          return array[idx] === item ? idx : -1;
        }
        if (item !== item) {
          idx = predicateFind(slice.call(array, i, length), _.isNaN);
          return idx >= 0 ? idx + i : -1;
        }
        for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
          if (array[idx] === item)
            return idx;
        }
        return -1;
      };
    }
    _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
    _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);
    _.range = function(start, stop, step) {
      if (stop == null) {
        stop = start || 0;
        start = 0;
      }
      step = step || 1;
      var length = Math.max(Math.ceil((stop - start) / step), 0);
      var range = Array(length);
      for (var idx = 0; idx < length; idx++, start += step) {
        range[idx] = start;
      }
      return range;
    };
    var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
      if (!(callingContext instanceof boundFunc))
        return sourceFunc.apply(context, args);
      var self = baseCreate(sourceFunc.prototype);
      var result = sourceFunc.apply(self, args);
      if (_.isObject(result))
        return result;
      return self;
    };
    _.bind = function(func, context) {
      if (nativeBind && func.bind === nativeBind)
        return nativeBind.apply(func, slice.call(arguments, 1));
      if (!_.isFunction(func))
        throw new TypeError('Bind must be called on a function');
      var args = slice.call(arguments, 2);
      var bound = function() {
        return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
      };
      return bound;
    };
    _.partial = function(func) {
      var boundArgs = slice.call(arguments, 1);
      var bound = function() {
        var position = 0,
            length = boundArgs.length;
        var args = Array(length);
        for (var i = 0; i < length; i++) {
          args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
        }
        while (position < arguments.length)
          args.push(arguments[position++]);
        return executeBound(func, bound, this, this, args);
      };
      return bound;
    };
    _.bindAll = function(obj) {
      var i,
          length = arguments.length,
          key;
      if (length <= 1)
        throw new Error('bindAll must be passed function names');
      for (i = 1; i < length; i++) {
        key = arguments[i];
        obj[key] = _.bind(obj[key], obj);
      }
      return obj;
    };
    _.memoize = function(func, hasher) {
      var memoize = function(key) {
        var cache = memoize.cache;
        var address = '' + (hasher ? hasher.apply(this, arguments) : key);
        if (!_.has(cache, address))
          cache[address] = func.apply(this, arguments);
        return cache[address];
      };
      memoize.cache = {};
      return memoize;
    };
    _.delay = function(func, wait) {
      var args = slice.call(arguments, 2);
      return setTimeout(function() {
        return func.apply(null, args);
      }, wait);
    };
    _.defer = _.partial(_.delay, _, 1);
    _.throttle = function(func, wait, options) {
      var context,
          args,
          result;
      var timeout = null;
      var previous = 0;
      if (!options)
        options = {};
      var later = function() {
        previous = options.leading === false ? 0 : _.now();
        timeout = null;
        result = func.apply(context, args);
        if (!timeout)
          context = args = null;
      };
      return function() {
        var now = _.now();
        if (!previous && options.leading === false)
          previous = now;
        var remaining = wait - (now - previous);
        context = this;
        args = arguments;
        if (remaining <= 0 || remaining > wait) {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }
          previous = now;
          result = func.apply(context, args);
          if (!timeout)
            context = args = null;
        } else if (!timeout && options.trailing !== false) {
          timeout = setTimeout(later, remaining);
        }
        return result;
      };
    };
    _.debounce = function(func, wait, immediate) {
      var timeout,
          args,
          context,
          timestamp,
          result;
      var later = function() {
        var last = _.now() - timestamp;
        if (last < wait && last >= 0) {
          timeout = setTimeout(later, wait - last);
        } else {
          timeout = null;
          if (!immediate) {
            result = func.apply(context, args);
            if (!timeout)
              context = args = null;
          }
        }
      };
      return function() {
        context = this;
        args = arguments;
        timestamp = _.now();
        var callNow = immediate && !timeout;
        if (!timeout)
          timeout = setTimeout(later, wait);
        if (callNow) {
          result = func.apply(context, args);
          context = args = null;
        }
        return result;
      };
    };
    _.wrap = function(func, wrapper) {
      return _.partial(wrapper, func);
    };
    _.negate = function(predicate) {
      return function() {
        return !predicate.apply(this, arguments);
      };
    };
    _.compose = function() {
      var args = arguments;
      var start = args.length - 1;
      return function() {
        var i = start;
        var result = args[start].apply(this, arguments);
        while (i--)
          result = args[i].call(this, result);
        return result;
      };
    };
    _.after = function(times, func) {
      return function() {
        if (--times < 1) {
          return func.apply(this, arguments);
        }
      };
    };
    _.before = function(times, func) {
      var memo;
      return function() {
        if (--times > 0) {
          memo = func.apply(this, arguments);
        }
        if (times <= 1)
          func = null;
        return memo;
      };
    };
    _.once = _.partial(_.before, 2);
    var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
    var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];
    function collectNonEnumProps(obj, keys) {
      var nonEnumIdx = nonEnumerableProps.length;
      var constructor = obj.constructor;
      var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;
      var prop = 'constructor';
      if (_.has(obj, prop) && !_.contains(keys, prop))
        keys.push(prop);
      while (nonEnumIdx--) {
        prop = nonEnumerableProps[nonEnumIdx];
        if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
          keys.push(prop);
        }
      }
    }
    _.keys = function(obj) {
      if (!_.isObject(obj))
        return [];
      if (nativeKeys)
        return nativeKeys(obj);
      var keys = [];
      for (var key in obj)
        if (_.has(obj, key))
          keys.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys);
      return keys;
    };
    _.allKeys = function(obj) {
      if (!_.isObject(obj))
        return [];
      var keys = [];
      for (var key in obj)
        keys.push(key);
      if (hasEnumBug)
        collectNonEnumProps(obj, keys);
      return keys;
    };
    _.values = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var values = Array(length);
      for (var i = 0; i < length; i++) {
        values[i] = obj[keys[i]];
      }
      return values;
    };
    _.mapObject = function(obj, iteratee, context) {
      iteratee = cb(iteratee, context);
      var keys = _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
    };
    _.pairs = function(obj) {
      var keys = _.keys(obj);
      var length = keys.length;
      var pairs = Array(length);
      for (var i = 0; i < length; i++) {
        pairs[i] = [keys[i], obj[keys[i]]];
      }
      return pairs;
    };
    _.invert = function(obj) {
      var result = {};
      var keys = _.keys(obj);
      for (var i = 0,
          length = keys.length; i < length; i++) {
        result[obj[keys[i]]] = keys[i];
      }
      return result;
    };
    _.functions = _.methods = function(obj) {
      var names = [];
      for (var key in obj) {
        if (_.isFunction(obj[key]))
          names.push(key);
      }
      return names.sort();
    };
    _.extend = createAssigner(_.allKeys);
    _.extendOwn = _.assign = createAssigner(_.keys);
    _.findKey = function(obj, predicate, context) {
      predicate = cb(predicate, context);
      var keys = _.keys(obj),
          key;
      for (var i = 0,
          length = keys.length; i < length; i++) {
        key = keys[i];
        if (predicate(obj[key], key, obj))
          return key;
      }
    };
    _.pick = function(object, oiteratee, context) {
      var result = {},
          obj = object,
          iteratee,
          keys;
      if (obj == null)
        return result;
      if (_.isFunction(oiteratee)) {
        keys = _.allKeys(obj);
        iteratee = optimizeCb(oiteratee, context);
      } else {
        keys = flatten(arguments, false, false, 1);
        iteratee = function(value, key, obj) {
          return key in obj;
        };
        obj = Object(obj);
      }
      for (var i = 0,
          length = keys.length; i < length; i++) {
        var key = keys[i];
        var value = obj[key];
        if (iteratee(value, key, obj))
          result[key] = value;
      }
      return result;
    };
    _.omit = function(obj, iteratee, context) {
      if (_.isFunction(iteratee)) {
        iteratee = _.negate(iteratee);
      } else {
        var keys = _.map(flatten(arguments, false, false, 1), String);
        iteratee = function(value, key) {
          return !_.contains(keys, key);
        };
      }
      return _.pick(obj, iteratee, context);
    };
    _.defaults = createAssigner(_.allKeys, true);
    _.create = function(prototype, props) {
      var result = baseCreate(prototype);
      if (props)
        _.extendOwn(result, props);
      return result;
    };
    _.clone = function(obj) {
      if (!_.isObject(obj))
        return obj;
      return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
    };
    _.tap = function(obj, interceptor) {
      interceptor(obj);
      return obj;
    };
    _.isMatch = function(object, attrs) {
      var keys = _.keys(attrs),
          length = keys.length;
      if (object == null)
        return !length;
      var obj = Object(object);
      for (var i = 0; i < length; i++) {
        var key = keys[i];
        if (attrs[key] !== obj[key] || !(key in obj))
          return false;
      }
      return true;
    };
    var eq = function(a, b, aStack, bStack) {
      if (a === b)
        return a !== 0 || 1 / a === 1 / b;
      if (a == null || b == null)
        return a === b;
      if (a instanceof _)
        a = a._wrapped;
      if (b instanceof _)
        b = b._wrapped;
      var className = toString.call(a);
      if (className !== toString.call(b))
        return false;
      switch (className) {
        case '[object RegExp]':
        case '[object String]':
          return '' + a === '' + b;
        case '[object Number]':
          if (+a !== +a)
            return +b !== +b;
          return +a === 0 ? 1 / +a === 1 / b : +a === +b;
        case '[object Date]':
        case '[object Boolean]':
          return +a === +b;
      }
      var areArrays = className === '[object Array]';
      if (!areArrays) {
        if (typeof a != 'object' || typeof b != 'object')
          return false;
        var aCtor = a.constructor,
            bCtor = b.constructor;
        if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor && _.isFunction(bCtor) && bCtor instanceof bCtor) && ('constructor' in a && 'constructor' in b)) {
          return false;
        }
      }
      aStack = aStack || [];
      bStack = bStack || [];
      var length = aStack.length;
      while (length--) {
        if (aStack[length] === a)
          return bStack[length] === b;
      }
      aStack.push(a);
      bStack.push(b);
      if (areArrays) {
        length = a.length;
        if (length !== b.length)
          return false;
        while (length--) {
          if (!eq(a[length], b[length], aStack, bStack))
            return false;
        }
      } else {
        var keys = _.keys(a),
            key;
        length = keys.length;
        if (_.keys(b).length !== length)
          return false;
        while (length--) {
          key = keys[length];
          if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack)))
            return false;
        }
      }
      aStack.pop();
      bStack.pop();
      return true;
    };
    _.isEqual = function(a, b) {
      return eq(a, b);
    };
    _.isEmpty = function(obj) {
      if (obj == null)
        return true;
      if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj)))
        return obj.length === 0;
      return _.keys(obj).length === 0;
    };
    _.isElement = function(obj) {
      return !!(obj && obj.nodeType === 1);
    };
    _.isArray = nativeIsArray || function(obj) {
      return toString.call(obj) === '[object Array]';
    };
    _.isObject = function(obj) {
      var type = typeof obj;
      return type === 'function' || type === 'object' && !!obj;
    };
    _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
      _['is' + name] = function(obj) {
        return toString.call(obj) === '[object ' + name + ']';
      };
    });
    if (!_.isArguments(arguments)) {
      _.isArguments = function(obj) {
        return _.has(obj, 'callee');
      };
    }
    if (typeof/./ != 'function' && typeof Int8Array != 'object') {
      _.isFunction = function(obj) {
        return typeof obj == 'function' || false;
      };
    }
    _.isFinite = function(obj) {
      return isFinite(obj) && !isNaN(parseFloat(obj));
    };
    _.isNaN = function(obj) {
      return _.isNumber(obj) && obj !== +obj;
    };
    _.isBoolean = function(obj) {
      return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
    };
    _.isNull = function(obj) {
      return obj === null;
    };
    _.isUndefined = function(obj) {
      return obj === void 0;
    };
    _.has = function(obj, key) {
      return obj != null && hasOwnProperty.call(obj, key);
    };
    _.noConflict = function() {
      root._ = previousUnderscore;
      return this;
    };
    _.identity = function(value) {
      return value;
    };
    _.constant = function(value) {
      return function() {
        return value;
      };
    };
    _.noop = function() {};
    _.property = property;
    _.propertyOf = function(obj) {
      return obj == null ? function() {} : function(key) {
        return obj[key];
      };
    };
    _.matcher = _.matches = function(attrs) {
      attrs = _.extendOwn({}, attrs);
      return function(obj) {
        return _.isMatch(obj, attrs);
      };
    };
    _.times = function(n, iteratee, context) {
      var accum = Array(Math.max(0, n));
      iteratee = optimizeCb(iteratee, context, 1);
      for (var i = 0; i < n; i++)
        accum[i] = iteratee(i);
      return accum;
    };
    _.random = function(min, max) {
      if (max == null) {
        max = min;
        min = 0;
      }
      return min + Math.floor(Math.random() * (max - min + 1));
    };
    _.now = Date.now || function() {
      return new Date().getTime();
    };
    var escapeMap = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;',
      '`': '&#x60;'
    };
    var unescapeMap = _.invert(escapeMap);
    var createEscaper = function(map) {
      var escaper = function(match) {
        return map[match];
      };
      var source = '(?:' + _.keys(map).join('|') + ')';
      var testRegexp = RegExp(source);
      var replaceRegexp = RegExp(source, 'g');
      return function(string) {
        string = string == null ? '' : '' + string;
        return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
      };
    };
    _.escape = createEscaper(escapeMap);
    _.unescape = createEscaper(unescapeMap);
    _.result = function(object, property, fallback) {
      var value = object == null ? void 0 : object[property];
      if (value === void 0) {
        value = fallback;
      }
      return _.isFunction(value) ? value.call(object) : value;
    };
    var idCounter = 0;
    _.uniqueId = function(prefix) {
      var id = ++idCounter + '';
      return prefix ? prefix + id : id;
    };
    _.templateSettings = {
      evaluate: /<%([\s\S]+?)%>/g,
      interpolate: /<%=([\s\S]+?)%>/g,
      escape: /<%-([\s\S]+?)%>/g
    };
    var noMatch = /(.)^/;
    var escapes = {
      "'": "'",
      '\\': '\\',
      '\r': 'r',
      '\n': 'n',
      '\u2028': 'u2028',
      '\u2029': 'u2029'
    };
    var escaper = /\\|'|\r|\n|\u2028|\u2029/g;
    var escapeChar = function(match) {
      return '\\' + escapes[match];
    };
    _.template = function(text, settings, oldSettings) {
      if (!settings && oldSettings)
        settings = oldSettings;
      settings = _.defaults({}, settings, _.templateSettings);
      var matcher = RegExp([(settings.escape || noMatch).source, (settings.interpolate || noMatch).source, (settings.evaluate || noMatch).source].join('|') + '|$', 'g');
      var index = 0;
      var source = "__p+='";
      text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
        source += text.slice(index, offset).replace(escaper, escapeChar);
        index = offset + match.length;
        if (escape) {
          source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
        } else if (interpolate) {
          source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
        } else if (evaluate) {
          source += "';\n" + evaluate + "\n__p+='";
        }
        return match;
      });
      source += "';\n";
      if (!settings.variable)
        source = 'with(obj||{}){\n' + source + '}\n';
      source = "var __t,__p='',__j=Array.prototype.join," + "print=function(){__p+=__j.call(arguments,'');};\n" + source + 'return __p;\n';
      try {
        var render = new Function(settings.variable || 'obj', '_', source);
      } catch (e) {
        e.source = source;
        throw e;
      }
      var template = function(data) {
        return render.call(this, data, _);
      };
      var argument = settings.variable || 'obj';
      template.source = 'function(' + argument + '){\n' + source + '}';
      return template;
    };
    _.chain = function(obj) {
      var instance = _(obj);
      instance._chain = true;
      return instance;
    };
    var result = function(instance, obj) {
      return instance._chain ? _(obj).chain() : obj;
    };
    _.mixin = function(obj) {
      _.each(_.functions(obj), function(name) {
        var func = _[name] = obj[name];
        _.prototype[name] = function() {
          var args = [this._wrapped];
          push.apply(args, arguments);
          return result(this, func.apply(_, args));
        };
      });
    };
    _.mixin(_);
    _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        var obj = this._wrapped;
        method.apply(obj, arguments);
        if ((name === 'shift' || name === 'splice') && obj.length === 0)
          delete obj[0];
        return result(this, obj);
      };
    });
    _.each(['concat', 'join', 'slice'], function(name) {
      var method = ArrayProto[name];
      _.prototype[name] = function() {
        return result(this, method.apply(this._wrapped, arguments));
      };
    });
    _.prototype.value = function() {
      return this._wrapped;
    };
    _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;
    _.prototype.toString = function() {
      return '' + this._wrapped;
    };
    if (typeof define === 'function' && define.amd) {
      define('underscore', [], function() {
        return _;
      });
    }
  }.call(this));
  return module.exports;
});

$__System.registerDynamic("32", ["bd"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('bd');
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
(function(global, factory) {
  if (typeof module === "object" && typeof module.exports === "object") {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error("jQuery requires a window with a document");
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {
  var arr = [];
  var document = window.document;
  var slice = arr.slice;
  var concat = arr.concat;
  var push = arr.push;
  var indexOf = arr.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var version = "2.2.3",
      jQuery = function(selector, context) {
        return new jQuery.fn.init(selector, context);
      },
      rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,
      rmsPrefix = /^-ms-/,
      rdashAlpha = /-([\da-z])/gi,
      fcamelCase = function(all, letter) {
        return letter.toUpperCase();
      };
  jQuery.fn = jQuery.prototype = {
    jquery: version,
    constructor: jQuery,
    selector: "",
    length: 0,
    toArray: function() {
      return slice.call(this);
    },
    get: function(num) {
      return num != null ? (num < 0 ? this[num + this.length] : this[num]) : slice.call(this);
    },
    pushStack: function(elems) {
      var ret = jQuery.merge(this.constructor(), elems);
      ret.prevObject = this;
      ret.context = this.context;
      return ret;
    },
    each: function(callback) {
      return jQuery.each(this, callback);
    },
    map: function(callback) {
      return this.pushStack(jQuery.map(this, function(elem, i) {
        return callback.call(elem, i, elem);
      }));
    },
    slice: function() {
      return this.pushStack(slice.apply(this, arguments));
    },
    first: function() {
      return this.eq(0);
    },
    last: function() {
      return this.eq(-1);
    },
    eq: function(i) {
      var len = this.length,
          j = +i + (i < 0 ? len : 0);
      return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
    },
    end: function() {
      return this.prevObject || this.constructor();
    },
    push: push,
    sort: arr.sort,
    splice: arr.splice
  };
  jQuery.extend = jQuery.fn.extend = function() {
    var options,
        name,
        src,
        copy,
        copyIsArray,
        clone,
        target = arguments[0] || {},
        i = 1,
        length = arguments.length,
        deep = false;
    if (typeof target === "boolean") {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== "object" && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else if (copy !== undefined) {
            target[name] = copy;
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({
    expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
    isReady: true,
    error: function(msg) {
      throw new Error(msg);
    },
    noop: function() {},
    isFunction: function(obj) {
      return jQuery.type(obj) === "function";
    },
    isArray: Array.isArray,
    isWindow: function(obj) {
      return obj != null && obj === obj.window;
    },
    isNumeric: function(obj) {
      var realStringObj = obj && obj.toString();
      return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
    },
    isPlainObject: function(obj) {
      var key;
      if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
        return false;
      }
      if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
        return false;
      }
      for (key in obj) {}
      return key === undefined || hasOwn.call(obj, key);
    },
    isEmptyObject: function(obj) {
      var name;
      for (name in obj) {
        return false;
      }
      return true;
    },
    type: function(obj) {
      if (obj == null) {
        return obj + "";
      }
      return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
    },
    globalEval: function(code) {
      var script,
          indirect = eval;
      code = jQuery.trim(code);
      if (code) {
        if (code.indexOf("use strict") === 1) {
          script = document.createElement("script");
          script.text = code;
          document.head.appendChild(script).parentNode.removeChild(script);
        } else {
          indirect(code);
        }
      }
    },
    camelCase: function(string) {
      return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
    },
    nodeName: function(elem, name) {
      return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
    },
    each: function(obj, callback) {
      var length,
          i = 0;
      if (isArrayLike(obj)) {
        length = obj.length;
        for (; i < length; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) {
            break;
          }
        }
      }
      return obj;
    },
    trim: function(text) {
      return text == null ? "" : (text + "").replace(rtrim, "");
    },
    makeArray: function(arr, results) {
      var ret = results || [];
      if (arr != null) {
        if (isArrayLike(Object(arr))) {
          jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
        } else {
          push.call(ret, arr);
        }
      }
      return ret;
    },
    inArray: function(elem, arr, i) {
      return arr == null ? -1 : indexOf.call(arr, elem, i);
    },
    merge: function(first, second) {
      var len = +second.length,
          j = 0,
          i = first.length;
      for (; j < len; j++) {
        first[i++] = second[j];
      }
      first.length = i;
      return first;
    },
    grep: function(elems, callback, invert) {
      var callbackInverse,
          matches = [],
          i = 0,
          length = elems.length,
          callbackExpect = !invert;
      for (; i < length; i++) {
        callbackInverse = !callback(elems[i], i);
        if (callbackInverse !== callbackExpect) {
          matches.push(elems[i]);
        }
      }
      return matches;
    },
    map: function(elems, callback, arg) {
      var length,
          value,
          i = 0,
          ret = [];
      if (isArrayLike(elems)) {
        length = elems.length;
        for (; i < length; i++) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      } else {
        for (i in elems) {
          value = callback(elems[i], i, arg);
          if (value != null) {
            ret.push(value);
          }
        }
      }
      return concat.apply([], ret);
    },
    guid: 1,
    proxy: function(fn, context) {
      var tmp,
          args,
          proxy;
      if (typeof context === "string") {
        tmp = fn[context];
        context = fn;
        fn = tmp;
      }
      if (!jQuery.isFunction(fn)) {
        return undefined;
      }
      args = slice.call(arguments, 2);
      proxy = function() {
        return fn.apply(context || this, args.concat(slice.call(arguments)));
      };
      proxy.guid = fn.guid = fn.guid || jQuery.guid++;
      return proxy;
    },
    now: Date.now,
    support: support
  });
  if (typeof Symbol === "function") {
    jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
  }
  jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
    class2type["[object " + name + "]"] = name.toLowerCase();
  });
  function isArrayLike(obj) {
    var length = !!obj && "length" in obj && obj.length,
        type = jQuery.type(obj);
    if (type === "function" || jQuery.isWindow(obj)) {
      return false;
    }
    return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1) in obj;
  }
  var Sizzle = (function(window) {
    var i,
        support,
        Expr,
        getText,
        isXML,
        tokenize,
        compile,
        select,
        outermostContext,
        sortInput,
        hasDuplicate,
        setDocument,
        document,
        docElem,
        documentIsHTML,
        rbuggyQSA,
        rbuggyMatches,
        matches,
        contains,
        expando = "sizzle" + 1 * new Date(),
        preferredDoc = window.document,
        dirruns = 0,
        done = 0,
        classCache = createCache(),
        tokenCache = createCache(),
        compilerCache = createCache(),
        sortOrder = function(a, b) {
          if (a === b) {
            hasDuplicate = true;
          }
          return 0;
        },
        MAX_NEGATIVE = 1 << 31,
        hasOwn = ({}).hasOwnProperty,
        arr = [],
        pop = arr.pop,
        push_native = arr.push,
        push = arr.push,
        slice = arr.slice,
        indexOf = function(list, elem) {
          var i = 0,
              len = list.length;
          for (; i < len; i++) {
            if (list[i] === elem) {
              return i;
            }
          }
          return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        whitespace = "[\\x20\\t\\r\\n\\f]",
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + ".*" + ")\\)|)",
        rwhitespace = new RegExp(whitespace + "+", "g"),
        rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"),
        rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"),
        rpseudo = new RegExp(pseudos),
        ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
          "ID": new RegExp("^#(" + identifier + ")"),
          "CLASS": new RegExp("^\\.(" + identifier + ")"),
          "TAG": new RegExp("^(" + identifier + "|[*])"),
          "ATTR": new RegExp("^" + attributes),
          "PSEUDO": new RegExp("^" + pseudos),
          "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
          "bool": new RegExp("^(?:" + booleans + ")$", "i"),
          "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i,
        rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/,
        rescape = /'|\\/g,
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"),
        funescape = function(_, escaped, escapedWhitespace) {
          var high = "0x" + escaped - 0x10000;
          return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 0x10000) : String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        unloadHandler = function() {
          setDocument();
        };
    try {
      push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e) {
      push = {apply: arr.length ? function(target, els) {
          push_native.apply(target, slice.call(els));
        } : function(target, els) {
          var j = target.length,
              i = 0;
          while ((target[j++] = els[i++])) {}
          target.length = j - 1;
        }};
    }
    function Sizzle(selector, context, results, seed) {
      var m,
          i,
          elem,
          nid,
          nidselect,
          match,
          groups,
          newSelector,
          newContext = context && context.ownerDocument,
          nodeType = context ? context.nodeType : 9;
      results = results || [];
      if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {
        return results;
      }
      if (!seed) {
        if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
          setDocument(context);
        }
        context = context || document;
        if (documentIsHTML) {
          if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {
            if ((m = match[1])) {
              if (nodeType === 9) {
                if ((elem = context.getElementById(m))) {
                  if (elem.id === m) {
                    results.push(elem);
                    return results;
                  }
                } else {
                  return results;
                }
              } else {
                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {
                  results.push(elem);
                  return results;
                }
              }
            } else if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
              push.apply(results, context.getElementsByClassName(m));
              return results;
            }
          }
          if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
            if (nodeType !== 1) {
              newContext = context;
              newSelector = selector;
            } else if (context.nodeName.toLowerCase() !== "object") {
              if ((nid = context.getAttribute("id"))) {
                nid = nid.replace(rescape, "\\$&");
              } else {
                context.setAttribute("id", (nid = expando));
              }
              groups = tokenize(selector);
              i = groups.length;
              nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
              while (i--) {
                groups[i] = nidselect + " " + toSelector(groups[i]);
              }
              newSelector = groups.join(",");
              newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            }
            if (newSelector) {
              try {
                push.apply(results, newContext.querySelectorAll(newSelector));
                return results;
              } catch (qsaError) {} finally {
                if (nid === expando) {
                  context.removeAttribute("id");
                }
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, "$1"), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + " ") > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return (cache[key + " "] = value);
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement("div");
      try {
        return !!fn(div);
      } catch (e) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split("|"),
          i = arr.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a,
          diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while ((cur = cur.nextSibling)) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === "input" && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === "input" || name === "button") && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j,
              matchIndexes = fn([], seed.length, argument),
              i = matchIndexes.length;
          while (i--) {
            if (seed[(j = matchIndexes[i])]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== "undefined" && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== "HTML" : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare,
          parent,
          doc = node ? node.ownerDocument || node : preferredDoc;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = document.documentElement;
      documentIsHTML = !isXML(document);
      if ((parent = document.defaultView) && parent.top !== parent) {
        if (parent.addEventListener) {
          parent.addEventListener("unload", unloadHandler, false);
        } else if (parent.attachEvent) {
          parent.attachEvent("onunload", unloadHandler);
        }
      }
      support.attributes = assert(function(div) {
        div.className = "i";
        return !div.getAttribute("className");
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(document.createComment(""));
        return !div.getElementsByTagName("*").length;
      });
      support.getElementsByClassName = rnative.test(document.getElementsByClassName);
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !document.getElementsByName || !document.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find["ID"] = function(id, context) {
          if (typeof context.getElementById !== "undefined" && documentIsHTML) {
            var m = context.getElementById(id);
            return m ? [m] : [];
          }
        };
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute("id") === attrId;
          };
        };
      } else {
        delete Expr.find["ID"];
        Expr.filter["ID"] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
            return node && node.value === attrId;
          };
        };
      }
      Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== "undefined") {
          return context.getElementsByTagName(tag);
        } else if (support.qsa) {
          return context.querySelectorAll(tag);
        }
      } : function(tag, context) {
        var elem,
            tmp = [],
            i = 0,
            results = context.getElementsByTagName(tag);
        if (tag === "*") {
          while ((elem = results[i++])) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if ((support.qsa = rnative.test(document.querySelectorAll))) {
        assert(function(div) {
          docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";
          if (div.querySelectorAll("[msallowcapture^='']").length) {
            rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
          }
          if (!div.querySelectorAll("[selected]").length) {
            rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
          }
          if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
            rbuggyQSA.push("~=");
          }
          if (!div.querySelectorAll(":checked").length) {
            rbuggyQSA.push(":checked");
          }
          if (!div.querySelectorAll("a#" + expando + "+*").length) {
            rbuggyQSA.push(".#.+[+~]");
          }
        });
        assert(function(div) {
          var input = document.createElement("input");
          input.setAttribute("type", "hidden");
          div.appendChild(input).setAttribute("name", "D");
          if (div.querySelectorAll("[name=d]").length) {
            rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
          }
          if (!div.querySelectorAll(":enabled").length) {
            rbuggyQSA.push(":enabled", ":disabled");
          }
          div.querySelectorAll("*,:x");
          rbuggyQSA.push(",.*:");
        });
      }
      if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, "div");
          matches.call(div, "[s!='']:x");
          rbuggyMatches.push("!=", pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a,
            bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while ((b = b.parentNode)) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {
          if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur,
            i = 0,
            aup = a.parentNode,
            bup = b.parentNode,
            ap = [a],
            bp = [b];
        if (!aup || !bup) {
          return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
        } else if (aup === bup) {
          return siblingCheck(a, b);
        }
        cur = a;
        while ((cur = cur.parentNode)) {
          ap.unshift(cur);
        }
        cur = b;
        while ((cur = cur.parentNode)) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return document;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "='$1']");
      if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e) {}
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()],
          val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error("Syntax error, unrecognized expression: " + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem,
          duplicates = [],
          j = 0,
          i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while ((elem = results[i++])) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node,
          ret = "",
          i = 0,
          nodeType = elem.nodeType;
      if (!nodeType) {
        while ((node = elem[i++])) {
          ret += getText(node);
        }
      } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
        if (typeof elem.textContent === "string") {
          return elem.textContent;
        } else {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            ret += getText(elem);
          }
        }
      } else if (nodeType === 3 || nodeType === 4) {
        return elem.nodeValue;
      }
      return ret;
    };
    Expr = Sizzle.selectors = {
      cacheLength: 50,
      createPseudo: markFunction,
      match: matchExpr,
      attrHandle: {},
      find: {},
      relative: {
        ">": {
          dir: "parentNode",
          first: true
        },
        " ": {dir: "parentNode"},
        "+": {
          dir: "previousSibling",
          first: true
        },
        "~": {dir: "previousSibling"}
      },
      preFilter: {
        "ATTR": function(match) {
          match[1] = match[1].replace(runescape, funescape);
          match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);
          if (match[2] === "~=") {
            match[3] = " " + match[3] + " ";
          }
          return match.slice(0, 4);
        },
        "CHILD": function(match) {
          match[1] = match[1].toLowerCase();
          if (match[1].slice(0, 3) === "nth") {
            if (!match[3]) {
              Sizzle.error(match[0]);
            }
            match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
            match[5] = +((match[7] + match[8]) || match[3] === "odd");
          } else if (match[3]) {
            Sizzle.error(match[0]);
          }
          return match;
        },
        "PSEUDO": function(match) {
          var excess,
              unquoted = !match[6] && match[2];
          if (matchExpr["CHILD"].test(match[0])) {
            return null;
          }
          if (match[3]) {
            match[2] = match[4] || match[5] || "";
          } else if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {
            match[0] = match[0].slice(0, excess);
            match[2] = unquoted.slice(0, excess);
          }
          return match.slice(0, 3);
        }
      },
      filter: {
        "TAG": function(nodeNameSelector) {
          var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
          return nodeNameSelector === "*" ? function() {
            return true;
          } : function(elem) {
            return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
          };
        },
        "CLASS": function(className) {
          var pattern = classCache[className + " "];
          return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
            return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
          });
        },
        "ATTR": function(name, operator, check) {
          return function(elem) {
            var result = Sizzle.attr(elem, name);
            if (result == null) {
              return operator === "!=";
            }
            if (!operator) {
              return true;
            }
            result += "";
            return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
          };
        },
        "CHILD": function(type, what, argument, first, last) {
          var simple = type.slice(0, 3) !== "nth",
              forward = type.slice(-4) !== "last",
              ofType = what === "of-type";
          return first === 1 && last === 0 ? function(elem) {
            return !!elem.parentNode;
          } : function(elem, context, xml) {
            var cache,
                uniqueCache,
                outerCache,
                node,
                nodeIndex,
                start,
                dir = simple !== forward ? "nextSibling" : "previousSibling",
                parent = elem.parentNode,
                name = ofType && elem.nodeName.toLowerCase(),
                useCache = !xml && !ofType,
                diff = false;
            if (parent) {
              if (simple) {
                while (dir) {
                  node = elem;
                  while ((node = node[dir])) {
                    if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                      return false;
                    }
                  }
                  start = dir = type === "only" && !start && "nextSibling";
                }
                return true;
              }
              start = [forward ? parent.firstChild : parent.lastChild];
              if (forward && useCache) {
                node = parent;
                outerCache = node[expando] || (node[expando] = {});
                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                cache = uniqueCache[type] || [];
                nodeIndex = cache[0] === dirruns && cache[1];
                diff = nodeIndex && cache[2];
                node = nodeIndex && parent.childNodes[nodeIndex];
                while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                  if (node.nodeType === 1 && ++diff && node === elem) {
                    uniqueCache[type] = [dirruns, nodeIndex, diff];
                    break;
                  }
                }
              } else {
                if (useCache) {
                  node = elem;
                  outerCache = node[expando] || (node[expando] = {});
                  uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                  cache = uniqueCache[type] || [];
                  nodeIndex = cache[0] === dirruns && cache[1];
                  diff = nodeIndex;
                }
                if (diff === false) {
                  while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {
                    if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                      if (useCache) {
                        outerCache = node[expando] || (node[expando] = {});
                        uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});
                        uniqueCache[type] = [dirruns, diff];
                      }
                      if (node === elem) {
                        break;
                      }
                    }
                  }
                }
              }
              diff -= last;
              return diff === first || (diff % first === 0 && diff / first >= 0);
            }
          };
        },
        "PSEUDO": function(pseudo, argument) {
          var args,
              fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
          if (fn[expando]) {
            return fn(argument);
          }
          if (fn.length > 1) {
            args = [pseudo, pseudo, "", argument];
            return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
              var idx,
                  matched = fn(seed, argument),
                  i = matched.length;
              while (i--) {
                idx = indexOf(seed, matched[i]);
                seed[idx] = !(matches[idx] = matched[i]);
              }
            }) : function(elem) {
              return fn(elem, 0, args);
            };
          }
          return fn;
        }
      },
      pseudos: {
        "not": markFunction(function(selector) {
          var input = [],
              results = [],
              matcher = compile(selector.replace(rtrim, "$1"));
          return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
            var elem,
                unmatched = matcher(seed, null, xml, []),
                i = seed.length;
            while (i--) {
              if ((elem = unmatched[i])) {
                seed[i] = !(matches[i] = elem);
              }
            }
          }) : function(elem, context, xml) {
            input[0] = elem;
            matcher(input, null, xml, results);
            input[0] = null;
            return !results.pop();
          };
        }),
        "has": markFunction(function(selector) {
          return function(elem) {
            return Sizzle(selector, elem).length > 0;
          };
        }),
        "contains": markFunction(function(text) {
          text = text.replace(runescape, funescape);
          return function(elem) {
            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
          };
        }),
        "lang": markFunction(function(lang) {
          if (!ridentifier.test(lang || "")) {
            Sizzle.error("unsupported lang: " + lang);
          }
          lang = lang.replace(runescape, funescape).toLowerCase();
          return function(elem) {
            var elemLang;
            do {
              if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {
                elemLang = elemLang.toLowerCase();
                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
              }
            } while ((elem = elem.parentNode) && elem.nodeType === 1);
            return false;
          };
        }),
        "target": function(elem) {
          var hash = window.location && window.location.hash;
          return hash && hash.slice(1) === elem.id;
        },
        "root": function(elem) {
          return elem === docElem;
        },
        "focus": function(elem) {
          return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
        },
        "enabled": function(elem) {
          return elem.disabled === false;
        },
        "disabled": function(elem) {
          return elem.disabled === true;
        },
        "checked": function(elem) {
          var nodeName = elem.nodeName.toLowerCase();
          return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
        },
        "selected": function(elem) {
          if (elem.parentNode) {
            elem.parentNode.selectedIndex;
          }
          return elem.selected === true;
        },
        "empty": function(elem) {
          for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
            if (elem.nodeType < 6) {
              return false;
            }
          }
          return true;
        },
        "parent": function(elem) {
          return !Expr.pseudos["empty"](elem);
        },
        "header": function(elem) {
          return rheader.test(elem.nodeName);
        },
        "input": function(elem) {
          return rinputs.test(elem.nodeName);
        },
        "button": function(elem) {
          var name = elem.nodeName.toLowerCase();
          return name === "input" && elem.type === "button" || name === "button";
        },
        "text": function(elem) {
          var attr;
          return elem.nodeName.toLowerCase() === "input" && elem.type === "text" && ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
        },
        "first": createPositionalPseudo(function() {
          return [0];
        }),
        "last": createPositionalPseudo(function(matchIndexes, length) {
          return [length - 1];
        }),
        "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
          return [argument < 0 ? argument + length : argument];
        }),
        "even": createPositionalPseudo(function(matchIndexes, length) {
          var i = 0;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "odd": createPositionalPseudo(function(matchIndexes, length) {
          var i = 1;
          for (; i < length; i += 2) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; --i >= 0; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        }),
        "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
          var i = argument < 0 ? argument + length : argument;
          for (; ++i < length; ) {
            matchIndexes.push(i);
          }
          return matchIndexes;
        })
      }
    };
    Expr.pseudos["nth"] = Expr.pseudos["eq"];
    for (i in {
      radio: true,
      checkbox: true,
      file: true,
      password: true,
      image: true
    }) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in {
      submit: true,
      reset: true
    }) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {}
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters();
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched,
          match,
          tokens,
          type,
          soFar,
          groups,
          preFilters,
          cached = tokenCache[selector + " "];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push((tokens = []));
        }
        matched = false;
        if ((match = rcombinators.exec(soFar))) {
          matched = match.shift();
          tokens.push({
            value: matched,
            type: match[0].replace(rtrim, " ")
          });
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({
              value: matched,
              type: type,
              matches: match
            });
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0,
          len = tokens.length,
          selector = "";
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir,
          checkNonElements = base && dir === "parentNode",
          doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while ((elem = elem[dir])) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache,
            uniqueCache,
            outerCache,
            newCache = [dirruns, doneName];
        if (xml) {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while ((elem = elem[dir])) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});
              if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return (newCache[2] = oldCache[2]);
              } else {
                uniqueCache[dir] = newCache;
                if ((newCache[2] = matcher(elem, context, xml))) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0,
          len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem,
          newUnmatched = [],
          i = 0,
          len = unmatched.length,
          mapped = map != null;
      for (; i < len; i++) {
        if ((elem = unmatched[i])) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp,
            i,
            elem,
            preMap = [],
            postMap = [],
            preexisting = results.length,
            elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
            matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
            matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if ((elem = temp[i])) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if ((elem = matcherOut[i])) {
                  temp.push((matcherIn[i] = elem));
                }
              }
              postFinder(null, (matcherOut = []), temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext,
          matcher,
          j,
          len = tokens.length,
          leadingRelative = Expr.relative[tokens[0].type],
          implicitRelative = leadingRelative || Expr.relative[" "],
          i = leadingRelative ? 1 : 0,
          matchContext = addCombinator(function(elem) {
            return elem === checkContext;
          }, implicitRelative, true),
          matchAnyContext = addCombinator(function(elem) {
            return indexOf(checkContext, elem) > -1;
          }, implicitRelative, true),
          matchers = [function(elem, context, xml) {
            var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
            checkContext = null;
            return ret;
          }];
      for (; i < len; i++) {
        if ((matcher = Expr.relative[tokens[i].type])) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: tokens[i - 2].type === " " ? "*" : ""})).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0,
          byElement = elementMatchers.length > 0,
          superMatcher = function(seed, context, xml, results, outermost) {
            var elem,
                j,
                matcher,
                matchedCount = 0,
                i = "0",
                unmatched = seed && [],
                setMatched = [],
                contextBackup = outermostContext,
                elems = seed || byElement && Expr.find["TAG"]("*", outermost),
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
                len = elems.length;
            if (outermost) {
              outermostContext = context === document || context || outermost;
            }
            for (; i !== len && (elem = elems[i]) != null; i++) {
              if (byElement && elem) {
                j = 0;
                if (!context && elem.ownerDocument !== document) {
                  setDocument(elem);
                  xml = !documentIsHTML;
                }
                while ((matcher = elementMatchers[j++])) {
                  if (matcher(elem, context || document, xml)) {
                    results.push(elem);
                    break;
                  }
                }
                if (outermost) {
                  dirruns = dirrunsUnique;
                }
              }
              if (bySet) {
                if ((elem = !matcher && elem)) {
                  matchedCount--;
                }
                if (seed) {
                  unmatched.push(elem);
                }
              }
            }
            matchedCount += i;
            if (bySet && i !== matchedCount) {
              j = 0;
              while ((matcher = setMatchers[j++])) {
                matcher(unmatched, setMatched, context, xml);
              }
              if (seed) {
                if (matchedCount > 0) {
                  while (i--) {
                    if (!(unmatched[i] || setMatched[i])) {
                      setMatched[i] = pop.call(results);
                    }
                  }
                }
                setMatched = condense(setMatched);
              }
              push.apply(results, setMatched);
              if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {
                Sizzle.uniqueSort(results);
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
              outermostContext = contextBackup;
            }
            return unmatched;
          };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i,
          setMatchers = [],
          elementMatchers = [],
          cached = compilerCache[selector + " "];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i,
          tokens,
          token,
          type,
          find,
          compiled = typeof selector === "function" && selector,
          match = !seed && tokenize((selector = compiled.selector || selector));
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else if (compiled) {
            context = context.parentNode;
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[(type = token.type)]) {
            break;
          }
          if ((find = Expr.find[type])) {
            if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split("").sort(sortOrder).join("") === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement("div")) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "<a href='#'></a>";
      return div.firstChild.getAttribute("href") === "#";
    })) {
      addHandle("type|href|height|width", function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = "<input/>";
      div.firstChild.setAttribute("value", "");
      return div.firstChild.getAttribute("value") === "";
    })) {
      addHandle("value", function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === "input") {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute("disabled") == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  })(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[":"] = jQuery.expr.pseudos;
  jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var dir = function(elem, dir, until) {
    var matched = [],
        truncate = until !== undefined;
    while ((elem = elem[dir]) && elem.nodeType !== 9) {
      if (elem.nodeType === 1) {
        if (truncate && jQuery(elem).is(until)) {
          break;
        }
        matched.push(elem);
      }
    }
    return matched;
  };
  var siblings = function(n, elem) {
    var matched = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        matched.push(n);
      }
    }
    return matched;
  };
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return (elem === qualifier) !== not;
      });
    }
    if (typeof qualifier === "string") {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return (indexOf.call(qualifier, elem) > -1) !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ":not(" + expr + ")";
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({
    find: function(selector) {
      var i,
          len = this.length,
          ret = [],
          self = this;
      if (typeof selector !== "string") {
        return this.pushStack(jQuery(selector).filter(function() {
          for (i = 0; i < len; i++) {
            if (jQuery.contains(self[i], this)) {
              return true;
            }
          }
        }));
      }
      for (i = 0; i < len; i++) {
        jQuery.find(selector, self[i], ret);
      }
      ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
      ret.selector = this.selector ? this.selector + " " + selector : selector;
      return ret;
    },
    filter: function(selector) {
      return this.pushStack(winnow(this, selector || [], false));
    },
    not: function(selector) {
      return this.pushStack(winnow(this, selector || [], true));
    },
    is: function(selector) {
      return !!winnow(this, typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
    }
  });
  var rootjQuery,
      rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
      init = jQuery.fn.init = function(selector, context, root) {
        var match,
            elem;
        if (!selector) {
          return this;
        }
        root = root || rootjQuery;
        if (typeof selector === "string") {
          if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {
            match = [null, selector, null];
          } else {
            match = rquickExpr.exec(selector);
          }
          if (match && (match[1] || !context)) {
            if (match[1]) {
              context = context instanceof jQuery ? context[0] : context;
              jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
              if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                for (match in context) {
                  if (jQuery.isFunction(this[match])) {
                    this[match](context[match]);
                  } else {
                    this.attr(match, context[match]);
                  }
                }
              }
              return this;
            } else {
              elem = document.getElementById(match[2]);
              if (elem && elem.parentNode) {
                this.length = 1;
                this[0] = elem;
              }
              this.context = document;
              this.selector = selector;
              return this;
            }
          } else if (!context || context.jquery) {
            return (context || root).find(selector);
          } else {
            return this.constructor(context).find(selector);
          }
        } else if (selector.nodeType) {
          this.context = this[0] = selector;
          this.length = 1;
          return this;
        } else if (jQuery.isFunction(selector)) {
          return root.ready !== undefined ? root.ready(selector) : selector(jQuery);
        }
        if (selector.selector !== undefined) {
          this.selector = selector.selector;
          this.context = selector.context;
        }
        return jQuery.makeArray(selector, this);
      };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/,
      guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
      };
  jQuery.fn.extend({
    has: function(target) {
      var targets = jQuery(target, this),
          l = targets.length;
      return this.filter(function() {
        var i = 0;
        for (; i < l; i++) {
          if (jQuery.contains(this, targets[i])) {
            return true;
          }
        }
      });
    },
    closest: function(selectors, context) {
      var cur,
          i = 0,
          l = this.length,
          matched = [],
          pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;
      for (; i < l; i++) {
        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
          if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
            matched.push(cur);
            break;
          }
        }
      }
      return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
    },
    index: function(elem) {
      if (!elem) {
        return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
      }
      if (typeof elem === "string") {
        return indexOf.call(jQuery(elem), this[0]);
      }
      return indexOf.call(this, elem.jquery ? elem[0] : elem);
    },
    add: function(selector, context) {
      return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
    },
    addBack: function(selector) {
      return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
    }
  });
  function sibling(cur, dir) {
    while ((cur = cur[dir]) && cur.nodeType !== 1) {}
    return cur;
  }
  jQuery.each({
    parent: function(elem) {
      var parent = elem.parentNode;
      return parent && parent.nodeType !== 11 ? parent : null;
    },
    parents: function(elem) {
      return dir(elem, "parentNode");
    },
    parentsUntil: function(elem, i, until) {
      return dir(elem, "parentNode", until);
    },
    next: function(elem) {
      return sibling(elem, "nextSibling");
    },
    prev: function(elem) {
      return sibling(elem, "previousSibling");
    },
    nextAll: function(elem) {
      return dir(elem, "nextSibling");
    },
    prevAll: function(elem) {
      return dir(elem, "previousSibling");
    },
    nextUntil: function(elem, i, until) {
      return dir(elem, "nextSibling", until);
    },
    prevUntil: function(elem, i, until) {
      return dir(elem, "previousSibling", until);
    },
    siblings: function(elem) {
      return siblings((elem.parentNode || {}).firstChild, elem);
    },
    children: function(elem) {
      return siblings(elem.firstChild);
    },
    contents: function(elem) {
      return elem.contentDocument || jQuery.merge([], elem.childNodes);
    }
  }, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var matched = jQuery.map(this, fn, until);
      if (name.slice(-5) !== "Until") {
        selector = until;
      }
      if (selector && typeof selector === "string") {
        matched = jQuery.filter(selector, matched);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          jQuery.uniqueSort(matched);
        }
        if (rparentsprev.test(name)) {
          matched.reverse();
        }
      }
      return this.pushStack(matched);
    };
  });
  var rnotwhite = (/\S+/g);
  function createOptions(options) {
    var object = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);
    var firing,
        memory,
        fired,
        locked,
        list = [],
        queue = [],
        firingIndex = -1,
        fire = function() {
          locked = options.once;
          fired = firing = true;
          for (; queue.length; firingIndex = -1) {
            memory = queue.shift();
            while (++firingIndex < list.length) {
              if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {
                firingIndex = list.length;
                memory = false;
              }
            }
          }
          if (!options.memory) {
            memory = false;
          }
          firing = false;
          if (locked) {
            if (memory) {
              list = [];
            } else {
              list = "";
            }
          }
        },
        self = {
          add: function() {
            if (list) {
              if (memory && !firing) {
                firingIndex = list.length - 1;
                queue.push(memory);
              }
              (function add(args) {
                jQuery.each(args, function(_, arg) {
                  if (jQuery.isFunction(arg)) {
                    if (!options.unique || !self.has(arg)) {
                      list.push(arg);
                    }
                  } else if (arg && arg.length && jQuery.type(arg) !== "string") {
                    add(arg);
                  }
                });
              })(arguments);
              if (memory && !firing) {
                fire();
              }
            }
            return this;
          },
          remove: function() {
            jQuery.each(arguments, function(_, arg) {
              var index;
              while ((index = jQuery.inArray(arg, list, index)) > -1) {
                list.splice(index, 1);
                if (index <= firingIndex) {
                  firingIndex--;
                }
              }
            });
            return this;
          },
          has: function(fn) {
            return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
          },
          empty: function() {
            if (list) {
              list = [];
            }
            return this;
          },
          disable: function() {
            locked = queue = [];
            list = memory = "";
            return this;
          },
          disabled: function() {
            return !list;
          },
          lock: function() {
            locked = queue = [];
            if (!memory) {
              list = memory = "";
            }
            return this;
          },
          locked: function() {
            return !!locked;
          },
          fireWith: function(context, args) {
            if (!locked) {
              args = args || [];
              args = [context, args.slice ? args.slice() : args];
              queue.push(args);
              if (!firing) {
                fire();
              }
            }
            return this;
          },
          fire: function() {
            self.fireWith(this, arguments);
            return this;
          },
          fired: function() {
            return !!fired;
          }
        };
    return self;
  };
  jQuery.extend({
    Deferred: function(func) {
      var tuples = [["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]],
          state = "pending",
          promise = {
            state: function() {
              return state;
            },
            always: function() {
              deferred.done(arguments).fail(arguments);
              return this;
            },
            then: function() {
              var fns = arguments;
              return jQuery.Deferred(function(newDefer) {
                jQuery.each(tuples, function(i, tuple) {
                  var fn = jQuery.isFunction(fns[i]) && fns[i];
                  deferred[tuple[1]](function() {
                    var returned = fn && fn.apply(this, arguments);
                    if (returned && jQuery.isFunction(returned.promise)) {
                      returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                    } else {
                      newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                    }
                  });
                });
                fns = null;
              }).promise();
            },
            promise: function(obj) {
              return obj != null ? jQuery.extend(obj, promise) : promise;
            }
          },
          deferred = {};
      promise.pipe = promise.then;
      jQuery.each(tuples, function(i, tuple) {
        var list = tuple[2],
            stateString = tuple[3];
        promise[tuple[1]] = list.add;
        if (stateString) {
          list.add(function() {
            state = stateString;
          }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
        }
        deferred[tuple[0]] = function() {
          deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
          return this;
        };
        deferred[tuple[0] + "With"] = list.fireWith;
      });
      promise.promise(deferred);
      if (func) {
        func.call(deferred, deferred);
      }
      return deferred;
    },
    when: function(subordinate) {
      var i = 0,
          resolveValues = slice.call(arguments),
          length = resolveValues.length,
          remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
          deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
          updateFunc = function(i, contexts, values) {
            return function(value) {
              contexts[i] = this;
              values[i] = arguments.length > 1 ? slice.call(arguments) : value;
              if (values === progressValues) {
                deferred.notifyWith(contexts, values);
              } else if (!(--remaining)) {
                deferred.resolveWith(contexts, values);
              }
            };
          },
          progressValues,
          progressContexts,
          resolveContexts;
      if (length > 1) {
        progressValues = new Array(length);
        progressContexts = new Array(length);
        resolveContexts = new Array(length);
        for (; i < length; i++) {
          if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
            resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
          } else {
            --remaining;
          }
        }
      }
      if (!remaining) {
        deferred.resolveWith(resolveContexts, resolveValues);
      }
      return deferred.promise();
    }
  });
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({
    isReady: false,
    readyWait: 1,
    holdReady: function(hold) {
      if (hold) {
        jQuery.readyWait++;
      } else {
        jQuery.ready(true);
      }
    },
    ready: function(wait) {
      if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
        return;
      }
      jQuery.isReady = true;
      if (wait !== true && --jQuery.readyWait > 0) {
        return;
      }
      readyList.resolveWith(document, [jQuery]);
      if (jQuery.fn.triggerHandler) {
        jQuery(document).triggerHandler("ready");
        jQuery(document).off("ready");
      }
    }
  });
  function completed() {
    document.removeEventListener("DOMContentLoaded", completed);
    window.removeEventListener("load", completed);
    jQuery.ready();
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {
        window.setTimeout(jQuery.ready);
      } else {
        document.addEventListener("DOMContentLoaded", completed);
        window.addEventListener("load", completed);
      }
    }
    return readyList.promise(obj);
  };
  jQuery.ready.promise();
  var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0,
        len = elems.length,
        bulk = key == null;
    if (jQuery.type(key) === "object") {
      chainable = true;
      for (i in key) {
        access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else if (value !== undefined) {
      chainable = true;
      if (!jQuery.isFunction(value)) {
        raw = true;
      }
      if (bulk) {
        if (raw) {
          fn.call(elems, value);
          fn = null;
        } else {
          bulk = fn;
          fn = function(elem, key, value) {
            return bulk.call(jQuery(elem), value);
          };
        }
      }
      if (fn) {
        for (; i < len; i++) {
          fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
  };
  var acceptData = function(owner) {
    return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
  };
  function Data() {
    this.expando = jQuery.expando + Data.uid++;
  }
  Data.uid = 1;
  Data.prototype = {
    register: function(owner, initial) {
      var value = initial || {};
      if (owner.nodeType) {
        owner[this.expando] = value;
      } else {
        Object.defineProperty(owner, this.expando, {
          value: value,
          writable: true,
          configurable: true
        });
      }
      return owner[this.expando];
    },
    cache: function(owner) {
      if (!acceptData(owner)) {
        return {};
      }
      var value = owner[this.expando];
      if (!value) {
        value = {};
        if (acceptData(owner)) {
          if (owner.nodeType) {
            owner[this.expando] = value;
          } else {
            Object.defineProperty(owner, this.expando, {
              value: value,
              configurable: true
            });
          }
        }
      }
      return value;
    },
    set: function(owner, data, value) {
      var prop,
          cache = this.cache(owner);
      if (typeof data === "string") {
        cache[data] = value;
      } else {
        for (prop in data) {
          cache[prop] = data[prop];
        }
      }
      return cache;
    },
    get: function(owner, key) {
      return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
    },
    access: function(owner, key, value) {
      var stored;
      if (key === undefined || ((key && typeof key === "string") && value === undefined)) {
        stored = this.get(owner, key);
        return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
      }
      this.set(owner, key, value);
      return value !== undefined ? value : key;
    },
    remove: function(owner, key) {
      var i,
          name,
          camel,
          cache = owner[this.expando];
      if (cache === undefined) {
        return;
      }
      if (key === undefined) {
        this.register(owner);
      } else {
        if (jQuery.isArray(key)) {
          name = key.concat(key.map(jQuery.camelCase));
        } else {
          camel = jQuery.camelCase(key);
          if (key in cache) {
            name = [key, camel];
          } else {
            name = camel;
            name = name in cache ? [name] : (name.match(rnotwhite) || []);
          }
        }
        i = name.length;
        while (i--) {
          delete cache[name[i]];
        }
      }
      if (key === undefined || jQuery.isEmptyObject(cache)) {
        if (owner.nodeType) {
          owner[this.expando] = undefined;
        } else {
          delete owner[this.expando];
        }
      }
    },
    hasData: function(owner) {
      var cache = owner[this.expando];
      return cache !== undefined && !jQuery.isEmptyObject(cache);
    }
  };
  var dataPriv = new Data();
  var dataUser = new Data();
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
      rmultiDash = /[A-Z]/g;
  function dataAttr(elem, key, data) {
    var name;
    if (data === undefined && elem.nodeType === 1) {
      name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === "string") {
        try {
          data = data === "true" ? true : data === "false" ? false : data === "null" ? null : +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e) {}
        dataUser.set(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  jQuery.extend({
    hasData: function(elem) {
      return dataUser.hasData(elem) || dataPriv.hasData(elem);
    },
    data: function(elem, name, data) {
      return dataUser.access(elem, name, data);
    },
    removeData: function(elem, name) {
      dataUser.remove(elem, name);
    },
    _data: function(elem, name, data) {
      return dataPriv.access(elem, name, data);
    },
    _removeData: function(elem, name) {
      dataPriv.remove(elem, name);
    }
  });
  jQuery.fn.extend({
    data: function(key, value) {
      var i,
          name,
          data,
          elem = this[0],
          attrs = elem && elem.attributes;
      if (key === undefined) {
        if (this.length) {
          data = dataUser.get(elem);
          if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
            i = attrs.length;
            while (i--) {
              if (attrs[i]) {
                name = attrs[i].name;
                if (name.indexOf("data-") === 0) {
                  name = jQuery.camelCase(name.slice(5));
                  dataAttr(elem, name, data[name]);
                }
              }
            }
            dataPriv.set(elem, "hasDataAttrs", true);
          }
        }
        return data;
      }
      if (typeof key === "object") {
        return this.each(function() {
          dataUser.set(this, key);
        });
      }
      return access(this, function(value) {
        var data,
            camelKey;
        if (elem && value === undefined) {
          data = dataUser.get(elem, key) || dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());
          if (data !== undefined) {
            return data;
          }
          camelKey = jQuery.camelCase(key);
          data = dataUser.get(elem, camelKey);
          if (data !== undefined) {
            return data;
          }
          data = dataAttr(elem, camelKey, undefined);
          if (data !== undefined) {
            return data;
          }
          return;
        }
        camelKey = jQuery.camelCase(key);
        this.each(function() {
          var data = dataUser.get(this, camelKey);
          dataUser.set(this, camelKey, value);
          if (key.indexOf("-") > -1 && data !== undefined) {
            dataUser.set(this, key, value);
          }
        });
      }, null, value, arguments.length > 1, null, true);
    },
    removeData: function(key) {
      return this.each(function() {
        dataUser.remove(this, key);
      });
    }
  });
  jQuery.extend({
    queue: function(elem, type, data) {
      var queue;
      if (elem) {
        type = (type || "fx") + "queue";
        queue = dataPriv.get(elem, type);
        if (data) {
          if (!queue || jQuery.isArray(data)) {
            queue = dataPriv.access(elem, type, jQuery.makeArray(data));
          } else {
            queue.push(data);
          }
        }
        return queue || [];
      }
    },
    dequeue: function(elem, type) {
      type = type || "fx";
      var queue = jQuery.queue(elem, type),
          startLength = queue.length,
          fn = queue.shift(),
          hooks = jQuery._queueHooks(elem, type),
          next = function() {
            jQuery.dequeue(elem, type);
          };
      if (fn === "inprogress") {
        fn = queue.shift();
        startLength--;
      }
      if (fn) {
        if (type === "fx") {
          queue.unshift("inprogress");
        }
        delete hooks.stop;
        fn.call(elem, next, hooks);
      }
      if (!startLength && hooks) {
        hooks.empty.fire();
      }
    },
    _queueHooks: function(elem, type) {
      var key = type + "queueHooks";
      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {empty: jQuery.Callbacks("once memory").add(function() {
          dataPriv.remove(elem, [type + "queue", key]);
        })});
    }
  });
  jQuery.fn.extend({
    queue: function(type, data) {
      var setter = 2;
      if (typeof type !== "string") {
        data = type;
        type = "fx";
        setter--;
      }
      if (arguments.length < setter) {
        return jQuery.queue(this[0], type);
      }
      return data === undefined ? this : this.each(function() {
        var queue = jQuery.queue(this, type, data);
        jQuery._queueHooks(this, type);
        if (type === "fx" && queue[0] !== "inprogress") {
          jQuery.dequeue(this, type);
        }
      });
    },
    dequeue: function(type) {
      return this.each(function() {
        jQuery.dequeue(this, type);
      });
    },
    clearQueue: function(type) {
      return this.queue(type || "fx", []);
    },
    promise: function(type, obj) {
      var tmp,
          count = 1,
          defer = jQuery.Deferred(),
          elements = this,
          i = this.length,
          resolve = function() {
            if (!(--count)) {
              defer.resolveWith(elements, [elements]);
            }
          };
      if (typeof type !== "string") {
        obj = type;
        type = undefined;
      }
      type = type || "fx";
      while (i--) {
        tmp = dataPriv.get(elements[i], type + "queueHooks");
        if (tmp && tmp.empty) {
          count++;
          tmp.empty.add(resolve);
        }
      }
      resolve();
      return defer.promise(obj);
    }
  });
  var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;
  var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i");
  var cssExpand = ["Top", "Right", "Bottom", "Left"];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
  };
  function adjustCSS(elem, prop, valueParts, tween) {
    var adjusted,
        scale = 1,
        maxIterations = 20,
        currentValue = tween ? function() {
          return tween.cur();
        } : function() {
          return jQuery.css(elem, prop, "");
        },
        initial = currentValue(),
        unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));
    if (initialInUnit && initialInUnit[3] !== unit) {
      unit = unit || initialInUnit[3];
      valueParts = valueParts || [];
      initialInUnit = +initial || 1;
      do {
        scale = scale || ".5";
        initialInUnit = initialInUnit / scale;
        jQuery.style(elem, prop, initialInUnit + unit);
      } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
    }
    if (valueParts) {
      initialInUnit = +initialInUnit || +initial || 0;
      adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
      if (tween) {
        tween.unit = unit;
        tween.start = initialInUnit;
        tween.end = adjusted;
      }
    }
    return adjusted;
  }
  var rcheckableType = (/^(?:checkbox|radio)$/i);
  var rtagName = (/<([\w:-]+)/);
  var rscriptType = (/^$|\/(?:java|ecma)script/i);
  var wrapMap = {
    option: [1, "<select multiple='multiple'>", "</select>"],
    thead: [1, "<table>", "</table>"],
    col: [2, "<table><colgroup>", "</colgroup></table>"],
    tr: [2, "<table><tbody>", "</tbody></table>"],
    td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
    _default: [0, "", ""]
  };
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
  }
  function setGlobalEval(elems, refElements) {
    var i = 0,
        l = elems.length;
    for (; i < l; i++) {
      dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
    }
  }
  var rhtml = /<|&#?\w+;/;
  function buildFragment(elems, context, scripts, selection, ignored) {
    var elem,
        tmp,
        tag,
        wrap,
        contains,
        j,
        fragment = context.createDocumentFragment(),
        nodes = [],
        i = 0,
        l = elems.length;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === "object") {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else if (!rhtml.test(elem)) {
          nodes.push(context.createTextNode(elem));
        } else {
          tmp = tmp || fragment.appendChild(context.createElement("div"));
          tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
          wrap = wrapMap[tag] || wrapMap._default;
          tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];
          j = wrap[0];
          while (j--) {
            tmp = tmp.lastChild;
          }
          jQuery.merge(nodes, tmp.childNodes);
          tmp = fragment.firstChild;
          tmp.textContent = "";
        }
      }
    }
    fragment.textContent = "";
    i = 0;
    while ((elem = nodes[i++])) {
      if (selection && jQuery.inArray(elem, selection) > -1) {
        if (ignored) {
          ignored.push(elem);
        }
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(fragment.appendChild(elem), "script");
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while ((elem = tmp[j++])) {
          if (rscriptType.test(elem.type || "")) {
            scripts.push(elem);
          }
        }
      }
    }
    return fragment;
  }
  (function() {
    var fragment = document.createDocumentFragment(),
        div = fragment.appendChild(document.createElement("div")),
        input = document.createElement("input");
    input.setAttribute("type", "radio");
    input.setAttribute("checked", "checked");
    input.setAttribute("name", "t");
    div.appendChild(input);
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    div.innerHTML = "<textarea>x</textarea>";
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
  })();
  var rkeyEvent = /^key/,
      rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
      rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {}
  }
  function on(elem, types, selector, data, fn, one) {
    var origFn,
        type;
    if (typeof types === "object") {
      if (typeof selector !== "string") {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        on(elem, type, selector, data, types[type], one);
      }
      return elem;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else if (fn == null) {
      if (typeof selector === "string") {
        fn = data;
        data = undefined;
      } else {
        fn = data;
        data = selector;
        selector = undefined;
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else if (!fn) {
      return elem;
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return elem.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }
  jQuery.event = {
    global: {},
    add: function(elem, types, handler, data, selector) {
      var handleObjIn,
          eventHandle,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.get(elem);
      if (!elemData) {
        return;
      }
      if (handler.handler) {
        handleObjIn = handler;
        handler = handleObjIn.handler;
        selector = handleObjIn.selector;
      }
      if (!handler.guid) {
        handler.guid = jQuery.guid++;
      }
      if (!(events = elemData.events)) {
        events = elemData.events = {};
      }
      if (!(eventHandle = elemData.handle)) {
        eventHandle = elemData.handle = function(e) {
          return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
        };
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        special = jQuery.event.special[type] || {};
        handleObj = jQuery.extend({
          type: type,
          origType: origType,
          data: data,
          handler: handler,
          guid: handler.guid,
          selector: selector,
          needsContext: selector && jQuery.expr.match.needsContext.test(selector),
          namespace: namespaces.join(".")
        }, handleObjIn);
        if (!(handlers = events[type])) {
          handlers = events[type] = [];
          handlers.delegateCount = 0;
          if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
            if (elem.addEventListener) {
              elem.addEventListener(type, eventHandle);
            }
          }
        }
        if (special.add) {
          special.add.call(elem, handleObj);
          if (!handleObj.handler.guid) {
            handleObj.handler.guid = handler.guid;
          }
        }
        if (selector) {
          handlers.splice(handlers.delegateCount++, 0, handleObj);
        } else {
          handlers.push(handleObj);
        }
        jQuery.event.global[type] = true;
      }
    },
    remove: function(elem, types, handler, selector, mappedTypes) {
      var j,
          origCount,
          tmp,
          events,
          t,
          handleObj,
          special,
          handlers,
          type,
          namespaces,
          origType,
          elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
      if (!elemData || !(events = elemData.events)) {
        return;
      }
      types = (types || "").match(rnotwhite) || [""];
      t = types.length;
      while (t--) {
        tmp = rtypenamespace.exec(types[t]) || [];
        type = origType = tmp[1];
        namespaces = (tmp[2] || "").split(".").sort();
        if (!type) {
          for (type in events) {
            jQuery.event.remove(elem, type + types[t], handler, selector, true);
          }
          continue;
        }
        special = jQuery.event.special[type] || {};
        type = (selector ? special.delegateType : special.bindType) || type;
        handlers = events[type] || [];
        tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");
        origCount = j = handlers.length;
        while (j--) {
          handleObj = handlers[j];
          if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
            handlers.splice(j, 1);
            if (handleObj.selector) {
              handlers.delegateCount--;
            }
            if (special.remove) {
              special.remove.call(elem, handleObj);
            }
          }
        }
        if (origCount && !handlers.length) {
          if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
            jQuery.removeEvent(elem, type, elemData.handle);
          }
          delete events[type];
        }
      }
      if (jQuery.isEmptyObject(events)) {
        dataPriv.remove(elem, "handle events");
      }
    },
    dispatch: function(event) {
      event = jQuery.event.fix(event);
      var i,
          j,
          ret,
          matched,
          handleObj,
          handlerQueue = [],
          args = slice.call(arguments),
          handlers = (dataPriv.get(this, "events") || {})[event.type] || [],
          special = jQuery.event.special[event.type] || {};
      args[0] = event;
      event.delegateTarget = this;
      if (special.preDispatch && special.preDispatch.call(this, event) === false) {
        return;
      }
      handlerQueue = jQuery.event.handlers.call(this, event, handlers);
      i = 0;
      while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
        event.currentTarget = matched.elem;
        j = 0;
        while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
          if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {
            event.handleObj = handleObj;
            event.data = handleObj.data;
            ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
            if (ret !== undefined) {
              if ((event.result = ret) === false) {
                event.preventDefault();
                event.stopPropagation();
              }
            }
          }
        }
      }
      if (special.postDispatch) {
        special.postDispatch.call(this, event);
      }
      return event.result;
    },
    handlers: function(event, handlers) {
      var i,
          matches,
          sel,
          handleObj,
          handlerQueue = [],
          delegateCount = handlers.delegateCount,
          cur = event.target;
      if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {
        for (; cur !== this; cur = cur.parentNode || this) {
          if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
            matches = [];
            for (i = 0; i < delegateCount; i++) {
              handleObj = handlers[i];
              sel = handleObj.selector + " ";
              if (matches[sel] === undefined) {
                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
              }
              if (matches[sel]) {
                matches.push(handleObj);
              }
            }
            if (matches.length) {
              handlerQueue.push({
                elem: cur,
                handlers: matches
              });
            }
          }
        }
      }
      if (delegateCount < handlers.length) {
        handlerQueue.push({
          elem: this,
          handlers: handlers.slice(delegateCount)
        });
      }
      return handlerQueue;
    },
    props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),
    fixHooks: {},
    keyHooks: {
      props: "char charCode key keyCode".split(" "),
      filter: function(event, original) {
        if (event.which == null) {
          event.which = original.charCode != null ? original.charCode : original.keyCode;
        }
        return event;
      }
    },
    mouseHooks: {
      props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
      filter: function(event, original) {
        var eventDoc,
            doc,
            body,
            button = original.button;
        if (event.pageX == null && original.clientX != null) {
          eventDoc = event.target.ownerDocument || document;
          doc = eventDoc.documentElement;
          body = eventDoc.body;
          event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
          event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
        }
        if (!event.which && button !== undefined) {
          event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
        }
        return event;
      }
    },
    fix: function(event) {
      if (event[jQuery.expando]) {
        return event;
      }
      var i,
          prop,
          copy,
          type = event.type,
          originalEvent = event,
          fixHook = this.fixHooks[type];
      if (!fixHook) {
        this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
      }
      copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
      event = new jQuery.Event(originalEvent);
      i = copy.length;
      while (i--) {
        prop = copy[i];
        event[prop] = originalEvent[prop];
      }
      if (!event.target) {
        event.target = document;
      }
      if (event.target.nodeType === 3) {
        event.target = event.target.parentNode;
      }
      return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
    },
    special: {
      load: {noBubble: true},
      focus: {
        trigger: function() {
          if (this !== safeActiveElement() && this.focus) {
            this.focus();
            return false;
          }
        },
        delegateType: "focusin"
      },
      blur: {
        trigger: function() {
          if (this === safeActiveElement() && this.blur) {
            this.blur();
            return false;
          }
        },
        delegateType: "focusout"
      },
      click: {
        trigger: function() {
          if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
            this.click();
            return false;
          }
        },
        _default: function(event) {
          return jQuery.nodeName(event.target, "a");
        }
      },
      beforeunload: {postDispatch: function(event) {
          if (event.result !== undefined && event.originalEvent) {
            event.originalEvent.returnValue = event.result;
          }
        }}
    }
  };
  jQuery.removeEvent = function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {
    constructor: jQuery.Event,
    isDefaultPrevented: returnFalse,
    isPropagationStopped: returnFalse,
    isImmediatePropagationStopped: returnFalse,
    preventDefault: function() {
      var e = this.originalEvent;
      this.isDefaultPrevented = returnTrue;
      if (e) {
        e.preventDefault();
      }
    },
    stopPropagation: function() {
      var e = this.originalEvent;
      this.isPropagationStopped = returnTrue;
      if (e) {
        e.stopPropagation();
      }
    },
    stopImmediatePropagation: function() {
      var e = this.originalEvent;
      this.isImmediatePropagationStopped = returnTrue;
      if (e) {
        e.stopImmediatePropagation();
      }
      this.stopPropagation();
    }
  };
  jQuery.each({
    mouseenter: "mouseover",
    mouseleave: "mouseout",
    pointerenter: "pointerover",
    pointerleave: "pointerout"
  }, function(orig, fix) {
    jQuery.event.special[orig] = {
      delegateType: fix,
      bindType: fix,
      handle: function(event) {
        var ret,
            target = this,
            related = event.relatedTarget,
            handleObj = event.handleObj;
        if (!related || (related !== target && !jQuery.contains(target, related))) {
          event.type = handleObj.origType;
          ret = handleObj.handler.apply(this, arguments);
          event.type = fix;
        }
        return ret;
      }
    };
  });
  jQuery.fn.extend({
    on: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn);
    },
    one: function(types, selector, data, fn) {
      return on(this, types, selector, data, fn, 1);
    },
    off: function(types, selector, fn) {
      var handleObj,
          type;
      if (types && types.preventDefault && types.handleObj) {
        handleObj = types.handleObj;
        jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
        return this;
      }
      if (typeof types === "object") {
        for (type in types) {
          this.off(type, selector, types[type]);
        }
        return this;
      }
      if (selector === false || typeof selector === "function") {
        fn = selector;
        selector = undefined;
      }
      if (fn === false) {
        fn = returnFalse;
      }
      return this.each(function() {
        jQuery.event.remove(this, types, fn, selector);
      });
    }
  });
  var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
      rnoInnerhtml = /<script|<style|<link/i,
      rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
      rscriptTypeMasked = /^true\/(.*)/,
      rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
  }
  function disableScript(elem) {
    elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute("type");
    }
    return elem;
  }
  function cloneCopyEvent(src, dest) {
    var i,
        l,
        type,
        pdataOld,
        pdataCur,
        udataOld,
        udataCur,
        events;
    if (dest.nodeType !== 1) {
      return;
    }
    if (dataPriv.hasData(src)) {
      pdataOld = dataPriv.access(src);
      pdataCur = dataPriv.set(dest, pdataOld);
      events = pdataOld.events;
      if (events) {
        delete pdataCur.handle;
        pdataCur.events = {};
        for (type in events) {
          for (i = 0, l = events[type].length; i < l; i++) {
            jQuery.event.add(dest, type, events[type][i]);
          }
        }
      }
    }
    if (dataUser.hasData(src)) {
      udataOld = dataUser.access(src);
      udataCur = jQuery.extend({}, udataOld);
      dataUser.set(dest, udataCur);
    }
  }
  function fixInput(src, dest) {
    var nodeName = dest.nodeName.toLowerCase();
    if (nodeName === "input" && rcheckableType.test(src.type)) {
      dest.checked = src.checked;
    } else if (nodeName === "input" || nodeName === "textarea") {
      dest.defaultValue = src.defaultValue;
    }
  }
  function domManip(collection, args, callback, ignored) {
    args = concat.apply([], args);
    var fragment,
        first,
        scripts,
        hasScripts,
        node,
        doc,
        i = 0,
        l = collection.length,
        iNoClone = l - 1,
        value = args[0],
        isFunction = jQuery.isFunction(value);
    if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
      return collection.each(function(index) {
        var self = collection.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        domManip(self, args, callback, ignored);
      });
    }
    if (l) {
      fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first || ignored) {
        scripts = jQuery.map(getAll(fragment, "script"), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, "script"));
            }
          }
          callback.call(collection[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
              }
            }
          }
        }
      }
    }
    return collection;
  }
  function remove(elem, selector, keepData) {
    var node,
        nodes = selector ? jQuery.filter(selector, elem) : elem,
        i = 0;
    for (; (node = nodes[i]) != null; i++) {
      if (!keepData && node.nodeType === 1) {
        jQuery.cleanData(getAll(node));
      }
      if (node.parentNode) {
        if (keepData && jQuery.contains(node.ownerDocument, node)) {
          setGlobalEval(getAll(node, "script"));
        }
        node.parentNode.removeChild(node);
      }
    }
    return elem;
  }
  jQuery.extend({
    htmlPrefilter: function(html) {
      return html.replace(rxhtmlTag, "<$1></$2>");
    },
    clone: function(elem, dataAndEvents, deepDataAndEvents) {
      var i,
          l,
          srcElements,
          destElements,
          clone = elem.cloneNode(true),
          inPage = jQuery.contains(elem.ownerDocument, elem);
      if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
        destElements = getAll(clone);
        srcElements = getAll(elem);
        for (i = 0, l = srcElements.length; i < l; i++) {
          fixInput(srcElements[i], destElements[i]);
        }
      }
      if (dataAndEvents) {
        if (deepDataAndEvents) {
          srcElements = srcElements || getAll(elem);
          destElements = destElements || getAll(clone);
          for (i = 0, l = srcElements.length; i < l; i++) {
            cloneCopyEvent(srcElements[i], destElements[i]);
          }
        } else {
          cloneCopyEvent(elem, clone);
        }
      }
      destElements = getAll(clone, "script");
      if (destElements.length > 0) {
        setGlobalEval(destElements, !inPage && getAll(elem, "script"));
      }
      return clone;
    },
    cleanData: function(elems) {
      var data,
          elem,
          type,
          special = jQuery.event.special,
          i = 0;
      for (; (elem = elems[i]) !== undefined; i++) {
        if (acceptData(elem)) {
          if ((data = elem[dataPriv.expando])) {
            if (data.events) {
              for (type in data.events) {
                if (special[type]) {
                  jQuery.event.remove(elem, type);
                } else {
                  jQuery.removeEvent(elem, type, data.handle);
                }
              }
            }
            elem[dataPriv.expando] = undefined;
          }
          if (elem[dataUser.expando]) {
            elem[dataUser.expando] = undefined;
          }
        }
      }
    }
  });
  jQuery.fn.extend({
    domManip: domManip,
    detach: function(selector) {
      return remove(this, selector, true);
    },
    remove: function(selector) {
      return remove(this, selector);
    },
    text: function(value) {
      return access(this, function(value) {
        return value === undefined ? jQuery.text(this) : this.empty().each(function() {
          if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
            this.textContent = value;
          }
        });
      }, null, value, arguments.length);
    },
    append: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.appendChild(elem);
        }
      });
    },
    prepend: function() {
      return domManip(this, arguments, function(elem) {
        if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
          var target = manipulationTarget(this, elem);
          target.insertBefore(elem, target.firstChild);
        }
      });
    },
    before: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this);
        }
      });
    },
    after: function() {
      return domManip(this, arguments, function(elem) {
        if (this.parentNode) {
          this.parentNode.insertBefore(elem, this.nextSibling);
        }
      });
    },
    empty: function() {
      var elem,
          i = 0;
      for (; (elem = this[i]) != null; i++) {
        if (elem.nodeType === 1) {
          jQuery.cleanData(getAll(elem, false));
          elem.textContent = "";
        }
      }
      return this;
    },
    clone: function(dataAndEvents, deepDataAndEvents) {
      dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
      deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
      return this.map(function() {
        return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
      });
    },
    html: function(value) {
      return access(this, function(value) {
        var elem = this[0] || {},
            i = 0,
            l = this.length;
        if (value === undefined && elem.nodeType === 1) {
          return elem.innerHTML;
        }
        if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
          value = jQuery.htmlPrefilter(value);
          try {
            for (; i < l; i++) {
              elem = this[i] || {};
              if (elem.nodeType === 1) {
                jQuery.cleanData(getAll(elem, false));
                elem.innerHTML = value;
              }
            }
            elem = 0;
          } catch (e) {}
        }
        if (elem) {
          this.empty().append(value);
        }
      }, null, value, arguments.length);
    },
    replaceWith: function() {
      var ignored = [];
      return domManip(this, arguments, function(elem) {
        var parent = this.parentNode;
        if (jQuery.inArray(this, ignored) < 0) {
          jQuery.cleanData(getAll(this));
          if (parent) {
            parent.replaceChild(elem, this);
          }
        }
      }, ignored);
    }
  });
  jQuery.each({
    appendTo: "append",
    prependTo: "prepend",
    insertBefore: "before",
    insertAfter: "after",
    replaceAll: "replaceWith"
  }, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems,
          ret = [],
          insert = jQuery(selector),
          last = insert.length - 1,
          i = 0;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe,
      elemdisplay = {
        HTML: "block",
        BODY: "block"
      };
  function actualDisplay(name, doc) {
    var elem = jQuery(doc.createElement(name)).appendTo(doc.body),
        display = jQuery.css(elem[0], "display");
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document,
        display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === "none" || !display) {
        iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);
        doc = iframe[0].contentDocument;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  var rmargin = (/^margin/);
  var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i");
  var getStyles = function(elem) {
    var view = elem.ownerDocument.defaultView;
    if (!view || !view.opener) {
      view = window;
    }
    return view.getComputedStyle(elem);
  };
  var swap = function(elem, options, callback, args) {
    var ret,
        name,
        old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var documentElement = document.documentElement;
  (function() {
    var pixelPositionVal,
        boxSizingReliableVal,
        pixelMarginRightVal,
        reliableMarginLeftVal,
        container = document.createElement("div"),
        div = document.createElement("div");
    if (!div.style) {
      return;
    }
    div.style.backgroundClip = "content-box";
    div.cloneNode(true).style.backgroundClip = "";
    support.clearCloneStyle = div.style.backgroundClip === "content-box";
    container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
    container.appendChild(div);
    function computeStyleTests() {
      div.style.cssText = "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
      div.innerHTML = "";
      documentElement.appendChild(container);
      var divStyle = window.getComputedStyle(div);
      pixelPositionVal = divStyle.top !== "1%";
      reliableMarginLeftVal = divStyle.marginLeft === "2px";
      boxSizingReliableVal = divStyle.width === "4px";
      div.style.marginRight = "50%";
      pixelMarginRightVal = divStyle.marginRight === "4px";
      documentElement.removeChild(container);
    }
    jQuery.extend(support, {
      pixelPosition: function() {
        computeStyleTests();
        return pixelPositionVal;
      },
      boxSizingReliable: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return boxSizingReliableVal;
      },
      pixelMarginRight: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return pixelMarginRightVal;
      },
      reliableMarginLeft: function() {
        if (boxSizingReliableVal == null) {
          computeStyleTests();
        }
        return reliableMarginLeftVal;
      },
      reliableMarginRight: function() {
        var ret,
            marginDiv = div.appendChild(document.createElement("div"));
        marginDiv.style.cssText = div.style.cssText = "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
        marginDiv.style.marginRight = marginDiv.style.width = "0";
        div.style.width = "1px";
        documentElement.appendChild(container);
        ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);
        documentElement.removeChild(container);
        div.removeChild(marginDiv);
        return ret;
      }
    });
  })();
  function curCSS(elem, name, computed) {
    var width,
        minWidth,
        maxWidth,
        ret,
        style = elem.style;
    computed = computed || getStyles(elem);
    ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
    if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
      ret = jQuery.style(elem, name);
    }
    if (computed) {
      if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {
        width = style.width;
        minWidth = style.minWidth;
        maxWidth = style.maxWidth;
        style.minWidth = style.maxWidth = style.width = ret;
        ret = computed.width;
        style.width = width;
        style.minWidth = minWidth;
        style.maxWidth = maxWidth;
      }
    }
    return ret !== undefined ? ret + "" : ret;
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get: function() {
        if (conditionFn()) {
          delete this.get;
          return;
        }
        return (this.get = hookFn).apply(this, arguments);
      }};
  }
  var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
      cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
      },
      cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
      },
      cssPrefixes = ["Webkit", "O", "Moz", "ms"],
      emptyStyle = document.createElement("div").style;
  function vendorPropName(name) {
    if (name in emptyStyle) {
      return name;
    }
    var capName = name[0].toUpperCase() + name.slice(1),
        i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in emptyStyle) {
        return name;
      }
    }
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rcssNum.exec(value);
    return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? "border" : "content") ? 4 : name === "width" ? 1 : 0,
        val = 0;
    for (; i < 4; i += 2) {
      if (extra === "margin") {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === "content") {
          val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        }
        if (extra !== "margin") {
          val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      } else {
        val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);
        if (extra !== "padding") {
          val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true,
        val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
        styles = getStyles(elem),
        isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";
    if (document.msFullscreenElement && window.top !== window) {
      if (elem.getClientRects().length) {
        val = Math.round(elem.getBoundingClientRect()[name] * 100);
      }
    }
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
  }
  function showHide(elements, show) {
    var display,
        elem,
        hidden,
        values = [],
        index = 0,
        length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = dataPriv.get(elem, "olddisplay");
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === "none") {
          elem.style.display = "";
        }
        if (elem.style.display === "" && isHidden(elem)) {
          values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display !== "none" || !hidden) {
          dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === "none" || elem.style.display === "") {
        elem.style.display = show ? values[index] || "" : "none";
      }
    }
    return elements;
  }
  jQuery.extend({
    cssHooks: {opacity: {get: function(elem, computed) {
          if (computed) {
            var ret = curCSS(elem, "opacity");
            return ret === "" ? "1" : ret;
          }
        }}},
    cssNumber: {
      "animationIterationCount": true,
      "columnCount": true,
      "fillOpacity": true,
      "flexGrow": true,
      "flexShrink": true,
      "fontWeight": true,
      "lineHeight": true,
      "opacity": true,
      "order": true,
      "orphans": true,
      "widows": true,
      "zIndex": true,
      "zoom": true
    },
    cssProps: {"float": "cssFloat"},
    style: function(elem, name, value, extra) {
      if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
        return;
      }
      var ret,
          type,
          hooks,
          origName = jQuery.camelCase(name),
          style = elem.style;
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (value !== undefined) {
        type = typeof value;
        if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
          value = adjustCSS(elem, name, ret);
          type = "number";
        }
        if (value == null || value !== value) {
          return;
        }
        if (type === "number") {
          value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
        }
        if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
          style[name] = "inherit";
        }
        if (!hooks || !("set" in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
          style[name] = value;
        }
      } else {
        if (hooks && "get" in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
          return ret;
        }
        return style[name];
      }
    },
    css: function(elem, name, extra, styles) {
      var val,
          num,
          hooks,
          origName = jQuery.camelCase(name);
      name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);
      hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
      if (hooks && "get" in hooks) {
        val = hooks.get(elem, true, extra);
      }
      if (val === undefined) {
        val = curCSS(elem, name, styles);
      }
      if (val === "normal" && name in cssNormalTransform) {
        val = cssNormalTransform[name];
      }
      if (extra === "" || extra) {
        num = parseFloat(val);
        return extra === true || isFinite(num) ? num || 0 : val;
      }
      return val;
    }
  });
  jQuery.each(["height", "width"], function(i, name) {
    jQuery.cssHooks[name] = {
      get: function(elem, computed, extra) {
        if (computed) {
          return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
            return getWidthOrHeight(elem, name, extra);
          }) : getWidthOrHeight(elem, name, extra);
        }
      },
      set: function(elem, value, extra) {
        var matches,
            styles = extra && getStyles(elem),
            subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);
        if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {
          elem.style[name] = value;
          value = jQuery.css(elem, name);
        }
        return setPositiveNumber(elem, value, subtract);
      }
    };
  });
  jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
    if (computed) {
      return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function() {
        return elem.getBoundingClientRect().left;
      })) + "px";
    }
  });
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return swap(elem, {"display": "inline-block"}, curCSS, [elem, "marginRight"]);
    }
  });
  jQuery.each({
    margin: "",
    padding: "",
    border: "Width"
  }, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand: function(value) {
        var i = 0,
            expanded = {},
            parts = typeof value === "string" ? value.split(" ") : [value];
        for (; i < 4; i++) {
          expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
        }
        return expanded;
      }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({
    css: function(name, value) {
      return access(this, function(elem, name, value) {
        var styles,
            len,
            map = {},
            i = 0;
        if (jQuery.isArray(name)) {
          styles = getStyles(elem);
          len = name.length;
          for (; i < len; i++) {
            map[name[i]] = jQuery.css(elem, name[i], false, styles);
          }
          return map;
        }
        return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
      }, name, value, arguments.length > 1);
    },
    show: function() {
      return showHide(this, true);
    },
    hide: function() {
      return showHide(this);
    },
    toggle: function(state) {
      if (typeof state === "boolean") {
        return state ? this.show() : this.hide();
      }
      return this.each(function() {
        if (isHidden(this)) {
          jQuery(this).show();
        } else {
          jQuery(this).hide();
        }
      });
    }
  });
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {
    constructor: Tween,
    init: function(elem, options, prop, end, easing, unit) {
      this.elem = elem;
      this.prop = prop;
      this.easing = easing || jQuery.easing._default;
      this.options = options;
      this.start = this.now = this.cur();
      this.end = end;
      this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
    },
    cur: function() {
      var hooks = Tween.propHooks[this.prop];
      return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
    },
    run: function(percent) {
      var eased,
          hooks = Tween.propHooks[this.prop];
      if (this.options.duration) {
        this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
      } else {
        this.pos = eased = percent;
      }
      this.now = (this.end - this.start) * eased + this.start;
      if (this.options.step) {
        this.options.step.call(this.elem, this.now, this);
      }
      if (hooks && hooks.set) {
        hooks.set(this);
      } else {
        Tween.propHooks._default.set(this);
      }
      return this;
    }
  };
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default: {
      get: function(tween) {
        var result;
        if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
          return tween.elem[tween.prop];
        }
        result = jQuery.css(tween.elem, tween.prop, "");
        return !result || result === "auto" ? 0 : result;
      },
      set: function(tween) {
        if (jQuery.fx.step[tween.prop]) {
          jQuery.fx.step[tween.prop](tween);
        } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
          jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
        } else {
          tween.elem[tween.prop] = tween.now;
        }
      }
    }};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set: function(tween) {
      if (tween.elem.nodeType && tween.elem.parentNode) {
        tween.elem[tween.prop] = tween.now;
      }
    }};
  jQuery.easing = {
    linear: function(p) {
      return p;
    },
    swing: function(p) {
      return 0.5 - Math.cos(p * Math.PI) / 2;
    },
    _default: "swing"
  };
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow,
      timerId,
      rfxtypes = /^(?:toggle|show|hide)$/,
      rrun = /queueHooks$/;
  function createFxNow() {
    window.setTimeout(function() {
      fxNow = undefined;
    });
    return (fxNow = jQuery.now());
  }
  function genFx(type, includeWidth) {
    var which,
        i = 0,
        attrs = {height: type};
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs["margin" + which] = attrs["padding" + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween,
        collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]),
        index = 0,
        length = collection.length;
    for (; index < length; index++) {
      if ((tween = collection[index].call(animation, prop, value))) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop,
        value,
        toggle,
        tween,
        hooks,
        oldfire,
        display,
        checkDisplay,
        anim = this,
        orig = {},
        style = elem.style,
        hidden = elem.nodeType && isHidden(elem),
        dataShow = dataPriv.get(elem, "fxshow");
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, "fx");
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, "fx").length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ("height" in props || "width" in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, "display");
      checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
        style.display = "inline-block";
      }
    }
    if (opts.overflow) {
      style.overflow = "hidden";
      anim.always(function() {
        style.overflow = opts.overflow[0];
        style.overflowX = opts.overflow[1];
        style.overflowY = opts.overflow[2];
      });
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === "toggle";
        if (value === (hidden ? "hide" : "show")) {
          if (value === "show" && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ("hidden" in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = dataPriv.access(elem, "fxshow", {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        dataPriv.remove(elem, "fxshow");
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === "width" || prop === "height" ? 1 : 0;
          }
        }
      }
    } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
      style.display = display;
    }
  }
  function propFilter(props, specialEasing) {
    var index,
        name,
        easing,
        value,
        hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && "expand" in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result,
        stopped,
        index = 0,
        length = Animation.prefilters.length,
        deferred = jQuery.Deferred().always(function() {
          delete tick.elem;
        }),
        tick = function() {
          if (stopped) {
            return false;
          }
          var currentTime = fxNow || createFxNow(),
              remaining = Math.max(0, animation.startTime + animation.duration - currentTime),
              temp = remaining / animation.duration || 0,
              percent = 1 - temp,
              index = 0,
              length = animation.tweens.length;
          for (; index < length; index++) {
            animation.tweens[index].run(percent);
          }
          deferred.notifyWith(elem, [animation, percent, remaining]);
          if (percent < 1 && length) {
            return remaining;
          } else {
            deferred.resolveWith(elem, [animation]);
            return false;
          }
        },
        animation = deferred.promise({
          elem: elem,
          props: jQuery.extend({}, properties),
          opts: jQuery.extend(true, {
            specialEasing: {},
            easing: jQuery.easing._default
          }, options),
          originalProperties: properties,
          originalOptions: options,
          startTime: fxNow || createFxNow(),
          duration: options.duration,
          tweens: [],
          createTween: function(prop, end) {
            var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
            animation.tweens.push(tween);
            return tween;
          },
          stop: function(gotoEnd) {
            var index = 0,
                length = gotoEnd ? animation.tweens.length : 0;
            if (stopped) {
              return this;
            }
            stopped = true;
            for (; index < length; index++) {
              animation.tweens[index].run(1);
            }
            if (gotoEnd) {
              deferred.notifyWith(elem, [animation, 1, 0]);
              deferred.resolveWith(elem, [animation, gotoEnd]);
            } else {
              deferred.rejectWith(elem, [animation, gotoEnd]);
            }
            return this;
          }
        }),
        props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        if (jQuery.isFunction(result.stop)) {
          jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
        }
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {
      elem: elem,
      anim: animation,
      queue: animation.opts.queue
    }));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {
    tweeners: {"*": [function(prop, value) {
        var tween = this.createTween(prop, value);
        adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
        return tween;
      }]},
    tweener: function(props, callback) {
      if (jQuery.isFunction(props)) {
        callback = props;
        props = ["*"];
      } else {
        props = props.match(rnotwhite);
      }
      var prop,
          index = 0,
          length = props.length;
      for (; index < length; index++) {
        prop = props[index];
        Animation.tweeners[prop] = Animation.tweeners[prop] || [];
        Animation.tweeners[prop].unshift(callback);
      }
    },
    prefilters: [defaultPrefilter],
    prefilter: function(callback, prepend) {
      if (prepend) {
        Animation.prefilters.unshift(callback);
      } else {
        Animation.prefilters.push(callback);
      }
    }
  });
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
      complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
      duration: speed,
      easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
    };
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = "fx";
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({
    fadeTo: function(speed, to, easing, callback) {
      return this.filter(isHidden).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback);
    },
    animate: function(prop, speed, easing, callback) {
      var empty = jQuery.isEmptyObject(prop),
          optall = jQuery.speed(speed, easing, callback),
          doAnimation = function() {
            var anim = Animation(this, jQuery.extend({}, prop), optall);
            if (empty || dataPriv.get(this, "finish")) {
              anim.stop(true);
            }
          };
      doAnimation.finish = doAnimation;
      return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
    },
    stop: function(type, clearQueue, gotoEnd) {
      var stopQueue = function(hooks) {
        var stop = hooks.stop;
        delete hooks.stop;
        stop(gotoEnd);
      };
      if (typeof type !== "string") {
        gotoEnd = clearQueue;
        clearQueue = type;
        type = undefined;
      }
      if (clearQueue && type !== false) {
        this.queue(type || "fx", []);
      }
      return this.each(function() {
        var dequeue = true,
            index = type != null && type + "queueHooks",
            timers = jQuery.timers,
            data = dataPriv.get(this);
        if (index) {
          if (data[index] && data[index].stop) {
            stopQueue(data[index]);
          }
        } else {
          for (index in data) {
            if (data[index] && data[index].stop && rrun.test(index)) {
              stopQueue(data[index]);
            }
          }
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
            timers[index].anim.stop(gotoEnd);
            dequeue = false;
            timers.splice(index, 1);
          }
        }
        if (dequeue || !gotoEnd) {
          jQuery.dequeue(this, type);
        }
      });
    },
    finish: function(type) {
      if (type !== false) {
        type = type || "fx";
      }
      return this.each(function() {
        var index,
            data = dataPriv.get(this),
            queue = data[type + "queue"],
            hooks = data[type + "queueHooks"],
            timers = jQuery.timers,
            length = queue ? queue.length : 0;
        data.finish = true;
        jQuery.queue(this, type, []);
        if (hooks && hooks.stop) {
          hooks.stop.call(this, true);
        }
        for (index = timers.length; index--; ) {
          if (timers[index].elem === this && timers[index].queue === type) {
            timers[index].anim.stop(true);
            timers.splice(index, 1);
          }
        }
        for (index = 0; index < length; index++) {
          if (queue[index] && queue[index].finish) {
            queue[index].finish.call(this);
          }
        }
        delete data.finish;
      });
    }
  });
  jQuery.each(["toggle", "show", "hide"], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({
    slideDown: genFx("show"),
    slideUp: genFx("hide"),
    slideToggle: genFx("toggle"),
    fadeIn: {opacity: "show"},
    fadeOut: {opacity: "hide"},
    fadeToggle: {opacity: "toggle"}
  }, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer,
        i = 0,
        timers = jQuery.timers;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    window.clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {
    slow: 600,
    fast: 200,
    _default: 400
  };
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || "fx";
    return this.queue(type, function(next, hooks) {
      var timeout = window.setTimeout(next, time);
      hooks.stop = function() {
        window.clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input = document.createElement("input"),
        select = document.createElement("select"),
        opt = select.appendChild(document.createElement("option"));
    input.type = "checkbox";
    support.checkOn = input.value !== "";
    support.optSelected = opt.selected;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement("input");
    input.value = "t";
    input.type = "radio";
    support.radioValue = input.value === "t";
  })();
  var boolHook,
      attrHandle = jQuery.expr.attrHandle;
  jQuery.fn.extend({
    attr: function(name, value) {
      return access(this, jQuery.attr, name, value, arguments.length > 1);
    },
    removeAttr: function(name) {
      return this.each(function() {
        jQuery.removeAttr(this, name);
      });
    }
  });
  jQuery.extend({
    attr: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (typeof elem.getAttribute === "undefined") {
        return jQuery.prop(elem, name, value);
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = name.toLowerCase();
        hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
      }
      if (value !== undefined) {
        if (value === null) {
          jQuery.removeAttr(elem, name);
          return;
        }
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        elem.setAttribute(name, value + "");
        return value;
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      ret = jQuery.find.attr(elem, name);
      return ret == null ? undefined : ret;
    },
    attrHooks: {type: {set: function(elem, value) {
          if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
            var val = elem.value;
            elem.setAttribute("type", value);
            if (val) {
              elem.value = val;
            }
            return value;
          }
        }}},
    removeAttr: function(elem, value) {
      var name,
          propName,
          i = 0,
          attrNames = value && value.match(rnotwhite);
      if (attrNames && elem.nodeType === 1) {
        while ((name = attrNames[i++])) {
          propName = jQuery.propFix[name] || name;
          if (jQuery.expr.match.bool.test(name)) {
            elem[propName] = false;
          }
          elem.removeAttribute(name);
        }
      }
    }
  });
  boolHook = {set: function(elem, value, name) {
      if (value === false) {
        jQuery.removeAttr(elem, name);
      } else {
        elem.setAttribute(name, name);
      }
      return name;
    }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = function(elem, name, isXML) {
      var ret,
          handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    };
  });
  var rfocusable = /^(?:input|select|textarea|button)$/i,
      rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({
    prop: function(name, value) {
      return access(this, jQuery.prop, name, value, arguments.length > 1);
    },
    removeProp: function(name) {
      return this.each(function() {
        delete this[jQuery.propFix[name] || name];
      });
    }
  });
  jQuery.extend({
    prop: function(elem, name, value) {
      var ret,
          hooks,
          nType = elem.nodeType;
      if (nType === 3 || nType === 8 || nType === 2) {
        return;
      }
      if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
        name = jQuery.propFix[name] || name;
        hooks = jQuery.propHooks[name];
      }
      if (value !== undefined) {
        if (hooks && "set" in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        }
        return (elem[name] = value);
      }
      if (hooks && "get" in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      }
      return elem[name];
    },
    propHooks: {tabIndex: {get: function(elem) {
          var tabindex = jQuery.find.attr(elem, "tabindex");
          return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
        }}},
    propFix: {
      "for": "htmlFor",
      "class": "className"
    }
  });
  if (!support.optSelected) {
    jQuery.propHooks.selected = {
      get: function(elem) {
        var parent = elem.parentNode;
        if (parent && parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
        return null;
      },
      set: function(elem) {
        var parent = elem.parentNode;
        if (parent) {
          parent.selectedIndex;
          if (parent.parentNode) {
            parent.parentNode.selectedIndex;
          }
        }
      }
    };
  }
  jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  var rclass = /[\t\r\n\f]/g;
  function getClass(elem) {
    return elem.getAttribute && elem.getAttribute("class") || "";
  }
  jQuery.fn.extend({
    addClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).addClass(value.call(this, j, getClass(this)));
        });
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              if (cur.indexOf(" " + clazz + " ") < 0) {
                cur += clazz + " ";
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    removeClass: function(value) {
      var classes,
          elem,
          cur,
          curValue,
          clazz,
          j,
          finalValue,
          i = 0;
      if (jQuery.isFunction(value)) {
        return this.each(function(j) {
          jQuery(this).removeClass(value.call(this, j, getClass(this)));
        });
      }
      if (!arguments.length) {
        return this.attr("class", "");
      }
      if (typeof value === "string" && value) {
        classes = value.match(rnotwhite) || [];
        while ((elem = this[i++])) {
          curValue = getClass(elem);
          cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");
          if (cur) {
            j = 0;
            while ((clazz = classes[j++])) {
              while (cur.indexOf(" " + clazz + " ") > -1) {
                cur = cur.replace(" " + clazz + " ", " ");
              }
            }
            finalValue = jQuery.trim(cur);
            if (curValue !== finalValue) {
              elem.setAttribute("class", finalValue);
            }
          }
        }
      }
      return this;
    },
    toggleClass: function(value, stateVal) {
      var type = typeof value;
      if (typeof stateVal === "boolean" && type === "string") {
        return stateVal ? this.addClass(value) : this.removeClass(value);
      }
      if (jQuery.isFunction(value)) {
        return this.each(function(i) {
          jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
        });
      }
      return this.each(function() {
        var className,
            i,
            self,
            classNames;
        if (type === "string") {
          i = 0;
          self = jQuery(this);
          classNames = value.match(rnotwhite) || [];
          while ((className = classNames[i++])) {
            if (self.hasClass(className)) {
              self.removeClass(className);
            } else {
              self.addClass(className);
            }
          }
        } else if (value === undefined || type === "boolean") {
          className = getClass(this);
          if (className) {
            dataPriv.set(this, "__className__", className);
          }
          if (this.setAttribute) {
            this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
          }
        }
      });
    },
    hasClass: function(selector) {
      var className,
          elem,
          i = 0;
      className = " " + selector + " ";
      while ((elem = this[i++])) {
        if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
          return true;
        }
      }
      return false;
    }
  });
  var rreturn = /\r/g,
      rspaces = /[\x20\t\r\n\f]+/g;
  jQuery.fn.extend({val: function(value) {
      var hooks,
          ret,
          isFunction,
          elem = this[0];
      if (!arguments.length) {
        if (elem) {
          hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
          if (hooks && "get" in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
            return ret;
          }
          ret = elem.value;
          return typeof ret === "string" ? ret.replace(rreturn, "") : ret == null ? "" : ret;
        }
        return;
      }
      isFunction = jQuery.isFunction(value);
      return this.each(function(i) {
        var val;
        if (this.nodeType !== 1) {
          return;
        }
        if (isFunction) {
          val = value.call(this, i, jQuery(this).val());
        } else {
          val = value;
        }
        if (val == null) {
          val = "";
        } else if (typeof val === "number") {
          val += "";
        } else if (jQuery.isArray(val)) {
          val = jQuery.map(val, function(value) {
            return value == null ? "" : value + "";
          });
        }
        hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
        if (!hooks || !("set" in hooks) || hooks.set(this, val, "value") === undefined) {
          this.value = val;
        }
      });
    }});
  jQuery.extend({valHooks: {
      option: {get: function(elem) {
          var val = jQuery.find.attr(elem, "value");
          return val != null ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
        }},
      select: {
        get: function(elem) {
          var value,
              option,
              options = elem.options,
              index = elem.selectedIndex,
              one = elem.type === "select-one" || index < 0,
              values = one ? null : [],
              max = one ? index + 1 : options.length,
              i = index < 0 ? max : one ? index : 0;
          for (; i < max; i++) {
            option = options[i];
            if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
              value = jQuery(option).val();
              if (one) {
                return value;
              }
              values.push(value);
            }
          }
          return values;
        },
        set: function(elem, value) {
          var optionSet,
              option,
              options = elem.options,
              values = jQuery.makeArray(value),
              i = options.length;
          while (i--) {
            option = options[i];
            if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
              optionSet = true;
            }
          }
          if (!optionSet) {
            elem.selectedIndex = -1;
          }
          return values;
        }
      }
    }});
  jQuery.each(["radio", "checkbox"], function() {
    jQuery.valHooks[this] = {set: function(elem, value) {
        if (jQuery.isArray(value)) {
          return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
        }
      }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute("value") === null ? "on" : elem.value;
      };
    }
  });
  var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
  jQuery.extend(jQuery.event, {
    trigger: function(event, data, elem, onlyHandlers) {
      var i,
          cur,
          tmp,
          bubbleType,
          ontype,
          handle,
          special,
          eventPath = [elem || document],
          type = hasOwn.call(event, "type") ? event.type : event,
          namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
      cur = tmp = elem = elem || document;
      if (elem.nodeType === 3 || elem.nodeType === 8) {
        return;
      }
      if (rfocusMorph.test(type + jQuery.event.triggered)) {
        return;
      }
      if (type.indexOf(".") > -1) {
        namespaces = type.split(".");
        type = namespaces.shift();
        namespaces.sort();
      }
      ontype = type.indexOf(":") < 0 && "on" + type;
      event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === "object" && event);
      event.isTrigger = onlyHandlers ? 2 : 3;
      event.namespace = namespaces.join(".");
      event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;
      event.result = undefined;
      if (!event.target) {
        event.target = elem;
      }
      data = data == null ? [event] : jQuery.makeArray(data, [event]);
      special = jQuery.event.special[type] || {};
      if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
        return;
      }
      if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
        bubbleType = special.delegateType || type;
        if (!rfocusMorph.test(bubbleType + type)) {
          cur = cur.parentNode;
        }
        for (; cur; cur = cur.parentNode) {
          eventPath.push(cur);
          tmp = cur;
        }
        if (tmp === (elem.ownerDocument || document)) {
          eventPath.push(tmp.defaultView || tmp.parentWindow || window);
        }
      }
      i = 0;
      while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
        event.type = i > 1 ? bubbleType : special.bindType || type;
        handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
        if (handle) {
          handle.apply(cur, data);
        }
        handle = ontype && cur[ontype];
        if (handle && handle.apply && acceptData(cur)) {
          event.result = handle.apply(cur, data);
          if (event.result === false) {
            event.preventDefault();
          }
        }
      }
      event.type = type;
      if (!onlyHandlers && !event.isDefaultPrevented()) {
        if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {
          if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {
            tmp = elem[ontype];
            if (tmp) {
              elem[ontype] = null;
            }
            jQuery.event.triggered = type;
            elem[type]();
            jQuery.event.triggered = undefined;
            if (tmp) {
              elem[ontype] = tmp;
            }
          }
        }
      }
      return event.result;
    },
    simulate: function(type, elem, event) {
      var e = jQuery.extend(new jQuery.Event(), event, {
        type: type,
        isSimulated: true
      });
      jQuery.event.trigger(e, null, elem);
      if (e.isDefaultPrevented()) {
        event.preventDefault();
      }
    }
  });
  jQuery.fn.extend({
    trigger: function(type, data) {
      return this.each(function() {
        jQuery.event.trigger(type, data, this);
      });
    },
    triggerHandler: function(type, data) {
      var elem = this[0];
      if (elem) {
        return jQuery.event.trigger(type, data, elem, true);
      }
    }
  });
  jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover: function(fnOver, fnOut) {
      return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
    }});
  support.focusin = "onfocusin" in window;
  if (!support.focusin) {
    jQuery.each({
      focus: "focusin",
      blur: "focusout"
    }, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
      };
      jQuery.event.special[fix] = {
        setup: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix);
          if (!attaches) {
            doc.addEventListener(orig, handler, true);
          }
          dataPriv.access(doc, fix, (attaches || 0) + 1);
        },
        teardown: function() {
          var doc = this.ownerDocument || this,
              attaches = dataPriv.access(doc, fix) - 1;
          if (!attaches) {
            doc.removeEventListener(orig, handler, true);
            dataPriv.remove(doc, fix);
          } else {
            dataPriv.access(doc, fix, attaches);
          }
        }
      };
    });
  }
  var location = window.location;
  var nonce = jQuery.now();
  var rquery = (/\?/);
  jQuery.parseJSON = function(data) {
    return JSON.parse(data + "");
  };
  jQuery.parseXML = function(data) {
    var xml;
    if (!data || typeof data !== "string") {
      return null;
    }
    try {
      xml = (new window.DOMParser()).parseFromString(data, "text/xml");
    } catch (e) {
      xml = undefined;
    }
    if (!xml || xml.getElementsByTagName("parsererror").length) {
      jQuery.error("Invalid XML: " + data);
    }
    return xml;
  };
  var rhash = /#.*$/,
      rts = /([?&])_=[^&]*/,
      rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,
      rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
      rnoContent = /^(?:GET|HEAD)$/,
      rprotocol = /^\/\//,
      prefilters = {},
      transports = {},
      allTypes = "*/".concat("*"),
      originAnchor = document.createElement("a");
  originAnchor.href = location.href;
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== "string") {
        func = dataTypeExpression;
        dataTypeExpression = "*";
      }
      var dataType,
          i = 0,
          dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while ((dataType = dataTypes[i++])) {
          if (dataType[0] === "+") {
            dataType = dataType.slice(1) || "*";
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {},
        seekingTransport = (structure === transports);
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else if (seekingTransport) {
          return !(selected = dataTypeOrTransport);
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
  }
  function ajaxExtend(target, src) {
    var key,
        deep,
        flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var ct,
        type,
        finalDataType,
        firstDataType,
        contents = s.contents,
        dataTypes = s.dataTypes;
    while (dataTypes[0] === "*") {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2,
        current,
        conv,
        tmp,
        prev,
        converters = {},
        dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === "*") {
          current = prev;
        } else if (prev !== "*" && prev !== current) {
          conv = converters[prev + " " + current] || converters["* " + current];
          if (!conv) {
            for (conv2 in converters) {
              tmp = conv2.split(" ");
              if (tmp[1] === current) {
                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                if (conv) {
                  if (conv === true) {
                    conv = converters[conv2];
                  } else if (converters[conv2] !== true) {
                    current = tmp[0];
                    dataTypes.unshift(tmp[1]);
                  }
                  break;
                }
              }
            }
          }
          if (conv !== true) {
            if (conv && s.throws) {
              response = conv(response);
            } else {
              try {
                response = conv(response);
              } catch (e) {
                return {
                  state: "parsererror",
                  error: conv ? e : "No conversion from " + prev + " to " + current
                };
              }
            }
          }
        }
      }
    }
    return {
      state: "success",
      data: response
    };
  }
  jQuery.extend({
    active: 0,
    lastModified: {},
    etag: {},
    ajaxSettings: {
      url: location.href,
      type: "GET",
      isLocal: rlocalProtocol.test(location.protocol),
      global: true,
      processData: true,
      async: true,
      contentType: "application/x-www-form-urlencoded; charset=UTF-8",
      accepts: {
        "*": allTypes,
        text: "text/plain",
        html: "text/html",
        xml: "application/xml, text/xml",
        json: "application/json, text/javascript"
      },
      contents: {
        xml: /\bxml\b/,
        html: /\bhtml/,
        json: /\bjson\b/
      },
      responseFields: {
        xml: "responseXML",
        text: "responseText",
        json: "responseJSON"
      },
      converters: {
        "* text": String,
        "text html": true,
        "text json": jQuery.parseJSON,
        "text xml": jQuery.parseXML
      },
      flatOptions: {
        url: true,
        context: true
      }
    },
    ajaxSetup: function(target, settings) {
      return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
    },
    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
    ajaxTransport: addToPrefiltersOrTransports(transports),
    ajax: function(url, options) {
      if (typeof url === "object") {
        options = url;
        url = undefined;
      }
      options = options || {};
      var transport,
          cacheURL,
          responseHeadersString,
          responseHeaders,
          timeoutTimer,
          urlAnchor,
          fireGlobals,
          i,
          s = jQuery.ajaxSetup({}, options),
          callbackContext = s.context || s,
          globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
          deferred = jQuery.Deferred(),
          completeDeferred = jQuery.Callbacks("once memory"),
          statusCode = s.statusCode || {},
          requestHeaders = {},
          requestHeadersNames = {},
          state = 0,
          strAbort = "canceled",
          jqXHR = {
            readyState: 0,
            getResponseHeader: function(key) {
              var match;
              if (state === 2) {
                if (!responseHeaders) {
                  responseHeaders = {};
                  while ((match = rheaders.exec(responseHeadersString))) {
                    responseHeaders[match[1].toLowerCase()] = match[2];
                  }
                }
                match = responseHeaders[key.toLowerCase()];
              }
              return match == null ? null : match;
            },
            getAllResponseHeaders: function() {
              return state === 2 ? responseHeadersString : null;
            },
            setRequestHeader: function(name, value) {
              var lname = name.toLowerCase();
              if (!state) {
                name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                requestHeaders[name] = value;
              }
              return this;
            },
            overrideMimeType: function(type) {
              if (!state) {
                s.mimeType = type;
              }
              return this;
            },
            statusCode: function(map) {
              var code;
              if (map) {
                if (state < 2) {
                  for (code in map) {
                    statusCode[code] = [statusCode[code], map[code]];
                  }
                } else {
                  jqXHR.always(map[jqXHR.status]);
                }
              }
              return this;
            },
            abort: function(statusText) {
              var finalText = statusText || strAbort;
              if (transport) {
                transport.abort(finalText);
              }
              done(0, finalText);
              return this;
            }
          };
      deferred.promise(jqXHR).complete = completeDeferred.add;
      jqXHR.success = jqXHR.done;
      jqXHR.error = jqXHR.fail;
      s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");
      s.type = options.method || options.type || s.method || s.type;
      s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];
      if (s.crossDomain == null) {
        urlAnchor = document.createElement("a");
        try {
          urlAnchor.href = s.url;
          urlAnchor.href = urlAnchor.href;
          s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
        } catch (e) {
          s.crossDomain = true;
        }
      }
      if (s.data && s.processData && typeof s.data !== "string") {
        s.data = jQuery.param(s.data, s.traditional);
      }
      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
      if (state === 2) {
        return jqXHR;
      }
      fireGlobals = jQuery.event && s.global;
      if (fireGlobals && jQuery.active++ === 0) {
        jQuery.event.trigger("ajaxStart");
      }
      s.type = s.type.toUpperCase();
      s.hasContent = !rnoContent.test(s.type);
      cacheURL = s.url;
      if (!s.hasContent) {
        if (s.data) {
          cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);
          delete s.data;
        }
        if (s.cache === false) {
          s.url = rts.test(cacheURL) ? cacheURL.replace(rts, "$1_=" + nonce++) : cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
        }
      }
      if (s.ifModified) {
        if (jQuery.lastModified[cacheURL]) {
          jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
        }
        if (jQuery.etag[cacheURL]) {
          jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
        }
      }
      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
        jqXHR.setRequestHeader("Content-Type", s.contentType);
      }
      jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
      for (i in s.headers) {
        jqXHR.setRequestHeader(i, s.headers[i]);
      }
      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
        return jqXHR.abort();
      }
      strAbort = "abort";
      for (i in {
        success: 1,
        error: 1,
        complete: 1
      }) {
        jqXHR[i](s[i]);
      }
      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
      if (!transport) {
        done(-1, "No Transport");
      } else {
        jqXHR.readyState = 1;
        if (fireGlobals) {
          globalEventContext.trigger("ajaxSend", [jqXHR, s]);
        }
        if (state === 2) {
          return jqXHR;
        }
        if (s.async && s.timeout > 0) {
          timeoutTimer = window.setTimeout(function() {
            jqXHR.abort("timeout");
          }, s.timeout);
        }
        try {
          state = 1;
          transport.send(requestHeaders, done);
        } catch (e) {
          if (state < 2) {
            done(-1, e);
          } else {
            throw e;
          }
        }
      }
      function done(status, nativeStatusText, responses, headers) {
        var isSuccess,
            success,
            error,
            response,
            modified,
            statusText = nativeStatusText;
        if (state === 2) {
          return;
        }
        state = 2;
        if (timeoutTimer) {
          window.clearTimeout(timeoutTimer);
        }
        transport = undefined;
        responseHeadersString = headers || "";
        jqXHR.readyState = status > 0 ? 4 : 0;
        isSuccess = status >= 200 && status < 300 || status === 304;
        if (responses) {
          response = ajaxHandleResponses(s, jqXHR, responses);
        }
        response = ajaxConvert(s, response, jqXHR, isSuccess);
        if (isSuccess) {
          if (s.ifModified) {
            modified = jqXHR.getResponseHeader("Last-Modified");
            if (modified) {
              jQuery.lastModified[cacheURL] = modified;
            }
            modified = jqXHR.getResponseHeader("etag");
            if (modified) {
              jQuery.etag[cacheURL] = modified;
            }
          }
          if (status === 204 || s.type === "HEAD") {
            statusText = "nocontent";
          } else if (status === 304) {
            statusText = "notmodified";
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        } else {
          error = statusText;
          if (status || !statusText) {
            statusText = "error";
            if (status < 0) {
              status = 0;
            }
          }
        }
        jqXHR.status = status;
        jqXHR.statusText = (nativeStatusText || statusText) + "";
        if (isSuccess) {
          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
        } else {
          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
        }
        jqXHR.statusCode(statusCode);
        statusCode = undefined;
        if (fireGlobals) {
          globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
        }
        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
        if (fireGlobals) {
          globalEventContext.trigger("ajaxComplete", [jqXHR, s]);
          if (!(--jQuery.active)) {
            jQuery.event.trigger("ajaxStop");
          }
        }
      }
      return jqXHR;
    },
    getJSON: function(url, data, callback) {
      return jQuery.get(url, data, callback, "json");
    },
    getScript: function(url, callback) {
      return jQuery.get(url, undefined, callback, "script");
    }
  });
  jQuery.each(["get", "post"], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax(jQuery.extend({
        url: url,
        type: method,
        dataType: type,
        data: data,
        success: callback
      }, jQuery.isPlainObject(url) && url));
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({
      url: url,
      type: "GET",
      dataType: "script",
      async: false,
      global: false,
      "throws": true
    });
  };
  jQuery.fn.extend({
    wrapAll: function(html) {
      var wrap;
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapAll(html.call(this, i));
        });
      }
      if (this[0]) {
        wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
        if (this[0].parentNode) {
          wrap.insertBefore(this[0]);
        }
        wrap.map(function() {
          var elem = this;
          while (elem.firstElementChild) {
            elem = elem.firstElementChild;
          }
          return elem;
        }).append(this);
      }
      return this;
    },
    wrapInner: function(html) {
      if (jQuery.isFunction(html)) {
        return this.each(function(i) {
          jQuery(this).wrapInner(html.call(this, i));
        });
      }
      return this.each(function() {
        var self = jQuery(this),
            contents = self.contents();
        if (contents.length) {
          contents.wrapAll(html);
        } else {
          self.append(html);
        }
      });
    },
    wrap: function(html) {
      var isFunction = jQuery.isFunction(html);
      return this.each(function(i) {
        jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
      });
    },
    unwrap: function() {
      return this.parent().each(function() {
        if (!jQuery.nodeName(this, "body")) {
          jQuery(this).replaceWith(this.childNodes);
        }
      }).end();
    }
  });
  jQuery.expr.filters.hidden = function(elem) {
    return !jQuery.expr.filters.visible(elem);
  };
  jQuery.expr.filters.visible = function(elem) {
    return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
  };
  var r20 = /%20/g,
      rbracket = /\[\]$/,
      rCRLF = /\r?\n/g,
      rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
      rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
        }
      });
    } else if (!traditional && jQuery.type(obj) === "object") {
      for (name in obj) {
        buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
      }
    } else {
      add(prefix, obj);
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix,
        s = [],
        add = function(key, value) {
          value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
          s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join("&").replace(r20, "+");
  };
  jQuery.fn.extend({
    serialize: function() {
      return jQuery.param(this.serializeArray());
    },
    serializeArray: function() {
      return this.map(function() {
        var elements = jQuery.prop(this, "elements");
        return elements ? jQuery.makeArray(elements) : this;
      }).filter(function() {
        var type = this.type;
        return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
      }).map(function(i, elem) {
        var val = jQuery(this).val();
        return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
          return {
            name: elem.name,
            value: val.replace(rCRLF, "\r\n")
          };
        }) : {
          name: elem.name,
          value: val.replace(rCRLF, "\r\n")
        };
      }).get();
    }
  });
  jQuery.ajaxSettings.xhr = function() {
    try {
      return new window.XMLHttpRequest();
    } catch (e) {}
  };
  var xhrSuccessStatus = {
    0: 200,
    1223: 204
  },
      xhrSupported = jQuery.ajaxSettings.xhr();
  support.cors = !!xhrSupported && ("withCredentials" in xhrSupported);
  support.ajax = xhrSupported = !!xhrSupported;
  jQuery.ajaxTransport(function(options) {
    var callback,
        errorCallback;
    if (support.cors || xhrSupported && !options.crossDomain) {
      return {
        send: function(headers, complete) {
          var i,
              xhr = options.xhr();
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers["X-Requested-With"]) {
            headers["X-Requested-With"] = "XMLHttpRequest";
          }
          for (i in headers) {
            xhr.setRequestHeader(i, headers[i]);
          }
          callback = function(type) {
            return function() {
              if (callback) {
                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;
                if (type === "abort") {
                  xhr.abort();
                } else if (type === "error") {
                  if (typeof xhr.status !== "number") {
                    complete(0, "error");
                  } else {
                    complete(xhr.status, xhr.statusText);
                  }
                } else {
                  complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders());
                }
              }
            };
          };
          xhr.onload = callback();
          errorCallback = xhr.onerror = callback("error");
          if (xhr.onabort !== undefined) {
            xhr.onabort = errorCallback;
          } else {
            xhr.onreadystatechange = function() {
              if (xhr.readyState === 4) {
                window.setTimeout(function() {
                  if (callback) {
                    errorCallback();
                  }
                });
              }
            };
          }
          callback = callback("abort");
          try {
            xhr.send(options.hasContent && options.data || null);
          } catch (e) {
            if (callback) {
              throw e;
            }
          }
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  jQuery.ajaxSetup({
    accepts: {script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"},
    contents: {script: /\b(?:java|ecma)script\b/},
    converters: {"text script": function(text) {
        jQuery.globalEval(text);
        return text;
      }}
  });
  jQuery.ajaxPrefilter("script", function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = "GET";
    }
  });
  jQuery.ajaxTransport("script", function(s) {
    if (s.crossDomain) {
      var script,
          callback;
      return {
        send: function(_, complete) {
          script = jQuery("<script>").prop({
            charset: s.scriptCharset,
            src: s.url
          }).on("load error", callback = function(evt) {
            script.remove();
            callback = null;
            if (evt) {
              complete(evt.type === "error" ? 404 : 200, evt.type);
            }
          });
          document.head.appendChild(script[0]);
        },
        abort: function() {
          if (callback) {
            callback();
          }
        }
      };
    }
  });
  var oldCallbacks = [],
      rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({
    jsonp: "callback",
    jsonpCallback: function() {
      var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
      this[callback] = true;
      return callback;
    }
  });
  jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {
    var callbackName,
        overwritten,
        responseContainer,
        jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");
    if (jsonProp || s.dataTypes[0] === "jsonp") {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
      } else if (s.jsonp !== false) {
        s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
      }
      s.converters["script json"] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + " was not called");
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = "json";
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        if (overwritten === undefined) {
          jQuery(window).removeProp(callbackName);
        } else {
          window[callbackName] = overwritten;
        }
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return "script";
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== "string") {
      return null;
    }
    if (typeof context === "boolean") {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data),
        scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== "string" && _load) {
      return _load.apply(this, arguments);
    }
    var selector,
        type,
        response,
        self = this,
        off = url.indexOf(" ");
    if (off > -1) {
      selector = jQuery.trim(url.slice(off));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else if (params && typeof params === "object") {
      type = "POST";
    }
    if (self.length > 0) {
      jQuery.ajax({
        url: url,
        type: type || "GET",
        dataType: "html",
        data: params
      }).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).always(callback && function(jqXHR, status) {
        self.each(function() {
          callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
        });
      });
    }
    return this;
  };
  jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
  }
  jQuery.offset = {setOffset: function(elem, options, i) {
      var curPosition,
          curLeft,
          curCSSTop,
          curTop,
          curOffset,
          curCSSLeft,
          calculatePosition,
          position = jQuery.css(elem, "position"),
          curElem = jQuery(elem),
          props = {};
      if (position === "static") {
        elem.style.position = "relative";
      }
      curOffset = curElem.offset();
      curCSSTop = jQuery.css(elem, "top");
      curCSSLeft = jQuery.css(elem, "left");
      calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;
      if (calculatePosition) {
        curPosition = curElem.position();
        curTop = curPosition.top;
        curLeft = curPosition.left;
      } else {
        curTop = parseFloat(curCSSTop) || 0;
        curLeft = parseFloat(curCSSLeft) || 0;
      }
      if (jQuery.isFunction(options)) {
        options = options.call(elem, i, jQuery.extend({}, curOffset));
      }
      if (options.top != null) {
        props.top = (options.top - curOffset.top) + curTop;
      }
      if (options.left != null) {
        props.left = (options.left - curOffset.left) + curLeft;
      }
      if ("using" in options) {
        options.using.call(elem, props);
      } else {
        curElem.css(props);
      }
    }};
  jQuery.fn.extend({
    offset: function(options) {
      if (arguments.length) {
        return options === undefined ? this : this.each(function(i) {
          jQuery.offset.setOffset(this, options, i);
        });
      }
      var docElem,
          win,
          elem = this[0],
          box = {
            top: 0,
            left: 0
          },
          doc = elem && elem.ownerDocument;
      if (!doc) {
        return;
      }
      docElem = doc.documentElement;
      if (!jQuery.contains(docElem, elem)) {
        return box;
      }
      box = elem.getBoundingClientRect();
      win = getWindow(doc);
      return {
        top: box.top + win.pageYOffset - docElem.clientTop,
        left: box.left + win.pageXOffset - docElem.clientLeft
      };
    },
    position: function() {
      if (!this[0]) {
        return;
      }
      var offsetParent,
          offset,
          elem = this[0],
          parentOffset = {
            top: 0,
            left: 0
          };
      if (jQuery.css(elem, "position") === "fixed") {
        offset = elem.getBoundingClientRect();
      } else {
        offsetParent = this.offsetParent();
        offset = this.offset();
        if (!jQuery.nodeName(offsetParent[0], "html")) {
          parentOffset = offsetParent.offset();
        }
        parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
        parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
      }
      return {
        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
      };
    },
    offsetParent: function() {
      return this.map(function() {
        var offsetParent = this.offsetParent;
        while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
          offsetParent = offsetParent.offsetParent;
        }
        return offsetParent || documentElement;
      });
    }
  });
  jQuery.each({
    scrollLeft: "pageXOffset",
    scrollTop: "pageYOffset"
  }, function(method, prop) {
    var top = "pageYOffset" === prop;
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? win[prop] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length);
    };
  });
  jQuery.each(["top", "left"], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
      }
    });
  });
  jQuery.each({
    Height: "height",
    Width: "width"
  }, function(name, type) {
    jQuery.each({
      padding: "inner" + name,
      content: type,
      "": "outer" + name
    }, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean"),
            extra = defaultExtra || (margin === true || value === true ? "margin" : "border");
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement["client" + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.extend({
    bind: function(types, data, fn) {
      return this.on(types, null, data, fn);
    },
    unbind: function(types, fn) {
      return this.off(types, null, fn);
    },
    delegate: function(selector, types, data, fn) {
      return this.on(types, selector, data, fn);
    },
    undelegate: function(selector, types, fn) {
      return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
    },
    size: function() {
      return this.length;
    }
  });
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === "function" && define.amd) {
    define("be", [], function() {
      return jQuery;
    }), define("jquery", ["be"], function(m) {
      return m;
    });
  }
  var _jQuery = window.jQuery,
      _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (!noGlobal) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
}));

})();
(function() {
var define = $__System.amdDefine;
define("3", ["be"], function(main) {
  return main;
});

})();
$__System.registerDynamic("bf", [], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  var process = module.exports = {};
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
  }
  process.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      setTimeout(drainQueue, 0);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = '';
  process.versions = {};
  function noop() {}
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.binding = function(name) {
    throw new Error('process.binding is not supported');
  };
  process.cwd = function() {
    return '/';
  };
  process.chdir = function(dir) {
    throw new Error('process.chdir is not supported');
  };
  process.umask = function() {
    return 0;
  };
  return module.exports;
});

$__System.registerDynamic("c0", ["bf"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('bf');
  return module.exports;
});

$__System.registerDynamic("c1", ["c0"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__System._nodeRequire ? process : $__require('c0');
  return module.exports;
});

$__System.registerDynamic("22", ["c1"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('c1');
  return module.exports;
});

$__System.registerDynamic("c2", ["32", "3", "22"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(process) {
    (function(factory) {
      var root = (typeof self == 'object' && self.self === self && self) || (typeof global == 'object' && global.global === global && global);
      if (typeof define === 'function' && define.amd) {
        define(['underscore', 'jquery', 'exports'], function(_, $, exports) {
          root.Backbone = factory(root, exports, _, $);
        });
      } else if (typeof exports !== 'undefined') {
        var _ = $__require('32'),
            $;
        try {
          $ = $__require('3');
        } catch (e) {}
        factory(root, exports, _, $);
      } else {
        root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
      }
    })(function(root, Backbone, _, $) {
      var previousBackbone = root.Backbone;
      var slice = Array.prototype.slice;
      Backbone.VERSION = '1.3.2';
      Backbone.$ = $;
      Backbone.noConflict = function() {
        root.Backbone = previousBackbone;
        return this;
      };
      Backbone.emulateHTTP = false;
      Backbone.emulateJSON = false;
      var addMethod = function(length, method, attribute) {
        switch (length) {
          case 1:
            return function() {
              return _[method](this[attribute]);
            };
          case 2:
            return function(value) {
              return _[method](this[attribute], value);
            };
          case 3:
            return function(iteratee, context) {
              return _[method](this[attribute], cb(iteratee, this), context);
            };
          case 4:
            return function(iteratee, defaultVal, context) {
              return _[method](this[attribute], cb(iteratee, this), defaultVal, context);
            };
          default:
            return function() {
              var args = slice.call(arguments);
              args.unshift(this[attribute]);
              return _[method].apply(_, args);
            };
        }
      };
      var addUnderscoreMethods = function(Class, methods, attribute) {
        _.each(methods, function(length, method) {
          if (_[method])
            Class.prototype[method] = addMethod(length, method, attribute);
        });
      };
      var cb = function(iteratee, instance) {
        if (_.isFunction(iteratee))
          return iteratee;
        if (_.isObject(iteratee) && !instance._isModel(iteratee))
          return modelMatcher(iteratee);
        if (_.isString(iteratee))
          return function(model) {
            return model.get(iteratee);
          };
        return iteratee;
      };
      var modelMatcher = function(attrs) {
        var matcher = _.matches(attrs);
        return function(model) {
          return matcher(model.attributes);
        };
      };
      var Events = Backbone.Events = {};
      var eventSplitter = /\s+/;
      var eventsApi = function(iteratee, events, name, callback, opts) {
        var i = 0,
            names;
        if (name && typeof name === 'object') {
          if (callback !== void 0 && 'context' in opts && opts.context === void 0)
            opts.context = callback;
          for (names = _.keys(name); i < names.length; i++) {
            events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
          }
        } else if (name && eventSplitter.test(name)) {
          for (names = name.split(eventSplitter); i < names.length; i++) {
            events = iteratee(events, names[i], callback, opts);
          }
        } else {
          events = iteratee(events, name, callback, opts);
        }
        return events;
      };
      Events.on = function(name, callback, context) {
        return internalOn(this, name, callback, context);
      };
      var internalOn = function(obj, name, callback, context, listening) {
        obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
          context: context,
          ctx: obj,
          listening: listening
        });
        if (listening) {
          var listeners = obj._listeners || (obj._listeners = {});
          listeners[listening.id] = listening;
        }
        return obj;
      };
      Events.listenTo = function(obj, name, callback) {
        if (!obj)
          return this;
        var id = obj._listenId || (obj._listenId = _.uniqueId('l'));
        var listeningTo = this._listeningTo || (this._listeningTo = {});
        var listening = listeningTo[id];
        if (!listening) {
          var thisId = this._listenId || (this._listenId = _.uniqueId('l'));
          listening = listeningTo[id] = {
            obj: obj,
            objId: id,
            id: thisId,
            listeningTo: listeningTo,
            count: 0
          };
        }
        internalOn(obj, name, callback, this, listening);
        return this;
      };
      var onApi = function(events, name, callback, options) {
        if (callback) {
          var handlers = events[name] || (events[name] = []);
          var context = options.context,
              ctx = options.ctx,
              listening = options.listening;
          if (listening)
            listening.count++;
          handlers.push({
            callback: callback,
            context: context,
            ctx: context || ctx,
            listening: listening
          });
        }
        return events;
      };
      Events.off = function(name, callback, context) {
        if (!this._events)
          return this;
        this._events = eventsApi(offApi, this._events, name, callback, {
          context: context,
          listeners: this._listeners
        });
        return this;
      };
      Events.stopListening = function(obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo)
          return this;
        var ids = obj ? [obj._listenId] : _.keys(listeningTo);
        for (var i = 0; i < ids.length; i++) {
          var listening = listeningTo[ids[i]];
          if (!listening)
            break;
          listening.obj.off(name, callback, this);
        }
        return this;
      };
      var offApi = function(events, name, callback, options) {
        if (!events)
          return;
        var i = 0,
            listening;
        var context = options.context,
            listeners = options.listeners;
        if (!name && !callback && !context) {
          var ids = _.keys(listeners);
          for (; i < ids.length; i++) {
            listening = listeners[ids[i]];
            delete listeners[listening.id];
            delete listening.listeningTo[listening.objId];
          }
          return;
        }
        var names = name ? [name] : _.keys(events);
        for (; i < names.length; i++) {
          name = names[i];
          var handlers = events[name];
          if (!handlers)
            break;
          var remaining = [];
          for (var j = 0; j < handlers.length; j++) {
            var handler = handlers[j];
            if (callback && callback !== handler.callback && callback !== handler.callback._callback || context && context !== handler.context) {
              remaining.push(handler);
            } else {
              listening = handler.listening;
              if (listening && --listening.count === 0) {
                delete listeners[listening.id];
                delete listening.listeningTo[listening.objId];
              }
            }
          }
          if (remaining.length) {
            events[name] = remaining;
          } else {
            delete events[name];
          }
        }
        return events;
      };
      Events.once = function(name, callback, context) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.off, this));
        if (typeof name === 'string' && context == null)
          callback = void 0;
        return this.on(events, callback, context);
      };
      Events.listenToOnce = function(obj, name, callback) {
        var events = eventsApi(onceMap, {}, name, callback, _.bind(this.stopListening, this, obj));
        return this.listenTo(obj, events);
      };
      var onceMap = function(map, name, callback, offer) {
        if (callback) {
          var once = map[name] = _.once(function() {
            offer(name, once);
            callback.apply(this, arguments);
          });
          once._callback = callback;
        }
        return map;
      };
      Events.trigger = function(name) {
        if (!this._events)
          return this;
        var length = Math.max(0, arguments.length - 1);
        var args = Array(length);
        for (var i = 0; i < length; i++)
          args[i] = arguments[i + 1];
        eventsApi(triggerApi, this._events, name, void 0, args);
        return this;
      };
      var triggerApi = function(objEvents, name, callback, args) {
        if (objEvents) {
          var events = objEvents[name];
          var allEvents = objEvents.all;
          if (events && allEvents)
            allEvents = allEvents.slice();
          if (events)
            triggerEvents(events, args);
          if (allEvents)
            triggerEvents(allEvents, [name].concat(args));
        }
        return objEvents;
      };
      var triggerEvents = function(events, args) {
        var ev,
            i = -1,
            l = events.length,
            a1 = args[0],
            a2 = args[1],
            a3 = args[2];
        switch (args.length) {
          case 0:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx);
            return;
          case 1:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1);
            return;
          case 2:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1, a2);
            return;
          case 3:
            while (++i < l)
              (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            return;
          default:
            while (++i < l)
              (ev = events[i]).callback.apply(ev.ctx, args);
            return;
        }
      };
      Events.bind = Events.on;
      Events.unbind = Events.off;
      _.extend(Backbone, Events);
      var Model = Backbone.Model = function(attributes, options) {
        var attrs = attributes || {};
        options || (options = {});
        this.cid = _.uniqueId(this.cidPrefix);
        this.attributes = {};
        if (options.collection)
          this.collection = options.collection;
        if (options.parse)
          attrs = this.parse(attrs, options) || {};
        var defaults = _.result(this, 'defaults');
        attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
        this.set(attrs, options);
        this.changed = {};
        this.initialize.apply(this, arguments);
      };
      _.extend(Model.prototype, Events, {
        changed: null,
        validationError: null,
        idAttribute: 'id',
        cidPrefix: 'c',
        initialize: function() {},
        toJSON: function(options) {
          return _.clone(this.attributes);
        },
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
        get: function(attr) {
          return this.attributes[attr];
        },
        escape: function(attr) {
          return _.escape(this.get(attr));
        },
        has: function(attr) {
          return this.get(attr) != null;
        },
        matches: function(attrs) {
          return !!_.iteratee(attrs, this)(this.attributes);
        },
        set: function(key, val, options) {
          if (key == null)
            return this;
          var attrs;
          if (typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options || (options = {});
          if (!this._validate(attrs, options))
            return false;
          var unset = options.unset;
          var silent = options.silent;
          var changes = [];
          var changing = this._changing;
          this._changing = true;
          if (!changing) {
            this._previousAttributes = _.clone(this.attributes);
            this.changed = {};
          }
          var current = this.attributes;
          var changed = this.changed;
          var prev = this._previousAttributes;
          for (var attr in attrs) {
            val = attrs[attr];
            if (!_.isEqual(current[attr], val))
              changes.push(attr);
            if (!_.isEqual(prev[attr], val)) {
              changed[attr] = val;
            } else {
              delete changed[attr];
            }
            unset ? delete current[attr] : current[attr] = val;
          }
          if (this.idAttribute in attrs)
            this.id = this.get(this.idAttribute);
          if (!silent) {
            if (changes.length)
              this._pending = options;
            for (var i = 0; i < changes.length; i++) {
              this.trigger('change:' + changes[i], this, current[changes[i]], options);
            }
          }
          if (changing)
            return this;
          if (!silent) {
            while (this._pending) {
              options = this._pending;
              this._pending = false;
              this.trigger('change', this, options);
            }
          }
          this._pending = false;
          this._changing = false;
          return this;
        },
        unset: function(attr, options) {
          return this.set(attr, void 0, _.extend({}, options, {unset: true}));
        },
        clear: function(options) {
          var attrs = {};
          for (var key in this.attributes)
            attrs[key] = void 0;
          return this.set(attrs, _.extend({}, options, {unset: true}));
        },
        hasChanged: function(attr) {
          if (attr == null)
            return !_.isEmpty(this.changed);
          return _.has(this.changed, attr);
        },
        changedAttributes: function(diff) {
          if (!diff)
            return this.hasChanged() ? _.clone(this.changed) : false;
          var old = this._changing ? this._previousAttributes : this.attributes;
          var changed = {};
          for (var attr in diff) {
            var val = diff[attr];
            if (_.isEqual(old[attr], val))
              continue;
            changed[attr] = val;
          }
          return _.size(changed) ? changed : false;
        },
        previous: function(attr) {
          if (attr == null || !this._previousAttributes)
            return null;
          return this._previousAttributes[attr];
        },
        previousAttributes: function() {
          return _.clone(this._previousAttributes);
        },
        fetch: function(options) {
          options = _.extend({parse: true}, options);
          var model = this;
          var success = options.success;
          options.success = function(resp) {
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (!model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        save: function(key, val, options) {
          var attrs;
          if (key == null || typeof key === 'object') {
            attrs = key;
            options = val;
          } else {
            (attrs = {})[key] = val;
          }
          options = _.extend({
            validate: true,
            parse: true
          }, options);
          var wait = options.wait;
          if (attrs && !wait) {
            if (!this.set(attrs, options))
              return false;
          } else if (!this._validate(attrs, options)) {
            return false;
          }
          var model = this;
          var success = options.success;
          var attributes = this.attributes;
          options.success = function(resp) {
            model.attributes = attributes;
            var serverAttrs = options.parse ? model.parse(resp, options) : resp;
            if (wait)
              serverAttrs = _.extend({}, attrs, serverAttrs);
            if (serverAttrs && !model.set(serverAttrs, options))
              return false;
            if (success)
              success.call(options.context, model, resp, options);
            model.trigger('sync', model, resp, options);
          };
          wrapError(this, options);
          if (attrs && wait)
            this.attributes = _.extend({}, attributes, attrs);
          var method = this.isNew() ? 'create' : (options.patch ? 'patch' : 'update');
          if (method === 'patch' && !options.attrs)
            options.attrs = attrs;
          var xhr = this.sync(method, this, options);
          this.attributes = attributes;
          return xhr;
        },
        destroy: function(options) {
          options = options ? _.clone(options) : {};
          var model = this;
          var success = options.success;
          var wait = options.wait;
          var destroy = function() {
            model.stopListening();
            model.trigger('destroy', model, model.collection, options);
          };
          options.success = function(resp) {
            if (wait)
              destroy();
            if (success)
              success.call(options.context, model, resp, options);
            if (!model.isNew())
              model.trigger('sync', model, resp, options);
          };
          var xhr = false;
          if (this.isNew()) {
            _.defer(options.success);
          } else {
            wrapError(this, options);
            xhr = this.sync('delete', this, options);
          }
          if (!wait)
            destroy();
          return xhr;
        },
        url: function() {
          var base = _.result(this, 'urlRoot') || _.result(this.collection, 'url') || urlError();
          if (this.isNew())
            return base;
          var id = this.get(this.idAttribute);
          return base.replace(/[^\/]$/, '$&/') + encodeURIComponent(id);
        },
        parse: function(resp, options) {
          return resp;
        },
        clone: function() {
          return new this.constructor(this.attributes);
        },
        isNew: function() {
          return !this.has(this.idAttribute);
        },
        isValid: function(options) {
          return this._validate({}, _.extend({}, options, {validate: true}));
        },
        _validate: function(attrs, options) {
          if (!options.validate || !this.validate)
            return true;
          attrs = _.extend({}, this.attributes, attrs);
          var error = this.validationError = this.validate(attrs, options) || null;
          if (!error)
            return true;
          this.trigger('invalid', this, error, _.extend(options, {validationError: error}));
          return false;
        }
      });
      var modelMethods = {
        keys: 1,
        values: 1,
        pairs: 1,
        invert: 1,
        pick: 0,
        omit: 0,
        chain: 1,
        isEmpty: 1
      };
      addUnderscoreMethods(Model, modelMethods, 'attributes');
      var Collection = Backbone.Collection = function(models, options) {
        options || (options = {});
        if (options.model)
          this.model = options.model;
        if (options.comparator !== void 0)
          this.comparator = options.comparator;
        this._reset();
        this.initialize.apply(this, arguments);
        if (models)
          this.reset(models, _.extend({silent: true}, options));
      };
      var setOptions = {
        add: true,
        remove: true,
        merge: true
      };
      var addOptions = {
        add: true,
        remove: false
      };
      var splice = function(array, insert, at) {
        at = Math.min(Math.max(at, 0), array.length);
        var tail = Array(array.length - at);
        var length = insert.length;
        var i;
        for (i = 0; i < tail.length; i++)
          tail[i] = array[i + at];
        for (i = 0; i < length; i++)
          array[i + at] = insert[i];
        for (i = 0; i < tail.length; i++)
          array[i + length + at] = tail[i];
      };
      _.extend(Collection.prototype, Events, {
        model: Model,
        initialize: function() {},
        toJSON: function(options) {
          return this.map(function(model) {
            return model.toJSON(options);
          });
        },
        sync: function() {
          return Backbone.sync.apply(this, arguments);
        },
        add: function(models, options) {
          return this.set(models, _.extend({merge: false}, options, addOptions));
        },
        remove: function(models, options) {
          options = _.extend({}, options);
          var singular = !_.isArray(models);
          models = singular ? [models] : models.slice();
          var removed = this._removeModels(models, options);
          if (!options.silent && removed.length) {
            options.changes = {
              added: [],
              merged: [],
              removed: removed
            };
            this.trigger('update', this, options);
          }
          return singular ? removed[0] : removed;
        },
        set: function(models, options) {
          if (models == null)
            return;
          options = _.extend({}, setOptions, options);
          if (options.parse && !this._isModel(models)) {
            models = this.parse(models, options) || [];
          }
          var singular = !_.isArray(models);
          models = singular ? [models] : models.slice();
          var at = options.at;
          if (at != null)
            at = +at;
          if (at > this.length)
            at = this.length;
          if (at < 0)
            at += this.length + 1;
          var set = [];
          var toAdd = [];
          var toMerge = [];
          var toRemove = [];
          var modelMap = {};
          var add = options.add;
          var merge = options.merge;
          var remove = options.remove;
          var sort = false;
          var sortable = this.comparator && at == null && options.sort !== false;
          var sortAttr = _.isString(this.comparator) ? this.comparator : null;
          var model,
              i;
          for (i = 0; i < models.length; i++) {
            model = models[i];
            var existing = this.get(model);
            if (existing) {
              if (merge && model !== existing) {
                var attrs = this._isModel(model) ? model.attributes : model;
                if (options.parse)
                  attrs = existing.parse(attrs, options);
                existing.set(attrs, options);
                toMerge.push(existing);
                if (sortable && !sort)
                  sort = existing.hasChanged(sortAttr);
              }
              if (!modelMap[existing.cid]) {
                modelMap[existing.cid] = true;
                set.push(existing);
              }
              models[i] = existing;
            } else if (add) {
              model = models[i] = this._prepareModel(model, options);
              if (model) {
                toAdd.push(model);
                this._addReference(model, options);
                modelMap[model.cid] = true;
                set.push(model);
              }
            }
          }
          if (remove) {
            for (i = 0; i < this.length; i++) {
              model = this.models[i];
              if (!modelMap[model.cid])
                toRemove.push(model);
            }
            if (toRemove.length)
              this._removeModels(toRemove, options);
          }
          var orderChanged = false;
          var replace = !sortable && add && remove;
          if (set.length && replace) {
            orderChanged = this.length !== set.length || _.some(this.models, function(m, index) {
              return m !== set[index];
            });
            this.models.length = 0;
            splice(this.models, set, 0);
            this.length = this.models.length;
          } else if (toAdd.length) {
            if (sortable)
              sort = true;
            splice(this.models, toAdd, at == null ? this.length : at);
            this.length = this.models.length;
          }
          if (sort)
            this.sort({silent: true});
          if (!options.silent) {
            for (i = 0; i < toAdd.length; i++) {
              if (at != null)
                options.index = at + i;
              model = toAdd[i];
              model.trigger('add', model, this, options);
            }
            if (sort || orderChanged)
              this.trigger('sort', this, options);
            if (toAdd.length || toRemove.length || toMerge.length) {
              options.changes = {
                added: toAdd,
                removed: toRemove,
                merged: toMerge
              };
              this.trigger('update', this, options);
            }
          }
          return singular ? models[0] : models;
        },
        reset: function(models, options) {
          options = options ? _.clone(options) : {};
          for (var i = 0; i < this.models.length; i++) {
            this._removeReference(this.models[i], options);
          }
          options.previousModels = this.models;
          this._reset();
          models = this.add(models, _.extend({silent: true}, options));
          if (!options.silent)
            this.trigger('reset', this, options);
          return models;
        },
        push: function(model, options) {
          return this.add(model, _.extend({at: this.length}, options));
        },
        pop: function(options) {
          var model = this.at(this.length - 1);
          return this.remove(model, options);
        },
        unshift: function(model, options) {
          return this.add(model, _.extend({at: 0}, options));
        },
        shift: function(options) {
          var model = this.at(0);
          return this.remove(model, options);
        },
        slice: function() {
          return slice.apply(this.models, arguments);
        },
        get: function(obj) {
          if (obj == null)
            return void 0;
          return this._byId[obj] || this._byId[this.modelId(obj.attributes || obj)] || obj.cid && this._byId[obj.cid];
        },
        has: function(obj) {
          return this.get(obj) != null;
        },
        at: function(index) {
          if (index < 0)
            index += this.length;
          return this.models[index];
        },
        where: function(attrs, first) {
          return this[first ? 'find' : 'filter'](attrs);
        },
        findWhere: function(attrs) {
          return this.where(attrs, true);
        },
        sort: function(options) {
          var comparator = this.comparator;
          if (!comparator)
            throw new Error('Cannot sort a set without a comparator');
          options || (options = {});
          var length = comparator.length;
          if (_.isFunction(comparator))
            comparator = _.bind(comparator, this);
          if (length === 1 || _.isString(comparator)) {
            this.models = this.sortBy(comparator);
          } else {
            this.models.sort(comparator);
          }
          if (!options.silent)
            this.trigger('sort', this, options);
          return this;
        },
        pluck: function(attr) {
          return this.map(attr + '');
        },
        fetch: function(options) {
          options = _.extend({parse: true}, options);
          var success = options.success;
          var collection = this;
          options.success = function(resp) {
            var method = options.reset ? 'reset' : 'set';
            collection[method](resp, options);
            if (success)
              success.call(options.context, collection, resp, options);
            collection.trigger('sync', collection, resp, options);
          };
          wrapError(this, options);
          return this.sync('read', this, options);
        },
        create: function(model, options) {
          options = options ? _.clone(options) : {};
          var wait = options.wait;
          model = this._prepareModel(model, options);
          if (!model)
            return false;
          if (!wait)
            this.add(model, options);
          var collection = this;
          var success = options.success;
          options.success = function(m, resp, callbackOpts) {
            if (wait)
              collection.add(m, callbackOpts);
            if (success)
              success.call(callbackOpts.context, m, resp, callbackOpts);
          };
          model.save(null, options);
          return model;
        },
        parse: function(resp, options) {
          return resp;
        },
        clone: function() {
          return new this.constructor(this.models, {
            model: this.model,
            comparator: this.comparator
          });
        },
        modelId: function(attrs) {
          return attrs[this.model.prototype.idAttribute || 'id'];
        },
        _reset: function() {
          this.length = 0;
          this.models = [];
          this._byId = {};
        },
        _prepareModel: function(attrs, options) {
          if (this._isModel(attrs)) {
            if (!attrs.collection)
              attrs.collection = this;
            return attrs;
          }
          options = options ? _.clone(options) : {};
          options.collection = this;
          var model = new this.model(attrs, options);
          if (!model.validationError)
            return model;
          this.trigger('invalid', this, model.validationError, options);
          return false;
        },
        _removeModels: function(models, options) {
          var removed = [];
          for (var i = 0; i < models.length; i++) {
            var model = this.get(models[i]);
            if (!model)
              continue;
            var index = this.indexOf(model);
            this.models.splice(index, 1);
            this.length--;
            delete this._byId[model.cid];
            var id = this.modelId(model.attributes);
            if (id != null)
              delete this._byId[id];
            if (!options.silent) {
              options.index = index;
              model.trigger('remove', model, this, options);
            }
            removed.push(model);
            this._removeReference(model, options);
          }
          return removed;
        },
        _isModel: function(model) {
          return model instanceof Model;
        },
        _addReference: function(model, options) {
          this._byId[model.cid] = model;
          var id = this.modelId(model.attributes);
          if (id != null)
            this._byId[id] = model;
          model.on('all', this._onModelEvent, this);
        },
        _removeReference: function(model, options) {
          delete this._byId[model.cid];
          var id = this.modelId(model.attributes);
          if (id != null)
            delete this._byId[id];
          if (this === model.collection)
            delete model.collection;
          model.off('all', this._onModelEvent, this);
        },
        _onModelEvent: function(event, model, collection, options) {
          if (model) {
            if ((event === 'add' || event === 'remove') && collection !== this)
              return;
            if (event === 'destroy')
              this.remove(model, options);
            if (event === 'change') {
              var prevId = this.modelId(model.previousAttributes());
              var id = this.modelId(model.attributes);
              if (prevId !== id) {
                if (prevId != null)
                  delete this._byId[prevId];
                if (id != null)
                  this._byId[id] = model;
              }
            }
          }
          this.trigger.apply(this, arguments);
        }
      });
      var collectionMethods = {
        forEach: 3,
        each: 3,
        map: 3,
        collect: 3,
        reduce: 0,
        foldl: 0,
        inject: 0,
        reduceRight: 0,
        foldr: 0,
        find: 3,
        detect: 3,
        filter: 3,
        select: 3,
        reject: 3,
        every: 3,
        all: 3,
        some: 3,
        any: 3,
        include: 3,
        includes: 3,
        contains: 3,
        invoke: 0,
        max: 3,
        min: 3,
        toArray: 1,
        size: 1,
        first: 3,
        head: 3,
        take: 3,
        initial: 3,
        rest: 3,
        tail: 3,
        drop: 3,
        last: 3,
        without: 0,
        difference: 0,
        indexOf: 3,
        shuffle: 1,
        lastIndexOf: 3,
        isEmpty: 1,
        chain: 1,
        sample: 3,
        partition: 3,
        groupBy: 3,
        countBy: 3,
        sortBy: 3,
        indexBy: 3,
        findIndex: 3,
        findLastIndex: 3
      };
      addUnderscoreMethods(Collection, collectionMethods, 'models');
      var View = Backbone.View = function(options) {
        this.cid = _.uniqueId('view');
        _.extend(this, _.pick(options, viewOptions));
        this._ensureElement();
        this.initialize.apply(this, arguments);
      };
      var delegateEventSplitter = /^(\S+)\s*(.*)$/;
      var viewOptions = ['model', 'collection', 'el', 'id', 'attributes', 'className', 'tagName', 'events'];
      _.extend(View.prototype, Events, {
        tagName: 'div',
        $: function(selector) {
          return this.$el.find(selector);
        },
        initialize: function() {},
        render: function() {
          return this;
        },
        remove: function() {
          this._removeElement();
          this.stopListening();
          return this;
        },
        _removeElement: function() {
          this.$el.remove();
        },
        setElement: function(element) {
          this.undelegateEvents();
          this._setElement(element);
          this.delegateEvents();
          return this;
        },
        _setElement: function(el) {
          this.$el = el instanceof Backbone.$ ? el : Backbone.$(el);
          this.el = this.$el[0];
        },
        delegateEvents: function(events) {
          events || (events = _.result(this, 'events'));
          if (!events)
            return this;
          this.undelegateEvents();
          for (var key in events) {
            var method = events[key];
            if (!_.isFunction(method))
              method = this[method];
            if (!method)
              continue;
            var match = key.match(delegateEventSplitter);
            this.delegate(match[1], match[2], _.bind(method, this));
          }
          return this;
        },
        delegate: function(eventName, selector, listener) {
          this.$el.on(eventName + '.delegateEvents' + this.cid, selector, listener);
          return this;
        },
        undelegateEvents: function() {
          if (this.$el)
            this.$el.off('.delegateEvents' + this.cid);
          return this;
        },
        undelegate: function(eventName, selector, listener) {
          this.$el.off(eventName + '.delegateEvents' + this.cid, selector, listener);
          return this;
        },
        _createElement: function(tagName) {
          return document.createElement(tagName);
        },
        _ensureElement: function() {
          if (!this.el) {
            var attrs = _.extend({}, _.result(this, 'attributes'));
            if (this.id)
              attrs.id = _.result(this, 'id');
            if (this.className)
              attrs['class'] = _.result(this, 'className');
            this.setElement(this._createElement(_.result(this, 'tagName')));
            this._setAttributes(attrs);
          } else {
            this.setElement(_.result(this, 'el'));
          }
        },
        _setAttributes: function(attributes) {
          this.$el.attr(attributes);
        }
      });
      Backbone.sync = function(method, model, options) {
        var type = methodMap[method];
        _.defaults(options || (options = {}), {
          emulateHTTP: Backbone.emulateHTTP,
          emulateJSON: Backbone.emulateJSON
        });
        var params = {
          type: type,
          dataType: 'json'
        };
        if (!options.url) {
          params.url = _.result(model, 'url') || urlError();
        }
        if (options.data == null && model && (method === 'create' || method === 'update' || method === 'patch')) {
          params.contentType = 'application/json';
          params.data = JSON.stringify(options.attrs || model.toJSON(options));
        }
        if (options.emulateJSON) {
          params.contentType = 'application/x-www-form-urlencoded';
          params.data = params.data ? {model: params.data} : {};
        }
        if (options.emulateHTTP && (type === 'PUT' || type === 'DELETE' || type === 'PATCH')) {
          params.type = 'POST';
          if (options.emulateJSON)
            params.data._method = type;
          var beforeSend = options.beforeSend;
          options.beforeSend = function(xhr) {
            xhr.setRequestHeader('X-HTTP-Method-Override', type);
            if (beforeSend)
              return beforeSend.apply(this, arguments);
          };
        }
        if (params.type !== 'GET' && !options.emulateJSON) {
          params.processData = false;
        }
        var error = options.error;
        options.error = function(xhr, textStatus, errorThrown) {
          options.textStatus = textStatus;
          options.errorThrown = errorThrown;
          if (error)
            error.call(options.context, xhr, textStatus, errorThrown);
        };
        var xhr = options.xhr = Backbone.ajax(_.extend(params, options));
        model.trigger('request', model, xhr, options);
        return xhr;
      };
      var methodMap = {
        'create': 'POST',
        'update': 'PUT',
        'patch': 'PATCH',
        'delete': 'DELETE',
        'read': 'GET'
      };
      Backbone.ajax = function() {
        return Backbone.$.ajax.apply(Backbone.$, arguments);
      };
      var Router = Backbone.Router = function(options) {
        options || (options = {});
        if (options.routes)
          this.routes = options.routes;
        this._bindRoutes();
        this.initialize.apply(this, arguments);
      };
      var optionalParam = /\((.*?)\)/g;
      var namedParam = /(\(\?)?:\w+/g;
      var splatParam = /\*\w+/g;
      var escapeRegExp = /[\-{}\[\]+?.,\\\^$|#\s]/g;
      _.extend(Router.prototype, Events, {
        initialize: function() {},
        route: function(route, name, callback) {
          if (!_.isRegExp(route))
            route = this._routeToRegExp(route);
          if (_.isFunction(name)) {
            callback = name;
            name = '';
          }
          if (!callback)
            callback = this[name];
          var router = this;
          Backbone.history.route(route, function(fragment) {
            var args = router._extractParameters(route, fragment);
            if (router.execute(callback, args, name) !== false) {
              router.trigger.apply(router, ['route:' + name].concat(args));
              router.trigger('route', name, args);
              Backbone.history.trigger('route', router, name, args);
            }
          });
          return this;
        },
        execute: function(callback, args, name) {
          if (callback)
            callback.apply(this, args);
        },
        navigate: function(fragment, options) {
          Backbone.history.navigate(fragment, options);
          return this;
        },
        _bindRoutes: function() {
          if (!this.routes)
            return;
          this.routes = _.result(this, 'routes');
          var route,
              routes = _.keys(this.routes);
          while ((route = routes.pop()) != null) {
            this.route(route, this.routes[route]);
          }
        },
        _routeToRegExp: function(route) {
          route = route.replace(escapeRegExp, '\\$&').replace(optionalParam, '(?:$1)?').replace(namedParam, function(match, optional) {
            return optional ? match : '([^/?]+)';
          }).replace(splatParam, '([^?]*?)');
          return new RegExp('^' + route + '(?:\\?([\\s\\S]*))?$');
        },
        _extractParameters: function(route, fragment) {
          var params = route.exec(fragment).slice(1);
          return _.map(params, function(param, i) {
            if (i === params.length - 1)
              return param || null;
            return param ? decodeURIComponent(param) : null;
          });
        }
      });
      var History = Backbone.History = function() {
        this.handlers = [];
        this.checkUrl = _.bind(this.checkUrl, this);
        if (typeof window !== 'undefined') {
          this.location = window.location;
          this.history = window.history;
        }
      };
      var routeStripper = /^[#\/]|\s+$/g;
      var rootStripper = /^\/+|\/+$/g;
      var pathStripper = /#.*$/;
      History.started = false;
      _.extend(History.prototype, Events, {
        interval: 50,
        atRoot: function() {
          var path = this.location.pathname.replace(/[^\/]$/, '$&/');
          return path === this.root && !this.getSearch();
        },
        matchRoot: function() {
          var path = this.decodeFragment(this.location.pathname);
          var rootPath = path.slice(0, this.root.length - 1) + '/';
          return rootPath === this.root;
        },
        decodeFragment: function(fragment) {
          return decodeURI(fragment.replace(/%25/g, '%2525'));
        },
        getSearch: function() {
          var match = this.location.href.replace(/#.*/, '').match(/\?.+/);
          return match ? match[0] : '';
        },
        getHash: function(window) {
          var match = (window || this).location.href.match(/#(.*)$/);
          return match ? match[1] : '';
        },
        getPath: function() {
          var path = this.decodeFragment(this.location.pathname + this.getSearch()).slice(this.root.length - 1);
          return path.charAt(0) === '/' ? path.slice(1) : path;
        },
        getFragment: function(fragment) {
          if (fragment == null) {
            if (this._usePushState || !this._wantsHashChange) {
              fragment = this.getPath();
            } else {
              fragment = this.getHash();
            }
          }
          return fragment.replace(routeStripper, '');
        },
        start: function(options) {
          if (History.started)
            throw new Error('Backbone.history has already been started');
          History.started = true;
          this.options = _.extend({root: '/'}, this.options, options);
          this.root = this.options.root;
          this._wantsHashChange = this.options.hashChange !== false;
          this._hasHashChange = 'onhashchange' in window && (document.documentMode === void 0 || document.documentMode > 7);
          this._useHashChange = this._wantsHashChange && this._hasHashChange;
          this._wantsPushState = !!this.options.pushState;
          this._hasPushState = !!(this.history && this.history.pushState);
          this._usePushState = this._wantsPushState && this._hasPushState;
          this.fragment = this.getFragment();
          this.root = ('/' + this.root + '/').replace(rootStripper, '/');
          if (this._wantsHashChange && this._wantsPushState) {
            if (!this._hasPushState && !this.atRoot()) {
              var rootPath = this.root.slice(0, -1) || '/';
              this.location.replace(rootPath + '#' + this.getPath());
              return true;
            } else if (this._hasPushState && this.atRoot()) {
              this.navigate(this.getHash(), {replace: true});
            }
          }
          if (!this._hasHashChange && this._wantsHashChange && !this._usePushState) {
            this.iframe = document.createElement('iframe');
            this.iframe.src = 'javascript:0';
            this.iframe.style.display = 'none';
            this.iframe.tabIndex = -1;
            var body = document.body;
            var iWindow = body.insertBefore(this.iframe, body.firstChild).contentWindow;
            iWindow.document.open();
            iWindow.document.close();
            iWindow.location.hash = '#' + this.fragment;
          }
          var addEventListener = window.addEventListener || function(eventName, listener) {
            return attachEvent('on' + eventName, listener);
          };
          if (this._usePushState) {
            addEventListener('popstate', this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            addEventListener('hashchange', this.checkUrl, false);
          } else if (this._wantsHashChange) {
            this._checkUrlInterval = setInterval(this.checkUrl, this.interval);
          }
          if (!this.options.silent)
            return this.loadUrl();
        },
        stop: function() {
          var removeEventListener = window.removeEventListener || function(eventName, listener) {
            return detachEvent('on' + eventName, listener);
          };
          if (this._usePushState) {
            removeEventListener('popstate', this.checkUrl, false);
          } else if (this._useHashChange && !this.iframe) {
            removeEventListener('hashchange', this.checkUrl, false);
          }
          if (this.iframe) {
            document.body.removeChild(this.iframe);
            this.iframe = null;
          }
          if (this._checkUrlInterval)
            clearInterval(this._checkUrlInterval);
          History.started = false;
        },
        route: function(route, callback) {
          this.handlers.unshift({
            route: route,
            callback: callback
          });
        },
        checkUrl: function(e) {
          var current = this.getFragment();
          if (current === this.fragment && this.iframe) {
            current = this.getHash(this.iframe.contentWindow);
          }
          if (current === this.fragment)
            return false;
          if (this.iframe)
            this.navigate(current);
          this.loadUrl();
        },
        loadUrl: function(fragment) {
          if (!this.matchRoot())
            return false;
          fragment = this.fragment = this.getFragment(fragment);
          return _.some(this.handlers, function(handler) {
            if (handler.route.test(fragment)) {
              handler.callback(fragment);
              return true;
            }
          });
        },
        navigate: function(fragment, options) {
          if (!History.started)
            return false;
          if (!options || options === true)
            options = {trigger: !!options};
          fragment = this.getFragment(fragment || '');
          var rootPath = this.root;
          if (fragment === '' || fragment.charAt(0) === '?') {
            rootPath = rootPath.slice(0, -1) || '/';
          }
          var url = rootPath + fragment;
          fragment = this.decodeFragment(fragment.replace(pathStripper, ''));
          if (this.fragment === fragment)
            return;
          this.fragment = fragment;
          if (this._usePushState) {
            this.history[options.replace ? 'replaceState' : 'pushState']({}, document.title, url);
          } else if (this._wantsHashChange) {
            this._updateHash(this.location, fragment, options.replace);
            if (this.iframe && fragment !== this.getHash(this.iframe.contentWindow)) {
              var iWindow = this.iframe.contentWindow;
              if (!options.replace) {
                iWindow.document.open();
                iWindow.document.close();
              }
              this._updateHash(iWindow.location, fragment, options.replace);
            }
          } else {
            return this.location.assign(url);
          }
          if (options.trigger)
            return this.loadUrl(fragment);
        },
        _updateHash: function(location, fragment, replace) {
          if (replace) {
            var href = location.href.replace(/(javascript:|#).*$/, '');
            location.replace(href + '#' + fragment);
          } else {
            location.hash = '#' + fragment;
          }
        }
      });
      Backbone.history = new History;
      var extend = function(protoProps, staticProps) {
        var parent = this;
        var child;
        if (protoProps && _.has(protoProps, 'constructor')) {
          child = protoProps.constructor;
        } else {
          child = function() {
            return parent.apply(this, arguments);
          };
        }
        _.extend(child, parent, staticProps);
        child.prototype = _.create(parent.prototype, protoProps);
        child.prototype.constructor = child;
        child.__super__ = parent.prototype;
        return child;
      };
      Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;
      var urlError = function() {
        throw new Error('A "url" property or function must be specified');
      };
      var wrapError = function(model, options) {
        var error = options.error;
        options.error = function(resp) {
          if (error)
            error.call(options.context, model, resp, options);
          model.trigger('error', model, resp, options);
        };
      };
      return Backbone;
    });
  })($__require('22'));
  return module.exports;
});

$__System.registerDynamic("9b", ["c2"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('c2');
  return module.exports;
});

$__System.registerDynamic("c3", ["32", "9b"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  "format cjs";
  (function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory($__require('32'), $__require('9b')) : typeof define === 'function' && define.amd ? define(['underscore', 'backbone'], factory) : (global.Backbone = global.Backbone || {}, global.Backbone.Radio = factory(global._, global.Backbone));
  }(this, function(_, Backbone) {
    'use strict';
    _ = 'default' in _ ? _['default'] : _;
    Backbone = 'default' in Backbone ? Backbone['default'] : Backbone;
    var babelHelpers = {};
    babelHelpers.typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function(obj) {
      return typeof obj;
    } : function(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj;
    };
    babelHelpers;
    var previousRadio = Backbone.Radio;
    var Radio = Backbone.Radio = {};
    Radio.VERSION = '1.0.4';
    Radio.noConflict = function() {
      Backbone.Radio = previousRadio;
      return this;
    };
    Radio.DEBUG = false;
    Radio._debugText = function(warning, eventName, channelName) {
      return warning + (channelName ? ' on the ' + channelName + ' channel' : '') + ': "' + eventName + '"';
    };
    Radio.debugLog = function(warning, eventName, channelName) {
      if (Radio.DEBUG && console && console.warn) {
        console.warn(Radio._debugText(warning, eventName, channelName));
      }
    };
    var eventSplitter = /\s+/;
    Radio._eventsApi = function(obj, action, name, rest) {
      if (!name) {
        return false;
      }
      var results = {};
      if ((typeof name === 'undefined' ? 'undefined' : babelHelpers.typeof(name)) === 'object') {
        for (var key in name) {
          var result = obj[action].apply(obj, [key, name[key]].concat(rest));
          eventSplitter.test(key) ? _.extend(results, result) : results[key] = result;
        }
        return results;
      }
      if (eventSplitter.test(name)) {
        var names = name.split(eventSplitter);
        for (var i = 0,
            l = names.length; i < l; i++) {
          results[names[i]] = obj[action].apply(obj, [names[i]].concat(rest));
        }
        return results;
      }
      return false;
    };
    Radio._callHandler = function(callback, context, args) {
      var a1 = args[0],
          a2 = args[1],
          a3 = args[2];
      switch (args.length) {
        case 0:
          return callback.call(context);
        case 1:
          return callback.call(context, a1);
        case 2:
          return callback.call(context, a1, a2);
        case 3:
          return callback.call(context, a1, a2, a3);
        default:
          return callback.apply(context, args);
      }
    };
    function removeHandler(store, name, callback, context) {
      var event = store[name];
      if ((!callback || callback === event.callback || callback === event.callback._callback) && (!context || context === event.context)) {
        delete store[name];
        return true;
      }
    }
    function removeHandlers(store, name, callback, context) {
      store || (store = {});
      var names = name ? [name] : _.keys(store);
      var matched = false;
      for (var i = 0,
          length = names.length; i < length; i++) {
        name = names[i];
        if (!store[name]) {
          continue;
        }
        if (removeHandler(store, name, callback, context)) {
          matched = true;
        }
      }
      return matched;
    }
    var _logs = {};
    function _partial(channelName) {
      return _logs[channelName] || (_logs[channelName] = _.partial(Radio.log, channelName));
    }
    _.extend(Radio, {
      log: function log(channelName, eventName) {
        if (typeof console === 'undefined') {
          return;
        }
        var args = _.drop(arguments, 2);
        console.log('[' + channelName + '] "' + eventName + '"', args);
      },
      tuneIn: function tuneIn(channelName) {
        var channel = Radio.channel(channelName);
        channel._tunedIn = true;
        channel.on('all', _partial(channelName));
        return this;
      },
      tuneOut: function tuneOut(channelName) {
        var channel = Radio.channel(channelName);
        channel._tunedIn = false;
        channel.off('all', _partial(channelName));
        delete _logs[channelName];
        return this;
      }
    });
    function makeCallback(callback) {
      return _.isFunction(callback) ? callback : function() {
        return callback;
      };
    }
    Radio.Requests = {
      request: function request(name) {
        var args = _.rest(arguments);
        var results = Radio._eventsApi(this, 'request', name, args);
        if (results) {
          return results;
        }
        var channelName = this.channelName;
        var requests = this._requests;
        if (channelName && this._tunedIn) {
          Radio.log.apply(this, [channelName, name].concat(args));
        }
        if (requests && (requests[name] || requests['default'])) {
          var handler = requests[name] || requests['default'];
          args = requests[name] ? args : arguments;
          return Radio._callHandler(handler.callback, handler.context, args);
        } else {
          Radio.debugLog('An unhandled request was fired', name, channelName);
        }
      },
      reply: function reply(name, callback, context) {
        if (Radio._eventsApi(this, 'reply', name, [callback, context])) {
          return this;
        }
        this._requests || (this._requests = {});
        if (this._requests[name]) {
          Radio.debugLog('A request was overwritten', name, this.channelName);
        }
        this._requests[name] = {
          callback: makeCallback(callback),
          context: context || this
        };
        return this;
      },
      replyOnce: function replyOnce(name, callback, context) {
        if (Radio._eventsApi(this, 'replyOnce', name, [callback, context])) {
          return this;
        }
        var self = this;
        var once = _.once(function() {
          self.stopReplying(name);
          return makeCallback(callback).apply(this, arguments);
        });
        return this.reply(name, once, context);
      },
      stopReplying: function stopReplying(name, callback, context) {
        if (Radio._eventsApi(this, 'stopReplying', name)) {
          return this;
        }
        if (!name && !callback && !context) {
          delete this._requests;
        } else if (!removeHandlers(this._requests, name, callback, context)) {
          Radio.debugLog('Attempted to remove the unregistered request', name, this.channelName);
        }
        return this;
      }
    };
    Radio._channels = {};
    Radio.channel = function(channelName) {
      if (!channelName) {
        throw new Error('You must provide a name for the channel.');
      }
      if (Radio._channels[channelName]) {
        return Radio._channels[channelName];
      } else {
        return Radio._channels[channelName] = new Radio.Channel(channelName);
      }
    };
    Radio.Channel = function(channelName) {
      this.channelName = channelName;
    };
    _.extend(Radio.Channel.prototype, Backbone.Events, Radio.Requests, {reset: function reset() {
        this.off();
        this.stopListening();
        this.stopReplying();
        return this;
      }});
    var channel;
    var args;
    var systems = [Backbone.Events, Radio.Requests];
    _.each(systems, function(system) {
      _.each(system, function(method, methodName) {
        Radio[methodName] = function(channelName) {
          args = _.rest(arguments);
          channel = this.channel(channelName);
          return channel[methodName].apply(channel, args);
        };
      });
    });
    Radio.reset = function(channelName) {
      var channels = !channelName ? this._channels : [this._channels[channelName]];
      _.invoke(channels, 'reset');
    };
    return Radio;
  }));
  return module.exports;
});

$__System.registerDynamic("20", ["c3"], true, function($__require, exports, module) {
  ;
  var define,
      global = this,
      GLOBAL = this;
  module.exports = $__require('c3');
  return module.exports;
});

(function() {
var define = $__System.amdDefine;
var saveAs = saveAs || (function(view) {
  "use strict";
  if (typeof navigator !== "undefined" && /MSIE [1-9]\./.test(navigator.userAgent)) {
    return;
  }
  var doc = view.document,
      get_URL = function() {
        return view.URL || view.webkitURL || view;
      },
      save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a"),
      can_use_save_link = "download" in save_link,
      click = function(node) {
        var event = new MouseEvent("click");
        node.dispatchEvent(event);
      },
      is_safari = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent),
      webkit_req_fs = view.webkitRequestFileSystem,
      req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem,
      throw_outside = function(ex) {
        (view.setImmediate || view.setTimeout)(function() {
          throw ex;
        }, 0);
      },
      force_saveable_type = "application/octet-stream",
      fs_min_size = 0,
      arbitrary_revoke_timeout = 1000 * 40,
      revoke = function(file) {
        var revoker = function() {
          if (typeof file === "string") {
            get_URL().revokeObjectURL(file);
          } else {
            file.remove();
          }
        };
        setTimeout(revoker, arbitrary_revoke_timeout);
      },
      dispatch = function(filesaver, event_types, event) {
        event_types = [].concat(event_types);
        var i = event_types.length;
        while (i--) {
          var listener = filesaver["on" + event_types[i]];
          if (typeof listener === "function") {
            try {
              listener.call(filesaver, event || filesaver);
            } catch (ex) {
              throw_outside(ex);
            }
          }
        }
      },
      auto_bom = function(blob) {
        if (/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(blob.type)) {
          return new Blob(["\ufeff", blob], {type: blob.type});
        }
        return blob;
      },
      FileSaver = function(blob, name, no_auto_bom) {
        if (!no_auto_bom) {
          blob = auto_bom(blob);
        }
        var filesaver = this,
            type = blob.type,
            blob_changed = false,
            object_url,
            target_view,
            dispatch_all = function() {
              dispatch(filesaver, "writestart progress write writeend".split(" "));
            },
            fs_error = function() {
              if (target_view && is_safari && typeof FileReader !== "undefined") {
                var reader = new FileReader();
                reader.onloadend = function() {
                  var base64Data = reader.result;
                  target_view.location.href = "data:attachment/file" + base64Data.slice(base64Data.search(/[,;]/));
                  filesaver.readyState = filesaver.DONE;
                  dispatch_all();
                };
                reader.readAsDataURL(blob);
                filesaver.readyState = filesaver.INIT;
                return;
              }
              if (blob_changed || !object_url) {
                object_url = get_URL().createObjectURL(blob);
              }
              if (target_view) {
                target_view.location.href = object_url;
              } else {
                var new_tab = view.open(object_url, "_blank");
                if (new_tab === undefined && is_safari) {
                  view.location.href = object_url;
                }
              }
              filesaver.readyState = filesaver.DONE;
              dispatch_all();
              revoke(object_url);
            },
            abortable = function(func) {
              return function() {
                if (filesaver.readyState !== filesaver.DONE) {
                  return func.apply(this, arguments);
                }
              };
            },
            create_if_not_found = {
              create: true,
              exclusive: false
            },
            slice;
        ;
        filesaver.readyState = filesaver.INIT;
        if (!name) {
          name = "download";
        }
        if (can_use_save_link) {
          object_url = get_URL().createObjectURL(blob);
          setTimeout(function() {
            save_link.href = object_url;
            save_link.download = name;
            click(save_link);
            dispatch_all();
            revoke(object_url);
            filesaver.readyState = filesaver.DONE;
          });
          return;
        }
        if (view.chrome && type && type !== force_saveable_type) {
          slice = blob.slice || blob.webkitSlice;
          blob = slice.call(blob, 0, blob.size, force_saveable_type);
          blob_changed = true;
        }
        if (webkit_req_fs && name !== "download") {
          name += ".download";
        }
        if (type === force_saveable_type || webkit_req_fs) {
          target_view = view;
        }
        if (!req_fs) {
          fs_error();
          return;
        }
        fs_min_size += blob.size;
        req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
          fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
            var save = function() {
              dir.getFile(name, create_if_not_found, abortable(function(file) {
                file.createWriter(abortable(function(writer) {
                  writer.onwriteend = function(event) {
                    target_view.location.href = file.toURL();
                    filesaver.readyState = filesaver.DONE;
                    dispatch(filesaver, "writeend", event);
                    revoke(file);
                  };
                  writer.onerror = function() {
                    var error = writer.error;
                    if (error.code !== error.ABORT_ERR) {
                      fs_error();
                    }
                  };
                  "writestart progress write abort".split(" ").forEach(function(event) {
                    writer["on" + event] = filesaver["on" + event];
                  });
                  writer.write(blob);
                  filesaver.abort = function() {
                    writer.abort();
                    filesaver.readyState = filesaver.DONE;
                  };
                  filesaver.readyState = filesaver.WRITING;
                }), fs_error);
              }), fs_error);
            };
            dir.getFile(name, {create: false}, abortable(function(file) {
              file.remove();
              save();
            }), abortable(function(ex) {
              if (ex.code === ex.NOT_FOUND_ERR) {
                save();
              } else {
                fs_error();
              }
            }));
          }), fs_error);
        }), fs_error);
      },
      FS_proto = FileSaver.prototype,
      saveAs = function(blob, name, no_auto_bom) {
        return new FileSaver(blob, name, no_auto_bom);
      };
  ;
  if (typeof navigator !== "undefined" && navigator.msSaveOrOpenBlob) {
    return function(blob, name, no_auto_bom) {
      if (!no_auto_bom) {
        blob = auto_bom(blob);
      }
      return navigator.msSaveOrOpenBlob(blob, name || "download");
    };
  }
  FS_proto.abort = function() {
    var filesaver = this;
    filesaver.readyState = filesaver.DONE;
    dispatch(filesaver, "abort");
  };
  FS_proto.readyState = FS_proto.INIT = 0;
  FS_proto.WRITING = 1;
  FS_proto.DONE = 2;
  FS_proto.error = FS_proto.onwritestart = FS_proto.onprogress = FS_proto.onwrite = FS_proto.onabort = FS_proto.onerror = FS_proto.onwriteend = null;
  return saveAs;
}(typeof self !== "undefined" && self || typeof window !== "undefined" && window || this.content));
if (typeof module !== "undefined" && module.exports) {
  module.exports.saveAs = saveAs;
} else if ((typeof define !== "undefined" && define !== null) && (define.amd !== null)) {
  define("c4", [], function() {
    return saveAs;
  });
}

})();
(function() {
var define = $__System.amdDefine;
define("c5", ["c4"], function(main) {
  return main;
});

})();
$__System.registerDynamic("17", [], true, function($__require, exports, module) {
  "use strict";
  ;
  var define,
      global = this,
      GLOBAL = this;
  exports["default"] = function(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };
  exports.__esModule = true;
  return module.exports;
});

$__System.register('11', ['17'], function (_export) {
    var _classCallCheck, _instance, RODAN_EVENTS;

    return {
        setters: [function (_) {
            _classCallCheck = _['default'];
        }],
        execute: function () {
            // todo
            // CONTROLLERS: workflowjob messages the builder and it shouldn't

            // TODO - in final docs, explain
            //
            //  make model saves like workflowjob controller; only specify the "changed" fields
            //  server errors (json)
            //  explain options for route
            //  data: {query parameters}
            //  explain the "Global" collections
            //  difference between events and requests
            //  fields: {object with attributes to change}
            // how configuration.js is used for some events
            //  why we use "Collection" and not "List"
            //  mark some of these as "hidden" or try to remove them

            'use strict';

            _instance = null;

            /**
             * Backbone.Radio events use in the client. Do not instantiate this class.
             */

            RODAN_EVENTS =
            /** @ignore */
            function RODAN_EVENTS() {
                _classCallCheck(this, RODAN_EVENTS);

                if (_instance) {
                    throw new Error('this class cannot be instantiated more than once');
                }

                /** @ignore */
                this.REQUEST__RESOURCE_SHOWLAYOUTVIEW = 'REQUEST__RESOURCE_SHOWLAYOUTVIEW'; // Show LayoutView for Resource control (outside of the primary Resources view). This tells the ControllerResource which LayoutView to reference upon events. Takes {layoutView: LayoutView}.
                /** @ignore */
                this.REQUEST__RUNJOB_SHOWLAYOUTVIEW = 'REQUEST__RUNJOB_SHOWLAYOUTVIEW'; // Show LayoutView for RunJob control (outside of the primary RunJobs view). This tells the ControllerRunJob which LayoutView to reference upon events. Takes {layoutView: LayoutView}.
                /** @ignore */
                this.EVENT__SERVER_WENTAWAY = 'EVENT__SERVER_WENTAWAY'; // Called on server disconnect. No pass.
                /** @ignore */
                this.EVENT__SERVER_PANIC = 'EVENT__SERVER_PANIC'; // Called when the app suspects that something went wrong.
                /** @ignore */
                this.REQUEST__SYSTEM_HANDLE_ERROR = 'REQUEST__SYSTEM_HANDLE_ERROR'; // Sends error to error handler. Takes {model: BaseModel, response: HTTP response, option: associated options}.

                ///////////////////////////////////////////////////////////////////////////////////////
                // Authentication
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when authentication error occurred with no other info. */
                this.EVENT__AUTHENTICATION_ERROR_NULL = 'EVENT__AUTHENTICATION_ERROR_NULL';
                /** Triggered on success of authentication check. Sends {user: User}. */
                this.EVENT__AUTHENTICATION_LOGIN_SUCCESS = 'EVENT__AUTHENTICATION_LOGIN_SUCCESS';
                /** Triggered after authentication attempt; user must log in. */
                this.EVENT__AUTHENTICATION_LOGINREQUIRED = 'EVENT__AUTHENTICATION_LOGINREQUIRED';
                /** Triggered on success of deauthentication. */
                this.EVENT__AUTHENTICATION_LOGOUT_SUCCESS = 'EVENT__AUTHENTICATION_LOGOUT_SUCCESS';
                /** Request check of authentication status. The client will make a request to the Rodan server. Upon response from the server, the client will fire one of the above AUTHENTICATION events. */
                this.REQUEST__AUTHENTICATION_CHECK = 'REQUEST__AUTHENTICATION_CHECK';
                /** Request login authentication. Takes {username: string, password: string}. Upon response from the server, the client will fire one of the above AUTHENTICATION events. */
                this.REQUEST__AUTHENTICATION_LOGIN = 'REQUEST__AUTHENTICATION_LOGIN';
                /** Request logout for currently logged in user. Upon response from the server, the client will fire one of the above AUTHENTICATION events. */
                this.REQUEST__AUTHENTICATION_LOGOUT = 'REQUEST__AUTHENTICATION_LOGOUT';
                /** Request currently logged in User. Returns User or null. */
                this.REQUEST__AUTHENTICATION_USER = 'REQUEST__AUTHENTICATION_USER';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Configuration
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when configuration file has been loaded. */
                this.EVENT__CONFIGURATION_LOADED = 'EVENT__CONFIGURATION_LOADED';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Context Menu
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request context menu be hidden. */
                this.REQUEST__CONTEXTMENU_HIDE = 'REQUEST__CONTEXTMENU_HIDE';
                /** Request context menu be shown. Takes {items: [{label: string, channel: string (Radio channel; default: 'rodan'), request: string (Radio request name), options: object (optional; options sent to Radio request)}], top: float (coordinate), left: float (coordinate)}. */
                this.REQUEST__CONTEXTMENU_SHOW = 'REQUEST__CONTEXTMENU_SHOW';

                ///////////////////////////////////////////////////////////////////////////////////////
                // General
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request "About" information be shown. */
                this.REQUEST__SHOW_ABOUT = 'REQUEST__SHOW_ABOUT';
                /** Request "Help" page be shown. */
                this.REQUEST__SHOW_HELP = 'REQUEST__SHOW_HELP';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Global Collections
                //
                // The 'LOAD' commands are not meant for general use. They are called on startup.
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request all InputPortTypes. Returns GlobalInputPortTypeCollection. */
                this.REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION = 'REQUEST__GLOBAL_INPUTPORTTYPE_COLLECTION';
                /** Request load of InputPortTypes from server. Takes {data: {query parameters}}. */
                this.REQUEST__GLOBAL_INPUTPORTTYPES_LOAD = 'REQUEST__GLOBAL_INPUTPORTTYPES_LOAD';
                /** Request all Jobs. Returns GlobalJobCollection. */
                this.REQUEST__GLOBAL_JOB_COLLECTION = 'REQUEST__GLOBAL_JOB_COLLECTION';
                /** Request load of Jobs from server. Takes {data: {query parameters}}. */
                this.REQUEST__GLOBAL_JOBS_LOAD = 'REQUEST__GLOBAL_JOBS_LOAD';
                /** Request all OutputPortTypes. Returns GlobalOutputPortTypeCollection. */
                this.REQUEST__GLOBAL_OUTPUTPORTTYPE_COLLECTION = 'REQUEST__GLOBAL_OUTPUTPORTTYPE_COLLECTION';
                /** Request load of OutputPortTypes from server. Takes {data: {query parameters}}. */
                this.REQUEST__GLOBAL_OUTPUTPORTTYPES_LOAD = 'REQUEST__GLOBAL_OUTPUTPORTTYPES_LOAD';
                /** Request all Projects. Returns GlobalProjectCollection. */
                this.REQUEST__GLOBAL_PROJECT_COLLECTION = 'REQUEST__GLOBAL_PROJECT_COLLECTION';
                /** Request load of Projects from server. Takes {data: {query parameters}}. */
                this.REQUEST__GLOBAL_PROJECTS_LOAD = 'REQUEST__GLOBAL_PROJECTS_LOAD';
                /** Request all ResourceTypes. Returns GlobalResourceTypeCollection. */
                this.REQUEST__GLOBAL_RESOURCETYPE_COLLECTION = 'REQUEST__GLOBAL_RESOURCETYPE_COLLECTION';
                /** Request load of ResourceTypes from server. Takes {data: {query parameters}}. */
                this.REQUEST__GLOBAL_RESOURCETYPES_LOAD = 'REQUEST__GLOBAL_RESOURCETYPES_LOAD';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Main Region
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request main region be filled with provided Marionette View. Takes {view: Marionette.View}. */
                this.REQUEST__MAINREGION_SHOW_VIEW = 'REQUEST__MAINREGION_SHOW_VIEW';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Modal
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request modal window to hide/close. */
                this.REQUEST__MODAL_HIDE = 'REQUEST__MODAL_HIDE';
                /** Request modal window to show/open with provided Marionette View. If another modal is currently open the request will not show. Takes {view: Marionette.View, title: string}. */
                this.REQUEST__MODAL_SHOW = 'REQUEST__MODAL_SHOW';
                /** Request modal window to show/open without view. If another modal is currently open the request will not show. Takes {title: string, text: string}. */
                this.REQUEST__MODAL_SHOW_SIMPLE = 'REQUEST__MODAL_SHOW_SIMPLE';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Model
                //
                // In addition to the three events below, each model will fire its own custom events:
                //  - EVENT__MODEL_CHANGE<model_url>
                //  - EVENT__MODEL_SYNC<model_url>
                //
                // These events are fired on the 'rodan' Radio channel. These are useful if you wish
                // to listen only for events by specific models, but regardless of the encapsulating
                // Backbone object.
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when an instance of BaseModel has been added to a Backbone.Collection. Sends {model: BaseModel, collection: BaseCollection, options: Javascript object}). */
                this.EVENT__COLLECTION_ADD = 'EVENT__COLLECTION_ADD';
                /** Triggered when an instance of BaseModel has changed (bound to 'change' event in Backbone). Sends {model: BaseModel, options: Javascript object}. */
                this.EVENT__MODEL_CHANGE = 'EVENT__MODEL_CHANGE';
                /** Triggered when an instance of BaseModel has been synced (bound to 'sync' event in Backbone). Sends {model: BaseModel, response: XMLHTTPRequest, options: Javascript object}. */
                this.EVENT__MODEL_SYNC = 'EVENT__MODEL_SYNC';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Project
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when Project has been created. Sends {project: Project}. */
                this.EVENT__PROJECT_CREATED = 'EVENT__PROJECT_CREATED';
                /** Triggered when Project has been deleted. Sends {project: Project}. */
                this.EVENT__PROJECT_DELETED = 'EVENT__PROJECT_DELETED';
                /** Triggered when Project has been saved. Sends {project: Project}. */
                this.EVENT__PROJECT_SAVED = 'EVENT__PROJECT_SAVED';
                /** Triggered when the user selects an individual Project. Sends {project: Project}. */
                this.EVENT__PROJECT_SELECTED = 'EVENT__PROJECT_SELECTED';
                /** Triggered when the user selects to see all available Projects. */
                this.EVENT__PROJECT_SELECTED_COLLECTION = 'EVENT__PROJECT_SELECTED_COLLECTION';
                /** Request a Project be created. Takes {creator: User}. */
                this.REQUEST__PROJECT_CREATE = 'REQUEST__PROJECT_CREATE';
                /** Request a Project be deleted. Takes {project: Project}. */
                this.REQUEST__PROJECT_DELETE = 'REQUEST__PROJECT_DELETE';
                /** Request currently active/open Project. Returns Project (or null). */
                this.REQUEST__PROJECT_GET_ACTIVE = 'REQUEST__PROJECT_GET_ACTIVE';
                /** Request a Project be saved/updated. Takes {project: Project, fields: {object with attributes to change}}. */
                this.REQUEST__PROJECT_SAVE = 'REQUEST__PROJECT_SAVE';
                /** Request a Project be set as active Project. Takes {project: Project}. */
                this.REQUEST__PROJECT_SET_ACTIVE = 'REQUEST__PROJECT_SET_ACTIVE';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Resource
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when Resource created. Sends {resource: Resource}. */
                this.EVENT__RESOURCE_CREATED = 'EVENT__RESOURCE_CREATED';
                /** Triggered when Resource deleted. Sends {resource: Resource}. */
                this.EVENT__RESOURCE_DELETED = 'EVENT__RESOURCE_DELETED';
                /** Triggered when Resource saved. Sends {resource: Resource}. */
                this.EVENT__RESOURCE_SAVED = 'EVENT__RESOURCE_SAVED';
                /** Triggered when the user selects an individual Resource. Sends {resource: Resource}. */
                this.EVENT__RESOURCE_SELECTED = 'EVENT__RESOURCE_SELECTED';
                /** Triggered when the user selects to see all available Resources. Sends {project: Project (Project associated with ResourceCollection)}. */
                this.EVENT__RESOURCE_SELECTED_COLLECTION = 'EVENT__RESOURCE_SELECTED_COLLECTION';
                /** Request a Resource be created. Takes {project: Project, file: JavaScript File object}. */
                this.REQUEST__RESOURCE_CREATE = 'REQUEST__RESOURCE_CREATE';
                /** Request a Resource be deleted. Takes {resource: Resource}. */
                this.REQUEST__RESOURCE_DELETE = 'REQUEST__RESOURCE_DELETE';
                /** Request a Resource be downloaded. Takes {resource: Resource}. */
                this.REQUEST__RESOURCE_DOWNLOAD = 'REQUEST__RESOURCE_DOWNLOAD';
                /** Request a Resource be saved/updated. Takes {resource: Resource, fields: {object with attributes to change}}. */
                this.REQUEST__RESOURCE_SAVE = 'REQUEST__RESOURCE_SAVE';
                /** Request a ResourceCollection to be loaded. Takes {data: Object (query parameters)}. Returns ResourceCollection. */
                this.REQUEST__RESOURCES_LOAD = 'REQUEST__RESOURCES_LOAD';

                ///////////////////////////////////////////////////////////////////////////////////////
                // RunJob
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when interactive RunJob has been acquired by the current user. Sends {runjob: RunJob}. */
                this.EVENT__RUNJOB_ACQUIRED = 'EVENT__RUNJOB_ACQUIRED';
                /** Triggered when the user selects an individual RunJob. Sends {runjob: RunJob}. */
                this.EVENT__RUNJOB_SELECTED = 'EVENT__RUNJOB_SELECTED';
                /** Triggered when the user selects to see RunJobs for a Project. */
                this.EVENT__RUNJOB_SELECTED_COLLECTION = 'EVENT__RUNJOB_SELECTED_COLLECTION';
                /** Request the provided RunJob be locked on the server for the current user. Takes {runjob: RunJob}. */
                this.REQUEST__RUNJOB_ACQUIRE = 'REQUEST__RUNJOB_ACQUIRE';
                /** Request a RunJobCollection to be loaded. Takes {data: Object (query parameters)}. Returns RunJobCollection. */
                this.REQUEST__RUNJOBS_LOAD = 'REQUEST__RUNJOBS_LOAD';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Server
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when server date has been updated. Sends {date: Date}. */
                this.EVENT__SERVER_DATE_UPDATED = 'EVENT__SERVER_DATE_UPDATED';
                /** Triggered on Rodan-based server errors. Sends {json: JSON object of error}. */
                this.EVENT__SERVER_ERROR = 'EVENT__SERVER_ERROR';
                /** Triggered when the client has no pending HTTP requests waiting to complete. Only fires if EVENT__SERVER_WAITING had previously been fired. */
                this.EVENT__SERVER_IDLE = 'EVENT__SERVER_IDLE';
                /** Triggered when server routes have been loaded. */
                this.EVENT__SERVER_ROUTESLOADED = 'EVENT__SERVER_ROUTESLOADED';
                /** Triggered when client has been waiting a predefined amount of time for 'complete' state (i.e. not waiting on server response). */
                this.EVENT__SERVER_WAITING = 'EVENT__SERVER_WAITING';
                /** Request server configuration. Returns object. */
                this.REQUEST__SERVER_CONFIGURATION = 'REQUEST__SERVER_CONFIGURATION';
                /** Request last known server date and time. Returns Date. */
                this.REQUEST__SERVER_DATE = 'REQUEST__SERVER_DATE';
                /** Request server hostname. Returns string (hostname). */
                this.REQUEST__SERVER_GET_HOSTNAME = 'REQUEST__SERVER_GET_HOSTNAME';
                /** Request server URL for route. Takes {route: string}. Returns string (URL). */
                this.REQUEST__SERVER_GET_ROUTE = 'REQUEST__SERVER_GET_ROUTE';
                /** Request options for server route. Takes {route: string}. Returns Javascript object with all options for route. */
                this.REQUEST__SERVER_GET_ROUTE_OPTIONS = 'REQUEST__SERVER_GET_ROUTE_OPTIONS';
                /** Request version of server. Returns string. */
                this.REQUEST__SERVER_GET_VERSION = 'REQUEST__SERVER_GET_VERSION';
                /** Request the client to load all routes. EVENT__SERVER_ROUTESLOADED is triggered on success. */
                this.REQUEST__SERVER_LOAD_ROUTES = 'REQUEST__SERVER_LOAD_ROUTES';
                /** Request the client to load all options for routes. Must authenticate prior to making this request. */
                this.REQUEST__SERVER_LOAD_ROUTE_OPTIONS = 'REQUEST__SERVER_LOAD_ROUTE_OPTIONS';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Transfer Manager
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when file upload fails. Sends {request: jQuery XMLHTTPRequest, file: Javascript file object}. */
                this.EVENT__TRANSFERMANAGER_UPLOAD_FAILED = 'EVENT__TRANSFERMANAGER_UPLOAD_FAILED';
                /** Triggered when file upload succeeds. Sends {request: jQuery XMLHTTPRequest, file: Javascript file object}. */
                this.EVENT__TRANSFERMANAGER_UPLOAD_SUCCEEDED = 'EVENT__TRANSFERMANAGER_UPLOAD_SUCCEEDED';
                /** Request download of a file from a URL. Takes {url: string (URL of file location), filename: string (name to give file when saving to local machine)}. */
                this.REQUEST__TRANSFERMANAGER_DOWNLOAD = 'REQUEST__TRANSFERMANAGER_DOWNLOAD';
                /** Request counts of uploads for this session. Returns {completed: int >= 0, failed:  int >= 0, pending:  int >= 0}. */
                this.REQUEST__TRANSFERMANAGER_GET_UPLOAD_COUNT = 'REQUEST__TRANSFERMANAGER_GET_UPLOAD_COUNT';
                /** Request the TransferManager to monitor a file upload. Takes {request: jQuery XMLHTTPRequest, file: Javascript file object}. */
                this.REQUEST__TRANSFERMANAGER_MONITOR_UPLOAD = 'REQUEST__TRANSFERMANAGER_MONITOR_UPLOAD';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Updater
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Request the Updater to clear registered update callback. Takes nothing. */
                this.REQUEST__UPDATER_CLEAR = 'REQUEST__UPDATER_CLEAR';
                /** Request a set of collections to be updated. Takes {collections: [BaseCollection]}. */
                this.REQUEST__UPDATER_SET_COLLECTIONS = 'REQUEST__UPDATER_SET_COLLECTIONS';

                ///////////////////////////////////////////////////////////////////////////////////////
                // Workflow
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when Workflow has been created. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOW_CREATED = 'EVENT__WORKFLOW_CREATED';
                /** Triggered when Workflow has been deleted. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOW_DELETED = 'EVENT__WORKFLOW_DELETED';
                /** Triggered when Workflow has been saved. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOW_SAVED = 'EVENT__WORKFLOW_SAVED';
                /** Triggered when the user selects an individual Workflow. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOW_SELECTED = 'EVENT__WORKFLOW_SELECTED';
                /** Triggered when the user selects to see all available Workflows. Sends {project: Project (Project associated with WorkflowCollection)}. */
                this.EVENT__WORKFLOW_SELECTED_COLLECTION = 'EVENT__WORKFLOW_SELECTED_COLLECTION';
                /** Request a Workflow be created. Takes {project: Project}. */
                this.REQUEST__WORKFLOW_CREATE = 'REQUEST__WORKFLOW_CREATE';
                /** Request a Workflow be deleted. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOW_DELETE = 'REQUEST__WORKFLOW_DELETE';
                /** Request a Workflow be saved/updated. Takes {workflow: Workflow, fields: {object with attributes to change}}. */
                this.REQUEST__WORKFLOW_SAVE = 'REQUEST__WORKFLOW_SAVE';

                ///////////////////////////////////////////////////////////////////////////////////////
                // WorkflowBuilder
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when the user selects an individual Workflow to edit. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOWBUILDER_SELECTED = 'EVENT__WORKFLOWBUILDER_SELECTED';
                /** Triggered when a Workflow is loaded into the WorkflowBuilder. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOWBUILDER_LOADED_WORKFLOW = 'EVENT__WORKFLOWBUILDER_LOADED_WORKFLOW';
                /** Triggered when a Workflow has been validated. Sends {workflow: Workflow}. */
                this.EVENT__WORKFLOWBUILDER_VALIDATED_WORKFLOW = 'EVENT__WORKFLOWBUILDER_VALIDATED_WORKFLOW';
                /** Request a Connection be added to a Workflow between two ports. Takes {inputport: InputPort, outputport: OutputPort, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ADD_CONNECTION = 'REQUEST__WORKFLOWBUILDER_ADD_CONNECTION';
                /** Request a WorkflowJob be created from a Job of category Configuration.RESOURCE_DISTRIBUTOR_CATEGORY that can satisfy the provided InputPorts. Takes {inputports: [InputPort], workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ADD_DISTRIBUTOR = 'REQUEST__WORKFLOWBUILDER_ADD_DISTRIBUTOR';
                /** Request an InputPort be added to a WorkflowJob. Takes {inputporttype: InputPortType, workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ADD_INPUTPORT = 'REQUEST__WORKFLOWBUILDER_ADD_INPUTPORT';
                /** Request an OutputPort be added to a WorkflowJob. Takes {outputporttype: InputPortType, workflowjob: WorkflowJob, workflow: Workflow, targetinputports: [InputPort] (optional)}. If targetinputports is provided the WorkflowBuilder will attempt to create Connections between the created OutputPort and those InputPort. */
                this.REQUEST__WORKFLOWBUILDER_ADD_OUTPUTPORT = 'REQUEST__WORKFLOWBUILDER_ADD_OUTPUTPORT';
                /** Request a WorkflowJob be created from a Job. Takes {job: Job, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOB = 'REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOB';
                /** Request a WorkflowJobGroup be created for the provided WorkflowJobs. Takes {workflowjobs: [WorkflowJob], workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOBGROUP = 'REQUEST__WORKFLOWBUILDER_ADD_WORKFLOWJOBGROUP';
                /** Request a Resource be assigned to an InputPort. Takes {resource: Resource, inputport: InputPort, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_ASSIGN_RESOURCE = 'REQUEST__WORKFLOWBUILDER_ASSIGN_RESOURCE';
                /** Request a WorkflowRun be created. The WorkflowBuilder will use the known Resource assignments that have been made. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_CREATE_WORKFLOWRUN = 'EVENT__WORKFLOWBUILDER_CREATE_WORKFLOWRUN';
                /** Request the Resources that are currently assigned to an InputPort. Takes {inputport: InputPort}. Returns [Resource]. */
                this.REQUEST__WORKFLOWBUILDER_GET_RESOURCEASSIGNMENTS = 'REQUEST__WORKFLOWBUILDER_GET_RESOURCEASSIGNMENTS';
                /** Request all InputPorts that could satisfy the provided OutputPort in the given Workflow. Takes {workflow: Workflow, outputport: OutputPort}. Returns [string] (InputPort URLs). */
                this.REQUEST__WORKFLOWBUILDER_GET_SATISFYING_INPUTPORTS = 'REQUEST__WORKFLOWBUILDER_GET_SATISFYING_INPUTPORTS';
                /** Request a Workflow (origin) be added to another Workflow (target). Takes {origin: Workflow, target: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_IMPORT_WORKFLOW = 'REQUEST__WORKFLOWBUILDER_IMPORT_WORKFLOW';
                /** Request a Workflow be fetched and loaded. If no Workflow has yet been loaded in the WorkflowBuilder, or the Workflow to be loaded differs from the one currently loaded in the WorkflowBuilder, the WorkflowBuilder will be initialized with the new Workflow. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW = 'REQUEST__WORKFLOWBUILDER_LOAD_WORKFLOW';
                /** Request a Connection be removed from a Workflow. Takes {connection: Connection, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_REMOVE_CONNECTION = 'REQUEST__WORKFLOWBUILDER_REMOVE_CONNECTION';
                /** Request an InputPort be removed from a WorkflowJob. Takes {inputport: InputPort, workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_REMOVE_INPUTPORT = 'REQUEST__WORKFLOWBUILDER_REMOVE_INPUTPORT';
                /** Request an OutputPort be removed from a WorkflowJob. Takes {outputport: OutputPort, workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_REMOVE_OUTPUTPORT = 'REQUEST__WORKFLOWBUILDER_REMOVE_OUTPUTPORT';
                /** Request a WorkflowJob be removed from a Workflow. Takes {workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB = 'REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOB';
                /** Request a WorkflowJobGroup and all its associated WorkflowJobs be removed from a Workflow. Takes {workflowjobgroup: WorkflowJobGroup, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOBGROUP = 'REQUEST__WORKFLOWBUILDER_REMOVE_WORKFLOWJOBGROUP';
                /** Request that future WorkflowJob creation automatically adds minimal ports. Takes {addports: boolean}. */
                this.REQUEST__WORKFLOWBUILDER_SET_ADDPORTS = 'REQUEST__WORKFLOWBUILDER_SET_ADDPORTS';
                /** Request a Job collection view be displayed for adding Jobs to the currently loaded Workflow. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_JOBCOLLECTION_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_JOBCOLLECTION_VIEW';
                /** Request a resource assignment view be displayed for an InputPort. Takes {inputport: InputPort, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_RESOURCEASSIGNMENT_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_RESOURCEASSIGNMENT_VIEW';
                /** Request a Workflow data view be displayed for a Workflow. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOW_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOW_VIEW';
                /** Request a Workflow collection view be displayed for importing Workflows. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWCOLLECTION_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWCOLLECTION_VIEW';
                /** Request a port view for adding/deleting ports for a WorkflowJob be displayed. Takes {workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_PORTS_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_PORTS_VIEW';
                /** Request a WorkflowJob settings view be displayed for a WorkflowJob. Takes {workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_SETTINGS_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_SETTINGS_VIEW';
                /** Request a WorkflowJob data view be displayed for a WorkflowJob. Takes {workflowjob: WorkflowJob, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOB_VIEW';
                /** Request a WorkflowJobGroup data view be displayed for a WorkflowJobGroup. Takes {workflowjobgroup: WorkflowJobGroup, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOBGROUP_VIEW = 'REQUEST__WORKFLOWBUILDER_SHOW_WORKFLOWJOBGROUP_VIEW';
                /** Request a Resource be unassigned to an InputPort. Takes {resource: Resource, inputport: InputPort, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_UNASSIGN_RESOURCE = 'REQUEST__WORKFLOWBUILDER_UNASSIGN_RESOURCE';
                /** Request a WorkflowJobGroup be removed from a Workflow, but keep all associated WorkflowJobs, ports, and Connections. Takes {workflowjobgroup: WorkflowJobGroup, workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_UNGROUP_WORKFLOWJOBGROUP = 'REQUEST__WORKFLOWBUILDER_UNGROUP_WORKFLOWJOBGROUP';
                /** Request a Workflow be validated. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW = 'REQUEST__WORKFLOWBUILDER_VALIDATE_WORKFLOW';

                ///////////////////////////////////////////////////////////////////////////////////////
                // WorkflowJob
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when WorkflowJob created. Sends {workflowjob: WorkflowJob}. */
                this.EVENT__WORKFLOWJOB_CREATED = 'EVENT__WORKFLOWJOB_CREATED';
                /** Triggered when WorkflowJob deleted. Sends {workflowjob: WorkflowJob}. */
                this.EVENT__WORKFLOWJOB_DELETED = 'EVENT__WORKFLOWJOB_DELETED';
                /** Triggered when WorkflowJob saved. Sends {workflowjob: WorkflowJob}. */
                this.EVENT__WORKFLOWJOB_SAVED = 'EVENT__WORKFLOWJOB_SAVED';
                /** Request a WorkflowJob be created of a Job type and added to a Workflow. Takes {job: Job, workflow: Workflow, addports: boolean, targetinputports: [InputPort] (optional)}. The minimum required InputPorts will be created iff addports is true. If targetinputports array of InputPorts is provided, Connections will be made to those InputPorts (from this WorkflowJob's OutputPort) iff the WorkflowJob created has one and only one OutputPort. */
                this.REQUEST__WORKFLOWJOB_CREATE = 'REQUEST__WORKFLOWJOB_CREATE'; //
                /** Request a WorkflowJob be deleted. Takes {workflowjob: WorkflowJob}. */
                this.REQUEST__WORKFLOWJOB_DELETE = 'REQUEST__WORKFLOWJOB_DELETE';
                /** Request a WorkflowJob be saved/updated. Takes {workflowjob: WorkflowJob, workflow: Workflow (optional)}. If a Workflow is passed the WorkflowJobController will request a validation for that Workflow after the save has completed. */
                this.REQUEST__WORKFLOWJOB_SAVE = 'REQUEST__WORKFLOWJOB_SAVE';

                ///////////////////////////////////////////////////////////////////////////////////////
                // WorkflowJobGroup
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when WorkflowJobGroup imported. Sends {workflowjobgroup: WorkflowJobGroup}. */
                this.EVENT__WORKFLOWJOBGROUP_IMPORTED = 'EVENT__WORKFLOWJOBGROUP_IMPORTED';
                /** Triggered when WorkflowJobGroup has been deleted. Sends {workflowjobgroup: WorkflowJobGroup}. */
                this.EVENT__WORKFLOWJOBGROUP_DELETED = 'EVENT__WORKFLOWJOBGROUP_DELETED';
                /** Triggered when WorkflowJobGroup saved. Sends {workflowjobgroup: WorkflowJobGroup}. */
                this.EVENT__WORKFLOWJOBGROUP_SAVED = 'EVENT__WORKFLOWJOBGROUP_SAVED';
                /** Request a WorkflowJobGroup be deleted. Takes {workflowjobgroup: WorkflowJobGroup}. */
                this.REQUEST__WORKFLOWJOBGROUP_DELETE = 'REQUEST__WORKFLOWJOBGROUP_DELETE';
                /** Request arrays of InputPort URLs and OutputPort URLs for the given WorkflowJobGroup. Takes {url: string (WorkflowJobGroup URL), workflow: Workflow}. Returns {inputports: [InputPort], outputports: [OutputPort]}. */
                this.REQUEST__WORKFLOWJOBGROUP_GET_PORTS = 'REQUEST__WORKFLOWJOBGROUP_GET_PORTS';
                /** Request a Workflow (origin) be imported into another Workflow (target) as a WorkflowJobGroup. Takes {target: Workflow, origin: Workflow}. */
                this.REQUEST__WORKFLOWJOBGROUP_IMPORT = 'REQUEST__WORKFLOWJOBGROUP_IMPORT';
                /** Request WorkflowJobGroups be loaded for a given Workflow. Takes {workflow: Workflow}. */
                this.REQUEST__WORKFLOWJOBGROUP_LOAD_COLLECTION = 'REQUEST__WORKFLOWJOBGROUP_LOAD_COLLECTION';
                /** Request a WorkflowJobGroup be saved/updated. Takes {workflowjobgroup: WorkflowJobGroup}. */
                this.REQUEST__WORKFLOWJOBGROUP_SAVE = 'REQUEST__WORKFLOWJOBGROUP_SAVE';

                ///////////////////////////////////////////////////////////////////////////////////////
                // WorkflowRun
                ///////////////////////////////////////////////////////////////////////////////////////
                /** Triggered when WorkflowRun created. Sends {workflowrun: WorkflowRun}. */
                this.EVENT__WORKFLOWRUN_CREATED = 'EVENT__WORKFLOWRUN_CREATED';
                /** Triggered when WorkflowRun saved. Sends {workflowrun: WorkflowRun}. */
                this.EVENT__WORKFLOWRUN_SAVED = 'EVENT__WORKFLOWRUN_SAVED';
                /** Triggered when the user selects an individual WorkflowRun. Sends {workflow: WorkflowRun}. */
                this.EVENT__WORKFLOWRUN_SELECTED = 'EVENT__WORKFLOWRUN_SELECTED';
                /** Triggered when the user selects to see all available WorkflowRuns. Sends {project: Project (Project associated with WorkflowRunCollection)}. */
                this.EVENT__WORKFLOWRUN_SELECTED_COLLECTION = 'EVENT__WORKFLOWRUN_SELECTED_COLLECTION';
                /** Request a WorkflowRun be created. Takes {workflow: Workflow, assignments: [string (Resource URLs or individual ResourceList URL)] (index by InputPort URLs)}. */
                this.REQUEST__WORKFLOWRUN_CREATE = 'REQUEST__WORKFLOWRUN_CREATE';
                /** Request a WorkflowRun be saved/updated. Takes {model: WorkflowRun}. */
                this.REQUEST__WORKFLOWRUN_SAVE = 'REQUEST__WORKFLOWRUN_SAVE';
            }
            /** @ignore */
            ;

            _export('default', new RODAN_EVENTS());
        }
    };
});

$__System.register('c6', ['11', '16', '17', '20', '52', 'c5'], function (_export) {
    var RODAN_EVENTS, _createClass, _classCallCheck, Radio, Backbone, saveAs, TransferManager;

    return {
        setters: [function (_5) {
            RODAN_EVENTS = _5['default'];
        }, function (_) {
            _createClass = _['default'];
        }, function (_2) {
            _classCallCheck = _2['default'];
        }, function (_4) {
            Radio = _4['default'];
        }, function (_3) {
            Backbone = _3['default'];
        }, function (_c5) {
            saveAs = _c5['default'];
        }],
        execute: function () {

            /**
             * File transfer manager. This manages all file (i.e. Resource) uploads and downloads.
             */
            'use strict';

            TransferManager = (function () {
                ///////////////////////////////////////////////////////////////////////////////////////
                // PUBLIC METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Constructor.
                 */

                function TransferManager() {
                    _classCallCheck(this, TransferManager);

                    this._initializeRadio();
                    this._uploadsPending = new Backbone.Collection();
                    this._uploadsFailed = new Backbone.Collection();
                    this._uploadsCompleted = new Backbone.Collection();
                }

                ///////////////////////////////////////////////////////////////////////////////////////
                // PRIVATE METHODS
                ///////////////////////////////////////////////////////////////////////////////////////
                /**
                 * Initialize Radio.
                 */

                _createClass(TransferManager, [{
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this = this;

                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__TRANSFERMANAGER_DOWNLOAD, function (options) {
                            return _this._handleRequestDownload(options);
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__TRANSFERMANAGER_GET_UPLOAD_COUNT, function () {
                            return _this._handleRequestGetUploadCount();
                        });
                        Radio.channel('rodan').reply(RODAN_EVENTS.REQUEST__TRANSFERMANAGER_MONITOR_UPLOAD, function (options) {
                            return _this._handleRequestMonitorUpload(options);
                        });
                    }

                    /**
                     * Handle download request.
                     */
                }, {
                    key: '_handleRequestDownload',
                    value: function _handleRequestDownload(options) {
                        var _this2 = this;

                        var request = new XMLHttpRequest();
                        request.open('GET', options.url, true);
                        request.responseType = 'blob';
                        request.onreadystatechange = function (event) {
                            return _this2._handleStateChange(event, options.filename, options.mimetype);
                        };
                        request.onprogress = function (event) {
                            return _this2._handleDownloadProgress(event);
                        };
                        request.send();
                    }

                    /**
                     * Return upload count.
                     */
                }, {
                    key: '_handleRequestGetUploadCount',
                    value: function _handleRequestGetUploadCount() {
                        return { pending: this._uploadsPending.length, completed: this._uploadsCompleted.length, failed: this._uploadsFailed.length };
                    }

                    /**
                     * Handle request monitor upload.
                     */
                }, {
                    key: '_handleRequestMonitorUpload',
                    value: function _handleRequestMonitorUpload(options) {
                        var _this3 = this;

                        var request = options.request;
                        request.id = this._getRandomId();
                        options.id = request.id;
                        this._uploadsPending.add(options);
                        request.done(function (response, code, jqXHR) {
                            return _this3._handleUploadSuccess(response, code, jqXHR);
                        });
                        request.fail(function (jqXHR, code, error) {
                            return _this3._handleUploadFail(jqXHR, code, error);
                        });
                    }

                    /**
                     * Handle upload success.
                     */
                }, {
                    key: '_handleUploadSuccess',
                    value: function _handleUploadSuccess(response, code, jqXHR) {
                        var upload = this._uploadsPending.remove(jqXHR.id);
                        this._uploadsCompleted.add(upload);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__TRANSFERMANAGER_UPLOAD_SUCCEEDED, { request: upload.jqXHR, file: upload.file });
                    }

                    /**
                     * Handle upload fail.
                     */
                }, {
                    key: '_handleUploadFail',
                    value: function _handleUploadFail(jqXHR, code, error) {
                        var upload = this._uploadsPending.remove(jqXHR.id);
                        this._uploadsFailed.add(upload);
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__TRANSFERMANAGER_UPLOAD_FAILED, { request: upload.jqXHR, file: upload.file });
                    }

                    /**
                     * Handle request state change.
                     */
                }, {
                    key: '_handleStateChange',
                    value: function _handleStateChange(event, filename, mimetype) {
                        var request = event.currentTarget;
                        switch (request.readyState) {
                            case 0:
                                //UNSENT
                                {
                                    break;
                                }

                            case 1:
                                //OPENED
                                {
                                    break;
                                }

                            case 2:
                                //HEADERS_RECEIVED
                                {
                                    break;
                                }

                            case 3:
                                //LOADING
                                {
                                    break;
                                }

                            case 4:
                                {
                                    var blob = new Blob([request.response], { type: mimetype });
                                    saveAs(blob, filename);
                                    break;
                                }

                            default:
                                {
                                    break;
                                }
                        }
                    }

                    /**
                     * Handle download progress.
                     */
                }, {
                    key: '_handleDownloadProgress',
                    value: function _handleDownloadProgress(event) {}

                    /**
                     * Returns random 8-digit ID.
                     */
                }, {
                    key: '_getRandomId',
                    value: function _getRandomId() {
                        return Math.floor((1 + Math.random()) * 10000000);
                    }
                }]);

                return TransferManager;
            })();

            _export('default', TransferManager);
        }
    };
});

$__System.register('c7', ['3', '4', '5', '10', '11', '14', '15', '16', '17', '20', '27', '31', '32', '36', '38', '39', '46', '51', '53', '77', '81', '82', '83', '89', '2c', '2a', '3f', '4e', '7a', '7d', '8a', '8b', '8e', 'a0', 'a1', 'b9', 'c6'], function (_export) {
    var $, bootstrap, Configuration, RODAN_EVENTS, _get, _inherits, _createClass, _classCallCheck, Radio, Marionette, BehaviorTable, _, ControllerAuthentication, ControllerContextMenu, ControllerModal, ControllerResource, ControllerServer, ControllerWorkflow, ControllerWorkflowBuilder, ControllerWorkflowRun, ErrorHandler, GlobalInputPortTypeCollection, GlobalJobCollection, moment, ControllerProject, ControllerRunJob, ControllerWorkflowJob, ControllerWorkflowJobGroup, GlobalOutputPortTypeCollection, GlobalProjectCollection, GlobalResourceTypeCollection, LayoutViewMaster, RadioManager, UpdateManager, TransferManager, Application;

    return {
        setters: [function (_9) {
            $ = _9['default'];
        }, function (_6) {
            bootstrap = _6['default'];
        }, function (_7) {}, function (_21) {
            Configuration = _21['default'];
        }, function (_23) {
            RODAN_EVENTS = _23['default'];
        }, function (_2) {
            _get = _2['default'];
        }, function (_3) {
            _inherits = _3['default'];
        }, function (_4) {
            _createClass = _4['default'];
        }, function (_5) {
            _classCallCheck = _5['default'];
        }, function (_11) {
            Radio = _11['default'];
        }, function (_10) {
            Marionette = _10['default'];
        }, function (_12) {
            BehaviorTable = _12['default'];
        }, function (_8) {
            _ = _8['default'];
        }, function (_13) {
            ControllerAuthentication = _13['default'];
        }, function (_14) {
            ControllerContextMenu = _14['default'];
        }, function (_15) {
            ControllerModal = _15['default'];
        }, function (_16) {
            ControllerResource = _16['default'];
        }, function (_17) {
            ControllerServer = _17['default'];
        }, function (_18) {
            ControllerWorkflow = _18['default'];
        }, function (_19) {
            ControllerWorkflowBuilder = _19['default'];
        }, function (_20) {
            ControllerWorkflowRun = _20['default'];
        }, function (_22) {
            ErrorHandler = _22['default'];
        }, function (_24) {
            GlobalInputPortTypeCollection = _24['default'];
        }, function (_25) {
            GlobalJobCollection = _25['default'];
        }, function (_c) {
            moment = _c['default'];
        }, function (_a) {}, function (_f) {
            ControllerProject = _f['default'];
        }, function (_e) {
            ControllerRunJob = _e['default'];
        }, function (_a2) {
            ControllerWorkflowJob = _a2['default'];
        }, function (_d) {
            ControllerWorkflowJobGroup = _d['default'];
        }, function (_a3) {
            GlobalOutputPortTypeCollection = _a3['default'];
        }, function (_b) {
            GlobalProjectCollection = _b['default'];
        }, function (_e2) {
            GlobalResourceTypeCollection = _e2['default'];
        }, function (_a0) {
            LayoutViewMaster = _a0['default'];
        }, function (_a1) {
            RadioManager = _a1['default'];
        }, function (_b9) {
            UpdateManager = _b9['default'];
        }, function (_c6) {
            TransferManager = _c6['default'];
        }],
        execute: function () {

            /**
             * Main application class.
             */
            'use strict';

            Application = (function (_Marionette$Application) {
                _inherits(Application, _Marionette$Application);

                function Application() {
                    _classCallCheck(this, Application);

                    _get(Object.getPrototypeOf(Application.prototype), 'constructor', this).apply(this, arguments);
                }

                _createClass(Application, [{
                    key: 'onStart',

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PUBLIC METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Called on Marionette.Application.start(). This will load the configuration from the host.
                     */
                    value: function onStart() {
                        var _this = this;

                        Configuration.load('configuration.json', function () {
                            return _this._startUp();
                        });
                    }

                    ///////////////////////////////////////////////////////////////////////////////////////
                    // PRIVATE METHODS
                    ///////////////////////////////////////////////////////////////////////////////////////
                    /**
                     * Application start-up
                     */
                }, {
                    key: '_startUp',
                    value: function _startUp() {
                        Configuration.load('info.json');
                        this.addRegions({
                            regionMaster: '#region-master'
                        });

                        // Non-network and non-GUI inits. Do these first.
                        this._initializeBehaviors();
                        this._initializeDateTimeFormatter();
                        this._initializeRadio();
                        this._initializeCollections();
                        this._initializeManagers();

                        this._initializeAjaxPrefilters();
                        this._initializeViews();
                        this._initializeControllers();
                        this._errorHandler = new ErrorHandler();

                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_LOAD_ROUTES);
                    }

                    /**
                     * Initialize managers.
                     */
                }, {
                    key: '_initializeManagers',
                    value: function _initializeManagers() {
                        this._transferManager = new TransferManager();
                        this._radioManager = new RadioManager();
                        this._updateManager = new UpdateManager();
                    }

                    /**
                     * Initializes various helpers.
                     */
                }, {
                    key: '_initializeDateTimeFormatter',
                    value: function _initializeDateTimeFormatter() {
                        moment.defaultFormat = Configuration.DATETIME_FORMAT;
                        _.formatFromUTC = function (dateTime) {
                            // TODO - see https://github.com/DDMAL/rodan-client/issues/59
                            try {
                                return moment(dateTime).format();
                            } catch (error) {
                                return moment.moment(dateTime).format();
                            }
                        };
                    }

                    /**
                     * Initialize behaviors.
                     */
                }, {
                    key: '_initializeBehaviors',
                    value: function _initializeBehaviors() {
                        Marionette.Behaviors.behaviorsLookup = function () {
                            return { 'Table': BehaviorTable };
                        };
                    }

                    /**
                     * Set event binding.
                     */
                }, {
                    key: '_initializeRadio',
                    value: function _initializeRadio() {
                        var _this2 = this;

                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__SERVER_ROUTESLOADED, function () {
                            return _this2._handleEventRoutesLoaded();
                        });
                        Radio.channel('rodan').on(RODAN_EVENTS.EVENT__AUTHENTICATION_LOGIN_SUCCESS, function () {
                            return _this2._handleAuthenticationSuccess();
                        });
                    }

                    /**
                     * Initialize controllers. These are not used for viewing; rather, they are server/auth control.
                     */
                }, {
                    key: '_initializeControllers',
                    value: function _initializeControllers() {
                        this._contextMenuController = new ControllerContextMenu();
                        this._controllerServer = new ControllerServer();
                        this._controllerAuthentication = new ControllerAuthentication(this._controllerServer);
                        this._modalController = new ControllerModal();
                        this._projectController = new ControllerProject();
                        this._resourceController = new ControllerResource();
                        this._runJobController = new ControllerRunJob();
                        this._workflowController = new ControllerWorkflow();
                        this._workflowRunController = new ControllerWorkflowRun();
                        this._workflowBuilderController = new ControllerWorkflowBuilder();
                        this._workflowJobController = new ControllerWorkflowJob();
                        this._workflowJobGroupController = new ControllerWorkflowJobGroup();
                    }

                    /**
                     * Initialize AJAX prefilters. This allows the application a lower level of request monitoring (if desired).
                     */
                }, {
                    key: '_initializeAjaxPrefilters',
                    value: function _initializeAjaxPrefilters() {
                        var that = this;
                        $.ajaxPrefilter(function (options) {
                            that._controllerAuthentication.ajaxPrefilter(options);
                        });
                    }

                    /**
                     * Initialize collections.
                     */
                }, {
                    key: '_initializeCollections',
                    value: function _initializeCollections() {
                        this._jobCollection = new GlobalJobCollection();
                        this._resourceTypeCollection = new GlobalResourceTypeCollection();
                        this._inputPortTypeCollection = new GlobalInputPortTypeCollection();
                        this._outputPortTypeCollection = new GlobalOutputPortTypeCollection();
                        this._projectCollection = new GlobalProjectCollection();
                    }

                    /**
                     * Initialize all the views so they can respond to events.
                     */
                }, {
                    key: '_initializeViews',
                    value: function _initializeViews() {
                        this._layoutViewMaster = new LayoutViewMaster();
                    }

                    /**
                     * Handle EVENT__SERVER_ROUTESLOADED.
                     */
                }, {
                    key: '_handleEventRoutesLoaded',
                    value: function _handleEventRoutesLoaded() {
                        // Render layout views.
                        /** @ignore */
                        this.regionMaster.show(this._layoutViewMaster);

                        // Check authentication.
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_CHECK);
                    }

                    /**
                     * Handle authentication success.
                     */
                }, {
                    key: '_handleAuthenticationSuccess',
                    value: function _handleAuthenticationSuccess() {
                        var user = Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__AUTHENTICATION_USER);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__SERVER_LOAD_ROUTE_OPTIONS);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_PROJECTS_LOAD, { data: { user: user.get('uuid') } });
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_INPUTPORTTYPES_LOAD);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_OUTPUTPORTTYPES_LOAD);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_RESOURCETYPES_LOAD);
                        Radio.channel('rodan').request(RODAN_EVENTS.REQUEST__GLOBAL_JOBS_LOAD, { data: { enabled: 'True' } });
                        Radio.channel('rodan').trigger(RODAN_EVENTS.EVENT__PROJECT_SELECTED_COLLECTION);
                    }
                }]);

                return Application;
            })(Marionette.Application);

            _export('default', Application);
        }
    };
});

$__System.register('1', ['c7'], function (_export) {
  /**
   * Entry point of production application.
   */
  'use strict';

  var Application, app;
  return {
    setters: [function (_c7) {
      Application = _c7['default'];
    }],
    execute: function () {
      app = new Application();

      app.start();
    }
  };
});

$__System.register('github:twbs/bootstrap@3.3.6/css/bootstrap.css!github:systemjs/plugin-css@0.1.21.js', [], false, function() {});
(function(c){if (typeof document == 'undefined') return; var d=document,a='appendChild',i='styleSheet',s=d.createElement('style');s.type='text/css';d.getElementsByTagName('head')[0][a](s);s[i]?s[i].cssText=c:s[a](d.createTextNode(c));})
("/*!\n * Bootstrap v3.3.6 (http://getbootstrap.com)\n * Copyright 2011-2015 Twitter, Inc.\n * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)\n *//*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */html{font-family:sans-serif;-webkit-text-size-adjust:100%;-ms-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block;vertical-align:baseline}audio:not([controls]){display:none;height:0}[hidden],template{display:none}a{background-color:transparent}a:active,a:hover{outline:0}abbr[title]{border-bottom:1px dotted}b,strong{font-weight:700}dfn{font-style:italic}h1{margin:.67em 0;font-size:2em}mark{color:#000;background:#ff0}small{font-size:80%}sub,sup{position:relative;font-size:75%;line-height:0;vertical-align:baseline}sup{top:-.5em}sub{bottom:-.25em}img{border:0}svg:not(:root){overflow:hidden}figure{margin:1em 40px}hr{height:0;-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box}pre{overflow:auto}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}button,input,optgroup,select,textarea{margin:0;font:inherit;color:inherit}button{overflow:visible}button,select{text-transform:none}button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}button[disabled],html input[disabled]{cursor:default}button::-moz-focus-inner,input::-moz-focus-inner{padding:0;border:0}input{line-height:normal}input[type=checkbox],input[type=radio]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;padding:0}input[type=number]::-webkit-inner-spin-button,input[type=number]::-webkit-outer-spin-button{height:auto}input[type=search]{-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;-webkit-appearance:textfield}input[type=search]::-webkit-search-cancel-button,input[type=search]::-webkit-search-decoration{-webkit-appearance:none}fieldset{padding:.35em .625em .75em;margin:0 2px;border:1px solid silver}legend{padding:0;border:0}textarea{overflow:auto}optgroup{font-weight:700}table{border-spacing:0;border-collapse:collapse}td,th{padding:0}/*! Source: https://github.com/h5bp/html5-boilerplate/blob/master/src/css/main.css */@media print{*,:after,:before{color:#000!important;text-shadow:none!important;background:0 0!important;-webkit-box-shadow:none!important;box-shadow:none!important}a,a:visited{text-decoration:underline}a[href]:after{content:\" (\" attr(href) \")\"}abbr[title]:after{content:\" (\" attr(title) \")\"}a[href^=\"javascript:\"]:after,a[href^=\"#\"]:after{content:\"\"}blockquote,pre{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}img,tr{page-break-inside:avoid}img{max-width:100%!important}h2,h3,p{orphans:3;widows:3}h2,h3{page-break-after:avoid}.navbar{display:none}.btn>.caret,.dropup>.btn>.caret{border-top-color:#000!important}.label{border:1px solid #000}.table{border-collapse:collapse!important}.table td,.table th{background-color:#fff!important}.table-bordered td,.table-bordered th{border:1px solid #ddd!important}}@font-face{font-family:'Glyphicons Halflings';src:url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.eot);src:url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.eot?#iefix) format('embedded-opentype'),url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.woff2) format('woff2'),url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.woff) format('woff'),url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.ttf) format('truetype'),url(libs/github/twbs/bootstrap@3.3.6/fonts/glyphicons-halflings-regular.svg#glyphicons_halflingsregular) format('svg')}.glyphicon{position:relative;top:1px;display:inline-block;font-family:'Glyphicons Halflings';font-style:normal;font-weight:400;line-height:1;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.glyphicon-asterisk:before{content:\"\\002a\"}.glyphicon-plus:before{content:\"\\002b\"}.glyphicon-eur:before,.glyphicon-euro:before{content:\"\\20ac\"}.glyphicon-minus:before{content:\"\\2212\"}.glyphicon-cloud:before{content:\"\\2601\"}.glyphicon-envelope:before{content:\"\\2709\"}.glyphicon-pencil:before{content:\"\\270f\"}.glyphicon-glass:before{content:\"\\e001\"}.glyphicon-music:before{content:\"\\e002\"}.glyphicon-search:before{content:\"\\e003\"}.glyphicon-heart:before{content:\"\\e005\"}.glyphicon-star:before{content:\"\\e006\"}.glyphicon-star-empty:before{content:\"\\e007\"}.glyphicon-user:before{content:\"\\e008\"}.glyphicon-film:before{content:\"\\e009\"}.glyphicon-th-large:before{content:\"\\e010\"}.glyphicon-th:before{content:\"\\e011\"}.glyphicon-th-list:before{content:\"\\e012\"}.glyphicon-ok:before{content:\"\\e013\"}.glyphicon-remove:before{content:\"\\e014\"}.glyphicon-zoom-in:before{content:\"\\e015\"}.glyphicon-zoom-out:before{content:\"\\e016\"}.glyphicon-off:before{content:\"\\e017\"}.glyphicon-signal:before{content:\"\\e018\"}.glyphicon-cog:before{content:\"\\e019\"}.glyphicon-trash:before{content:\"\\e020\"}.glyphicon-home:before{content:\"\\e021\"}.glyphicon-file:before{content:\"\\e022\"}.glyphicon-time:before{content:\"\\e023\"}.glyphicon-road:before{content:\"\\e024\"}.glyphicon-download-alt:before{content:\"\\e025\"}.glyphicon-download:before{content:\"\\e026\"}.glyphicon-upload:before{content:\"\\e027\"}.glyphicon-inbox:before{content:\"\\e028\"}.glyphicon-play-circle:before{content:\"\\e029\"}.glyphicon-repeat:before{content:\"\\e030\"}.glyphicon-refresh:before{content:\"\\e031\"}.glyphicon-list-alt:before{content:\"\\e032\"}.glyphicon-lock:before{content:\"\\e033\"}.glyphicon-flag:before{content:\"\\e034\"}.glyphicon-headphones:before{content:\"\\e035\"}.glyphicon-volume-off:before{content:\"\\e036\"}.glyphicon-volume-down:before{content:\"\\e037\"}.glyphicon-volume-up:before{content:\"\\e038\"}.glyphicon-qrcode:before{content:\"\\e039\"}.glyphicon-barcode:before{content:\"\\e040\"}.glyphicon-tag:before{content:\"\\e041\"}.glyphicon-tags:before{content:\"\\e042\"}.glyphicon-book:before{content:\"\\e043\"}.glyphicon-bookmark:before{content:\"\\e044\"}.glyphicon-print:before{content:\"\\e045\"}.glyphicon-camera:before{content:\"\\e046\"}.glyphicon-font:before{content:\"\\e047\"}.glyphicon-bold:before{content:\"\\e048\"}.glyphicon-italic:before{content:\"\\e049\"}.glyphicon-text-height:before{content:\"\\e050\"}.glyphicon-text-width:before{content:\"\\e051\"}.glyphicon-align-left:before{content:\"\\e052\"}.glyphicon-align-center:before{content:\"\\e053\"}.glyphicon-align-right:before{content:\"\\e054\"}.glyphicon-align-justify:before{content:\"\\e055\"}.glyphicon-list:before{content:\"\\e056\"}.glyphicon-indent-left:before{content:\"\\e057\"}.glyphicon-indent-right:before{content:\"\\e058\"}.glyphicon-facetime-video:before{content:\"\\e059\"}.glyphicon-picture:before{content:\"\\e060\"}.glyphicon-map-marker:before{content:\"\\e062\"}.glyphicon-adjust:before{content:\"\\e063\"}.glyphicon-tint:before{content:\"\\e064\"}.glyphicon-edit:before{content:\"\\e065\"}.glyphicon-share:before{content:\"\\e066\"}.glyphicon-check:before{content:\"\\e067\"}.glyphicon-move:before{content:\"\\e068\"}.glyphicon-step-backward:before{content:\"\\e069\"}.glyphicon-fast-backward:before{content:\"\\e070\"}.glyphicon-backward:before{content:\"\\e071\"}.glyphicon-play:before{content:\"\\e072\"}.glyphicon-pause:before{content:\"\\e073\"}.glyphicon-stop:before{content:\"\\e074\"}.glyphicon-forward:before{content:\"\\e075\"}.glyphicon-fast-forward:before{content:\"\\e076\"}.glyphicon-step-forward:before{content:\"\\e077\"}.glyphicon-eject:before{content:\"\\e078\"}.glyphicon-chevron-left:before{content:\"\\e079\"}.glyphicon-chevron-right:before{content:\"\\e080\"}.glyphicon-plus-sign:before{content:\"\\e081\"}.glyphicon-minus-sign:before{content:\"\\e082\"}.glyphicon-remove-sign:before{content:\"\\e083\"}.glyphicon-ok-sign:before{content:\"\\e084\"}.glyphicon-question-sign:before{content:\"\\e085\"}.glyphicon-info-sign:before{content:\"\\e086\"}.glyphicon-screenshot:before{content:\"\\e087\"}.glyphicon-remove-circle:before{content:\"\\e088\"}.glyphicon-ok-circle:before{content:\"\\e089\"}.glyphicon-ban-circle:before{content:\"\\e090\"}.glyphicon-arrow-left:before{content:\"\\e091\"}.glyphicon-arrow-right:before{content:\"\\e092\"}.glyphicon-arrow-up:before{content:\"\\e093\"}.glyphicon-arrow-down:before{content:\"\\e094\"}.glyphicon-share-alt:before{content:\"\\e095\"}.glyphicon-resize-full:before{content:\"\\e096\"}.glyphicon-resize-small:before{content:\"\\e097\"}.glyphicon-exclamation-sign:before{content:\"\\e101\"}.glyphicon-gift:before{content:\"\\e102\"}.glyphicon-leaf:before{content:\"\\e103\"}.glyphicon-fire:before{content:\"\\e104\"}.glyphicon-eye-open:before{content:\"\\e105\"}.glyphicon-eye-close:before{content:\"\\e106\"}.glyphicon-warning-sign:before{content:\"\\e107\"}.glyphicon-plane:before{content:\"\\e108\"}.glyphicon-calendar:before{content:\"\\e109\"}.glyphicon-random:before{content:\"\\e110\"}.glyphicon-comment:before{content:\"\\e111\"}.glyphicon-magnet:before{content:\"\\e112\"}.glyphicon-chevron-up:before{content:\"\\e113\"}.glyphicon-chevron-down:before{content:\"\\e114\"}.glyphicon-retweet:before{content:\"\\e115\"}.glyphicon-shopping-cart:before{content:\"\\e116\"}.glyphicon-folder-close:before{content:\"\\e117\"}.glyphicon-folder-open:before{content:\"\\e118\"}.glyphicon-resize-vertical:before{content:\"\\e119\"}.glyphicon-resize-horizontal:before{content:\"\\e120\"}.glyphicon-hdd:before{content:\"\\e121\"}.glyphicon-bullhorn:before{content:\"\\e122\"}.glyphicon-bell:before{content:\"\\e123\"}.glyphicon-certificate:before{content:\"\\e124\"}.glyphicon-thumbs-up:before{content:\"\\e125\"}.glyphicon-thumbs-down:before{content:\"\\e126\"}.glyphicon-hand-right:before{content:\"\\e127\"}.glyphicon-hand-left:before{content:\"\\e128\"}.glyphicon-hand-up:before{content:\"\\e129\"}.glyphicon-hand-down:before{content:\"\\e130\"}.glyphicon-circle-arrow-right:before{content:\"\\e131\"}.glyphicon-circle-arrow-left:before{content:\"\\e132\"}.glyphicon-circle-arrow-up:before{content:\"\\e133\"}.glyphicon-circle-arrow-down:before{content:\"\\e134\"}.glyphicon-globe:before{content:\"\\e135\"}.glyphicon-wrench:before{content:\"\\e136\"}.glyphicon-tasks:before{content:\"\\e137\"}.glyphicon-filter:before{content:\"\\e138\"}.glyphicon-briefcase:before{content:\"\\e139\"}.glyphicon-fullscreen:before{content:\"\\e140\"}.glyphicon-dashboard:before{content:\"\\e141\"}.glyphicon-paperclip:before{content:\"\\e142\"}.glyphicon-heart-empty:before{content:\"\\e143\"}.glyphicon-link:before{content:\"\\e144\"}.glyphicon-phone:before{content:\"\\e145\"}.glyphicon-pushpin:before{content:\"\\e146\"}.glyphicon-usd:before{content:\"\\e148\"}.glyphicon-gbp:before{content:\"\\e149\"}.glyphicon-sort:before{content:\"\\e150\"}.glyphicon-sort-by-alphabet:before{content:\"\\e151\"}.glyphicon-sort-by-alphabet-alt:before{content:\"\\e152\"}.glyphicon-sort-by-order:before{content:\"\\e153\"}.glyphicon-sort-by-order-alt:before{content:\"\\e154\"}.glyphicon-sort-by-attributes:before{content:\"\\e155\"}.glyphicon-sort-by-attributes-alt:before{content:\"\\e156\"}.glyphicon-unchecked:before{content:\"\\e157\"}.glyphicon-expand:before{content:\"\\e158\"}.glyphicon-collapse-down:before{content:\"\\e159\"}.glyphicon-collapse-up:before{content:\"\\e160\"}.glyphicon-log-in:before{content:\"\\e161\"}.glyphicon-flash:before{content:\"\\e162\"}.glyphicon-log-out:before{content:\"\\e163\"}.glyphicon-new-window:before{content:\"\\e164\"}.glyphicon-record:before{content:\"\\e165\"}.glyphicon-save:before{content:\"\\e166\"}.glyphicon-open:before{content:\"\\e167\"}.glyphicon-saved:before{content:\"\\e168\"}.glyphicon-import:before{content:\"\\e169\"}.glyphicon-export:before{content:\"\\e170\"}.glyphicon-send:before{content:\"\\e171\"}.glyphicon-floppy-disk:before{content:\"\\e172\"}.glyphicon-floppy-saved:before{content:\"\\e173\"}.glyphicon-floppy-remove:before{content:\"\\e174\"}.glyphicon-floppy-save:before{content:\"\\e175\"}.glyphicon-floppy-open:before{content:\"\\e176\"}.glyphicon-credit-card:before{content:\"\\e177\"}.glyphicon-transfer:before{content:\"\\e178\"}.glyphicon-cutlery:before{content:\"\\e179\"}.glyphicon-header:before{content:\"\\e180\"}.glyphicon-compressed:before{content:\"\\e181\"}.glyphicon-earphone:before{content:\"\\e182\"}.glyphicon-phone-alt:before{content:\"\\e183\"}.glyphicon-tower:before{content:\"\\e184\"}.glyphicon-stats:before{content:\"\\e185\"}.glyphicon-sd-video:before{content:\"\\e186\"}.glyphicon-hd-video:before{content:\"\\e187\"}.glyphicon-subtitles:before{content:\"\\e188\"}.glyphicon-sound-stereo:before{content:\"\\e189\"}.glyphicon-sound-dolby:before{content:\"\\e190\"}.glyphicon-sound-5-1:before{content:\"\\e191\"}.glyphicon-sound-6-1:before{content:\"\\e192\"}.glyphicon-sound-7-1:before{content:\"\\e193\"}.glyphicon-copyright-mark:before{content:\"\\e194\"}.glyphicon-registration-mark:before{content:\"\\e195\"}.glyphicon-cloud-download:before{content:\"\\e197\"}.glyphicon-cloud-upload:before{content:\"\\e198\"}.glyphicon-tree-conifer:before{content:\"\\e199\"}.glyphicon-tree-deciduous:before{content:\"\\e200\"}.glyphicon-cd:before{content:\"\\e201\"}.glyphicon-save-file:before{content:\"\\e202\"}.glyphicon-open-file:before{content:\"\\e203\"}.glyphicon-level-up:before{content:\"\\e204\"}.glyphicon-copy:before{content:\"\\e205\"}.glyphicon-paste:before{content:\"\\e206\"}.glyphicon-alert:before{content:\"\\e209\"}.glyphicon-equalizer:before{content:\"\\e210\"}.glyphicon-king:before{content:\"\\e211\"}.glyphicon-queen:before{content:\"\\e212\"}.glyphicon-pawn:before{content:\"\\e213\"}.glyphicon-bishop:before{content:\"\\e214\"}.glyphicon-knight:before{content:\"\\e215\"}.glyphicon-baby-formula:before{content:\"\\e216\"}.glyphicon-tent:before{content:\"\\26fa\"}.glyphicon-blackboard:before{content:\"\\e218\"}.glyphicon-bed:before{content:\"\\e219\"}.glyphicon-apple:before{content:\"\\f8ff\"}.glyphicon-erase:before{content:\"\\e221\"}.glyphicon-hourglass:before{content:\"\\231b\"}.glyphicon-lamp:before{content:\"\\e223\"}.glyphicon-duplicate:before{content:\"\\e224\"}.glyphicon-piggy-bank:before{content:\"\\e225\"}.glyphicon-scissors:before{content:\"\\e226\"}.glyphicon-bitcoin:before{content:\"\\e227\"}.glyphicon-btc:before{content:\"\\e227\"}.glyphicon-xbt:before{content:\"\\e227\"}.glyphicon-yen:before{content:\"\\00a5\"}.glyphicon-jpy:before{content:\"\\00a5\"}.glyphicon-ruble:before{content:\"\\20bd\"}.glyphicon-rub:before{content:\"\\20bd\"}.glyphicon-scale:before{content:\"\\e230\"}.glyphicon-ice-lolly:before{content:\"\\e231\"}.glyphicon-ice-lolly-tasted:before{content:\"\\e232\"}.glyphicon-education:before{content:\"\\e233\"}.glyphicon-option-horizontal:before{content:\"\\e234\"}.glyphicon-option-vertical:before{content:\"\\e235\"}.glyphicon-menu-hamburger:before{content:\"\\e236\"}.glyphicon-modal-window:before{content:\"\\e237\"}.glyphicon-oil:before{content:\"\\e238\"}.glyphicon-grain:before{content:\"\\e239\"}.glyphicon-sunglasses:before{content:\"\\e240\"}.glyphicon-text-size:before{content:\"\\e241\"}.glyphicon-text-color:before{content:\"\\e242\"}.glyphicon-text-background:before{content:\"\\e243\"}.glyphicon-object-align-top:before{content:\"\\e244\"}.glyphicon-object-align-bottom:before{content:\"\\e245\"}.glyphicon-object-align-horizontal:before{content:\"\\e246\"}.glyphicon-object-align-left:before{content:\"\\e247\"}.glyphicon-object-align-vertical:before{content:\"\\e248\"}.glyphicon-object-align-right:before{content:\"\\e249\"}.glyphicon-triangle-right:before{content:\"\\e250\"}.glyphicon-triangle-left:before{content:\"\\e251\"}.glyphicon-triangle-bottom:before{content:\"\\e252\"}.glyphicon-triangle-top:before{content:\"\\e253\"}.glyphicon-console:before{content:\"\\e254\"}.glyphicon-superscript:before{content:\"\\e255\"}.glyphicon-subscript:before{content:\"\\e256\"}.glyphicon-menu-left:before{content:\"\\e257\"}.glyphicon-menu-right:before{content:\"\\e258\"}.glyphicon-menu-down:before{content:\"\\e259\"}.glyphicon-menu-up:before{content:\"\\e260\"}*{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}:after,:before{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}html{font-size:10px;-webkit-tap-highlight-color:transparent}body{font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;line-height:1.42857143;color:#333;background-color:#fff}button,input,select,textarea{font-family:inherit;font-size:inherit;line-height:inherit}a{color:#337ab7;text-decoration:none}a:focus,a:hover{color:#23527c;text-decoration:underline}a:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}figure{margin:0}img{vertical-align:middle}.carousel-inner>.item>a>img,.carousel-inner>.item>img,.img-responsive,.thumbnail a>img,.thumbnail>img{display:block;max-width:100%;height:auto}.img-rounded{border-radius:6px}.img-thumbnail{display:inline-block;max-width:100%;height:auto;padding:4px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:all .2s ease-in-out;-o-transition:all .2s ease-in-out;transition:all .2s ease-in-out}.img-circle{border-radius:50%}hr{margin-top:20px;margin-bottom:20px;border:0;border-top:1px solid #eee}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0,0,0,0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}[role=button]{cursor:pointer}.h1,.h2,.h3,.h4,.h5,.h6,h1,h2,h3,h4,h5,h6{font-family:inherit;font-weight:500;line-height:1.1;color:inherit}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-weight:400;line-height:1;color:#777}.h1,.h2,.h3,h1,h2,h3{margin-top:20px;margin-bottom:10px}.h1 .small,.h1 small,.h2 .small,.h2 small,.h3 .small,.h3 small,h1 .small,h1 small,h2 .small,h2 small,h3 .small,h3 small{font-size:65%}.h4,.h5,.h6,h4,h5,h6{margin-top:10px;margin-bottom:10px}.h4 .small,.h4 small,.h5 .small,.h5 small,.h6 .small,.h6 small,h4 .small,h4 small,h5 .small,h5 small,h6 .small,h6 small{font-size:75%}.h1,h1{font-size:36px}.h2,h2{font-size:30px}.h3,h3{font-size:24px}.h4,h4{font-size:18px}.h5,h5{font-size:14px}.h6,h6{font-size:12px}p{margin:0 0 10px}.lead{margin-bottom:20px;font-size:16px;font-weight:300;line-height:1.4}@media (min-width:768px){.lead{font-size:21px}}.small,small{font-size:85%}.mark,mark{padding:.2em;background-color:#fcf8e3}.text-left{text-align:left}.text-right{text-align:right}.text-center{text-align:center}.text-justify{text-align:justify}.text-nowrap{white-space:nowrap}.text-lowercase{text-transform:lowercase}.text-uppercase{text-transform:uppercase}.text-capitalize{text-transform:capitalize}.text-muted{color:#777}.text-primary{color:#337ab7}a.text-primary:focus,a.text-primary:hover{color:#286090}.text-success{color:#3c763d}a.text-success:focus,a.text-success:hover{color:#2b542c}.text-info{color:#31708f}a.text-info:focus,a.text-info:hover{color:#245269}.text-warning{color:#8a6d3b}a.text-warning:focus,a.text-warning:hover{color:#66512c}.text-danger{color:#a94442}a.text-danger:focus,a.text-danger:hover{color:#843534}.bg-primary{color:#fff;background-color:#337ab7}a.bg-primary:focus,a.bg-primary:hover{background-color:#286090}.bg-success{background-color:#dff0d8}a.bg-success:focus,a.bg-success:hover{background-color:#c1e2b3}.bg-info{background-color:#d9edf7}a.bg-info:focus,a.bg-info:hover{background-color:#afd9ee}.bg-warning{background-color:#fcf8e3}a.bg-warning:focus,a.bg-warning:hover{background-color:#f7ecb5}.bg-danger{background-color:#f2dede}a.bg-danger:focus,a.bg-danger:hover{background-color:#e4b9b9}.page-header{padding-bottom:9px;margin:40px 0 20px;border-bottom:1px solid #eee}ol,ul{margin-top:0;margin-bottom:10px}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}.list-unstyled{padding-left:0;list-style:none}.list-inline{padding-left:0;margin-left:-5px;list-style:none}.list-inline>li{display:inline-block;padding-right:5px;padding-left:5px}dl{margin-top:0;margin-bottom:20px}dd,dt{line-height:1.42857143}dt{font-weight:700}dd{margin-left:0}@media (min-width:768px){.dl-horizontal dt{float:left;width:160px;overflow:hidden;clear:left;text-align:right;text-overflow:ellipsis;white-space:nowrap}.dl-horizontal dd{margin-left:180px}}abbr[data-original-title],abbr[title]{cursor:help;border-bottom:1px dotted #777}.initialism{font-size:90%;text-transform:uppercase}blockquote{padding:10px 20px;margin:0 0 20px;font-size:17.5px;border-left:5px solid #eee}blockquote ol:last-child,blockquote p:last-child,blockquote ul:last-child{margin-bottom:0}blockquote .small,blockquote footer,blockquote small{display:block;font-size:80%;line-height:1.42857143;color:#777}blockquote .small:before,blockquote footer:before,blockquote small:before{content:'\\2014 \\00A0'}.blockquote-reverse,blockquote.pull-right{padding-right:15px;padding-left:0;text-align:right;border-right:5px solid #eee;border-left:0}.blockquote-reverse .small:before,.blockquote-reverse footer:before,.blockquote-reverse small:before,blockquote.pull-right .small:before,blockquote.pull-right footer:before,blockquote.pull-right small:before{content:''}.blockquote-reverse .small:after,.blockquote-reverse footer:after,.blockquote-reverse small:after,blockquote.pull-right .small:after,blockquote.pull-right footer:after,blockquote.pull-right small:after{content:'\\00A0 \\2014'}address{margin-bottom:20px;font-style:normal;line-height:1.42857143}code,kbd,pre,samp{font-family:Menlo,Monaco,Consolas,\"Courier New\",monospace}code{padding:2px 4px;font-size:90%;color:#c7254e;background-color:#f9f2f4;border-radius:4px}kbd{padding:2px 4px;font-size:90%;color:#fff;background-color:#333;border-radius:3px;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.25);box-shadow:inset 0 -1px 0 rgba(0,0,0,.25)}kbd kbd{padding:0;font-size:100%;font-weight:700;-webkit-box-shadow:none;box-shadow:none}pre{display:block;padding:9.5px;margin:0 0 10px;font-size:13px;line-height:1.42857143;color:#333;word-break:break-all;word-wrap:break-word;background-color:#f5f5f5;border:1px solid #ccc;border-radius:4px}pre code{padding:0;font-size:inherit;color:inherit;white-space:pre-wrap;background-color:transparent;border-radius:0}.pre-scrollable{max-height:340px;overflow-y:scroll}.container{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}@media (min-width:768px){.container{width:750px}}@media (min-width:992px){.container{width:970px}}@media (min-width:1200px){.container{width:1170px}}.container-fluid{padding-right:15px;padding-left:15px;margin-right:auto;margin-left:auto}.row{margin-right:-15px;margin-left:-15px}.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9,.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9,.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9,.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{position:relative;min-height:1px;padding-right:15px;padding-left:15px}.col-xs-1,.col-xs-10,.col-xs-11,.col-xs-12,.col-xs-2,.col-xs-3,.col-xs-4,.col-xs-5,.col-xs-6,.col-xs-7,.col-xs-8,.col-xs-9{float:left}.col-xs-12{width:100%}.col-xs-11{width:91.66666667%}.col-xs-10{width:83.33333333%}.col-xs-9{width:75%}.col-xs-8{width:66.66666667%}.col-xs-7{width:58.33333333%}.col-xs-6{width:50%}.col-xs-5{width:41.66666667%}.col-xs-4{width:33.33333333%}.col-xs-3{width:25%}.col-xs-2{width:16.66666667%}.col-xs-1{width:8.33333333%}.col-xs-pull-12{right:100%}.col-xs-pull-11{right:91.66666667%}.col-xs-pull-10{right:83.33333333%}.col-xs-pull-9{right:75%}.col-xs-pull-8{right:66.66666667%}.col-xs-pull-7{right:58.33333333%}.col-xs-pull-6{right:50%}.col-xs-pull-5{right:41.66666667%}.col-xs-pull-4{right:33.33333333%}.col-xs-pull-3{right:25%}.col-xs-pull-2{right:16.66666667%}.col-xs-pull-1{right:8.33333333%}.col-xs-pull-0{right:auto}.col-xs-push-12{left:100%}.col-xs-push-11{left:91.66666667%}.col-xs-push-10{left:83.33333333%}.col-xs-push-9{left:75%}.col-xs-push-8{left:66.66666667%}.col-xs-push-7{left:58.33333333%}.col-xs-push-6{left:50%}.col-xs-push-5{left:41.66666667%}.col-xs-push-4{left:33.33333333%}.col-xs-push-3{left:25%}.col-xs-push-2{left:16.66666667%}.col-xs-push-1{left:8.33333333%}.col-xs-push-0{left:auto}.col-xs-offset-12{margin-left:100%}.col-xs-offset-11{margin-left:91.66666667%}.col-xs-offset-10{margin-left:83.33333333%}.col-xs-offset-9{margin-left:75%}.col-xs-offset-8{margin-left:66.66666667%}.col-xs-offset-7{margin-left:58.33333333%}.col-xs-offset-6{margin-left:50%}.col-xs-offset-5{margin-left:41.66666667%}.col-xs-offset-4{margin-left:33.33333333%}.col-xs-offset-3{margin-left:25%}.col-xs-offset-2{margin-left:16.66666667%}.col-xs-offset-1{margin-left:8.33333333%}.col-xs-offset-0{margin-left:0}@media (min-width:768px){.col-sm-1,.col-sm-10,.col-sm-11,.col-sm-12,.col-sm-2,.col-sm-3,.col-sm-4,.col-sm-5,.col-sm-6,.col-sm-7,.col-sm-8,.col-sm-9{float:left}.col-sm-12{width:100%}.col-sm-11{width:91.66666667%}.col-sm-10{width:83.33333333%}.col-sm-9{width:75%}.col-sm-8{width:66.66666667%}.col-sm-7{width:58.33333333%}.col-sm-6{width:50%}.col-sm-5{width:41.66666667%}.col-sm-4{width:33.33333333%}.col-sm-3{width:25%}.col-sm-2{width:16.66666667%}.col-sm-1{width:8.33333333%}.col-sm-pull-12{right:100%}.col-sm-pull-11{right:91.66666667%}.col-sm-pull-10{right:83.33333333%}.col-sm-pull-9{right:75%}.col-sm-pull-8{right:66.66666667%}.col-sm-pull-7{right:58.33333333%}.col-sm-pull-6{right:50%}.col-sm-pull-5{right:41.66666667%}.col-sm-pull-4{right:33.33333333%}.col-sm-pull-3{right:25%}.col-sm-pull-2{right:16.66666667%}.col-sm-pull-1{right:8.33333333%}.col-sm-pull-0{right:auto}.col-sm-push-12{left:100%}.col-sm-push-11{left:91.66666667%}.col-sm-push-10{left:83.33333333%}.col-sm-push-9{left:75%}.col-sm-push-8{left:66.66666667%}.col-sm-push-7{left:58.33333333%}.col-sm-push-6{left:50%}.col-sm-push-5{left:41.66666667%}.col-sm-push-4{left:33.33333333%}.col-sm-push-3{left:25%}.col-sm-push-2{left:16.66666667%}.col-sm-push-1{left:8.33333333%}.col-sm-push-0{left:auto}.col-sm-offset-12{margin-left:100%}.col-sm-offset-11{margin-left:91.66666667%}.col-sm-offset-10{margin-left:83.33333333%}.col-sm-offset-9{margin-left:75%}.col-sm-offset-8{margin-left:66.66666667%}.col-sm-offset-7{margin-left:58.33333333%}.col-sm-offset-6{margin-left:50%}.col-sm-offset-5{margin-left:41.66666667%}.col-sm-offset-4{margin-left:33.33333333%}.col-sm-offset-3{margin-left:25%}.col-sm-offset-2{margin-left:16.66666667%}.col-sm-offset-1{margin-left:8.33333333%}.col-sm-offset-0{margin-left:0}}@media (min-width:992px){.col-md-1,.col-md-10,.col-md-11,.col-md-12,.col-md-2,.col-md-3,.col-md-4,.col-md-5,.col-md-6,.col-md-7,.col-md-8,.col-md-9{float:left}.col-md-12{width:100%}.col-md-11{width:91.66666667%}.col-md-10{width:83.33333333%}.col-md-9{width:75%}.col-md-8{width:66.66666667%}.col-md-7{width:58.33333333%}.col-md-6{width:50%}.col-md-5{width:41.66666667%}.col-md-4{width:33.33333333%}.col-md-3{width:25%}.col-md-2{width:16.66666667%}.col-md-1{width:8.33333333%}.col-md-pull-12{right:100%}.col-md-pull-11{right:91.66666667%}.col-md-pull-10{right:83.33333333%}.col-md-pull-9{right:75%}.col-md-pull-8{right:66.66666667%}.col-md-pull-7{right:58.33333333%}.col-md-pull-6{right:50%}.col-md-pull-5{right:41.66666667%}.col-md-pull-4{right:33.33333333%}.col-md-pull-3{right:25%}.col-md-pull-2{right:16.66666667%}.col-md-pull-1{right:8.33333333%}.col-md-pull-0{right:auto}.col-md-push-12{left:100%}.col-md-push-11{left:91.66666667%}.col-md-push-10{left:83.33333333%}.col-md-push-9{left:75%}.col-md-push-8{left:66.66666667%}.col-md-push-7{left:58.33333333%}.col-md-push-6{left:50%}.col-md-push-5{left:41.66666667%}.col-md-push-4{left:33.33333333%}.col-md-push-3{left:25%}.col-md-push-2{left:16.66666667%}.col-md-push-1{left:8.33333333%}.col-md-push-0{left:auto}.col-md-offset-12{margin-left:100%}.col-md-offset-11{margin-left:91.66666667%}.col-md-offset-10{margin-left:83.33333333%}.col-md-offset-9{margin-left:75%}.col-md-offset-8{margin-left:66.66666667%}.col-md-offset-7{margin-left:58.33333333%}.col-md-offset-6{margin-left:50%}.col-md-offset-5{margin-left:41.66666667%}.col-md-offset-4{margin-left:33.33333333%}.col-md-offset-3{margin-left:25%}.col-md-offset-2{margin-left:16.66666667%}.col-md-offset-1{margin-left:8.33333333%}.col-md-offset-0{margin-left:0}}@media (min-width:1200px){.col-lg-1,.col-lg-10,.col-lg-11,.col-lg-12,.col-lg-2,.col-lg-3,.col-lg-4,.col-lg-5,.col-lg-6,.col-lg-7,.col-lg-8,.col-lg-9{float:left}.col-lg-12{width:100%}.col-lg-11{width:91.66666667%}.col-lg-10{width:83.33333333%}.col-lg-9{width:75%}.col-lg-8{width:66.66666667%}.col-lg-7{width:58.33333333%}.col-lg-6{width:50%}.col-lg-5{width:41.66666667%}.col-lg-4{width:33.33333333%}.col-lg-3{width:25%}.col-lg-2{width:16.66666667%}.col-lg-1{width:8.33333333%}.col-lg-pull-12{right:100%}.col-lg-pull-11{right:91.66666667%}.col-lg-pull-10{right:83.33333333%}.col-lg-pull-9{right:75%}.col-lg-pull-8{right:66.66666667%}.col-lg-pull-7{right:58.33333333%}.col-lg-pull-6{right:50%}.col-lg-pull-5{right:41.66666667%}.col-lg-pull-4{right:33.33333333%}.col-lg-pull-3{right:25%}.col-lg-pull-2{right:16.66666667%}.col-lg-pull-1{right:8.33333333%}.col-lg-pull-0{right:auto}.col-lg-push-12{left:100%}.col-lg-push-11{left:91.66666667%}.col-lg-push-10{left:83.33333333%}.col-lg-push-9{left:75%}.col-lg-push-8{left:66.66666667%}.col-lg-push-7{left:58.33333333%}.col-lg-push-6{left:50%}.col-lg-push-5{left:41.66666667%}.col-lg-push-4{left:33.33333333%}.col-lg-push-3{left:25%}.col-lg-push-2{left:16.66666667%}.col-lg-push-1{left:8.33333333%}.col-lg-push-0{left:auto}.col-lg-offset-12{margin-left:100%}.col-lg-offset-11{margin-left:91.66666667%}.col-lg-offset-10{margin-left:83.33333333%}.col-lg-offset-9{margin-left:75%}.col-lg-offset-8{margin-left:66.66666667%}.col-lg-offset-7{margin-left:58.33333333%}.col-lg-offset-6{margin-left:50%}.col-lg-offset-5{margin-left:41.66666667%}.col-lg-offset-4{margin-left:33.33333333%}.col-lg-offset-3{margin-left:25%}.col-lg-offset-2{margin-left:16.66666667%}.col-lg-offset-1{margin-left:8.33333333%}.col-lg-offset-0{margin-left:0}}table{background-color:transparent}caption{padding-top:8px;padding-bottom:8px;color:#777;text-align:left}th{text-align:left}.table{width:100%;max-width:100%;margin-bottom:20px}.table>tbody>tr>td,.table>tbody>tr>th,.table>tfoot>tr>td,.table>tfoot>tr>th,.table>thead>tr>td,.table>thead>tr>th{padding:8px;line-height:1.42857143;vertical-align:top;border-top:1px solid #ddd}.table>thead>tr>th{vertical-align:bottom;border-bottom:2px solid #ddd}.table>caption+thead>tr:first-child>td,.table>caption+thead>tr:first-child>th,.table>colgroup+thead>tr:first-child>td,.table>colgroup+thead>tr:first-child>th,.table>thead:first-child>tr:first-child>td,.table>thead:first-child>tr:first-child>th{border-top:0}.table>tbody+tbody{border-top:2px solid #ddd}.table .table{background-color:#fff}.table-condensed>tbody>tr>td,.table-condensed>tbody>tr>th,.table-condensed>tfoot>tr>td,.table-condensed>tfoot>tr>th,.table-condensed>thead>tr>td,.table-condensed>thead>tr>th{padding:5px}.table-bordered{border:1px solid #ddd}.table-bordered>tbody>tr>td,.table-bordered>tbody>tr>th,.table-bordered>tfoot>tr>td,.table-bordered>tfoot>tr>th,.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border:1px solid #ddd}.table-bordered>thead>tr>td,.table-bordered>thead>tr>th{border-bottom-width:2px}.table-striped>tbody>tr:nth-of-type(odd){background-color:#f9f9f9}.table-hover>tbody>tr:hover{background-color:#f5f5f5}table col[class*=col-]{position:static;display:table-column;float:none}table td[class*=col-],table th[class*=col-]{position:static;display:table-cell;float:none}.table>tbody>tr.active>td,.table>tbody>tr.active>th,.table>tbody>tr>td.active,.table>tbody>tr>th.active,.table>tfoot>tr.active>td,.table>tfoot>tr.active>th,.table>tfoot>tr>td.active,.table>tfoot>tr>th.active,.table>thead>tr.active>td,.table>thead>tr.active>th,.table>thead>tr>td.active,.table>thead>tr>th.active{background-color:#f5f5f5}.table-hover>tbody>tr.active:hover>td,.table-hover>tbody>tr.active:hover>th,.table-hover>tbody>tr:hover>.active,.table-hover>tbody>tr>td.active:hover,.table-hover>tbody>tr>th.active:hover{background-color:#e8e8e8}.table>tbody>tr.success>td,.table>tbody>tr.success>th,.table>tbody>tr>td.success,.table>tbody>tr>th.success,.table>tfoot>tr.success>td,.table>tfoot>tr.success>th,.table>tfoot>tr>td.success,.table>tfoot>tr>th.success,.table>thead>tr.success>td,.table>thead>tr.success>th,.table>thead>tr>td.success,.table>thead>tr>th.success{background-color:#dff0d8}.table-hover>tbody>tr.success:hover>td,.table-hover>tbody>tr.success:hover>th,.table-hover>tbody>tr:hover>.success,.table-hover>tbody>tr>td.success:hover,.table-hover>tbody>tr>th.success:hover{background-color:#d0e9c6}.table>tbody>tr.info>td,.table>tbody>tr.info>th,.table>tbody>tr>td.info,.table>tbody>tr>th.info,.table>tfoot>tr.info>td,.table>tfoot>tr.info>th,.table>tfoot>tr>td.info,.table>tfoot>tr>th.info,.table>thead>tr.info>td,.table>thead>tr.info>th,.table>thead>tr>td.info,.table>thead>tr>th.info{background-color:#d9edf7}.table-hover>tbody>tr.info:hover>td,.table-hover>tbody>tr.info:hover>th,.table-hover>tbody>tr:hover>.info,.table-hover>tbody>tr>td.info:hover,.table-hover>tbody>tr>th.info:hover{background-color:#c4e3f3}.table>tbody>tr.warning>td,.table>tbody>tr.warning>th,.table>tbody>tr>td.warning,.table>tbody>tr>th.warning,.table>tfoot>tr.warning>td,.table>tfoot>tr.warning>th,.table>tfoot>tr>td.warning,.table>tfoot>tr>th.warning,.table>thead>tr.warning>td,.table>thead>tr.warning>th,.table>thead>tr>td.warning,.table>thead>tr>th.warning{background-color:#fcf8e3}.table-hover>tbody>tr.warning:hover>td,.table-hover>tbody>tr.warning:hover>th,.table-hover>tbody>tr:hover>.warning,.table-hover>tbody>tr>td.warning:hover,.table-hover>tbody>tr>th.warning:hover{background-color:#faf2cc}.table>tbody>tr.danger>td,.table>tbody>tr.danger>th,.table>tbody>tr>td.danger,.table>tbody>tr>th.danger,.table>tfoot>tr.danger>td,.table>tfoot>tr.danger>th,.table>tfoot>tr>td.danger,.table>tfoot>tr>th.danger,.table>thead>tr.danger>td,.table>thead>tr.danger>th,.table>thead>tr>td.danger,.table>thead>tr>th.danger{background-color:#f2dede}.table-hover>tbody>tr.danger:hover>td,.table-hover>tbody>tr.danger:hover>th,.table-hover>tbody>tr:hover>.danger,.table-hover>tbody>tr>td.danger:hover,.table-hover>tbody>tr>th.danger:hover{background-color:#ebcccc}.table-responsive{min-height:.01%;overflow-x:auto}@media screen and (max-width:767px){.table-responsive{width:100%;margin-bottom:15px;overflow-y:hidden;-ms-overflow-style:-ms-autohiding-scrollbar;border:1px solid #ddd}.table-responsive>.table{margin-bottom:0}.table-responsive>.table>tbody>tr>td,.table-responsive>.table>tbody>tr>th,.table-responsive>.table>tfoot>tr>td,.table-responsive>.table>tfoot>tr>th,.table-responsive>.table>thead>tr>td,.table-responsive>.table>thead>tr>th{white-space:nowrap}.table-responsive>.table-bordered{border:0}.table-responsive>.table-bordered>tbody>tr>td:first-child,.table-responsive>.table-bordered>tbody>tr>th:first-child,.table-responsive>.table-bordered>tfoot>tr>td:first-child,.table-responsive>.table-bordered>tfoot>tr>th:first-child,.table-responsive>.table-bordered>thead>tr>td:first-child,.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.table-responsive>.table-bordered>tbody>tr>td:last-child,.table-responsive>.table-bordered>tbody>tr>th:last-child,.table-responsive>.table-bordered>tfoot>tr>td:last-child,.table-responsive>.table-bordered>tfoot>tr>th:last-child,.table-responsive>.table-bordered>thead>tr>td:last-child,.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.table-responsive>.table-bordered>tbody>tr:last-child>td,.table-responsive>.table-bordered>tbody>tr:last-child>th,.table-responsive>.table-bordered>tfoot>tr:last-child>td,.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}}fieldset{min-width:0;padding:0;margin:0;border:0}legend{display:block;width:100%;padding:0;margin-bottom:20px;font-size:21px;line-height:inherit;color:#333;border:0;border-bottom:1px solid #e5e5e5}label{display:inline-block;max-width:100%;margin-bottom:5px;font-weight:700}input[type=search]{-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box}input[type=checkbox],input[type=radio]{margin:4px 0 0;margin-top:1px\\9;line-height:normal}input[type=file]{display:block}input[type=range]{display:block;width:100%}select[multiple],select[size]{height:auto}input[type=file]:focus,input[type=checkbox]:focus,input[type=radio]:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}output{display:block;padding-top:7px;font-size:14px;line-height:1.42857143;color:#555}.form-control{display:block;width:100%;height:34px;padding:6px 12px;font-size:14px;line-height:1.42857143;color:#555;background-color:#fff;background-image:none;border:1px solid #ccc;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075);-webkit-transition:border-color ease-in-out .15s,-webkit-box-shadow ease-in-out .15s;-o-transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s;transition:border-color ease-in-out .15s,box-shadow ease-in-out .15s}.form-control:focus{border-color:#66afe9;outline:0;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6);box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 8px rgba(102,175,233,.6)}.form-control::-moz-placeholder{color:#999;opacity:1}.form-control:-ms-input-placeholder{color:#999}.form-control::-webkit-input-placeholder{color:#999}.form-control::-ms-expand{background-color:transparent;border:0}.form-control[disabled],.form-control[readonly],fieldset[disabled] .form-control{background-color:#eee;opacity:1}.form-control[disabled],fieldset[disabled] .form-control{cursor:not-allowed}textarea.form-control{height:auto}input[type=search]{-webkit-appearance:none}@media screen and (-webkit-min-device-pixel-ratio:0){input[type=date].form-control,input[type=time].form-control,input[type=datetime-local].form-control,input[type=month].form-control{line-height:34px}.input-group-sm input[type=date],.input-group-sm input[type=time],.input-group-sm input[type=datetime-local],.input-group-sm input[type=month],input[type=date].input-sm,input[type=time].input-sm,input[type=datetime-local].input-sm,input[type=month].input-sm{line-height:30px}.input-group-lg input[type=date],.input-group-lg input[type=time],.input-group-lg input[type=datetime-local],.input-group-lg input[type=month],input[type=date].input-lg,input[type=time].input-lg,input[type=datetime-local].input-lg,input[type=month].input-lg{line-height:46px}}.form-group{margin-bottom:15px}.checkbox,.radio{position:relative;display:block;margin-top:10px;margin-bottom:10px}.checkbox label,.radio label{min-height:20px;padding-left:20px;margin-bottom:0;font-weight:400;cursor:pointer}.checkbox input[type=checkbox],.checkbox-inline input[type=checkbox],.radio input[type=radio],.radio-inline input[type=radio]{position:absolute;margin-top:4px\\9;margin-left:-20px}.checkbox+.checkbox,.radio+.radio{margin-top:-5px}.checkbox-inline,.radio-inline{position:relative;display:inline-block;padding-left:20px;margin-bottom:0;font-weight:400;vertical-align:middle;cursor:pointer}.checkbox-inline+.checkbox-inline,.radio-inline+.radio-inline{margin-top:0;margin-left:10px}fieldset[disabled] input[type=checkbox],fieldset[disabled] input[type=radio],input[type=checkbox].disabled,input[type=checkbox][disabled],input[type=radio].disabled,input[type=radio][disabled]{cursor:not-allowed}.checkbox-inline.disabled,.radio-inline.disabled,fieldset[disabled] .checkbox-inline,fieldset[disabled] .radio-inline{cursor:not-allowed}.checkbox.disabled label,.radio.disabled label,fieldset[disabled] .checkbox label,fieldset[disabled] .radio label{cursor:not-allowed}.form-control-static{min-height:34px;padding-top:7px;padding-bottom:7px;margin-bottom:0}.form-control-static.input-lg,.form-control-static.input-sm{padding-right:0;padding-left:0}.input-sm{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-sm{height:30px;line-height:30px}select[multiple].input-sm,textarea.input-sm{height:auto}.form-group-sm .form-control{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.form-group-sm select.form-control{height:30px;line-height:30px}.form-group-sm select[multiple].form-control,.form-group-sm textarea.form-control{height:auto}.form-group-sm .form-control-static{height:30px;min-height:32px;padding:6px 10px;font-size:12px;line-height:1.5}.input-lg{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-lg{height:46px;line-height:46px}select[multiple].input-lg,textarea.input-lg{height:auto}.form-group-lg .form-control{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.form-group-lg select.form-control{height:46px;line-height:46px}.form-group-lg select[multiple].form-control,.form-group-lg textarea.form-control{height:auto}.form-group-lg .form-control-static{height:46px;min-height:38px;padding:11px 16px;font-size:18px;line-height:1.3333333}.has-feedback{position:relative}.has-feedback .form-control{padding-right:42.5px}.form-control-feedback{position:absolute;top:0;right:0;z-index:2;display:block;width:34px;height:34px;line-height:34px;text-align:center;pointer-events:none}.form-group-lg .form-control+.form-control-feedback,.input-group-lg+.form-control-feedback,.input-lg+.form-control-feedback{width:46px;height:46px;line-height:46px}.form-group-sm .form-control+.form-control-feedback,.input-group-sm+.form-control-feedback,.input-sm+.form-control-feedback{width:30px;height:30px;line-height:30px}.has-success .checkbox,.has-success .checkbox-inline,.has-success .control-label,.has-success .help-block,.has-success .radio,.has-success .radio-inline,.has-success.checkbox label,.has-success.checkbox-inline label,.has-success.radio label,.has-success.radio-inline label{color:#3c763d}.has-success .form-control{border-color:#3c763d;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-success .form-control:focus{border-color:#2b542c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #67b168}.has-success .input-group-addon{color:#3c763d;background-color:#dff0d8;border-color:#3c763d}.has-success .form-control-feedback{color:#3c763d}.has-warning .checkbox,.has-warning .checkbox-inline,.has-warning .control-label,.has-warning .help-block,.has-warning .radio,.has-warning .radio-inline,.has-warning.checkbox label,.has-warning.checkbox-inline label,.has-warning.radio label,.has-warning.radio-inline label{color:#8a6d3b}.has-warning .form-control{border-color:#8a6d3b;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-warning .form-control:focus{border-color:#66512c;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #c0a16b}.has-warning .input-group-addon{color:#8a6d3b;background-color:#fcf8e3;border-color:#8a6d3b}.has-warning .form-control-feedback{color:#8a6d3b}.has-error .checkbox,.has-error .checkbox-inline,.has-error .control-label,.has-error .help-block,.has-error .radio,.has-error .radio-inline,.has-error.checkbox label,.has-error.checkbox-inline label,.has-error.radio label,.has-error.radio-inline label{color:#a94442}.has-error .form-control{border-color:#a94442;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075);box-shadow:inset 0 1px 1px rgba(0,0,0,.075)}.has-error .form-control:focus{border-color:#843534;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483;box-shadow:inset 0 1px 1px rgba(0,0,0,.075),0 0 6px #ce8483}.has-error .input-group-addon{color:#a94442;background-color:#f2dede;border-color:#a94442}.has-error .form-control-feedback{color:#a94442}.has-feedback label~.form-control-feedback{top:25px}.has-feedback label.sr-only~.form-control-feedback{top:0}.help-block{display:block;margin-top:5px;margin-bottom:10px;color:#737373}@media (min-width:768px){.form-inline .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.form-inline .form-control{display:inline-block;width:auto;vertical-align:middle}.form-inline .form-control-static{display:inline-block}.form-inline .input-group{display:inline-table;vertical-align:middle}.form-inline .input-group .form-control,.form-inline .input-group .input-group-addon,.form-inline .input-group .input-group-btn{width:auto}.form-inline .input-group>.form-control{width:100%}.form-inline .control-label{margin-bottom:0;vertical-align:middle}.form-inline .checkbox,.form-inline .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.form-inline .checkbox label,.form-inline .radio label{padding-left:0}.form-inline .checkbox input[type=checkbox],.form-inline .radio input[type=radio]{position:relative;margin-left:0}.form-inline .has-feedback .form-control-feedback{top:0}}.form-horizontal .checkbox,.form-horizontal .checkbox-inline,.form-horizontal .radio,.form-horizontal .radio-inline{padding-top:7px;margin-top:0;margin-bottom:0}.form-horizontal .checkbox,.form-horizontal .radio{min-height:27px}.form-horizontal .form-group{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.form-horizontal .control-label{padding-top:7px;margin-bottom:0;text-align:right}}.form-horizontal .has-feedback .form-control-feedback{right:15px}@media (min-width:768px){.form-horizontal .form-group-lg .control-label{padding-top:11px;font-size:18px}}@media (min-width:768px){.form-horizontal .form-group-sm .control-label{padding-top:6px;font-size:12px}}.btn{display:inline-block;padding:6px 12px;margin-bottom:0;font-size:14px;font-weight:400;line-height:1.42857143;text-align:center;white-space:nowrap;vertical-align:middle;-ms-touch-action:manipulation;touch-action:manipulation;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;background-image:none;border:1px solid transparent;border-radius:4px}.btn.active.focus,.btn.active:focus,.btn.focus,.btn:active.focus,.btn:active:focus,.btn:focus{outline:thin dotted;outline:5px auto -webkit-focus-ring-color;outline-offset:-2px}.btn.focus,.btn:focus,.btn:hover{color:#333;text-decoration:none}.btn.active,.btn:active{background-image:none;outline:0;-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn.disabled,.btn[disabled],fieldset[disabled] .btn{cursor:not-allowed;filter:alpha(opacity=65);-webkit-box-shadow:none;box-shadow:none;opacity:.65}a.btn.disabled,fieldset[disabled] a.btn{pointer-events:none}.btn-default{color:#333;background-color:#fff;border-color:#ccc}.btn-default.focus,.btn-default:focus{color:#333;background-color:#e6e6e6;border-color:#8c8c8c}.btn-default:hover{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{color:#333;background-color:#e6e6e6;border-color:#adadad}.btn-default.active.focus,.btn-default.active:focus,.btn-default.active:hover,.btn-default:active.focus,.btn-default:active:focus,.btn-default:active:hover,.open>.dropdown-toggle.btn-default.focus,.open>.dropdown-toggle.btn-default:focus,.open>.dropdown-toggle.btn-default:hover{color:#333;background-color:#d4d4d4;border-color:#8c8c8c}.btn-default.active,.btn-default:active,.open>.dropdown-toggle.btn-default{background-image:none}.btn-default.disabled.focus,.btn-default.disabled:focus,.btn-default.disabled:hover,.btn-default[disabled].focus,.btn-default[disabled]:focus,.btn-default[disabled]:hover,fieldset[disabled] .btn-default.focus,fieldset[disabled] .btn-default:focus,fieldset[disabled] .btn-default:hover{background-color:#fff;border-color:#ccc}.btn-default .badge{color:#fff;background-color:#333}.btn-primary{color:#fff;background-color:#337ab7;border-color:#2e6da4}.btn-primary.focus,.btn-primary:focus{color:#fff;background-color:#286090;border-color:#122b40}.btn-primary:hover{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{color:#fff;background-color:#286090;border-color:#204d74}.btn-primary.active.focus,.btn-primary.active:focus,.btn-primary.active:hover,.btn-primary:active.focus,.btn-primary:active:focus,.btn-primary:active:hover,.open>.dropdown-toggle.btn-primary.focus,.open>.dropdown-toggle.btn-primary:focus,.open>.dropdown-toggle.btn-primary:hover{color:#fff;background-color:#204d74;border-color:#122b40}.btn-primary.active,.btn-primary:active,.open>.dropdown-toggle.btn-primary{background-image:none}.btn-primary.disabled.focus,.btn-primary.disabled:focus,.btn-primary.disabled:hover,.btn-primary[disabled].focus,.btn-primary[disabled]:focus,.btn-primary[disabled]:hover,fieldset[disabled] .btn-primary.focus,fieldset[disabled] .btn-primary:focus,fieldset[disabled] .btn-primary:hover{background-color:#337ab7;border-color:#2e6da4}.btn-primary .badge{color:#337ab7;background-color:#fff}.btn-success{color:#fff;background-color:#5cb85c;border-color:#4cae4c}.btn-success.focus,.btn-success:focus{color:#fff;background-color:#449d44;border-color:#255625}.btn-success:hover{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{color:#fff;background-color:#449d44;border-color:#398439}.btn-success.active.focus,.btn-success.active:focus,.btn-success.active:hover,.btn-success:active.focus,.btn-success:active:focus,.btn-success:active:hover,.open>.dropdown-toggle.btn-success.focus,.open>.dropdown-toggle.btn-success:focus,.open>.dropdown-toggle.btn-success:hover{color:#fff;background-color:#398439;border-color:#255625}.btn-success.active,.btn-success:active,.open>.dropdown-toggle.btn-success{background-image:none}.btn-success.disabled.focus,.btn-success.disabled:focus,.btn-success.disabled:hover,.btn-success[disabled].focus,.btn-success[disabled]:focus,.btn-success[disabled]:hover,fieldset[disabled] .btn-success.focus,fieldset[disabled] .btn-success:focus,fieldset[disabled] .btn-success:hover{background-color:#5cb85c;border-color:#4cae4c}.btn-success .badge{color:#5cb85c;background-color:#fff}.btn-info{color:#fff;background-color:#5bc0de;border-color:#46b8da}.btn-info.focus,.btn-info:focus{color:#fff;background-color:#31b0d5;border-color:#1b6d85}.btn-info:hover{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{color:#fff;background-color:#31b0d5;border-color:#269abc}.btn-info.active.focus,.btn-info.active:focus,.btn-info.active:hover,.btn-info:active.focus,.btn-info:active:focus,.btn-info:active:hover,.open>.dropdown-toggle.btn-info.focus,.open>.dropdown-toggle.btn-info:focus,.open>.dropdown-toggle.btn-info:hover{color:#fff;background-color:#269abc;border-color:#1b6d85}.btn-info.active,.btn-info:active,.open>.dropdown-toggle.btn-info{background-image:none}.btn-info.disabled.focus,.btn-info.disabled:focus,.btn-info.disabled:hover,.btn-info[disabled].focus,.btn-info[disabled]:focus,.btn-info[disabled]:hover,fieldset[disabled] .btn-info.focus,fieldset[disabled] .btn-info:focus,fieldset[disabled] .btn-info:hover{background-color:#5bc0de;border-color:#46b8da}.btn-info .badge{color:#5bc0de;background-color:#fff}.btn-warning{color:#fff;background-color:#f0ad4e;border-color:#eea236}.btn-warning.focus,.btn-warning:focus{color:#fff;background-color:#ec971f;border-color:#985f0d}.btn-warning:hover{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{color:#fff;background-color:#ec971f;border-color:#d58512}.btn-warning.active.focus,.btn-warning.active:focus,.btn-warning.active:hover,.btn-warning:active.focus,.btn-warning:active:focus,.btn-warning:active:hover,.open>.dropdown-toggle.btn-warning.focus,.open>.dropdown-toggle.btn-warning:focus,.open>.dropdown-toggle.btn-warning:hover{color:#fff;background-color:#d58512;border-color:#985f0d}.btn-warning.active,.btn-warning:active,.open>.dropdown-toggle.btn-warning{background-image:none}.btn-warning.disabled.focus,.btn-warning.disabled:focus,.btn-warning.disabled:hover,.btn-warning[disabled].focus,.btn-warning[disabled]:focus,.btn-warning[disabled]:hover,fieldset[disabled] .btn-warning.focus,fieldset[disabled] .btn-warning:focus,fieldset[disabled] .btn-warning:hover{background-color:#f0ad4e;border-color:#eea236}.btn-warning .badge{color:#f0ad4e;background-color:#fff}.btn-danger{color:#fff;background-color:#d9534f;border-color:#d43f3a}.btn-danger.focus,.btn-danger:focus{color:#fff;background-color:#c9302c;border-color:#761c19}.btn-danger:hover{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{color:#fff;background-color:#c9302c;border-color:#ac2925}.btn-danger.active.focus,.btn-danger.active:focus,.btn-danger.active:hover,.btn-danger:active.focus,.btn-danger:active:focus,.btn-danger:active:hover,.open>.dropdown-toggle.btn-danger.focus,.open>.dropdown-toggle.btn-danger:focus,.open>.dropdown-toggle.btn-danger:hover{color:#fff;background-color:#ac2925;border-color:#761c19}.btn-danger.active,.btn-danger:active,.open>.dropdown-toggle.btn-danger{background-image:none}.btn-danger.disabled.focus,.btn-danger.disabled:focus,.btn-danger.disabled:hover,.btn-danger[disabled].focus,.btn-danger[disabled]:focus,.btn-danger[disabled]:hover,fieldset[disabled] .btn-danger.focus,fieldset[disabled] .btn-danger:focus,fieldset[disabled] .btn-danger:hover{background-color:#d9534f;border-color:#d43f3a}.btn-danger .badge{color:#d9534f;background-color:#fff}.btn-link{font-weight:400;color:#337ab7;border-radius:0}.btn-link,.btn-link.active,.btn-link:active,.btn-link[disabled],fieldset[disabled] .btn-link{background-color:transparent;-webkit-box-shadow:none;box-shadow:none}.btn-link,.btn-link:active,.btn-link:focus,.btn-link:hover{border-color:transparent}.btn-link:focus,.btn-link:hover{color:#23527c;text-decoration:underline;background-color:transparent}.btn-link[disabled]:focus,.btn-link[disabled]:hover,fieldset[disabled] .btn-link:focus,fieldset[disabled] .btn-link:hover{color:#777;text-decoration:none}.btn-group-lg>.btn,.btn-lg{padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}.btn-group-sm>.btn,.btn-sm{padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}.btn-group-xs>.btn,.btn-xs{padding:1px 5px;font-size:12px;line-height:1.5;border-radius:3px}.btn-block{display:block;width:100%}.btn-block+.btn-block{margin-top:5px}input[type=button].btn-block,input[type=reset].btn-block,input[type=submit].btn-block{width:100%}.fade{opacity:0;-webkit-transition:opacity .15s linear;-o-transition:opacity .15s linear;transition:opacity .15s linear}.fade.in{opacity:1}.collapse{display:none}.collapse.in{display:block}tr.collapse.in{display:table-row}tbody.collapse.in{display:table-row-group}.collapsing{position:relative;height:0;overflow:hidden;-webkit-transition-timing-function:ease;-o-transition-timing-function:ease;transition-timing-function:ease;-webkit-transition-duration:.35s;-o-transition-duration:.35s;transition-duration:.35s;-webkit-transition-property:height,visibility;-o-transition-property:height,visibility;transition-property:height,visibility}.caret{display:inline-block;width:0;height:0;margin-left:2px;vertical-align:middle;border-top:4px dashed;border-top:4px solid\\9;border-right:4px solid transparent;border-left:4px solid transparent}.dropdown,.dropup{position:relative}.dropdown-toggle:focus{outline:0}.dropdown-menu{position:absolute;top:100%;left:0;z-index:1000;display:none;float:left;min-width:160px;padding:5px 0;margin:2px 0 0;font-size:14px;text-align:left;list-style:none;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.15);border-radius:4px;-webkit-box-shadow:0 6px 12px rgba(0,0,0,.175);box-shadow:0 6px 12px rgba(0,0,0,.175)}.dropdown-menu.pull-right{right:0;left:auto}.dropdown-menu .divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.dropdown-menu>li>a{display:block;padding:3px 20px;clear:both;font-weight:400;line-height:1.42857143;color:#333;white-space:nowrap}.dropdown-menu>li>a:focus,.dropdown-menu>li>a:hover{color:#262626;text-decoration:none;background-color:#f5f5f5}.dropdown-menu>.active>a,.dropdown-menu>.active>a:focus,.dropdown-menu>.active>a:hover{color:#fff;text-decoration:none;background-color:#337ab7;outline:0}.dropdown-menu>.disabled>a,.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{color:#777}.dropdown-menu>.disabled>a:focus,.dropdown-menu>.disabled>a:hover{text-decoration:none;cursor:not-allowed;background-color:transparent;background-image:none;filter:progid:DXImageTransform.Microsoft.gradient(enabled=false)}.open>.dropdown-menu{display:block}.open>a{outline:0}.dropdown-menu-right{right:0;left:auto}.dropdown-menu-left{right:auto;left:0}.dropdown-header{display:block;padding:3px 20px;font-size:12px;line-height:1.42857143;color:#777;white-space:nowrap}.dropdown-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:990}.pull-right>.dropdown-menu{right:0;left:auto}.dropup .caret,.navbar-fixed-bottom .dropdown .caret{content:\"\";border-top:0;border-bottom:4px dashed;border-bottom:4px solid\\9}.dropup .dropdown-menu,.navbar-fixed-bottom .dropdown .dropdown-menu{top:auto;bottom:100%;margin-bottom:2px}@media (min-width:768px){.navbar-right .dropdown-menu{right:0;left:auto}.navbar-right .dropdown-menu-left{right:auto;left:0}}.btn-group,.btn-group-vertical{position:relative;display:inline-block;vertical-align:middle}.btn-group-vertical>.btn,.btn-group>.btn{position:relative;float:left}.btn-group-vertical>.btn.active,.btn-group-vertical>.btn:active,.btn-group-vertical>.btn:focus,.btn-group-vertical>.btn:hover,.btn-group>.btn.active,.btn-group>.btn:active,.btn-group>.btn:focus,.btn-group>.btn:hover{z-index:2}.btn-group .btn+.btn,.btn-group .btn+.btn-group,.btn-group .btn-group+.btn,.btn-group .btn-group+.btn-group{margin-left:-1px}.btn-toolbar{margin-left:-5px}.btn-toolbar .btn,.btn-toolbar .btn-group,.btn-toolbar .input-group{float:left}.btn-toolbar>.btn,.btn-toolbar>.btn-group,.btn-toolbar>.input-group{margin-left:5px}.btn-group>.btn:not(:first-child):not(:last-child):not(.dropdown-toggle){border-radius:0}.btn-group>.btn:first-child{margin-left:0}.btn-group>.btn:first-child:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn:last-child:not(:first-child),.btn-group>.dropdown-toggle:not(:first-child){border-top-left-radius:0;border-bottom-left-radius:0}.btn-group>.btn-group{float:left}.btn-group>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-top-right-radius:0;border-bottom-right-radius:0}.btn-group>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-bottom-left-radius:0}.btn-group .dropdown-toggle:active,.btn-group.open .dropdown-toggle{outline:0}.btn-group>.btn+.dropdown-toggle{padding-right:8px;padding-left:8px}.btn-group>.btn-lg+.dropdown-toggle{padding-right:12px;padding-left:12px}.btn-group.open .dropdown-toggle{-webkit-box-shadow:inset 0 3px 5px rgba(0,0,0,.125);box-shadow:inset 0 3px 5px rgba(0,0,0,.125)}.btn-group.open .dropdown-toggle.btn-link{-webkit-box-shadow:none;box-shadow:none}.btn .caret{margin-left:0}.btn-lg .caret{border-width:5px 5px 0;border-bottom-width:0}.dropup .btn-lg .caret{border-width:0 5px 5px}.btn-group-vertical>.btn,.btn-group-vertical>.btn-group,.btn-group-vertical>.btn-group>.btn{display:block;float:none;width:100%;max-width:100%}.btn-group-vertical>.btn-group>.btn{float:none}.btn-group-vertical>.btn+.btn,.btn-group-vertical>.btn+.btn-group,.btn-group-vertical>.btn-group+.btn,.btn-group-vertical>.btn-group+.btn-group{margin-top:-1px;margin-left:0}.btn-group-vertical>.btn:not(:first-child):not(:last-child){border-radius:0}.btn-group-vertical>.btn:first-child:not(:last-child){border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn:last-child:not(:first-child){border-top-left-radius:0;border-top-right-radius:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}.btn-group-vertical>.btn-group:not(:first-child):not(:last-child)>.btn{border-radius:0}.btn-group-vertical>.btn-group:first-child:not(:last-child)>.btn:last-child,.btn-group-vertical>.btn-group:first-child:not(:last-child)>.dropdown-toggle{border-bottom-right-radius:0;border-bottom-left-radius:0}.btn-group-vertical>.btn-group:last-child:not(:first-child)>.btn:first-child{border-top-left-radius:0;border-top-right-radius:0}.btn-group-justified{display:table;width:100%;table-layout:fixed;border-collapse:separate}.btn-group-justified>.btn,.btn-group-justified>.btn-group{display:table-cell;float:none;width:1%}.btn-group-justified>.btn-group .btn{width:100%}.btn-group-justified>.btn-group .dropdown-menu{left:auto}[data-toggle=buttons]>.btn input[type=checkbox],[data-toggle=buttons]>.btn input[type=radio],[data-toggle=buttons]>.btn-group>.btn input[type=checkbox],[data-toggle=buttons]>.btn-group>.btn input[type=radio]{position:absolute;clip:rect(0,0,0,0);pointer-events:none}.input-group{position:relative;display:table;border-collapse:separate}.input-group[class*=col-]{float:none;padding-right:0;padding-left:0}.input-group .form-control{position:relative;z-index:2;float:left;width:100%;margin-bottom:0}.input-group .form-control:focus{z-index:3}.input-group-lg>.form-control,.input-group-lg>.input-group-addon,.input-group-lg>.input-group-btn>.btn{height:46px;padding:10px 16px;font-size:18px;line-height:1.3333333;border-radius:6px}select.input-group-lg>.form-control,select.input-group-lg>.input-group-addon,select.input-group-lg>.input-group-btn>.btn{height:46px;line-height:46px}select[multiple].input-group-lg>.form-control,select[multiple].input-group-lg>.input-group-addon,select[multiple].input-group-lg>.input-group-btn>.btn,textarea.input-group-lg>.form-control,textarea.input-group-lg>.input-group-addon,textarea.input-group-lg>.input-group-btn>.btn{height:auto}.input-group-sm>.form-control,.input-group-sm>.input-group-addon,.input-group-sm>.input-group-btn>.btn{height:30px;padding:5px 10px;font-size:12px;line-height:1.5;border-radius:3px}select.input-group-sm>.form-control,select.input-group-sm>.input-group-addon,select.input-group-sm>.input-group-btn>.btn{height:30px;line-height:30px}select[multiple].input-group-sm>.form-control,select[multiple].input-group-sm>.input-group-addon,select[multiple].input-group-sm>.input-group-btn>.btn,textarea.input-group-sm>.form-control,textarea.input-group-sm>.input-group-addon,textarea.input-group-sm>.input-group-btn>.btn{height:auto}.input-group .form-control,.input-group-addon,.input-group-btn{display:table-cell}.input-group .form-control:not(:first-child):not(:last-child),.input-group-addon:not(:first-child):not(:last-child),.input-group-btn:not(:first-child):not(:last-child){border-radius:0}.input-group-addon,.input-group-btn{width:1%;white-space:nowrap;vertical-align:middle}.input-group-addon{padding:6px 12px;font-size:14px;font-weight:400;line-height:1;color:#555;text-align:center;background-color:#eee;border:1px solid #ccc;border-radius:4px}.input-group-addon.input-sm{padding:5px 10px;font-size:12px;border-radius:3px}.input-group-addon.input-lg{padding:10px 16px;font-size:18px;border-radius:6px}.input-group-addon input[type=checkbox],.input-group-addon input[type=radio]{margin-top:0}.input-group .form-control:first-child,.input-group-addon:first-child,.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group>.btn,.input-group-btn:first-child>.dropdown-toggle,.input-group-btn:last-child>.btn-group:not(:last-child)>.btn,.input-group-btn:last-child>.btn:not(:last-child):not(.dropdown-toggle){border-top-right-radius:0;border-bottom-right-radius:0}.input-group-addon:first-child{border-right:0}.input-group .form-control:last-child,.input-group-addon:last-child,.input-group-btn:first-child>.btn-group:not(:first-child)>.btn,.input-group-btn:first-child>.btn:not(:first-child),.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group>.btn,.input-group-btn:last-child>.dropdown-toggle{border-top-left-radius:0;border-bottom-left-radius:0}.input-group-addon:last-child{border-left:0}.input-group-btn{position:relative;font-size:0;white-space:nowrap}.input-group-btn>.btn{position:relative}.input-group-btn>.btn+.btn{margin-left:-1px}.input-group-btn>.btn:active,.input-group-btn>.btn:focus,.input-group-btn>.btn:hover{z-index:2}.input-group-btn:first-child>.btn,.input-group-btn:first-child>.btn-group{margin-right:-1px}.input-group-btn:last-child>.btn,.input-group-btn:last-child>.btn-group{z-index:2;margin-left:-1px}.nav{padding-left:0;margin-bottom:0;list-style:none}.nav>li{position:relative;display:block}.nav>li>a{position:relative;display:block;padding:10px 15px}.nav>li>a:focus,.nav>li>a:hover{text-decoration:none;background-color:#eee}.nav>li.disabled>a{color:#777}.nav>li.disabled>a:focus,.nav>li.disabled>a:hover{color:#777;text-decoration:none;cursor:not-allowed;background-color:transparent}.nav .open>a,.nav .open>a:focus,.nav .open>a:hover{background-color:#eee;border-color:#337ab7}.nav .nav-divider{height:1px;margin:9px 0;overflow:hidden;background-color:#e5e5e5}.nav>li>a>img{max-width:none}.nav-tabs{border-bottom:1px solid #ddd}.nav-tabs>li{float:left;margin-bottom:-1px}.nav-tabs>li>a{margin-right:2px;line-height:1.42857143;border:1px solid transparent;border-radius:4px 4px 0 0}.nav-tabs>li>a:hover{border-color:#eee #eee #ddd}.nav-tabs>li.active>a,.nav-tabs>li.active>a:focus,.nav-tabs>li.active>a:hover{color:#555;cursor:default;background-color:#fff;border:1px solid #ddd;border-bottom-color:transparent}.nav-tabs.nav-justified{width:100%;border-bottom:0}.nav-tabs.nav-justified>li{float:none}.nav-tabs.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-tabs.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-tabs.nav-justified>li{display:table-cell;width:1%}.nav-tabs.nav-justified>li>a{margin-bottom:0}}.nav-tabs.nav-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs.nav-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs.nav-justified>.active>a,.nav-tabs.nav-justified>.active>a:focus,.nav-tabs.nav-justified>.active>a:hover{border-bottom-color:#fff}}.nav-pills>li{float:left}.nav-pills>li>a{border-radius:4px}.nav-pills>li+li{margin-left:2px}.nav-pills>li.active>a,.nav-pills>li.active>a:focus,.nav-pills>li.active>a:hover{color:#fff;background-color:#337ab7}.nav-stacked>li{float:none}.nav-stacked>li+li{margin-top:2px;margin-left:0}.nav-justified{width:100%}.nav-justified>li{float:none}.nav-justified>li>a{margin-bottom:5px;text-align:center}.nav-justified>.dropdown .dropdown-menu{top:auto;left:auto}@media (min-width:768px){.nav-justified>li{display:table-cell;width:1%}.nav-justified>li>a{margin-bottom:0}}.nav-tabs-justified{border-bottom:0}.nav-tabs-justified>li>a{margin-right:0;border-radius:4px}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border:1px solid #ddd}@media (min-width:768px){.nav-tabs-justified>li>a{border-bottom:1px solid #ddd;border-radius:4px 4px 0 0}.nav-tabs-justified>.active>a,.nav-tabs-justified>.active>a:focus,.nav-tabs-justified>.active>a:hover{border-bottom-color:#fff}}.tab-content>.tab-pane{display:none}.tab-content>.active{display:block}.nav-tabs .dropdown-menu{margin-top:-1px;border-top-left-radius:0;border-top-right-radius:0}.navbar{position:relative;min-height:50px;margin-bottom:20px;border:1px solid transparent}@media (min-width:768px){.navbar{border-radius:4px}}@media (min-width:768px){.navbar-header{float:left}}.navbar-collapse{padding-right:15px;padding-left:15px;overflow-x:visible;-webkit-overflow-scrolling:touch;border-top:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1)}.navbar-collapse.in{overflow-y:auto}@media (min-width:768px){.navbar-collapse{width:auto;border-top:0;-webkit-box-shadow:none;box-shadow:none}.navbar-collapse.collapse{display:block!important;height:auto!important;padding-bottom:0;overflow:visible!important}.navbar-collapse.in{overflow-y:visible}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse,.navbar-static-top .navbar-collapse{padding-right:0;padding-left:0}}.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:340px}@media (max-device-width:480px) and (orientation:landscape){.navbar-fixed-bottom .navbar-collapse,.navbar-fixed-top .navbar-collapse{max-height:200px}}.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:-15px;margin-left:-15px}@media (min-width:768px){.container-fluid>.navbar-collapse,.container-fluid>.navbar-header,.container>.navbar-collapse,.container>.navbar-header{margin-right:0;margin-left:0}}.navbar-static-top{z-index:1000;border-width:0 0 1px}@media (min-width:768px){.navbar-static-top{border-radius:0}}.navbar-fixed-bottom,.navbar-fixed-top{position:fixed;right:0;left:0;z-index:1030}@media (min-width:768px){.navbar-fixed-bottom,.navbar-fixed-top{border-radius:0}}.navbar-fixed-top{top:0;border-width:0 0 1px}.navbar-fixed-bottom{bottom:0;margin-bottom:0;border-width:1px 0 0}.navbar-brand{float:left;height:50px;padding:15px 15px;font-size:18px;line-height:20px}.navbar-brand:focus,.navbar-brand:hover{text-decoration:none}.navbar-brand>img{display:block}@media (min-width:768px){.navbar>.container .navbar-brand,.navbar>.container-fluid .navbar-brand{margin-left:-15px}}.navbar-toggle{position:relative;float:right;padding:9px 10px;margin-top:8px;margin-right:15px;margin-bottom:8px;background-color:transparent;background-image:none;border:1px solid transparent;border-radius:4px}.navbar-toggle:focus{outline:0}.navbar-toggle .icon-bar{display:block;width:22px;height:2px;border-radius:1px}.navbar-toggle .icon-bar+.icon-bar{margin-top:4px}@media (min-width:768px){.navbar-toggle{display:none}}.navbar-nav{margin:7.5px -15px}.navbar-nav>li>a{padding-top:10px;padding-bottom:10px;line-height:20px}@media (max-width:767px){.navbar-nav .open .dropdown-menu{position:static;float:none;width:auto;margin-top:0;background-color:transparent;border:0;-webkit-box-shadow:none;box-shadow:none}.navbar-nav .open .dropdown-menu .dropdown-header,.navbar-nav .open .dropdown-menu>li>a{padding:5px 15px 5px 25px}.navbar-nav .open .dropdown-menu>li>a{line-height:20px}.navbar-nav .open .dropdown-menu>li>a:focus,.navbar-nav .open .dropdown-menu>li>a:hover{background-image:none}}@media (min-width:768px){.navbar-nav{float:left;margin:0}.navbar-nav>li{float:left}.navbar-nav>li>a{padding-top:15px;padding-bottom:15px}}.navbar-form{padding:10px 15px;margin-top:8px;margin-right:-15px;margin-bottom:8px;margin-left:-15px;border-top:1px solid transparent;border-bottom:1px solid transparent;-webkit-box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1);box-shadow:inset 0 1px 0 rgba(255,255,255,.1),0 1px 0 rgba(255,255,255,.1)}@media (min-width:768px){.navbar-form .form-group{display:inline-block;margin-bottom:0;vertical-align:middle}.navbar-form .form-control{display:inline-block;width:auto;vertical-align:middle}.navbar-form .form-control-static{display:inline-block}.navbar-form .input-group{display:inline-table;vertical-align:middle}.navbar-form .input-group .form-control,.navbar-form .input-group .input-group-addon,.navbar-form .input-group .input-group-btn{width:auto}.navbar-form .input-group>.form-control{width:100%}.navbar-form .control-label{margin-bottom:0;vertical-align:middle}.navbar-form .checkbox,.navbar-form .radio{display:inline-block;margin-top:0;margin-bottom:0;vertical-align:middle}.navbar-form .checkbox label,.navbar-form .radio label{padding-left:0}.navbar-form .checkbox input[type=checkbox],.navbar-form .radio input[type=radio]{position:relative;margin-left:0}.navbar-form .has-feedback .form-control-feedback{top:0}}@media (max-width:767px){.navbar-form .form-group{margin-bottom:5px}.navbar-form .form-group:last-child{margin-bottom:0}}@media (min-width:768px){.navbar-form{width:auto;padding-top:0;padding-bottom:0;margin-right:0;margin-left:0;border:0;-webkit-box-shadow:none;box-shadow:none}}.navbar-nav>li>.dropdown-menu{margin-top:0;border-top-left-radius:0;border-top-right-radius:0}.navbar-fixed-bottom .navbar-nav>li>.dropdown-menu{margin-bottom:0;border-top-left-radius:4px;border-top-right-radius:4px;border-bottom-right-radius:0;border-bottom-left-radius:0}.navbar-btn{margin-top:8px;margin-bottom:8px}.navbar-btn.btn-sm{margin-top:10px;margin-bottom:10px}.navbar-btn.btn-xs{margin-top:14px;margin-bottom:14px}.navbar-text{margin-top:15px;margin-bottom:15px}@media (min-width:768px){.navbar-text{float:left;margin-right:15px;margin-left:15px}}@media (min-width:768px){.navbar-left{float:left!important}.navbar-right{float:right!important;margin-right:-15px}.navbar-right~.navbar-right{margin-right:0}}.navbar-default{background-color:#f8f8f8;border-color:#e7e7e7}.navbar-default .navbar-brand{color:#777}.navbar-default .navbar-brand:focus,.navbar-default .navbar-brand:hover{color:#5e5e5e;background-color:transparent}.navbar-default .navbar-text{color:#777}.navbar-default .navbar-nav>li>a{color:#777}.navbar-default .navbar-nav>li>a:focus,.navbar-default .navbar-nav>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav>.active>a,.navbar-default .navbar-nav>.active>a:focus,.navbar-default .navbar-nav>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav>.disabled>a,.navbar-default .navbar-nav>.disabled>a:focus,.navbar-default .navbar-nav>.disabled>a:hover{color:#ccc;background-color:transparent}.navbar-default .navbar-toggle{border-color:#ddd}.navbar-default .navbar-toggle:focus,.navbar-default .navbar-toggle:hover{background-color:#ddd}.navbar-default .navbar-toggle .icon-bar{background-color:#888}.navbar-default .navbar-collapse,.navbar-default .navbar-form{border-color:#e7e7e7}.navbar-default .navbar-nav>.open>a,.navbar-default .navbar-nav>.open>a:focus,.navbar-default .navbar-nav>.open>a:hover{color:#555;background-color:#e7e7e7}@media (max-width:767px){.navbar-default .navbar-nav .open .dropdown-menu>li>a{color:#777}.navbar-default .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>li>a:hover{color:#333;background-color:transparent}.navbar-default .navbar-nav .open .dropdown-menu>.active>a,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.active>a:hover{color:#555;background-color:#e7e7e7}.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-default .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#ccc;background-color:transparent}}.navbar-default .navbar-link{color:#777}.navbar-default .navbar-link:hover{color:#333}.navbar-default .btn-link{color:#777}.navbar-default .btn-link:focus,.navbar-default .btn-link:hover{color:#333}.navbar-default .btn-link[disabled]:focus,.navbar-default .btn-link[disabled]:hover,fieldset[disabled] .navbar-default .btn-link:focus,fieldset[disabled] .navbar-default .btn-link:hover{color:#ccc}.navbar-inverse{background-color:#222;border-color:#080808}.navbar-inverse .navbar-brand{color:#9d9d9d}.navbar-inverse .navbar-brand:focus,.navbar-inverse .navbar-brand:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-text{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav>li>a:focus,.navbar-inverse .navbar-nav>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav>.active>a,.navbar-inverse .navbar-nav>.active>a:focus,.navbar-inverse .navbar-nav>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav>.disabled>a,.navbar-inverse .navbar-nav>.disabled>a:focus,.navbar-inverse .navbar-nav>.disabled>a:hover{color:#444;background-color:transparent}.navbar-inverse .navbar-toggle{border-color:#333}.navbar-inverse .navbar-toggle:focus,.navbar-inverse .navbar-toggle:hover{background-color:#333}.navbar-inverse .navbar-toggle .icon-bar{background-color:#fff}.navbar-inverse .navbar-collapse,.navbar-inverse .navbar-form{border-color:#101010}.navbar-inverse .navbar-nav>.open>a,.navbar-inverse .navbar-nav>.open>a:focus,.navbar-inverse .navbar-nav>.open>a:hover{color:#fff;background-color:#080808}@media (max-width:767px){.navbar-inverse .navbar-nav .open .dropdown-menu>.dropdown-header{border-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu .divider{background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a{color:#9d9d9d}.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>li>a:hover{color:#fff;background-color:transparent}.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.active>a:hover{color:#fff;background-color:#080808}.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:focus,.navbar-inverse .navbar-nav .open .dropdown-menu>.disabled>a:hover{color:#444;background-color:transparent}}.navbar-inverse .navbar-link{color:#9d9d9d}.navbar-inverse .navbar-link:hover{color:#fff}.navbar-inverse .btn-link{color:#9d9d9d}.navbar-inverse .btn-link:focus,.navbar-inverse .btn-link:hover{color:#fff}.navbar-inverse .btn-link[disabled]:focus,.navbar-inverse .btn-link[disabled]:hover,fieldset[disabled] .navbar-inverse .btn-link:focus,fieldset[disabled] .navbar-inverse .btn-link:hover{color:#444}.breadcrumb{padding:8px 15px;margin-bottom:20px;list-style:none;background-color:#f5f5f5;border-radius:4px}.breadcrumb>li{display:inline-block}.breadcrumb>li+li:before{padding:0 5px;color:#ccc;content:\"/\\00a0\"}.breadcrumb>.active{color:#777}.pagination{display:inline-block;padding-left:0;margin:20px 0;border-radius:4px}.pagination>li{display:inline}.pagination>li>a,.pagination>li>span{position:relative;float:left;padding:6px 12px;margin-left:-1px;line-height:1.42857143;color:#337ab7;text-decoration:none;background-color:#fff;border:1px solid #ddd}.pagination>li:first-child>a,.pagination>li:first-child>span{margin-left:0;border-top-left-radius:4px;border-bottom-left-radius:4px}.pagination>li:last-child>a,.pagination>li:last-child>span{border-top-right-radius:4px;border-bottom-right-radius:4px}.pagination>li>a:focus,.pagination>li>a:hover,.pagination>li>span:focus,.pagination>li>span:hover{z-index:2;color:#23527c;background-color:#eee;border-color:#ddd}.pagination>.active>a,.pagination>.active>a:focus,.pagination>.active>a:hover,.pagination>.active>span,.pagination>.active>span:focus,.pagination>.active>span:hover{z-index:3;color:#fff;cursor:default;background-color:#337ab7;border-color:#337ab7}.pagination>.disabled>a,.pagination>.disabled>a:focus,.pagination>.disabled>a:hover,.pagination>.disabled>span,.pagination>.disabled>span:focus,.pagination>.disabled>span:hover{color:#777;cursor:not-allowed;background-color:#fff;border-color:#ddd}.pagination-lg>li>a,.pagination-lg>li>span{padding:10px 16px;font-size:18px;line-height:1.3333333}.pagination-lg>li:first-child>a,.pagination-lg>li:first-child>span{border-top-left-radius:6px;border-bottom-left-radius:6px}.pagination-lg>li:last-child>a,.pagination-lg>li:last-child>span{border-top-right-radius:6px;border-bottom-right-radius:6px}.pagination-sm>li>a,.pagination-sm>li>span{padding:5px 10px;font-size:12px;line-height:1.5}.pagination-sm>li:first-child>a,.pagination-sm>li:first-child>span{border-top-left-radius:3px;border-bottom-left-radius:3px}.pagination-sm>li:last-child>a,.pagination-sm>li:last-child>span{border-top-right-radius:3px;border-bottom-right-radius:3px}.pager{padding-left:0;margin:20px 0;text-align:center;list-style:none}.pager li{display:inline}.pager li>a,.pager li>span{display:inline-block;padding:5px 14px;background-color:#fff;border:1px solid #ddd;border-radius:15px}.pager li>a:focus,.pager li>a:hover{text-decoration:none;background-color:#eee}.pager .next>a,.pager .next>span{float:right}.pager .previous>a,.pager .previous>span{float:left}.pager .disabled>a,.pager .disabled>a:focus,.pager .disabled>a:hover,.pager .disabled>span{color:#777;cursor:not-allowed;background-color:#fff}.label{display:inline;padding:.2em .6em .3em;font-size:75%;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:.25em}a.label:focus,a.label:hover{color:#fff;text-decoration:none;cursor:pointer}.label:empty{display:none}.btn .label{position:relative;top:-1px}.label-default{background-color:#777}.label-default[href]:focus,.label-default[href]:hover{background-color:#5e5e5e}.label-primary{background-color:#337ab7}.label-primary[href]:focus,.label-primary[href]:hover{background-color:#286090}.label-success{background-color:#5cb85c}.label-success[href]:focus,.label-success[href]:hover{background-color:#449d44}.label-info{background-color:#5bc0de}.label-info[href]:focus,.label-info[href]:hover{background-color:#31b0d5}.label-warning{background-color:#f0ad4e}.label-warning[href]:focus,.label-warning[href]:hover{background-color:#ec971f}.label-danger{background-color:#d9534f}.label-danger[href]:focus,.label-danger[href]:hover{background-color:#c9302c}.badge{display:inline-block;min-width:10px;padding:3px 7px;font-size:12px;font-weight:700;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:middle;background-color:#777;border-radius:10px}.badge:empty{display:none}.btn .badge{position:relative;top:-1px}.btn-group-xs>.btn .badge,.btn-xs .badge{top:0;padding:1px 5px}a.badge:focus,a.badge:hover{color:#fff;text-decoration:none;cursor:pointer}.list-group-item.active>.badge,.nav-pills>.active>a>.badge{color:#337ab7;background-color:#fff}.list-group-item>.badge{float:right}.list-group-item>.badge+.badge{margin-right:5px}.nav-pills>li>a>.badge{margin-left:3px}.jumbotron{padding-top:30px;padding-bottom:30px;margin-bottom:30px;color:inherit;background-color:#eee}.jumbotron .h1,.jumbotron h1{color:inherit}.jumbotron p{margin-bottom:15px;font-size:21px;font-weight:200}.jumbotron>hr{border-top-color:#d5d5d5}.container .jumbotron,.container-fluid .jumbotron{padding-right:15px;padding-left:15px;border-radius:6px}.jumbotron .container{max-width:100%}@media screen and (min-width:768px){.jumbotron{padding-top:48px;padding-bottom:48px}.container .jumbotron,.container-fluid .jumbotron{padding-right:60px;padding-left:60px}.jumbotron .h1,.jumbotron h1{font-size:63px}}.thumbnail{display:block;padding:4px;margin-bottom:20px;line-height:1.42857143;background-color:#fff;border:1px solid #ddd;border-radius:4px;-webkit-transition:border .2s ease-in-out;-o-transition:border .2s ease-in-out;transition:border .2s ease-in-out}.thumbnail a>img,.thumbnail>img{margin-right:auto;margin-left:auto}a.thumbnail.active,a.thumbnail:focus,a.thumbnail:hover{border-color:#337ab7}.thumbnail .caption{padding:9px;color:#333}.alert{padding:15px;margin-bottom:20px;border:1px solid transparent;border-radius:4px}.alert h4{margin-top:0;color:inherit}.alert .alert-link{font-weight:700}.alert>p,.alert>ul{margin-bottom:0}.alert>p+p{margin-top:5px}.alert-dismissable,.alert-dismissible{padding-right:35px}.alert-dismissable .close,.alert-dismissible .close{position:relative;top:-2px;right:-21px;color:inherit}.alert-success{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.alert-success hr{border-top-color:#c9e2b3}.alert-success .alert-link{color:#2b542c}.alert-info{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.alert-info hr{border-top-color:#a6e1ec}.alert-info .alert-link{color:#245269}.alert-warning{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.alert-warning hr{border-top-color:#f7e1b5}.alert-warning .alert-link{color:#66512c}.alert-danger{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.alert-danger hr{border-top-color:#e4b9c0}.alert-danger .alert-link{color:#843534}@-webkit-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@-o-keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}@keyframes progress-bar-stripes{from{background-position:40px 0}to{background-position:0 0}}.progress{height:20px;margin-bottom:20px;overflow:hidden;background-color:#f5f5f5;border-radius:4px;-webkit-box-shadow:inset 0 1px 2px rgba(0,0,0,.1);box-shadow:inset 0 1px 2px rgba(0,0,0,.1)}.progress-bar{float:left;width:0;height:100%;font-size:12px;line-height:20px;color:#fff;text-align:center;background-color:#337ab7;-webkit-box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);box-shadow:inset 0 -1px 0 rgba(0,0,0,.15);-webkit-transition:width .6s ease;-o-transition:width .6s ease;transition:width .6s ease}.progress-bar-striped,.progress-striped .progress-bar{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);-webkit-background-size:40px 40px;background-size:40px 40px}.progress-bar.active,.progress.active .progress-bar{-webkit-animation:progress-bar-stripes 2s linear infinite;-o-animation:progress-bar-stripes 2s linear infinite;animation:progress-bar-stripes 2s linear infinite}.progress-bar-success{background-color:#5cb85c}.progress-striped .progress-bar-success{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-info{background-color:#5bc0de}.progress-striped .progress-bar-info{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-warning{background-color:#f0ad4e}.progress-striped .progress-bar-warning{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.progress-bar-danger{background-color:#d9534f}.progress-striped .progress-bar-danger{background-image:-webkit-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:-o-linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent);background-image:linear-gradient(45deg,rgba(255,255,255,.15) 25%,transparent 25%,transparent 50%,rgba(255,255,255,.15) 50%,rgba(255,255,255,.15) 75%,transparent 75%,transparent)}.media{margin-top:15px}.media:first-child{margin-top:0}.media,.media-body{overflow:hidden;zoom:1}.media-body{width:10000px}.media-object{display:block}.media-object.img-thumbnail{max-width:none}.media-right,.media>.pull-right{padding-left:10px}.media-left,.media>.pull-left{padding-right:10px}.media-body,.media-left,.media-right{display:table-cell;vertical-align:top}.media-middle{vertical-align:middle}.media-bottom{vertical-align:bottom}.media-heading{margin-top:0;margin-bottom:5px}.media-list{padding-left:0;list-style:none}.list-group{padding-left:0;margin-bottom:20px}.list-group-item{position:relative;display:block;padding:10px 15px;margin-bottom:-1px;background-color:#fff;border:1px solid #ddd}.list-group-item:first-child{border-top-left-radius:4px;border-top-right-radius:4px}.list-group-item:last-child{margin-bottom:0;border-bottom-right-radius:4px;border-bottom-left-radius:4px}a.list-group-item,button.list-group-item{color:#555}a.list-group-item .list-group-item-heading,button.list-group-item .list-group-item-heading{color:#333}a.list-group-item:focus,a.list-group-item:hover,button.list-group-item:focus,button.list-group-item:hover{color:#555;text-decoration:none;background-color:#f5f5f5}button.list-group-item{width:100%;text-align:left}.list-group-item.disabled,.list-group-item.disabled:focus,.list-group-item.disabled:hover{color:#777;cursor:not-allowed;background-color:#eee}.list-group-item.disabled .list-group-item-heading,.list-group-item.disabled:focus .list-group-item-heading,.list-group-item.disabled:hover .list-group-item-heading{color:inherit}.list-group-item.disabled .list-group-item-text,.list-group-item.disabled:focus .list-group-item-text,.list-group-item.disabled:hover .list-group-item-text{color:#777}.list-group-item.active,.list-group-item.active:focus,.list-group-item.active:hover{z-index:2;color:#fff;background-color:#337ab7;border-color:#337ab7}.list-group-item.active .list-group-item-heading,.list-group-item.active .list-group-item-heading>.small,.list-group-item.active .list-group-item-heading>small,.list-group-item.active:focus .list-group-item-heading,.list-group-item.active:focus .list-group-item-heading>.small,.list-group-item.active:focus .list-group-item-heading>small,.list-group-item.active:hover .list-group-item-heading,.list-group-item.active:hover .list-group-item-heading>.small,.list-group-item.active:hover .list-group-item-heading>small{color:inherit}.list-group-item.active .list-group-item-text,.list-group-item.active:focus .list-group-item-text,.list-group-item.active:hover .list-group-item-text{color:#c7ddef}.list-group-item-success{color:#3c763d;background-color:#dff0d8}a.list-group-item-success,button.list-group-item-success{color:#3c763d}a.list-group-item-success .list-group-item-heading,button.list-group-item-success .list-group-item-heading{color:inherit}a.list-group-item-success:focus,a.list-group-item-success:hover,button.list-group-item-success:focus,button.list-group-item-success:hover{color:#3c763d;background-color:#d0e9c6}a.list-group-item-success.active,a.list-group-item-success.active:focus,a.list-group-item-success.active:hover,button.list-group-item-success.active,button.list-group-item-success.active:focus,button.list-group-item-success.active:hover{color:#fff;background-color:#3c763d;border-color:#3c763d}.list-group-item-info{color:#31708f;background-color:#d9edf7}a.list-group-item-info,button.list-group-item-info{color:#31708f}a.list-group-item-info .list-group-item-heading,button.list-group-item-info .list-group-item-heading{color:inherit}a.list-group-item-info:focus,a.list-group-item-info:hover,button.list-group-item-info:focus,button.list-group-item-info:hover{color:#31708f;background-color:#c4e3f3}a.list-group-item-info.active,a.list-group-item-info.active:focus,a.list-group-item-info.active:hover,button.list-group-item-info.active,button.list-group-item-info.active:focus,button.list-group-item-info.active:hover{color:#fff;background-color:#31708f;border-color:#31708f}.list-group-item-warning{color:#8a6d3b;background-color:#fcf8e3}a.list-group-item-warning,button.list-group-item-warning{color:#8a6d3b}a.list-group-item-warning .list-group-item-heading,button.list-group-item-warning .list-group-item-heading{color:inherit}a.list-group-item-warning:focus,a.list-group-item-warning:hover,button.list-group-item-warning:focus,button.list-group-item-warning:hover{color:#8a6d3b;background-color:#faf2cc}a.list-group-item-warning.active,a.list-group-item-warning.active:focus,a.list-group-item-warning.active:hover,button.list-group-item-warning.active,button.list-group-item-warning.active:focus,button.list-group-item-warning.active:hover{color:#fff;background-color:#8a6d3b;border-color:#8a6d3b}.list-group-item-danger{color:#a94442;background-color:#f2dede}a.list-group-item-danger,button.list-group-item-danger{color:#a94442}a.list-group-item-danger .list-group-item-heading,button.list-group-item-danger .list-group-item-heading{color:inherit}a.list-group-item-danger:focus,a.list-group-item-danger:hover,button.list-group-item-danger:focus,button.list-group-item-danger:hover{color:#a94442;background-color:#ebcccc}a.list-group-item-danger.active,a.list-group-item-danger.active:focus,a.list-group-item-danger.active:hover,button.list-group-item-danger.active,button.list-group-item-danger.active:focus,button.list-group-item-danger.active:hover{color:#fff;background-color:#a94442;border-color:#a94442}.list-group-item-heading{margin-top:0;margin-bottom:5px}.list-group-item-text{margin-bottom:0;line-height:1.3}.panel{margin-bottom:20px;background-color:#fff;border:1px solid transparent;border-radius:4px;-webkit-box-shadow:0 1px 1px rgba(0,0,0,.05);box-shadow:0 1px 1px rgba(0,0,0,.05)}.panel-body{padding:15px}.panel-heading{padding:10px 15px;border-bottom:1px solid transparent;border-top-left-radius:3px;border-top-right-radius:3px}.panel-heading>.dropdown .dropdown-toggle{color:inherit}.panel-title{margin-top:0;margin-bottom:0;font-size:16px;color:inherit}.panel-title>.small,.panel-title>.small>a,.panel-title>a,.panel-title>small,.panel-title>small>a{color:inherit}.panel-footer{padding:10px 15px;background-color:#f5f5f5;border-top:1px solid #ddd;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.list-group,.panel>.panel-collapse>.list-group{margin-bottom:0}.panel>.list-group .list-group-item,.panel>.panel-collapse>.list-group .list-group-item{border-width:1px 0;border-radius:0}.panel>.list-group:first-child .list-group-item:first-child,.panel>.panel-collapse>.list-group:first-child .list-group-item:first-child{border-top:0;border-top-left-radius:3px;border-top-right-radius:3px}.panel>.list-group:last-child .list-group-item:last-child,.panel>.panel-collapse>.list-group:last-child .list-group-item:last-child{border-bottom:0;border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.panel-heading+.panel-collapse>.list-group .list-group-item:first-child{border-top-left-radius:0;border-top-right-radius:0}.panel-heading+.list-group .list-group-item:first-child{border-top-width:0}.list-group+.panel-footer{border-top-width:0}.panel>.panel-collapse>.table,.panel>.table,.panel>.table-responsive>.table{margin-bottom:0}.panel>.panel-collapse>.table caption,.panel>.table caption,.panel>.table-responsive>.table caption{padding-right:15px;padding-left:15px}.panel>.table-responsive:first-child>.table:first-child,.panel>.table:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child,.panel>.table:first-child>thead:first-child>tr:first-child{border-top-left-radius:3px;border-top-right-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:first-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:first-child,.panel>.table:first-child>thead:first-child>tr:first-child td:first-child,.panel>.table:first-child>thead:first-child>tr:first-child th:first-child{border-top-left-radius:3px}.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table-responsive:first-child>.table:first-child>thead:first-child>tr:first-child th:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child td:last-child,.panel>.table:first-child>tbody:first-child>tr:first-child th:last-child,.panel>.table:first-child>thead:first-child>tr:first-child td:last-child,.panel>.table:first-child>thead:first-child>tr:first-child th:last-child{border-top-right-radius:3px}.panel>.table-responsive:last-child>.table:last-child,.panel>.table:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child{border-bottom-right-radius:3px;border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:first-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:first-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:first-child{border-bottom-left-radius:3px}.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table-responsive:last-child>.table:last-child>tfoot:last-child>tr:last-child th:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child td:last-child,.panel>.table:last-child>tbody:last-child>tr:last-child th:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child td:last-child,.panel>.table:last-child>tfoot:last-child>tr:last-child th:last-child{border-bottom-right-radius:3px}.panel>.panel-body+.table,.panel>.panel-body+.table-responsive,.panel>.table+.panel-body,.panel>.table-responsive+.panel-body{border-top:1px solid #ddd}.panel>.table>tbody:first-child>tr:first-child td,.panel>.table>tbody:first-child>tr:first-child th{border-top:0}.panel>.table-bordered,.panel>.table-responsive>.table-bordered{border:0}.panel>.table-bordered>tbody>tr>td:first-child,.panel>.table-bordered>tbody>tr>th:first-child,.panel>.table-bordered>tfoot>tr>td:first-child,.panel>.table-bordered>tfoot>tr>th:first-child,.panel>.table-bordered>thead>tr>td:first-child,.panel>.table-bordered>thead>tr>th:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:first-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:first-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:first-child,.panel>.table-responsive>.table-bordered>thead>tr>td:first-child,.panel>.table-responsive>.table-bordered>thead>tr>th:first-child{border-left:0}.panel>.table-bordered>tbody>tr>td:last-child,.panel>.table-bordered>tbody>tr>th:last-child,.panel>.table-bordered>tfoot>tr>td:last-child,.panel>.table-bordered>tfoot>tr>th:last-child,.panel>.table-bordered>thead>tr>td:last-child,.panel>.table-bordered>thead>tr>th:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>td:last-child,.panel>.table-responsive>.table-bordered>tbody>tr>th:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>td:last-child,.panel>.table-responsive>.table-bordered>tfoot>tr>th:last-child,.panel>.table-responsive>.table-bordered>thead>tr>td:last-child,.panel>.table-responsive>.table-bordered>thead>tr>th:last-child{border-right:0}.panel>.table-bordered>tbody>tr:first-child>td,.panel>.table-bordered>tbody>tr:first-child>th,.panel>.table-bordered>thead>tr:first-child>td,.panel>.table-bordered>thead>tr:first-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:first-child>th,.panel>.table-responsive>.table-bordered>thead>tr:first-child>td,.panel>.table-responsive>.table-bordered>thead>tr:first-child>th{border-bottom:0}.panel>.table-bordered>tbody>tr:last-child>td,.panel>.table-bordered>tbody>tr:last-child>th,.panel>.table-bordered>tfoot>tr:last-child>td,.panel>.table-bordered>tfoot>tr:last-child>th,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>td,.panel>.table-responsive>.table-bordered>tbody>tr:last-child>th,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>td,.panel>.table-responsive>.table-bordered>tfoot>tr:last-child>th{border-bottom:0}.panel>.table-responsive{margin-bottom:0;border:0}.panel-group{margin-bottom:20px}.panel-group .panel{margin-bottom:0;border-radius:4px}.panel-group .panel+.panel{margin-top:5px}.panel-group .panel-heading{border-bottom:0}.panel-group .panel-heading+.panel-collapse>.list-group,.panel-group .panel-heading+.panel-collapse>.panel-body{border-top:1px solid #ddd}.panel-group .panel-footer{border-top:0}.panel-group .panel-footer+.panel-collapse .panel-body{border-bottom:1px solid #ddd}.panel-default{border-color:#ddd}.panel-default>.panel-heading{color:#333;background-color:#f5f5f5;border-color:#ddd}.panel-default>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ddd}.panel-default>.panel-heading .badge{color:#f5f5f5;background-color:#333}.panel-default>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ddd}.panel-primary{border-color:#337ab7}.panel-primary>.panel-heading{color:#fff;background-color:#337ab7;border-color:#337ab7}.panel-primary>.panel-heading+.panel-collapse>.panel-body{border-top-color:#337ab7}.panel-primary>.panel-heading .badge{color:#337ab7;background-color:#fff}.panel-primary>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#337ab7}.panel-success{border-color:#d6e9c6}.panel-success>.panel-heading{color:#3c763d;background-color:#dff0d8;border-color:#d6e9c6}.panel-success>.panel-heading+.panel-collapse>.panel-body{border-top-color:#d6e9c6}.panel-success>.panel-heading .badge{color:#dff0d8;background-color:#3c763d}.panel-success>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#d6e9c6}.panel-info{border-color:#bce8f1}.panel-info>.panel-heading{color:#31708f;background-color:#d9edf7;border-color:#bce8f1}.panel-info>.panel-heading+.panel-collapse>.panel-body{border-top-color:#bce8f1}.panel-info>.panel-heading .badge{color:#d9edf7;background-color:#31708f}.panel-info>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#bce8f1}.panel-warning{border-color:#faebcc}.panel-warning>.panel-heading{color:#8a6d3b;background-color:#fcf8e3;border-color:#faebcc}.panel-warning>.panel-heading+.panel-collapse>.panel-body{border-top-color:#faebcc}.panel-warning>.panel-heading .badge{color:#fcf8e3;background-color:#8a6d3b}.panel-warning>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#faebcc}.panel-danger{border-color:#ebccd1}.panel-danger>.panel-heading{color:#a94442;background-color:#f2dede;border-color:#ebccd1}.panel-danger>.panel-heading+.panel-collapse>.panel-body{border-top-color:#ebccd1}.panel-danger>.panel-heading .badge{color:#f2dede;background-color:#a94442}.panel-danger>.panel-footer+.panel-collapse>.panel-body{border-bottom-color:#ebccd1}.embed-responsive{position:relative;display:block;height:0;padding:0;overflow:hidden}.embed-responsive .embed-responsive-item,.embed-responsive embed,.embed-responsive iframe,.embed-responsive object,.embed-responsive video{position:absolute;top:0;bottom:0;left:0;width:100%;height:100%;border:0}.embed-responsive-16by9{padding-bottom:56.25%}.embed-responsive-4by3{padding-bottom:75%}.well{min-height:20px;padding:19px;margin-bottom:20px;background-color:#f5f5f5;border:1px solid #e3e3e3;border-radius:4px;-webkit-box-shadow:inset 0 1px 1px rgba(0,0,0,.05);box-shadow:inset 0 1px 1px rgba(0,0,0,.05)}.well blockquote{border-color:#ddd;border-color:rgba(0,0,0,.15)}.well-lg{padding:24px;border-radius:6px}.well-sm{padding:9px;border-radius:3px}.close{float:right;font-size:21px;font-weight:700;line-height:1;color:#000;text-shadow:0 1px 0 #fff;filter:alpha(opacity=20);opacity:.2}.close:focus,.close:hover{color:#000;text-decoration:none;cursor:pointer;filter:alpha(opacity=50);opacity:.5}button.close{-webkit-appearance:none;padding:0;cursor:pointer;background:0 0;border:0}.modal-open{overflow:hidden}.modal{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1050;display:none;overflow:hidden;-webkit-overflow-scrolling:touch;outline:0}.modal.fade .modal-dialog{-webkit-transition:-webkit-transform .3s ease-out;-o-transition:-o-transform .3s ease-out;transition:transform .3s ease-out;-webkit-transform:translate(0,-25%);-ms-transform:translate(0,-25%);-o-transform:translate(0,-25%);transform:translate(0,-25%)}.modal.in .modal-dialog{-webkit-transform:translate(0,0);-ms-transform:translate(0,0);-o-transform:translate(0,0);transform:translate(0,0)}.modal-open .modal{overflow-x:hidden;overflow-y:auto}.modal-dialog{position:relative;width:auto;margin:10px}.modal-content{position:relative;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #999;border:1px solid rgba(0,0,0,.2);border-radius:6px;outline:0;-webkit-box-shadow:0 3px 9px rgba(0,0,0,.5);box-shadow:0 3px 9px rgba(0,0,0,.5)}.modal-backdrop{position:fixed;top:0;right:0;bottom:0;left:0;z-index:1040;background-color:#000}.modal-backdrop.fade{filter:alpha(opacity=0);opacity:0}.modal-backdrop.in{filter:alpha(opacity=50);opacity:.5}.modal-header{padding:15px;border-bottom:1px solid #e5e5e5}.modal-header .close{margin-top:-2px}.modal-title{margin:0;line-height:1.42857143}.modal-body{position:relative;padding:15px}.modal-footer{padding:15px;text-align:right;border-top:1px solid #e5e5e5}.modal-footer .btn+.btn{margin-bottom:0;margin-left:5px}.modal-footer .btn-group .btn+.btn{margin-left:-1px}.modal-footer .btn-block+.btn-block{margin-left:0}.modal-scrollbar-measure{position:absolute;top:-9999px;width:50px;height:50px;overflow:scroll}@media (min-width:768px){.modal-dialog{width:600px;margin:30px auto}.modal-content{-webkit-box-shadow:0 5px 15px rgba(0,0,0,.5);box-shadow:0 5px 15px rgba(0,0,0,.5)}.modal-sm{width:300px}}@media (min-width:992px){.modal-lg{width:900px}}.tooltip{position:absolute;z-index:1070;display:block;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:12px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;filter:alpha(opacity=0);opacity:0;line-break:auto}.tooltip.in{filter:alpha(opacity=90);opacity:.9}.tooltip.top{padding:5px 0;margin-top:-3px}.tooltip.right{padding:0 5px;margin-left:3px}.tooltip.bottom{padding:5px 0;margin-top:3px}.tooltip.left{padding:0 5px;margin-left:-3px}.tooltip-inner{max-width:200px;padding:3px 8px;color:#fff;text-align:center;background-color:#000;border-radius:4px}.tooltip-arrow{position:absolute;width:0;height:0;border-color:transparent;border-style:solid}.tooltip.top .tooltip-arrow{bottom:0;left:50%;margin-left:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-left .tooltip-arrow{right:5px;bottom:0;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.top-right .tooltip-arrow{bottom:0;left:5px;margin-bottom:-5px;border-width:5px 5px 0;border-top-color:#000}.tooltip.right .tooltip-arrow{top:50%;left:0;margin-top:-5px;border-width:5px 5px 5px 0;border-right-color:#000}.tooltip.left .tooltip-arrow{top:50%;right:0;margin-top:-5px;border-width:5px 0 5px 5px;border-left-color:#000}.tooltip.bottom .tooltip-arrow{top:0;left:50%;margin-left:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-left .tooltip-arrow{top:0;right:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.tooltip.bottom-right .tooltip-arrow{top:0;left:5px;margin-top:-5px;border-width:0 5px 5px;border-bottom-color:#000}.popover{position:absolute;top:0;left:0;z-index:1060;display:none;max-width:276px;padding:1px;font-family:\"Helvetica Neue\",Helvetica,Arial,sans-serif;font-size:14px;font-style:normal;font-weight:400;line-height:1.42857143;text-align:left;text-align:start;text-decoration:none;text-shadow:none;text-transform:none;letter-spacing:normal;word-break:normal;word-spacing:normal;word-wrap:normal;white-space:normal;background-color:#fff;-webkit-background-clip:padding-box;background-clip:padding-box;border:1px solid #ccc;border:1px solid rgba(0,0,0,.2);border-radius:6px;-webkit-box-shadow:0 5px 10px rgba(0,0,0,.2);box-shadow:0 5px 10px rgba(0,0,0,.2);line-break:auto}.popover.top{margin-top:-10px}.popover.right{margin-left:10px}.popover.bottom{margin-top:10px}.popover.left{margin-left:-10px}.popover-title{padding:8px 14px;margin:0;font-size:14px;background-color:#f7f7f7;border-bottom:1px solid #ebebeb;border-radius:5px 5px 0 0}.popover-content{padding:9px 14px}.popover>.arrow,.popover>.arrow:after{position:absolute;display:block;width:0;height:0;border-color:transparent;border-style:solid}.popover>.arrow{border-width:11px}.popover>.arrow:after{content:\"\";border-width:10px}.popover.top>.arrow{bottom:-11px;left:50%;margin-left:-11px;border-top-color:#999;border-top-color:rgba(0,0,0,.25);border-bottom-width:0}.popover.top>.arrow:after{bottom:1px;margin-left:-10px;content:\" \";border-top-color:#fff;border-bottom-width:0}.popover.right>.arrow{top:50%;left:-11px;margin-top:-11px;border-right-color:#999;border-right-color:rgba(0,0,0,.25);border-left-width:0}.popover.right>.arrow:after{bottom:-10px;left:1px;content:\" \";border-right-color:#fff;border-left-width:0}.popover.bottom>.arrow{top:-11px;left:50%;margin-left:-11px;border-top-width:0;border-bottom-color:#999;border-bottom-color:rgba(0,0,0,.25)}.popover.bottom>.arrow:after{top:1px;margin-left:-10px;content:\" \";border-top-width:0;border-bottom-color:#fff}.popover.left>.arrow{top:50%;right:-11px;margin-top:-11px;border-right-width:0;border-left-color:#999;border-left-color:rgba(0,0,0,.25)}.popover.left>.arrow:after{right:1px;bottom:-10px;content:\" \";border-right-width:0;border-left-color:#fff}.carousel{position:relative}.carousel-inner{position:relative;width:100%;overflow:hidden}.carousel-inner>.item{position:relative;display:none;-webkit-transition:.6s ease-in-out left;-o-transition:.6s ease-in-out left;transition:.6s ease-in-out left}.carousel-inner>.item>a>img,.carousel-inner>.item>img{line-height:1}@media all and (transform-3d),(-webkit-transform-3d){.carousel-inner>.item{-webkit-transition:-webkit-transform .6s ease-in-out;-o-transition:-o-transform .6s ease-in-out;transition:transform .6s ease-in-out;-webkit-backface-visibility:hidden;backface-visibility:hidden;-webkit-perspective:1000px;perspective:1000px}.carousel-inner>.item.active.right,.carousel-inner>.item.next{left:0;-webkit-transform:translate3d(100%,0,0);transform:translate3d(100%,0,0)}.carousel-inner>.item.active.left,.carousel-inner>.item.prev{left:0;-webkit-transform:translate3d(-100%,0,0);transform:translate3d(-100%,0,0)}.carousel-inner>.item.active,.carousel-inner>.item.next.left,.carousel-inner>.item.prev.right{left:0;-webkit-transform:translate3d(0,0,0);transform:translate3d(0,0,0)}}.carousel-inner>.active,.carousel-inner>.next,.carousel-inner>.prev{display:block}.carousel-inner>.active{left:0}.carousel-inner>.next,.carousel-inner>.prev{position:absolute;top:0;width:100%}.carousel-inner>.next{left:100%}.carousel-inner>.prev{left:-100%}.carousel-inner>.next.left,.carousel-inner>.prev.right{left:0}.carousel-inner>.active.left{left:-100%}.carousel-inner>.active.right{left:100%}.carousel-control{position:absolute;top:0;bottom:0;left:0;width:15%;font-size:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6);background-color:rgba(0,0,0,0);filter:alpha(opacity=50);opacity:.5}.carousel-control.left{background-image:-webkit-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.5)),to(rgba(0,0,0,.0001)));background-image:linear-gradient(to right,rgba(0,0,0,.5) 0,rgba(0,0,0,.0001) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#80000000', endColorstr='#00000000', GradientType=1);background-repeat:repeat-x}.carousel-control.right{right:0;left:auto;background-image:-webkit-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-o-linear-gradient(left,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);background-image:-webkit-gradient(linear,left top,right top,from(rgba(0,0,0,.0001)),to(rgba(0,0,0,.5)));background-image:linear-gradient(to right,rgba(0,0,0,.0001) 0,rgba(0,0,0,.5) 100%);filter:progid:DXImageTransform.Microsoft.gradient(startColorstr='#00000000', endColorstr='#80000000', GradientType=1);background-repeat:repeat-x}.carousel-control:focus,.carousel-control:hover{color:#fff;text-decoration:none;filter:alpha(opacity=90);outline:0;opacity:.9}.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{position:absolute;top:50%;z-index:5;display:inline-block;margin-top:-10px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{left:50%;margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{right:50%;margin-right:-10px}.carousel-control .icon-next,.carousel-control .icon-prev{width:20px;height:20px;font-family:serif;line-height:1}.carousel-control .icon-prev:before{content:'\\2039'}.carousel-control .icon-next:before{content:'\\203a'}.carousel-indicators{position:absolute;bottom:10px;left:50%;z-index:15;width:60%;padding-left:0;margin-left:-30%;text-align:center;list-style:none}.carousel-indicators li{display:inline-block;width:10px;height:10px;margin:1px;text-indent:-999px;cursor:pointer;background-color:#000\\9;background-color:rgba(0,0,0,0);border:1px solid #fff;border-radius:10px}.carousel-indicators .active{width:12px;height:12px;margin:0;background-color:#fff}.carousel-caption{position:absolute;right:15%;bottom:20px;left:15%;z-index:10;padding-top:20px;padding-bottom:20px;color:#fff;text-align:center;text-shadow:0 1px 2px rgba(0,0,0,.6)}.carousel-caption .btn{text-shadow:none}@media screen and (min-width:768px){.carousel-control .glyphicon-chevron-left,.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next,.carousel-control .icon-prev{width:30px;height:30px;margin-top:-10px;font-size:30px}.carousel-control .glyphicon-chevron-left,.carousel-control .icon-prev{margin-left:-10px}.carousel-control .glyphicon-chevron-right,.carousel-control .icon-next{margin-right:-10px}.carousel-caption{right:20%;left:20%;padding-bottom:30px}.carousel-indicators{bottom:20px}}.btn-group-vertical>.btn-group:after,.btn-group-vertical>.btn-group:before,.btn-toolbar:after,.btn-toolbar:before,.clearfix:after,.clearfix:before,.container-fluid:after,.container-fluid:before,.container:after,.container:before,.dl-horizontal dd:after,.dl-horizontal dd:before,.form-horizontal .form-group:after,.form-horizontal .form-group:before,.modal-footer:after,.modal-footer:before,.modal-header:after,.modal-header:before,.nav:after,.nav:before,.navbar-collapse:after,.navbar-collapse:before,.navbar-header:after,.navbar-header:before,.navbar:after,.navbar:before,.pager:after,.pager:before,.panel-body:after,.panel-body:before,.row:after,.row:before{display:table;content:\" \"}.btn-group-vertical>.btn-group:after,.btn-toolbar:after,.clearfix:after,.container-fluid:after,.container:after,.dl-horizontal dd:after,.form-horizontal .form-group:after,.modal-footer:after,.modal-header:after,.nav:after,.navbar-collapse:after,.navbar-header:after,.navbar:after,.pager:after,.panel-body:after,.row:after{clear:both}.center-block{display:block;margin-right:auto;margin-left:auto}.pull-right{float:right!important}.pull-left{float:left!important}.hide{display:none!important}.show{display:block!important}.invisible{visibility:hidden}.text-hide{font:0/0 a;color:transparent;text-shadow:none;background-color:transparent;border:0}.hidden{display:none!important}.affix{position:fixed}@-ms-viewport{width:device-width}.visible-lg,.visible-md,.visible-sm,.visible-xs{display:none!important}.visible-lg-block,.visible-lg-inline,.visible-lg-inline-block,.visible-md-block,.visible-md-inline,.visible-md-inline-block,.visible-sm-block,.visible-sm-inline,.visible-sm-inline-block,.visible-xs-block,.visible-xs-inline,.visible-xs-inline-block{display:none!important}@media (max-width:767px){.visible-xs{display:block!important}table.visible-xs{display:table!important}tr.visible-xs{display:table-row!important}td.visible-xs,th.visible-xs{display:table-cell!important}}@media (max-width:767px){.visible-xs-block{display:block!important}}@media (max-width:767px){.visible-xs-inline{display:inline!important}}@media (max-width:767px){.visible-xs-inline-block{display:inline-block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm{display:block!important}table.visible-sm{display:table!important}tr.visible-sm{display:table-row!important}td.visible-sm,th.visible-sm{display:table-cell!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-block{display:block!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline{display:inline!important}}@media (min-width:768px) and (max-width:991px){.visible-sm-inline-block{display:inline-block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md{display:block!important}table.visible-md{display:table!important}tr.visible-md{display:table-row!important}td.visible-md,th.visible-md{display:table-cell!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-block{display:block!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline{display:inline!important}}@media (min-width:992px) and (max-width:1199px){.visible-md-inline-block{display:inline-block!important}}@media (min-width:1200px){.visible-lg{display:block!important}table.visible-lg{display:table!important}tr.visible-lg{display:table-row!important}td.visible-lg,th.visible-lg{display:table-cell!important}}@media (min-width:1200px){.visible-lg-block{display:block!important}}@media (min-width:1200px){.visible-lg-inline{display:inline!important}}@media (min-width:1200px){.visible-lg-inline-block{display:inline-block!important}}@media (max-width:767px){.hidden-xs{display:none!important}}@media (min-width:768px) and (max-width:991px){.hidden-sm{display:none!important}}@media (min-width:992px) and (max-width:1199px){.hidden-md{display:none!important}}@media (min-width:1200px){.hidden-lg{display:none!important}}.visible-print{display:none!important}@media print{.visible-print{display:block!important}table.visible-print{display:table!important}tr.visible-print{display:table-row!important}td.visible-print,th.visible-print{display:table-cell!important}}.visible-print-block{display:none!important}@media print{.visible-print-block{display:block!important}}.visible-print-inline{display:none!important}@media print{.visible-print-inline{display:inline!important}}.visible-print-inline-block{display:none!important}@media print{.visible-print-inline-block{display:inline-block!important}}@media print{.hidden-print{display:none!important}}");
})
(function(factory) {
  factory();
});